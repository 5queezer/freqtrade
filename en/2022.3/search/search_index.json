{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Star Fork Download Introduction \u00b6 Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning. DISCLAIMER This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS. Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect. We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it. Sponsored promotion \u00b6 Features \u00b6 Develop your Strategy: Write your strategy in python, using pandas . Example strategies to inspire you are available in the strategy repository . Download market data: Download historical data of the exchange and the markets your may want to trade with. Backtest: Test your strategy on downloaded historical data. Optimize: Find the best parameters for your strategy using hyperoptimization which employs machining learning methods. You can optimize buy, sell, take profit (ROI), stop-loss and trailing stop-loss parameters for your strategy. Select markets: Create your static list or use an automatic one based on top traded volumes and/or prices (not available during backtesting). You can also explicitly blacklist markets you don't want to trade. Run: Test your strategy with simulated money (Dry-Run mode) or deploy it with real money (Live-Trade mode). Run using Edge (optional module): The concept is to find the best historical trade expectancy by markets based on variation of the stop-loss and then allow/reject markets to trade. The sizing of the trade is based on a risk of a percentage of your capital. Control/Monitor: Use Telegram or a WebUI (start/stop the bot, show profit/loss, daily summary, current open trades results, etc.). Analyse: Further analysis can be performed on either Backtesting data or Freqtrade trading history (SQL database), including automated standard plots, and methods to load the data into interactive environments . Supported exchange marketplaces \u00b6 Please read the exchange specific notes to learn about eventual, special configurations needed for each exchange. Binance Bittrex FTX Gate.io Huobi Kraken OKX (Former OKEX) potentially many others through . (We cannot guarantee they will work) Community tested \u00b6 Exchanges confirmed working by the community: Bitvavo Kucoin Requirements \u00b6 Hardware requirements \u00b6 To run this bot we recommend you a linux cloud instance with a minimum of: 2GB RAM 1GB disk space 2vCPU Software requirements \u00b6 Docker (Recommended) Alternatively Python 3.8+ pip (pip3) git TA-Lib virtualenv (Recommended) Support \u00b6 Help / Discord \u00b6 For any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server . Ready to try? \u00b6 Begin by reading the installation guide for docker (recommended), or for installation without docker .","title":"Home"},{"location":"#introduction","text":"Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning. DISCLAIMER This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS. Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect. We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it.","title":"Introduction"},{"location":"#sponsored-promotion","text":"","title":"Sponsored promotion"},{"location":"#features","text":"Develop your Strategy: Write your strategy in python, using pandas . Example strategies to inspire you are available in the strategy repository . Download market data: Download historical data of the exchange and the markets your may want to trade with. Backtest: Test your strategy on downloaded historical data. Optimize: Find the best parameters for your strategy using hyperoptimization which employs machining learning methods. You can optimize buy, sell, take profit (ROI), stop-loss and trailing stop-loss parameters for your strategy. Select markets: Create your static list or use an automatic one based on top traded volumes and/or prices (not available during backtesting). You can also explicitly blacklist markets you don't want to trade. Run: Test your strategy with simulated money (Dry-Run mode) or deploy it with real money (Live-Trade mode). Run using Edge (optional module): The concept is to find the best historical trade expectancy by markets based on variation of the stop-loss and then allow/reject markets to trade. The sizing of the trade is based on a risk of a percentage of your capital. Control/Monitor: Use Telegram or a WebUI (start/stop the bot, show profit/loss, daily summary, current open trades results, etc.). Analyse: Further analysis can be performed on either Backtesting data or Freqtrade trading history (SQL database), including automated standard plots, and methods to load the data into interactive environments .","title":"Features"},{"location":"#supported-exchange-marketplaces","text":"Please read the exchange specific notes to learn about eventual, special configurations needed for each exchange. Binance Bittrex FTX Gate.io Huobi Kraken OKX (Former OKEX) potentially many others through . (We cannot guarantee they will work)","title":"Supported exchange marketplaces"},{"location":"#community-tested","text":"Exchanges confirmed working by the community: Bitvavo Kucoin","title":"Community tested"},{"location":"#requirements","text":"","title":"Requirements"},{"location":"#hardware-requirements","text":"To run this bot we recommend you a linux cloud instance with a minimum of: 2GB RAM 1GB disk space 2vCPU","title":"Hardware requirements"},{"location":"#software-requirements","text":"Docker (Recommended) Alternatively Python 3.8+ pip (pip3) git TA-Lib virtualenv (Recommended)","title":"Software requirements"},{"location":"#support","text":"","title":"Support"},{"location":"#help-discord","text":"For any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server .","title":"Help / Discord"},{"location":"#ready-to-try","text":"Begin by reading the installation guide for docker (recommended), or for installation without docker .","title":"Ready to try?"},{"location":"advanced-hyperopt/","text":"Advanced Hyperopt \u00b6 This page explains some advanced Hyperopt topics that may require higher coding skills and Python knowledge than creation of an ordinal hyperoptimization class. Creating and using a custom loss function \u00b6 To use a custom loss function class, make sure that the function hyperopt_loss_function is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter --hyperopt-loss SuperDuperHyperOptLoss to your hyperopt call so this function is being used. A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found in userdata/hyperopts . ``` python from datetime import datetime from typing import Any, Dict from pandas import DataFrame from freqtrade.optimize.hyperopt import IHyperOptLoss TARGET_TRADES = 600 EXPECTED_MAX_PROFIT = 3.0 MAX_ACCEPTED_TRADE_DURATION = 300 class SuperDuperHyperOptLoss(IHyperOptLoss): \"\"\" Defines the default loss function for hyperopt \"\"\" @staticmethod def hyperopt_loss_function(results: DataFrame, trade_count: int, min_date: datetime, max_date: datetime, config: Dict, processed: Dict[str, DataFrame], backtest_stats: Dict[str, Any], *args, **kwargs) -> float: \"\"\" Objective function, returns smaller number for better results This is the legacy algorithm (used until now in freqtrade). Weights are distributed as follows: * 0.4 to trade duration * 0.25: Avoiding trade loss * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above \"\"\" total_profit = results['profit_ratio'].sum() trade_duration = results['trade_duration'].mean() trade_loss = 1 - 0.25 * exp(-(trade_count - TARGET_TRADES) ** 2 / 10 ** 5.8) profit_loss = max(0, 1 - total_profit / EXPECTED_MAX_PROFIT) duration_loss = 0.4 * min(trade_duration / MAX_ACCEPTED_TRADE_DURATION, 1) result = trade_loss + profit_loss + duration_loss return result ``` Currently, the arguments are: results : DataFrame containing the resulting trades. The following columns are available in results (corresponds to the output-file of backtesting when used with --export trades ): pair, profit_ratio, profit_abs, open_date, open_rate, fee_open, close_date, close_rate, fee_close, amount, trade_duration, is_open, sell_reason, stake_amount, min_rate, max_rate, stop_loss_ratio, stop_loss_abs trade_count : Amount of trades (identical to len(results) ) min_date : Start date of the timerange used min_date : End date of the timerange used config : Config object used (Note: Not all strategy-related parameters will be updated here if they are part of a hyperopt space). processed : Dict of Dataframes with the pair as keys containing the data used for backtesting. backtest_stats : Backtesting statistics using the same format as the backtesting file \"strategy\" substructure. Available fields can be seen in generate_strategy_stats() in optimize_reports.py . This function needs to return a floating point number ( float ). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you. Note This function is called once per epoch - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily. *args and **kwargs Please keep the arguments *args and **kwargs in the interface to allow us to extend this interface in the future. Overriding pre-defined spaces \u00b6 To override a pre-defined space ( roi_space , generate_roi_table , stoploss_space , trailing_space ), define a nested class called Hyperopt and define the required spaces as follows: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: # Define a custom stoploss space. def stoploss_space(): return [SKDecimal(-0.05, -0.01, decimals=3, name='stoploss')] # Define custom ROI space def roi_space() -> List[Dimension]: return [ Integer(10, 120, name='roi_t1'), Integer(10, 60, name='roi_t2'), Integer(10, 40, name='roi_t3'), SKDecimal(0.01, 0.04, decimals=3, name='roi_p1'), SKDecimal(0.01, 0.07, decimals=3, name='roi_p2'), SKDecimal(0.01, 0.20, decimals=3, name='roi_p3'), ] ``` Note All overrides are optional and can be mixed/matched as necessary. Overriding Base estimator \u00b6 You can define your own estimator for Hyperopt by implementing generate_estimator() in the Hyperopt subclass. ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): return \"RF\" ``` Possible values are either one of \"GP\", \"RF\", \"ET\", \"GBRT\" (Details can be found in the scikit-optimize documentation ), or \"an instance of a class that inherits from RegressorMixin (from sklearn) and where the predict method has an optional return_std argument, which returns std(Y | x) along with E[Y | x] \". Some research will be necessary to find additional Regressors. Example for ExtraTreesRegressor (\"ET\") with additional parameters: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): from skopt.learning import ExtraTreesRegressor # Corresponds to \"ET\" - but allows additional parameters. return ExtraTreesRegressor(n_estimators=100) ``` The dimensions parameter is the list of skopt.space.Dimension objects corresponding to the parameters to be optimized. It can be used to create isotropic kernels for the skopt.learning.GaussianProcessRegressor estimator. Here's an example: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): from skopt.utils import cook_estimator from skopt.learning.gaussian_process.kernels import (Matern, ConstantKernel) kernel_bounds = (0.0001, 10000) kernel = ( ConstantKernel(1.0, kernel_bounds) * Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=2.5) ) kernel += ( ConstantKernel(1.0, kernel_bounds) * Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=1.5) ) return cook_estimator(\"GP\", space=dimensions, kernel=kernel, n_restarts_optimizer=2) ``` Note While custom estimators can be provided, it's up to you as User to do research on possible parameters and analyze / understand which ones should be used. If you're unsure about this, best use one of the Defaults ( \"ET\" has proven to be the most versatile) without further parameters. Space options \u00b6 For the additional spaces, scikit-optimize (in combination with Freqtrade) provides the following space types: Categorical - Pick from a list of categories (e.g. Categorical(['a', 'b', 'c'], name=\"cat\") ) Integer - Pick from a range of whole numbers (e.g. Integer(1, 10, name='rsi') ) SKDecimal - Pick from a range of decimal numbers with limited precision (e.g. SKDecimal(0.1, 0.5, decimals=3, name='adx') ). Available only with freqtrade . Real - Pick from a range of decimal numbers with full precision (e.g. Real(0.1, 0.5, name='adx') You can import all of these from freqtrade.optimize.space , although Categorical , Integer and Real are only aliases for their corresponding scikit-optimize Spaces. SKDecimal is provided by freqtrade for faster optimizations. python from freqtrade.optimize.space import Categorical, Dimension, Integer, SKDecimal, Real # noqa SKDecimal vs. Real We recommend to use SKDecimal instead of the Real space in almost all cases. While the Real space provides full accuracy (up to ~16 decimal places) - this precision is rarely needed, and leads to unnecessary long hyperopt times. Assuming the definition of a rather small space ( SKDecimal(0.10, 0.15, decimals=2, name='xxx') ) - SKDecimal will have 5 possibilities ( [0.10, 0.11, 0.12, 0.13, 0.14, 0.15] ). A corresponding real space Real(0.10, 0.15 name='xxx') on the other hand has an almost unlimited number of possibilities ( [0.10, 0.010000000001, 0.010000000002, ... 0.014999999999, 0.01500000000] ).","title":"Advanced Hyperopt"},{"location":"advanced-hyperopt/#advanced-hyperopt","text":"This page explains some advanced Hyperopt topics that may require higher coding skills and Python knowledge than creation of an ordinal hyperoptimization class.","title":"Advanced Hyperopt"},{"location":"advanced-hyperopt/#creating-and-using-a-custom-loss-function","text":"To use a custom loss function class, make sure that the function hyperopt_loss_function is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter --hyperopt-loss SuperDuperHyperOptLoss to your hyperopt call so this function is being used. A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found in userdata/hyperopts . ``` python from datetime import datetime from typing import Any, Dict from pandas import DataFrame from freqtrade.optimize.hyperopt import IHyperOptLoss TARGET_TRADES = 600 EXPECTED_MAX_PROFIT = 3.0 MAX_ACCEPTED_TRADE_DURATION = 300 class SuperDuperHyperOptLoss(IHyperOptLoss): \"\"\" Defines the default loss function for hyperopt \"\"\" @staticmethod def hyperopt_loss_function(results: DataFrame, trade_count: int, min_date: datetime, max_date: datetime, config: Dict, processed: Dict[str, DataFrame], backtest_stats: Dict[str, Any], *args, **kwargs) -> float: \"\"\" Objective function, returns smaller number for better results This is the legacy algorithm (used until now in freqtrade). Weights are distributed as follows: * 0.4 to trade duration * 0.25: Avoiding trade loss * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above \"\"\" total_profit = results['profit_ratio'].sum() trade_duration = results['trade_duration'].mean() trade_loss = 1 - 0.25 * exp(-(trade_count - TARGET_TRADES) ** 2 / 10 ** 5.8) profit_loss = max(0, 1 - total_profit / EXPECTED_MAX_PROFIT) duration_loss = 0.4 * min(trade_duration / MAX_ACCEPTED_TRADE_DURATION, 1) result = trade_loss + profit_loss + duration_loss return result ``` Currently, the arguments are: results : DataFrame containing the resulting trades. The following columns are available in results (corresponds to the output-file of backtesting when used with --export trades ): pair, profit_ratio, profit_abs, open_date, open_rate, fee_open, close_date, close_rate, fee_close, amount, trade_duration, is_open, sell_reason, stake_amount, min_rate, max_rate, stop_loss_ratio, stop_loss_abs trade_count : Amount of trades (identical to len(results) ) min_date : Start date of the timerange used min_date : End date of the timerange used config : Config object used (Note: Not all strategy-related parameters will be updated here if they are part of a hyperopt space). processed : Dict of Dataframes with the pair as keys containing the data used for backtesting. backtest_stats : Backtesting statistics using the same format as the backtesting file \"strategy\" substructure. Available fields can be seen in generate_strategy_stats() in optimize_reports.py . This function needs to return a floating point number ( float ). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you. Note This function is called once per epoch - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily. *args and **kwargs Please keep the arguments *args and **kwargs in the interface to allow us to extend this interface in the future.","title":"Creating and using a custom loss function"},{"location":"advanced-hyperopt/#overriding-pre-defined-spaces","text":"To override a pre-defined space ( roi_space , generate_roi_table , stoploss_space , trailing_space ), define a nested class called Hyperopt and define the required spaces as follows: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: # Define a custom stoploss space. def stoploss_space(): return [SKDecimal(-0.05, -0.01, decimals=3, name='stoploss')] # Define custom ROI space def roi_space() -> List[Dimension]: return [ Integer(10, 120, name='roi_t1'), Integer(10, 60, name='roi_t2'), Integer(10, 40, name='roi_t3'), SKDecimal(0.01, 0.04, decimals=3, name='roi_p1'), SKDecimal(0.01, 0.07, decimals=3, name='roi_p2'), SKDecimal(0.01, 0.20, decimals=3, name='roi_p3'), ] ``` Note All overrides are optional and can be mixed/matched as necessary.","title":"Overriding pre-defined spaces"},{"location":"advanced-hyperopt/#overriding-base-estimator","text":"You can define your own estimator for Hyperopt by implementing generate_estimator() in the Hyperopt subclass. ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): return \"RF\" ``` Possible values are either one of \"GP\", \"RF\", \"ET\", \"GBRT\" (Details can be found in the scikit-optimize documentation ), or \"an instance of a class that inherits from RegressorMixin (from sklearn) and where the predict method has an optional return_std argument, which returns std(Y | x) along with E[Y | x] \". Some research will be necessary to find additional Regressors. Example for ExtraTreesRegressor (\"ET\") with additional parameters: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): from skopt.learning import ExtraTreesRegressor # Corresponds to \"ET\" - but allows additional parameters. return ExtraTreesRegressor(n_estimators=100) ``` The dimensions parameter is the list of skopt.space.Dimension objects corresponding to the parameters to be optimized. It can be used to create isotropic kernels for the skopt.learning.GaussianProcessRegressor estimator. Here's an example: ```python class MyAwesomeStrategy(IStrategy): class HyperOpt: def generate_estimator(dimensions: List['Dimension'], **kwargs): from skopt.utils import cook_estimator from skopt.learning.gaussian_process.kernels import (Matern, ConstantKernel) kernel_bounds = (0.0001, 10000) kernel = ( ConstantKernel(1.0, kernel_bounds) * Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=2.5) ) kernel += ( ConstantKernel(1.0, kernel_bounds) * Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=1.5) ) return cook_estimator(\"GP\", space=dimensions, kernel=kernel, n_restarts_optimizer=2) ``` Note While custom estimators can be provided, it's up to you as User to do research on possible parameters and analyze / understand which ones should be used. If you're unsure about this, best use one of the Defaults ( \"ET\" has proven to be the most versatile) without further parameters.","title":"Overriding Base estimator"},{"location":"advanced-hyperopt/#space-options","text":"For the additional spaces, scikit-optimize (in combination with Freqtrade) provides the following space types: Categorical - Pick from a list of categories (e.g. Categorical(['a', 'b', 'c'], name=\"cat\") ) Integer - Pick from a range of whole numbers (e.g. Integer(1, 10, name='rsi') ) SKDecimal - Pick from a range of decimal numbers with limited precision (e.g. SKDecimal(0.1, 0.5, decimals=3, name='adx') ). Available only with freqtrade . Real - Pick from a range of decimal numbers with full precision (e.g. Real(0.1, 0.5, name='adx') You can import all of these from freqtrade.optimize.space , although Categorical , Integer and Real are only aliases for their corresponding scikit-optimize Spaces. SKDecimal is provided by freqtrade for faster optimizations. python from freqtrade.optimize.space import Categorical, Dimension, Integer, SKDecimal, Real # noqa SKDecimal vs. Real We recommend to use SKDecimal instead of the Real space in almost all cases. While the Real space provides full accuracy (up to ~16 decimal places) - this precision is rarely needed, and leads to unnecessary long hyperopt times. Assuming the definition of a rather small space ( SKDecimal(0.10, 0.15, decimals=2, name='xxx') ) - SKDecimal will have 5 possibilities ( [0.10, 0.11, 0.12, 0.13, 0.14, 0.15] ). A corresponding real space Real(0.10, 0.15 name='xxx') on the other hand has an almost unlimited number of possibilities ( [0.10, 0.010000000001, 0.010000000002, ... 0.014999999999, 0.01500000000] ).","title":"Space options"},{"location":"advanced-setup/","text":"Advanced Post-installation Tasks \u00b6 This page explains some advanced tasks and configuration options that can be performed after the bot installation and may be uselful in some environments. If you do not know what things mentioned here mean, you probably do not need it. Running multiple instances of Freqtrade \u00b6 This section will show you how to run multiple bots at the same time, on the same machine. Things to consider \u00b6 Use different database files. Use different Telegram bots (requires multiple different configuration files; applies only when Telegram is enabled). Use different ports (applies only when Freqtrade REST API webserver is enabled). Different database files \u00b6 In order to keep track of your trades, profits, etc., freqtrade is using a SQLite database where it stores various types of information such as the trades you performed in the past and the current position(s) you are holding at any time. This allows you to keep track of your profits, but most importantly, keep track of ongoing activity if the bot process would be restarted or would be terminated unexpectedly. Freqtrade will, by default, use separate database files for dry-run and live bots (this assumes no database-url is given in either configuration nor via command line argument). For live trading mode, the default database will be tradesv3.sqlite and for dry-run it will be tradesv3.dryrun.sqlite . The optional argument to the trade command used to specify the path of these files is --db-url , which requires a valid SQLAlchemy url. So when you are starting a bot with only the config and strategy arguments in dry-run mode, the following 2 commands would have the same outcome. ``` bash freqtrade trade -c MyConfig.json -s MyStrategy is equivalent to \u00b6 freqtrade trade -c MyConfig.json -s MyStrategy --db-url sqlite:///tradesv3.dryrun.sqlite ``` It means that if you are running the trade command in two different terminals, for example to test your strategy both for trades in USDT and in another instance for trades in BTC, you will have to run them with different databases. If you specify the URL of a database which does not exist, freqtrade will create one with the name you specified. So to test your custom strategy with BTC and USDT stake currencies, you could use the following commands (in 2 separate terminals): ``` bash Terminal 1: \u00b6 freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.dryrun.sqlite Terminal 2: \u00b6 freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.dryrun.sqlite ``` Conversely, if you wish to do the same thing in production mode, you will also have to create at least one new database (in addition to the default one) and specify the path to the \"live\" databases, for example: ``` bash Terminal 1: \u00b6 freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.live.sqlite Terminal 2: \u00b6 freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.live.sqlite ``` For more information regarding usage of the sqlite databases, for example to manually enter or remove trades, please refer to the SQL Cheatsheet . Multiple instances using docker \u00b6 To run multiple instances of freqtrade using docker you will need to edit the docker-compose.yml file and add all the instances you want as separate services. Remember, you can separate your configuration into multiple files, so it's a good idea to think about making them modular, then if you need to edit something common to all bots, you can do that in a single config file. ``` yml version: '3' services: freqtrade1: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade1 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8080:8080\" # Default command used when running docker compose up command: > trade --logfile /freqtrade/user_data/logs/freqtrade1.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade1.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade1.json --strategy SampleStrategy freqtrade2: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade2 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8081:8080\" # Default command used when running docker compose up command: > trade --logfile /freqtrade/user_data/logs/freqtrade2.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade2.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade2.json --strategy SampleStrategy ``` You can use whatever naming convention you want, freqtrade1 and 2 are arbitrary. Note, that you will need to use different database files, port mappings and telegram configurations for each instance, as mentioned above. Configure the bot running as a systemd service \u00b6 Copy the freqtrade.service file to your systemd user directory (usually ~/.config/systemd/user ) and update WorkingDirectory and ExecStart to match your setup. Note Certain systems (like Raspbian) don't load service unit files from the user directory. In this case, copy freqtrade.service into /etc/systemd/user/ (requires superuser permissions). After that you can start the daemon with: bash systemctl --user start freqtrade For this to be persistent (run when user is logged out) you'll need to enable linger for your freqtrade user. bash sudo loginctl enable-linger \"$USER\" If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot state and restarting it in the case of failures. If the internals.sd_notify parameter is set to true in the configuration or the --sd-notify command line option is used, the bot will send keep-alive ping messages to systemd using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped) when it changes. The freqtrade.service.watchdog file contains an example of the service unit configuration file which uses systemd as the watchdog. Note The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container. Advanced Logging \u00b6 On many Linux systems the bot can be configured to send its log messages to syslog or journald system services. Logging to a remote syslog server is also available on Windows. The special values for the --logfile command line option can be used for this. Logging to syslog \u00b6 To send Freqtrade log messages to a local or remote syslog service use the --logfile command line option with the value in the following format: --logfile syslog:<syslog_address> -- send log messages to syslog service using the <syslog_address> as the syslog address. The syslog address can be either a Unix domain socket (socket filename) or a UDP socket specification, consisting of IP address and UDP port, separated by the : character. So, the following are the examples of possible usages: --logfile syslog:/dev/log -- log to syslog (rsyslog) using the /dev/log socket, suitable for most systems. --logfile syslog -- same as above, the shortcut for /dev/log . --logfile syslog:/var/run/syslog -- log to syslog (rsyslog) using the /var/run/syslog socket. Use this on MacOS. --logfile syslog:localhost:514 -- log to local syslog using UDP socket, if it listens on port 514. --logfile syslog:<ip>:514 -- log to remote syslog at IP address and port 514. This may be used on Windows for remote logging to an external syslog server. Log messages are send to syslog with the user facility. So you can see them with the following commands: tail -f /var/log/user , or install a comprehensive graphical viewer (for instance, 'Log File Viewer' for Ubuntu). On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better. For rsyslog the messages from the bot can be redirected into a separate dedicated log file. To achieve this, add if $programname startswith \"freqtrade\" then -/var/log/freqtrade.log to one of the rsyslog configuration files, for example at the end of the /etc/rsyslog.d/50-default.conf . For syslog ( rsyslog ), the reduction mode can be switched on. This will reduce the number of repeating messages. For instance, multiple bot Heartbeat messages will be reduced to a single message when nothing else happens with the bot. To achieve this, set in /etc/rsyslog.conf : ``` Filter duplicated messages \u00b6 $RepeatedMsgReduction on ``` Logging to journald \u00b6 This needs the systemd python package installed as the dependency, which is not available on Windows. Hence, the whole journald logging functionality is not available for a bot running on Windows. To send Freqtrade log messages to journald system service use the --logfile command line option with the value in the following format: --logfile journald -- send log messages to journald . Log messages are send to journald with the user facility. So you can see them with the following commands: journalctl -f -- shows Freqtrade log messages sent to journald along with other log messages fetched by journald . journalctl -f -u freqtrade.service -- this command can be used when the bot is run as a systemd service. There are many other options in the journalctl utility to filter the messages, see manual pages for this utility. On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better.","title":"Advanced Post-installation Tasks"},{"location":"advanced-setup/#advanced-post-installation-tasks","text":"This page explains some advanced tasks and configuration options that can be performed after the bot installation and may be uselful in some environments. If you do not know what things mentioned here mean, you probably do not need it.","title":"Advanced Post-installation Tasks"},{"location":"advanced-setup/#running-multiple-instances-of-freqtrade","text":"This section will show you how to run multiple bots at the same time, on the same machine.","title":"Running multiple instances of Freqtrade"},{"location":"advanced-setup/#things-to-consider","text":"Use different database files. Use different Telegram bots (requires multiple different configuration files; applies only when Telegram is enabled). Use different ports (applies only when Freqtrade REST API webserver is enabled).","title":"Things to consider"},{"location":"advanced-setup/#different-database-files","text":"In order to keep track of your trades, profits, etc., freqtrade is using a SQLite database where it stores various types of information such as the trades you performed in the past and the current position(s) you are holding at any time. This allows you to keep track of your profits, but most importantly, keep track of ongoing activity if the bot process would be restarted or would be terminated unexpectedly. Freqtrade will, by default, use separate database files for dry-run and live bots (this assumes no database-url is given in either configuration nor via command line argument). For live trading mode, the default database will be tradesv3.sqlite and for dry-run it will be tradesv3.dryrun.sqlite . The optional argument to the trade command used to specify the path of these files is --db-url , which requires a valid SQLAlchemy url. So when you are starting a bot with only the config and strategy arguments in dry-run mode, the following 2 commands would have the same outcome. ``` bash freqtrade trade -c MyConfig.json -s MyStrategy","title":"Different database files"},{"location":"advanced-setup/#is-equivalent-to","text":"freqtrade trade -c MyConfig.json -s MyStrategy --db-url sqlite:///tradesv3.dryrun.sqlite ``` It means that if you are running the trade command in two different terminals, for example to test your strategy both for trades in USDT and in another instance for trades in BTC, you will have to run them with different databases. If you specify the URL of a database which does not exist, freqtrade will create one with the name you specified. So to test your custom strategy with BTC and USDT stake currencies, you could use the following commands (in 2 separate terminals): ``` bash","title":"is equivalent to"},{"location":"advanced-setup/#terminal-1","text":"freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.dryrun.sqlite","title":"Terminal 1:"},{"location":"advanced-setup/#terminal-2","text":"freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.dryrun.sqlite ``` Conversely, if you wish to do the same thing in production mode, you will also have to create at least one new database (in addition to the default one) and specify the path to the \"live\" databases, for example: ``` bash","title":"Terminal 2:"},{"location":"advanced-setup/#terminal-1_1","text":"freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.live.sqlite","title":"Terminal 1:"},{"location":"advanced-setup/#terminal-2_1","text":"freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.live.sqlite ``` For more information regarding usage of the sqlite databases, for example to manually enter or remove trades, please refer to the SQL Cheatsheet .","title":"Terminal 2:"},{"location":"advanced-setup/#multiple-instances-using-docker","text":"To run multiple instances of freqtrade using docker you will need to edit the docker-compose.yml file and add all the instances you want as separate services. Remember, you can separate your configuration into multiple files, so it's a good idea to think about making them modular, then if you need to edit something common to all bots, you can do that in a single config file. ``` yml version: '3' services: freqtrade1: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade1 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8080:8080\" # Default command used when running docker compose up command: > trade --logfile /freqtrade/user_data/logs/freqtrade1.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade1.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade1.json --strategy SampleStrategy freqtrade2: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade2 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8081:8080\" # Default command used when running docker compose up command: > trade --logfile /freqtrade/user_data/logs/freqtrade2.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade2.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade2.json --strategy SampleStrategy ``` You can use whatever naming convention you want, freqtrade1 and 2 are arbitrary. Note, that you will need to use different database files, port mappings and telegram configurations for each instance, as mentioned above.","title":"Multiple instances using docker"},{"location":"advanced-setup/#configure-the-bot-running-as-a-systemd-service","text":"Copy the freqtrade.service file to your systemd user directory (usually ~/.config/systemd/user ) and update WorkingDirectory and ExecStart to match your setup. Note Certain systems (like Raspbian) don't load service unit files from the user directory. In this case, copy freqtrade.service into /etc/systemd/user/ (requires superuser permissions). After that you can start the daemon with: bash systemctl --user start freqtrade For this to be persistent (run when user is logged out) you'll need to enable linger for your freqtrade user. bash sudo loginctl enable-linger \"$USER\" If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot state and restarting it in the case of failures. If the internals.sd_notify parameter is set to true in the configuration or the --sd-notify command line option is used, the bot will send keep-alive ping messages to systemd using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped) when it changes. The freqtrade.service.watchdog file contains an example of the service unit configuration file which uses systemd as the watchdog. Note The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container.","title":"Configure the bot running as a systemd service"},{"location":"advanced-setup/#advanced-logging","text":"On many Linux systems the bot can be configured to send its log messages to syslog or journald system services. Logging to a remote syslog server is also available on Windows. The special values for the --logfile command line option can be used for this.","title":"Advanced Logging"},{"location":"advanced-setup/#logging-to-syslog","text":"To send Freqtrade log messages to a local or remote syslog service use the --logfile command line option with the value in the following format: --logfile syslog:<syslog_address> -- send log messages to syslog service using the <syslog_address> as the syslog address. The syslog address can be either a Unix domain socket (socket filename) or a UDP socket specification, consisting of IP address and UDP port, separated by the : character. So, the following are the examples of possible usages: --logfile syslog:/dev/log -- log to syslog (rsyslog) using the /dev/log socket, suitable for most systems. --logfile syslog -- same as above, the shortcut for /dev/log . --logfile syslog:/var/run/syslog -- log to syslog (rsyslog) using the /var/run/syslog socket. Use this on MacOS. --logfile syslog:localhost:514 -- log to local syslog using UDP socket, if it listens on port 514. --logfile syslog:<ip>:514 -- log to remote syslog at IP address and port 514. This may be used on Windows for remote logging to an external syslog server. Log messages are send to syslog with the user facility. So you can see them with the following commands: tail -f /var/log/user , or install a comprehensive graphical viewer (for instance, 'Log File Viewer' for Ubuntu). On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better. For rsyslog the messages from the bot can be redirected into a separate dedicated log file. To achieve this, add if $programname startswith \"freqtrade\" then -/var/log/freqtrade.log to one of the rsyslog configuration files, for example at the end of the /etc/rsyslog.d/50-default.conf . For syslog ( rsyslog ), the reduction mode can be switched on. This will reduce the number of repeating messages. For instance, multiple bot Heartbeat messages will be reduced to a single message when nothing else happens with the bot. To achieve this, set in /etc/rsyslog.conf : ```","title":"Logging to syslog"},{"location":"advanced-setup/#filter-duplicated-messages","text":"$RepeatedMsgReduction on ```","title":"Filter duplicated messages"},{"location":"advanced-setup/#logging-to-journald","text":"This needs the systemd python package installed as the dependency, which is not available on Windows. Hence, the whole journald logging functionality is not available for a bot running on Windows. To send Freqtrade log messages to journald system service use the --logfile command line option with the value in the following format: --logfile journald -- send log messages to journald . Log messages are send to journald with the user facility. So you can see them with the following commands: journalctl -f -- shows Freqtrade log messages sent to journald along with other log messages fetched by journald . journalctl -f -u freqtrade.service -- this command can be used when the bot is run as a systemd service. There are many other options in the journalctl utility to filter the messages, see manual pages for this utility. On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better.","title":"Logging to journald"},{"location":"backtesting/","text":"Backtesting \u00b6 This page explains how to validate your strategy performance by using Backtesting. Backtesting requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Backtesting command reference \u00b6 ``` usage: freqtrade backtesting [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]] [--export {none,trades}] [--export-filename PATH] [--breakdown {day,week,month} [{day,week,month} ...]] [--cache {none,day,week,month}] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying max_open_trades during backtest (same as setting max_open_trades to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting ( 1m , 5m , 30m , 1h , 1d ). --strategy-list STRATEGY_LIST [STRATEGY_LIST ...] Provide a space-separated list of strategies to backtest. Please note that timeframe needs to be set either in config or via command line. When using this together with --export trades , the strategy- name is injected into the filename (so backtest- data.json becomes backtest-data-SampleStrategy.json --export {none,trades} Export backtest results (default: trades). --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. --cache {none,day,week,month} Load a cached backtest result no older than specified age (default: day). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` Test your strategy with Backtesting \u00b6 Now you have good Buy and Sell strategies and some historic data, you want to test it against real data. This is what we call backtesting . Backtesting will use the crypto-currencies (pairs) from your config file and load historical candle (OHLCV) data from user_data/data/<exchange> by default. If no data is available for the exchange / pair / timeframe combination, backtesting will ask you to download them first using freqtrade download-data . For details on downloading, please refer to the Data Downloading section in the documentation. The result of backtesting will confirm if your bot has better odds of making a profit than a loss. All profit calculations include fees, and freqtrade will use the exchange's default fees for the calculation. Using dynamic pairlists for backtesting Using dynamic pairlists is possible (not all of the handlers are allowed to be used in backtest mode), however it relies on the current market conditions - which will not reflect the historic status of the pairlist. Also, when using pairlists other than StaticPairlist, reproducibility of backtesting-results cannot be guaranteed. Please read the pairlists documentation for more information. To achieve reproducible results, best generate a pairlist via the test-pairlist command and use that as static pairlist. Note By default, Freqtrade will export backtesting results to user_data/backtest_results . The exported trades can be used for further analysis or can be used by the plotting sub-command ( freqtrade plot-dataframe ) in the scripts directory. Starting balance \u00b6 Backtesting will require a starting balance, which can be provided as --dry-run-wallet <balance> or --starting-balance <balance> command line argument, or via dry_run_wallet configuration setting. This amount must be higher than stake_amount , otherwise the bot will not be able to simulate any trade. Dynamic stake amount \u00b6 Backtesting supports dynamic stake amount by configuring stake_amount as \"unlimited\" , which will split the starting balance into max_open_trades pieces. Profits from early trades will result in subsequent higher stake amounts, resulting in compounding of profits over the backtesting period. Example backtesting commands \u00b6 With 5 min candle (OHLCV) data (per default) bash freqtrade backtesting --strategy AwesomeStrategy Where --strategy AwesomeStrategy / -s AwesomeStrategy refers to the class name of the strategy, which is within a python file in the user_data/strategies directory. With 1 min candle (OHLCV) data bash freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m Providing a custom starting balance of 1000 (in stake currency) bash freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000 Using a different on-disk historical candle (OHLCV) data source Assume you downloaded the history data from the Bittrex exchange and kept it in the user_data/data/bittrex-20180101 directory. You can then use this data for backtesting as follows: bash freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/bittrex-20180101 Comparing multiple Strategies bash freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m Where SampleStrategy1 and AwesomeStrategy refer to class names of strategies. Prevent exporting trades to file bash freqtrade backtesting --strategy backtesting --export none --config config.json Only use this if you're sure you'll not want to plot or analyze your results further. Exporting trades to file specifying a custom filename bash freqtrade backtesting --strategy backtesting --export trades --export-filename=backtest_samplestrategy.json Please also read about the strategy startup period . Supplying custom fee value Sometimes your account has certain fee rebates (fee reductions starting with a certain account size or monthly volume), which are not visible to ccxt. To account for this in backtesting, you can use the --fee command line option to supply this value to backtesting. This fee must be a ratio, and will be applied twice (once for trade entry, and once for trade exit). For example, if the buying and selling commission fee is 0.1% (i.e., 0.001 written as ratio), then you would run backtesting as the following: bash freqtrade backtesting --fee 0.001 Note Only supply this option (or the corresponding configuration parameter) if you want to experiment with different fee values. By default, Backtesting fetches the default fee from the exchange pair/market info. Running backtest with smaller test-set by using timerange Use the --timerange argument to change how much of the test-set you want to use. For example, running backtesting with the --timerange=20190501- option will use all available data starting with May 1 st , 2019 from your input data. bash freqtrade backtesting --timerange=20190501- You can also specify particular date ranges. The full timerange specification: Use data until 2018/01/31: --timerange=-20180131 Use data since 2018/01/31: --timerange=20180131- Use data since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use data between POSIX / epoch timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Understand the backtesting result \u00b6 The most important in the backtesting is to understand the result. A backtesting result will look like that: ========================================================= BACKTESTING REPORT ========================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins Draws Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:-------------|-------------------------:| | ADA/BTC | 35 | -0.11 | -3.88 | -0.00019428 | -1.94 | 4:35:00 | 14 0 21 40.0 | | ARK/BTC | 11 | -0.41 | -4.52 | -0.00022647 | -2.26 | 2:03:00 | 3 0 8 27.3 | | BTS/BTC | 32 | 0.31 | 9.78 | 0.00048938 | 4.89 | 5:05:00 | 18 0 14 56.2 | | DASH/BTC | 13 | -0.08 | -1.07 | -0.00005343 | -0.53 | 4:39:00 | 6 0 7 46.2 | | ENG/BTC | 18 | 1.36 | 24.54 | 0.00122807 | 12.27 | 2:50:00 | 8 0 10 44.4 | | EOS/BTC | 36 | 0.08 | 3.06 | 0.00015304 | 1.53 | 3:34:00 | 16 0 20 44.4 | | ETC/BTC | 26 | 0.37 | 9.51 | 0.00047576 | 4.75 | 6:14:00 | 11 0 15 42.3 | | ETH/BTC | 33 | 0.30 | 9.96 | 0.00049856 | 4.98 | 7:31:00 | 16 0 17 48.5 | | IOTA/BTC | 32 | 0.03 | 1.09 | 0.00005444 | 0.54 | 3:12:00 | 14 0 18 43.8 | | LSK/BTC | 15 | 1.75 | 26.26 | 0.00131413 | 13.13 | 2:58:00 | 6 0 9 40.0 | | LTC/BTC | 32 | -0.04 | -1.38 | -0.00006886 | -0.69 | 4:49:00 | 11 0 21 34.4 | | NANO/BTC | 17 | 1.26 | 21.39 | 0.00107058 | 10.70 | 1:55:00 | 10 0 7 58.5 | | NEO/BTC | 23 | 0.82 | 18.97 | 0.00094936 | 9.48 | 2:59:00 | 10 0 13 43.5 | | REQ/BTC | 9 | 1.17 | 10.54 | 0.00052734 | 5.27 | 3:47:00 | 4 0 5 44.4 | | XLM/BTC | 16 | 1.22 | 19.54 | 0.00097800 | 9.77 | 3:15:00 | 7 0 9 43.8 | | XMR/BTC | 23 | -0.18 | -4.13 | -0.00020696 | -2.07 | 5:30:00 | 12 0 11 52.2 | | XRP/BTC | 35 | 0.66 | 22.96 | 0.00114897 | 11.48 | 3:49:00 | 12 0 23 34.3 | | ZEC/BTC | 22 | -0.46 | -10.18 | -0.00050971 | -5.09 | 2:22:00 | 7 0 15 31.8 | | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | ========================================================= SELL REASON STATS ========================================================== | Sell Reason | Sells | Wins | Draws | Losses | |:-------------------|--------:|------:|-------:|--------:| | trailing_stop_loss | 205 | 150 | 0 | 55 | | stop_loss | 166 | 0 | 0 | 166 | | sell_signal | 56 | 36 | 0 | 20 | | force_sell | 2 | 0 | 0 | 2 | ====================================================== LEFT OPEN TRADES REPORT ====================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Win Draw Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|--------------------:| | ADA/BTC | 1 | 0.89 | 0.89 | 0.00004434 | 0.44 | 6:00:00 | 1 0 0 100 | | LTC/BTC | 1 | 0.68 | 0.68 | 0.00003421 | 0.34 | 2:00:00 | 1 0 0 100 | | TOTAL | 2 | 0.78 | 1.57 | 0.00007855 | 0.78 | 4:00:00 | 2 0 0 100 | =============== SUMMARY METRICS =============== | Metric | Value | |-----------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades| 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | Trades per day | 3.575 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Buy signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | =============================================== Backtesting report table \u00b6 The 1 st table contains all trades the bot made, including \"left open trades\". The last line will give you the overall performance of your strategy, here: | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | The bot has made 429 trades for an average duration of 4:12:00 , with a performance of 76.20% (profit), that means it has earned a total of 0.00762792 BTC starting with a capital of 0.01 BTC. The column Avg Profit % shows the average profit for all trades made while the column Cum Profit % sums up all the profits/losses. The column Tot Profit % shows instead the total profit % in relation to the starting balance. In the above results, we have a starting balance of 0.01 BTC and an absolute profit of 0.00762792 BTC - so the Tot Profit % will be (0.00762792 / 0.01) * 100 ~= 76.2% . Your strategy performance is influenced by your buy strategy, your sell strategy, and also by the minimal_roi and stop_loss you have set. For example, if your minimal_roi is only \"0\": 0.01 you cannot expect the bot to make more profit than 1% (because it will sell every time a trade reaches 1%). json \"minimal_roi\": { \"0\": 0.01 }, On the other hand, if you set a too high minimal_roi like \"0\": 0.55 (55%), there is almost no chance that the bot will ever reach this profit. Hence, keep in mind that your performance is an integral mix of all different elements of the strategy, your configuration, and the crypto-currency pairs you have set up. Sell reasons table \u00b6 The 2 nd table contains a recap of sell reasons. This table can tell you which area needs some additional work (e.g. all or many of the sell_signal trades are losses, so you should work on improving the sell signal, or consider disabling it). Left open trades table \u00b6 The 3 rd table contains all trades the bot had to forcesell at the end of the backtesting period to present you the full picture. This is necessary to simulate realistic behavior, since the backtest period has to end at some point, while realistically, you could leave the bot running forever. These trades are also included in the first table, but are also shown separately in this table for clarity. Summary metrics \u00b6 The last element of the backtest report is the summary metrics table. It contains some useful key metrics about performance of your strategy on backtesting data. ``` =============== SUMMARY METRICS =============== | Metric | Value | |-----------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades| 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Buy signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | =============================================== ``` Backtesting from / Backtesting to : Backtesting range (usually defined with the --timerange option). Max open trades : Setting of max_open_trades (or --max-open-trades ) - or number of pairs in the pairlist (whatever is lower). Total/Daily Avg Trades : Identical to the total trades of the backtest output table / Total trades divided by the backtesting duration in days (this will give you information about how many trades to expect from the strategy). Starting balance : Start balance - as given by dry-run-wallet (config or command line). Final balance : Final balance - starting balance + absolute profit. Absolute profit : Profit made in stake currency. Total profit % : Total profit. Aligned to the TOTAL row's Tot Profit % from the first table. Calculated as (End capital \u2212 Starting capital) / Starting capital . Avg. stake amount : Average stake amount, either stake_amount or the average when using dynamic stake amount. Total trade volume : Volume generated on the exchange to reach the above profit. Best Pair / Worst Pair : Best and worst performing pair, and it's corresponding Cum Profit % . Best Trade / Worst Trade : Biggest single winning trade and biggest single losing trade. Best day / Worst day : Best and worst day based on daily profit. Days win/draw/lose : Winning / Losing days (draws are usually days without closed trade). Avg. Duration Winners / Avg. Duration Loser : Average durations for winning and losing trades. Rejected Buy signals : Buy signals that could not be acted upon due to max_open_trades being reached. Entry/Exit Timeouts : Entry/exit orders which did not fill (only applicable if custom pricing is used). Min balance / Max balance : Lowest and Highest Wallet balance during the backtest period. Drawdown (Account) : Maximum Account Drawdown experienced. Calculated as \\((Absolute Drawdown) / (DrawdownHigh + startingBalance)\\) . Drawdown : Maximum, absolute drawdown experienced. Difference between Drawdown High and Subsequent Low point. Drawdown high / Drawdown low : Profit at the beginning and end of the largest drawdown period. A negative low value means initial capital lost. Drawdown Start / Drawdown End : Start and end datetime for this largest drawdown (can also be visualized via the plot-dataframe sub-command). Market change : Change of the market during the backtest period. Calculated as average of all pairs changes from the first to the last candle using the \"close\" column. Daily / Weekly / Monthly breakdown \u00b6 You can get an overview over daily / weekly or monthly results by using the --breakdown <> switch. To visualize daily and weekly breakdowns, you can use the following: bash freqtrade backtesting --strategy MyAwesomeStrategy --breakdown day month ``` output ======================== DAY BREAKDOWN ========================= | Day | Tot Profit USDT | Wins | Draws | Losses | |------------+-------------------+--------+---------+----------| | 03/07/2021 | 200.0 | 2 | 0 | 0 | | 04/07/2021 | -50.31 | 0 | 0 | 2 | | 05/07/2021 | 220.611 | 3 | 2 | 0 | | 06/07/2021 | 150.974 | 3 | 0 | 2 | | 07/07/2021 | -70.193 | 1 | 0 | 2 | | 08/07/2021 | 212.413 | 2 | 0 | 3 | ``` The output will show a table containing the realized absolute Profit (in stake currency) for the given timeperiod, as well as wins, draws and losses that materialized (closed) on this day. Backtest result caching \u00b6 To save time, by default backtest will reuse a cached result from within the last day when the backtested strategy and config match that of a previous backtest. To force a new backtest despite existing result for an identical run specify --cache none parameter. Warning Caching is automatically disabled for open-ended timeranges ( --timerange 20210101- ), as freqtrade cannot ensure reliably that the underlying data didn't change. It can also use cached results where it shouldn't if the original backtest had missing data at the end, which was fixed by downloading more data. In this instance, please use --cache none once to force a fresh backtest. Further backtest-result analysis \u00b6 To further analyze your backtest results, you can export the trades . You can then load the trades to perform further analysis as shown in the data analysis backtesting section. Assumptions made by backtesting \u00b6 Since backtesting lacks some detailed information about what happens within a candle, it needs to take a few assumptions: Buys happen at open-price All orders are filled at the requested price (no slippage, no unfilled orders) Sell-signal sells happen at open-price of the consecutive candle Sell-signal is favored over Stoploss, because sell-signals are assumed to trigger on candle's open ROI sells are compared to high - but the ROI value is used (e.g. ROI = 2%, high=5% - so the sell will be at 2%) sells are never \"below the candle\", so a ROI of 2% may result in a sell at 2.4% if low was at 2.4% profit Forcesells caused by <N>=-1 ROI entries use low as sell value, unless N falls on the candle open (e.g. 120: -1 for 1h candles) Stoploss sells happen exactly at stoploss price, even if low was lower, but the loss will be 2 * fees higher than the stoploss price Stoploss is evaluated before ROI within one candle. So you can often see more trades with the stoploss sell reason comparing to the results obtained with the same strategy in the Dry Run/Live Trade modes Low happens before high for stoploss, protecting capital first Trailing stoploss Trailing Stoploss is only adjusted if it's below the candle's low (otherwise it would be triggered) On trade entry candles that trigger trailing stoploss, the \"minimum offset\" ( stop_positive_offset ) is assumed (instead of high) - and the stop is calculated from this point High happens first - adjusting stoploss Low uses the adjusted stoploss (so sells with large high-low difference are backtested correctly) ROI applies before trailing-stop, ensuring profits are \"top-capped\" at ROI if both ROI and trailing stop applies Sell-reason does not explain if a trade was positive or negative, just what triggered the sell (this can look odd if negative ROI values are used) Evaluation sequence (if multiple signals happen on the same candle) Sell-signal ROI (if not stoploss) Stoploss Taking these assumptions, backtesting tries to mirror real trading as closely as possible. However, backtesting will never replace running a strategy in dry-run mode. Also, keep in mind that past results don't guarantee future success. In addition to the above assumptions, strategy authors should carefully read the Common Mistakes section, to avoid using data in backtesting which is not available in real market conditions. Improved backtest accuracy \u00b6 One big limitation of backtesting is it's inability to know how prices moved intra-candle (was high before close, or viceversa?). So assuming you run backtesting with a 1h timeframe, there will be 4 prices for that candle (Open, High, Low, Close). While backtesting does take some assumptions (read above) about this - this can never be perfect, and will always be biased in one way or the other. To mitigate this, freqtrade can use a lower (faster) timeframe to simulate intra-candle movements. To utilize this, you can append --timeframe-detail 5m to your regular backtesting command. bash freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m This will load 1h data as well as 5m data for the timeframe. The strategy will be analyzed with the 1h timeframe - and for every \"open trade candle\" (candles where a trade is open) the 5m data will be used to simulate intra-candle movements. All callback functions ( custom_sell() , custom_stoploss() , ... ) will be running for each 5m candle once the trade is opened (so 12 times in the above example of 1h timeframe, and 5m detailed timeframe). --timeframe-detail must be smaller than the original timeframe, otherwise backtesting will fail to start. Obviously this will require more memory (5m data is bigger than 1h data), and will also impact runtime (depending on the amount of trades and trade durations). Also, data must be available / downloaded already. Tip You can use this function as the last part of strategy development, to ensure your strategy is not exploiting one of the backtesting assumptions . Strategies that perform similarly well with this mode have a good chance to perform well in dry/live modes too (although only forward-testing (dry-mode) can really confirm a strategy). Backtesting multiple strategies \u00b6 To compare multiple strategies, a list of Strategies can be provided to backtesting. This is limited to 1 timeframe value per run. However, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this will give a nice runtime boost. All listed Strategies need to be in the same directory. bash freqtrade backtesting --timerange 20180401-20180410 --timeframe 5m --strategy-list Strategy001 Strategy002 --export trades This will save the results to user_data/backtest_results/backtest-result-<strategy>.json , injecting the strategy-name into the target filename. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up to see the details per strategy. =========================================================== STRATEGY SUMMARY ========================================================================= | Strategy | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins | Draws | Losses | Drawdown % | |:------------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|------:|-------:|-------:|-----------:| | Strategy1 | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 | 0 | 243 | 45.2 | | Strategy2 | 1487 | -0.13 | -197.58 | -0.00988917 | -98.79 | 4:43:00 | 662 | 0 | 825 | 241.68 | Next step \u00b6 Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt","title":"Backtesting"},{"location":"backtesting/#backtesting","text":"This page explains how to validate your strategy performance by using Backtesting. Backtesting requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.","title":"Backtesting"},{"location":"backtesting/#backtesting-command-reference","text":"``` usage: freqtrade backtesting [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]] [--export {none,trades}] [--export-filename PATH] [--breakdown {day,week,month} [{day,week,month} ...]] [--cache {none,day,week,month}] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying max_open_trades during backtest (same as setting max_open_trades to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting ( 1m , 5m , 30m , 1h , 1d ). --strategy-list STRATEGY_LIST [STRATEGY_LIST ...] Provide a space-separated list of strategies to backtest. Please note that timeframe needs to be set either in config or via command line. When using this together with --export trades , the strategy- name is injected into the filename (so backtest- data.json becomes backtest-data-SampleStrategy.json --export {none,trades} Export backtest results (default: trades). --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. --cache {none,day,week,month} Load a cached backtest result no older than specified age (default: day). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ```","title":"Backtesting command reference"},{"location":"backtesting/#test-your-strategy-with-backtesting","text":"Now you have good Buy and Sell strategies and some historic data, you want to test it against real data. This is what we call backtesting . Backtesting will use the crypto-currencies (pairs) from your config file and load historical candle (OHLCV) data from user_data/data/<exchange> by default. If no data is available for the exchange / pair / timeframe combination, backtesting will ask you to download them first using freqtrade download-data . For details on downloading, please refer to the Data Downloading section in the documentation. The result of backtesting will confirm if your bot has better odds of making a profit than a loss. All profit calculations include fees, and freqtrade will use the exchange's default fees for the calculation. Using dynamic pairlists for backtesting Using dynamic pairlists is possible (not all of the handlers are allowed to be used in backtest mode), however it relies on the current market conditions - which will not reflect the historic status of the pairlist. Also, when using pairlists other than StaticPairlist, reproducibility of backtesting-results cannot be guaranteed. Please read the pairlists documentation for more information. To achieve reproducible results, best generate a pairlist via the test-pairlist command and use that as static pairlist. Note By default, Freqtrade will export backtesting results to user_data/backtest_results . The exported trades can be used for further analysis or can be used by the plotting sub-command ( freqtrade plot-dataframe ) in the scripts directory.","title":"Test your strategy with Backtesting"},{"location":"backtesting/#starting-balance","text":"Backtesting will require a starting balance, which can be provided as --dry-run-wallet <balance> or --starting-balance <balance> command line argument, or via dry_run_wallet configuration setting. This amount must be higher than stake_amount , otherwise the bot will not be able to simulate any trade.","title":"Starting balance"},{"location":"backtesting/#dynamic-stake-amount","text":"Backtesting supports dynamic stake amount by configuring stake_amount as \"unlimited\" , which will split the starting balance into max_open_trades pieces. Profits from early trades will result in subsequent higher stake amounts, resulting in compounding of profits over the backtesting period.","title":"Dynamic stake amount"},{"location":"backtesting/#example-backtesting-commands","text":"With 5 min candle (OHLCV) data (per default) bash freqtrade backtesting --strategy AwesomeStrategy Where --strategy AwesomeStrategy / -s AwesomeStrategy refers to the class name of the strategy, which is within a python file in the user_data/strategies directory. With 1 min candle (OHLCV) data bash freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m Providing a custom starting balance of 1000 (in stake currency) bash freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000 Using a different on-disk historical candle (OHLCV) data source Assume you downloaded the history data from the Bittrex exchange and kept it in the user_data/data/bittrex-20180101 directory. You can then use this data for backtesting as follows: bash freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/bittrex-20180101 Comparing multiple Strategies bash freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m Where SampleStrategy1 and AwesomeStrategy refer to class names of strategies. Prevent exporting trades to file bash freqtrade backtesting --strategy backtesting --export none --config config.json Only use this if you're sure you'll not want to plot or analyze your results further. Exporting trades to file specifying a custom filename bash freqtrade backtesting --strategy backtesting --export trades --export-filename=backtest_samplestrategy.json Please also read about the strategy startup period . Supplying custom fee value Sometimes your account has certain fee rebates (fee reductions starting with a certain account size or monthly volume), which are not visible to ccxt. To account for this in backtesting, you can use the --fee command line option to supply this value to backtesting. This fee must be a ratio, and will be applied twice (once for trade entry, and once for trade exit). For example, if the buying and selling commission fee is 0.1% (i.e., 0.001 written as ratio), then you would run backtesting as the following: bash freqtrade backtesting --fee 0.001 Note Only supply this option (or the corresponding configuration parameter) if you want to experiment with different fee values. By default, Backtesting fetches the default fee from the exchange pair/market info. Running backtest with smaller test-set by using timerange Use the --timerange argument to change how much of the test-set you want to use. For example, running backtesting with the --timerange=20190501- option will use all available data starting with May 1 st , 2019 from your input data. bash freqtrade backtesting --timerange=20190501- You can also specify particular date ranges. The full timerange specification: Use data until 2018/01/31: --timerange=-20180131 Use data since 2018/01/31: --timerange=20180131- Use data since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use data between POSIX / epoch timestamps 1527595200 1527618600: --timerange=1527595200-1527618600","title":"Example backtesting commands"},{"location":"backtesting/#understand-the-backtesting-result","text":"The most important in the backtesting is to understand the result. A backtesting result will look like that: ========================================================= BACKTESTING REPORT ========================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins Draws Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:-------------|-------------------------:| | ADA/BTC | 35 | -0.11 | -3.88 | -0.00019428 | -1.94 | 4:35:00 | 14 0 21 40.0 | | ARK/BTC | 11 | -0.41 | -4.52 | -0.00022647 | -2.26 | 2:03:00 | 3 0 8 27.3 | | BTS/BTC | 32 | 0.31 | 9.78 | 0.00048938 | 4.89 | 5:05:00 | 18 0 14 56.2 | | DASH/BTC | 13 | -0.08 | -1.07 | -0.00005343 | -0.53 | 4:39:00 | 6 0 7 46.2 | | ENG/BTC | 18 | 1.36 | 24.54 | 0.00122807 | 12.27 | 2:50:00 | 8 0 10 44.4 | | EOS/BTC | 36 | 0.08 | 3.06 | 0.00015304 | 1.53 | 3:34:00 | 16 0 20 44.4 | | ETC/BTC | 26 | 0.37 | 9.51 | 0.00047576 | 4.75 | 6:14:00 | 11 0 15 42.3 | | ETH/BTC | 33 | 0.30 | 9.96 | 0.00049856 | 4.98 | 7:31:00 | 16 0 17 48.5 | | IOTA/BTC | 32 | 0.03 | 1.09 | 0.00005444 | 0.54 | 3:12:00 | 14 0 18 43.8 | | LSK/BTC | 15 | 1.75 | 26.26 | 0.00131413 | 13.13 | 2:58:00 | 6 0 9 40.0 | | LTC/BTC | 32 | -0.04 | -1.38 | -0.00006886 | -0.69 | 4:49:00 | 11 0 21 34.4 | | NANO/BTC | 17 | 1.26 | 21.39 | 0.00107058 | 10.70 | 1:55:00 | 10 0 7 58.5 | | NEO/BTC | 23 | 0.82 | 18.97 | 0.00094936 | 9.48 | 2:59:00 | 10 0 13 43.5 | | REQ/BTC | 9 | 1.17 | 10.54 | 0.00052734 | 5.27 | 3:47:00 | 4 0 5 44.4 | | XLM/BTC | 16 | 1.22 | 19.54 | 0.00097800 | 9.77 | 3:15:00 | 7 0 9 43.8 | | XMR/BTC | 23 | -0.18 | -4.13 | -0.00020696 | -2.07 | 5:30:00 | 12 0 11 52.2 | | XRP/BTC | 35 | 0.66 | 22.96 | 0.00114897 | 11.48 | 3:49:00 | 12 0 23 34.3 | | ZEC/BTC | 22 | -0.46 | -10.18 | -0.00050971 | -5.09 | 2:22:00 | 7 0 15 31.8 | | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | ========================================================= SELL REASON STATS ========================================================== | Sell Reason | Sells | Wins | Draws | Losses | |:-------------------|--------:|------:|-------:|--------:| | trailing_stop_loss | 205 | 150 | 0 | 55 | | stop_loss | 166 | 0 | 0 | 166 | | sell_signal | 56 | 36 | 0 | 20 | | force_sell | 2 | 0 | 0 | 2 | ====================================================== LEFT OPEN TRADES REPORT ====================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Win Draw Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|--------------------:| | ADA/BTC | 1 | 0.89 | 0.89 | 0.00004434 | 0.44 | 6:00:00 | 1 0 0 100 | | LTC/BTC | 1 | 0.68 | 0.68 | 0.00003421 | 0.34 | 2:00:00 | 1 0 0 100 | | TOTAL | 2 | 0.78 | 1.57 | 0.00007855 | 0.78 | 4:00:00 | 2 0 0 100 | =============== SUMMARY METRICS =============== | Metric | Value | |-----------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades| 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | Trades per day | 3.575 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Buy signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | ===============================================","title":"Understand the backtesting result"},{"location":"backtesting/#backtesting-report-table","text":"The 1 st table contains all trades the bot made, including \"left open trades\". The last line will give you the overall performance of your strategy, here: | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | The bot has made 429 trades for an average duration of 4:12:00 , with a performance of 76.20% (profit), that means it has earned a total of 0.00762792 BTC starting with a capital of 0.01 BTC. The column Avg Profit % shows the average profit for all trades made while the column Cum Profit % sums up all the profits/losses. The column Tot Profit % shows instead the total profit % in relation to the starting balance. In the above results, we have a starting balance of 0.01 BTC and an absolute profit of 0.00762792 BTC - so the Tot Profit % will be (0.00762792 / 0.01) * 100 ~= 76.2% . Your strategy performance is influenced by your buy strategy, your sell strategy, and also by the minimal_roi and stop_loss you have set. For example, if your minimal_roi is only \"0\": 0.01 you cannot expect the bot to make more profit than 1% (because it will sell every time a trade reaches 1%). json \"minimal_roi\": { \"0\": 0.01 }, On the other hand, if you set a too high minimal_roi like \"0\": 0.55 (55%), there is almost no chance that the bot will ever reach this profit. Hence, keep in mind that your performance is an integral mix of all different elements of the strategy, your configuration, and the crypto-currency pairs you have set up.","title":"Backtesting report table"},{"location":"backtesting/#sell-reasons-table","text":"The 2 nd table contains a recap of sell reasons. This table can tell you which area needs some additional work (e.g. all or many of the sell_signal trades are losses, so you should work on improving the sell signal, or consider disabling it).","title":"Sell reasons table"},{"location":"backtesting/#left-open-trades-table","text":"The 3 rd table contains all trades the bot had to forcesell at the end of the backtesting period to present you the full picture. This is necessary to simulate realistic behavior, since the backtest period has to end at some point, while realistically, you could leave the bot running forever. These trades are also included in the first table, but are also shown separately in this table for clarity.","title":"Left open trades table"},{"location":"backtesting/#summary-metrics","text":"The last element of the backtest report is the summary metrics table. It contains some useful key metrics about performance of your strategy on backtesting data. ``` =============== SUMMARY METRICS =============== | Metric | Value | |-----------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades| 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Buy signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | =============================================== ``` Backtesting from / Backtesting to : Backtesting range (usually defined with the --timerange option). Max open trades : Setting of max_open_trades (or --max-open-trades ) - or number of pairs in the pairlist (whatever is lower). Total/Daily Avg Trades : Identical to the total trades of the backtest output table / Total trades divided by the backtesting duration in days (this will give you information about how many trades to expect from the strategy). Starting balance : Start balance - as given by dry-run-wallet (config or command line). Final balance : Final balance - starting balance + absolute profit. Absolute profit : Profit made in stake currency. Total profit % : Total profit. Aligned to the TOTAL row's Tot Profit % from the first table. Calculated as (End capital \u2212 Starting capital) / Starting capital . Avg. stake amount : Average stake amount, either stake_amount or the average when using dynamic stake amount. Total trade volume : Volume generated on the exchange to reach the above profit. Best Pair / Worst Pair : Best and worst performing pair, and it's corresponding Cum Profit % . Best Trade / Worst Trade : Biggest single winning trade and biggest single losing trade. Best day / Worst day : Best and worst day based on daily profit. Days win/draw/lose : Winning / Losing days (draws are usually days without closed trade). Avg. Duration Winners / Avg. Duration Loser : Average durations for winning and losing trades. Rejected Buy signals : Buy signals that could not be acted upon due to max_open_trades being reached. Entry/Exit Timeouts : Entry/exit orders which did not fill (only applicable if custom pricing is used). Min balance / Max balance : Lowest and Highest Wallet balance during the backtest period. Drawdown (Account) : Maximum Account Drawdown experienced. Calculated as \\((Absolute Drawdown) / (DrawdownHigh + startingBalance)\\) . Drawdown : Maximum, absolute drawdown experienced. Difference between Drawdown High and Subsequent Low point. Drawdown high / Drawdown low : Profit at the beginning and end of the largest drawdown period. A negative low value means initial capital lost. Drawdown Start / Drawdown End : Start and end datetime for this largest drawdown (can also be visualized via the plot-dataframe sub-command). Market change : Change of the market during the backtest period. Calculated as average of all pairs changes from the first to the last candle using the \"close\" column.","title":"Summary metrics"},{"location":"backtesting/#daily-weekly-monthly-breakdown","text":"You can get an overview over daily / weekly or monthly results by using the --breakdown <> switch. To visualize daily and weekly breakdowns, you can use the following: bash freqtrade backtesting --strategy MyAwesomeStrategy --breakdown day month ``` output ======================== DAY BREAKDOWN ========================= | Day | Tot Profit USDT | Wins | Draws | Losses | |------------+-------------------+--------+---------+----------| | 03/07/2021 | 200.0 | 2 | 0 | 0 | | 04/07/2021 | -50.31 | 0 | 0 | 2 | | 05/07/2021 | 220.611 | 3 | 2 | 0 | | 06/07/2021 | 150.974 | 3 | 0 | 2 | | 07/07/2021 | -70.193 | 1 | 0 | 2 | | 08/07/2021 | 212.413 | 2 | 0 | 3 | ``` The output will show a table containing the realized absolute Profit (in stake currency) for the given timeperiod, as well as wins, draws and losses that materialized (closed) on this day.","title":"Daily / Weekly / Monthly breakdown"},{"location":"backtesting/#backtest-result-caching","text":"To save time, by default backtest will reuse a cached result from within the last day when the backtested strategy and config match that of a previous backtest. To force a new backtest despite existing result for an identical run specify --cache none parameter. Warning Caching is automatically disabled for open-ended timeranges ( --timerange 20210101- ), as freqtrade cannot ensure reliably that the underlying data didn't change. It can also use cached results where it shouldn't if the original backtest had missing data at the end, which was fixed by downloading more data. In this instance, please use --cache none once to force a fresh backtest.","title":"Backtest result caching"},{"location":"backtesting/#further-backtest-result-analysis","text":"To further analyze your backtest results, you can export the trades . You can then load the trades to perform further analysis as shown in the data analysis backtesting section.","title":"Further backtest-result analysis"},{"location":"backtesting/#assumptions-made-by-backtesting","text":"Since backtesting lacks some detailed information about what happens within a candle, it needs to take a few assumptions: Buys happen at open-price All orders are filled at the requested price (no slippage, no unfilled orders) Sell-signal sells happen at open-price of the consecutive candle Sell-signal is favored over Stoploss, because sell-signals are assumed to trigger on candle's open ROI sells are compared to high - but the ROI value is used (e.g. ROI = 2%, high=5% - so the sell will be at 2%) sells are never \"below the candle\", so a ROI of 2% may result in a sell at 2.4% if low was at 2.4% profit Forcesells caused by <N>=-1 ROI entries use low as sell value, unless N falls on the candle open (e.g. 120: -1 for 1h candles) Stoploss sells happen exactly at stoploss price, even if low was lower, but the loss will be 2 * fees higher than the stoploss price Stoploss is evaluated before ROI within one candle. So you can often see more trades with the stoploss sell reason comparing to the results obtained with the same strategy in the Dry Run/Live Trade modes Low happens before high for stoploss, protecting capital first Trailing stoploss Trailing Stoploss is only adjusted if it's below the candle's low (otherwise it would be triggered) On trade entry candles that trigger trailing stoploss, the \"minimum offset\" ( stop_positive_offset ) is assumed (instead of high) - and the stop is calculated from this point High happens first - adjusting stoploss Low uses the adjusted stoploss (so sells with large high-low difference are backtested correctly) ROI applies before trailing-stop, ensuring profits are \"top-capped\" at ROI if both ROI and trailing stop applies Sell-reason does not explain if a trade was positive or negative, just what triggered the sell (this can look odd if negative ROI values are used) Evaluation sequence (if multiple signals happen on the same candle) Sell-signal ROI (if not stoploss) Stoploss Taking these assumptions, backtesting tries to mirror real trading as closely as possible. However, backtesting will never replace running a strategy in dry-run mode. Also, keep in mind that past results don't guarantee future success. In addition to the above assumptions, strategy authors should carefully read the Common Mistakes section, to avoid using data in backtesting which is not available in real market conditions.","title":"Assumptions made by backtesting"},{"location":"backtesting/#improved-backtest-accuracy","text":"One big limitation of backtesting is it's inability to know how prices moved intra-candle (was high before close, or viceversa?). So assuming you run backtesting with a 1h timeframe, there will be 4 prices for that candle (Open, High, Low, Close). While backtesting does take some assumptions (read above) about this - this can never be perfect, and will always be biased in one way or the other. To mitigate this, freqtrade can use a lower (faster) timeframe to simulate intra-candle movements. To utilize this, you can append --timeframe-detail 5m to your regular backtesting command. bash freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m This will load 1h data as well as 5m data for the timeframe. The strategy will be analyzed with the 1h timeframe - and for every \"open trade candle\" (candles where a trade is open) the 5m data will be used to simulate intra-candle movements. All callback functions ( custom_sell() , custom_stoploss() , ... ) will be running for each 5m candle once the trade is opened (so 12 times in the above example of 1h timeframe, and 5m detailed timeframe). --timeframe-detail must be smaller than the original timeframe, otherwise backtesting will fail to start. Obviously this will require more memory (5m data is bigger than 1h data), and will also impact runtime (depending on the amount of trades and trade durations). Also, data must be available / downloaded already. Tip You can use this function as the last part of strategy development, to ensure your strategy is not exploiting one of the backtesting assumptions . Strategies that perform similarly well with this mode have a good chance to perform well in dry/live modes too (although only forward-testing (dry-mode) can really confirm a strategy).","title":"Improved backtest accuracy"},{"location":"backtesting/#backtesting-multiple-strategies","text":"To compare multiple strategies, a list of Strategies can be provided to backtesting. This is limited to 1 timeframe value per run. However, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this will give a nice runtime boost. All listed Strategies need to be in the same directory. bash freqtrade backtesting --timerange 20180401-20180410 --timeframe 5m --strategy-list Strategy001 Strategy002 --export trades This will save the results to user_data/backtest_results/backtest-result-<strategy>.json , injecting the strategy-name into the target filename. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up to see the details per strategy. =========================================================== STRATEGY SUMMARY ========================================================================= | Strategy | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins | Draws | Losses | Drawdown % | |:------------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|------:|-------:|-------:|-----------:| | Strategy1 | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 | 0 | 243 | 45.2 | | Strategy2 | 1487 | -0.13 | -197.58 | -0.00988917 | -98.79 | 4:43:00 | 662 | 0 | 825 | 241.68 |","title":"Backtesting multiple strategies"},{"location":"backtesting/#next-step","text":"Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt","title":"Next step"},{"location":"bot-basics/","text":"Freqtrade basics \u00b6 This page provides you some basic concepts on how Freqtrade works and operates. Freqtrade terminology \u00b6 Strategy : Your trading strategy, telling the bot what to do. Trade : Open position. Open Order : Order which is currently placed on the exchange, and is not yet complete. Pair : Tradable pair, usually in the format of Base/Quote (e.g. XRP/USDT). Timeframe : Candle length to use (e.g. \"5m\" , \"1h\" , ...). Indicators : Technical indicators (SMA, EMA, RSI, ...). Limit order : Limit orders which execute at the defined limit price or better. Market order : Guaranteed to fill, may move price depending on the order size. Fee handling \u00b6 All profit calculations of Freqtrade include fees. For Backtesting / Hyperopt / Dry-run modes, the exchange default fee is used (lowest tier on the exchange). For live operations, fees are used as applied by the exchange (this includes BNB rebates etc.). Bot execution logic \u00b6 Starting freqtrade in dry-run or live mode (using freqtrade trade ) will start the bot and start the bot iteration loop. By default, loop runs every few seconds ( internals.process_throttle_secs ) and does roughly the following in the following sequence: Fetch open trades from persistence. Calculate current list of tradable pairs. Download OHLCV data for the pairlist including all informative pairs This step is only executed once per Candle to avoid unnecessary network traffic. Call bot_loop_start() strategy callback. Analyze strategy per pair. Call populate_indicators() Call populate_buy_trend() Call populate_sell_trend() Check timeouts for open orders. Calls check_buy_timeout() strategy callback for open buy orders. Calls check_sell_timeout() strategy callback for open sell orders. Verifies existing positions and eventually places sell orders. Considers stoploss, ROI and sell-signal, custom_sell() and custom_stoploss() . Determine sell-price based on ask_strategy configuration setting or by using the custom_exit_price() callback. Before a sell order is placed, confirm_trade_exit() strategy callback is called. Check position adjustments for open trades if enabled by calling adjust_trade_position() and place additional order if required. Check if trade-slots are still available (if max_open_trades is reached). Verifies buy signal trying to enter new positions. Determine buy-price based on bid_strategy configuration setting, or by using the custom_entry_price() callback. Determine stake size by calling the custom_stake_amount() callback. Before a buy order is placed, confirm_trade_entry() strategy callback is called. This loop will be repeated again and again until the bot is stopped. Backtesting / Hyperopt execution logic \u00b6 backtesting or hyperopt do only part of the above logic, since most of the trading operations are fully simulated. Load historic data for configured pairlist. Calls bot_loop_start() once. Calculate indicators (calls populate_indicators() once per pair). Calculate buy / sell signals (calls populate_buy_trend() and populate_sell_trend() once per pair). Loops per candle simulating entry and exit points. Confirm trade buy / sell (calls confirm_trade_entry() and confirm_trade_exit() if implemented in the strategy). Call custom_entry_price() (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle). Determine stake size by calling the custom_stake_amount() callback. Check position adjustments for open trades if enabled and call adjust_trade_position() to determine if an additional order is requested. Call custom_stoploss() and custom_sell() to find custom exit points. For sells based on sell-signal and custom-sell: Call custom_exit_price() to determine exit price (Prices are moved to be within the closing candle). Check for Order timeouts, either via the unfilledtimeout configuration, or via check_buy_timeout() / check_sell_timeout() strategy callbacks. Generate backtest report output Note Both Backtesting and Hyperopt include exchange default Fees in the calculation. Custom fees can be passed to backtesting / hyperopt by specifying the --fee argument.","title":"Freqtrade Basics"},{"location":"bot-basics/#freqtrade-basics","text":"This page provides you some basic concepts on how Freqtrade works and operates.","title":"Freqtrade basics"},{"location":"bot-basics/#freqtrade-terminology","text":"Strategy : Your trading strategy, telling the bot what to do. Trade : Open position. Open Order : Order which is currently placed on the exchange, and is not yet complete. Pair : Tradable pair, usually in the format of Base/Quote (e.g. XRP/USDT). Timeframe : Candle length to use (e.g. \"5m\" , \"1h\" , ...). Indicators : Technical indicators (SMA, EMA, RSI, ...). Limit order : Limit orders which execute at the defined limit price or better. Market order : Guaranteed to fill, may move price depending on the order size.","title":"Freqtrade terminology"},{"location":"bot-basics/#fee-handling","text":"All profit calculations of Freqtrade include fees. For Backtesting / Hyperopt / Dry-run modes, the exchange default fee is used (lowest tier on the exchange). For live operations, fees are used as applied by the exchange (this includes BNB rebates etc.).","title":"Fee handling"},{"location":"bot-basics/#bot-execution-logic","text":"Starting freqtrade in dry-run or live mode (using freqtrade trade ) will start the bot and start the bot iteration loop. By default, loop runs every few seconds ( internals.process_throttle_secs ) and does roughly the following in the following sequence: Fetch open trades from persistence. Calculate current list of tradable pairs. Download OHLCV data for the pairlist including all informative pairs This step is only executed once per Candle to avoid unnecessary network traffic. Call bot_loop_start() strategy callback. Analyze strategy per pair. Call populate_indicators() Call populate_buy_trend() Call populate_sell_trend() Check timeouts for open orders. Calls check_buy_timeout() strategy callback for open buy orders. Calls check_sell_timeout() strategy callback for open sell orders. Verifies existing positions and eventually places sell orders. Considers stoploss, ROI and sell-signal, custom_sell() and custom_stoploss() . Determine sell-price based on ask_strategy configuration setting or by using the custom_exit_price() callback. Before a sell order is placed, confirm_trade_exit() strategy callback is called. Check position adjustments for open trades if enabled by calling adjust_trade_position() and place additional order if required. Check if trade-slots are still available (if max_open_trades is reached). Verifies buy signal trying to enter new positions. Determine buy-price based on bid_strategy configuration setting, or by using the custom_entry_price() callback. Determine stake size by calling the custom_stake_amount() callback. Before a buy order is placed, confirm_trade_entry() strategy callback is called. This loop will be repeated again and again until the bot is stopped.","title":"Bot execution logic"},{"location":"bot-basics/#backtesting-hyperopt-execution-logic","text":"backtesting or hyperopt do only part of the above logic, since most of the trading operations are fully simulated. Load historic data for configured pairlist. Calls bot_loop_start() once. Calculate indicators (calls populate_indicators() once per pair). Calculate buy / sell signals (calls populate_buy_trend() and populate_sell_trend() once per pair). Loops per candle simulating entry and exit points. Confirm trade buy / sell (calls confirm_trade_entry() and confirm_trade_exit() if implemented in the strategy). Call custom_entry_price() (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle). Determine stake size by calling the custom_stake_amount() callback. Check position adjustments for open trades if enabled and call adjust_trade_position() to determine if an additional order is requested. Call custom_stoploss() and custom_sell() to find custom exit points. For sells based on sell-signal and custom-sell: Call custom_exit_price() to determine exit price (Prices are moved to be within the closing candle). Check for Order timeouts, either via the unfilledtimeout configuration, or via check_buy_timeout() / check_sell_timeout() strategy callbacks. Generate backtest report output Note Both Backtesting and Hyperopt include exchange default Fees in the calculation. Custom fees can be passed to backtesting / hyperopt by specifying the --fee argument.","title":"Backtesting / Hyperopt execution logic"},{"location":"bot-usage/","text":"Start the bot \u00b6 This page explains the different parameters of the bot and how to run it. Note If you've used setup.sh , don't forget to activate your virtual environment ( source .env/bin/activate ) before running freqtrade commands. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges. Bot commands \u00b6 ``` usage: freqtrade [-h] [-V] {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} ... Free, open source crypto trading bot positional arguments: {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} trade Trade module. create-userdir Create user-data directory. new-config Create new config new-strategy Create new strategy download-data Download backtesting data. convert-data Convert candle (OHLCV) data from one format to another. convert-trade-data Convert trade data from one format to another. list-data List downloaded data. backtesting Backtesting module. edge Edge module. hyperopt Hyperopt module. hyperopt-list List Hyperopt results hyperopt-show Show details of Hyperopt results list-exchanges Print available exchanges. list-hyperopts Print available hyperopt classes. list-markets Print markets on exchange. list-pairs Print pairs on exchange. list-strategies Print available strategies. list-timeframes Print available timeframes for the exchange. show-trades Show trades. test-pairlist Test your pairlist configuration. install-ui Install FreqUI plot-dataframe Plot candles with indicators. plot-profit Generate plot showing profits. webserver Webserver module. optional arguments: -h, --help show this help message and exit -V, --version show program's version number and exit ``` Bot trading commands \u00b6 ``` usage: freqtrade trade [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--db-url PATH] [--sd-notify] [--dry-run] [--dry-run-wallet DRY_RUN_WALLET] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --sd-notify Notify systemd service manager. --dry-run Enforce dry-run for trading (removes Exchange secrets and simulates trades). --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` How to specify which configuration file be used? \u00b6 The bot allows you to select which configuration file you want to use by means of the -c/--config command line option: bash freqtrade trade -c path/far/far/away/config.json Per default, the bot loads the config.json configuration file from the current working directory. How to use multiple configuration files? \u00b6 The bot allows you to use multiple configuration files by specifying multiple -c/--config options in the command line. Configuration parameters defined in the latter configuration files override parameters with the same name defined in the previous configuration files specified in the command line earlier. For example, you can make a separate configuration file with your key and secret for the Exchange you use for trading, specify default configuration file with empty key and secret values while running in the Dry Mode (which does not actually require them): bash freqtrade trade -c ./config.json and specify both configuration files when running in the normal Live Trade Mode: bash freqtrade trade -c ./config.json -c path/to/secrets/keys.config.json This could help you hide your private Exchange key and Exchange secret on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet. See more details on this technique with examples in the documentation page on configuration . Where to store custom data \u00b6 Freqtrade allows the creation of a user-data directory using freqtrade create-userdir --userdir someDirectory . This directory will look as follows: user_data/ \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopts \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies You can add the entry \"user_data_dir\" setting to your configuration, to always point your bot to this directory. Alternatively, pass in --userdir to every command. The bot will fail to start if the directory does not exist, but will create necessary subdirectories. This directory should contain your custom strategies, custom hyperopts and hyperopt loss functions, backtesting historical data (downloaded using either backtesting command or the download script) and plot outputs. It is recommended to use version control to keep track of changes to your strategies. How to use --strategy ? \u00b6 This parameter will allow you to load your custom strategy class. To test the bot installation, you can use the SampleStrategy installed by the create-userdir subcommand (usually user_data/strategy/sample_strategy.py ). The bot will search your strategy file within user_data/strategies . To use other directories, please read the next section about --strategy-path . To load a strategy, simply pass the class name (e.g.: CustomStrategy ) in this parameter. Example: In user_data/strategies you have a file my_awesome_strategy.py which has a strategy class called AwesomeStrategy to load it: bash freqtrade trade --strategy AwesomeStrategy If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code). Learn more about strategy file in Strategy Customization . How to use --strategy-path ? \u00b6 This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!): bash freqtrade trade --strategy AwesomeStrategy --strategy-path /some/directory How to install a strategy? \u00b6 This is very simple. Copy paste your strategy file into the directory user_data/strategies or use --strategy-path . And voila, the bot is ready to use it. How to use --db-url ? \u00b6 When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using --db-url . This can also be used to specify a custom database in production mode. Example command: bash freqtrade trade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite Next step \u00b6 The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization .","title":"Start the bot"},{"location":"bot-usage/#start-the-bot","text":"This page explains the different parameters of the bot and how to run it. Note If you've used setup.sh , don't forget to activate your virtual environment ( source .env/bin/activate ) before running freqtrade commands. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.","title":"Start the bot"},{"location":"bot-usage/#bot-commands","text":"``` usage: freqtrade [-h] [-V] {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} ... Free, open source crypto trading bot positional arguments: {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} trade Trade module. create-userdir Create user-data directory. new-config Create new config new-strategy Create new strategy download-data Download backtesting data. convert-data Convert candle (OHLCV) data from one format to another. convert-trade-data Convert trade data from one format to another. list-data List downloaded data. backtesting Backtesting module. edge Edge module. hyperopt Hyperopt module. hyperopt-list List Hyperopt results hyperopt-show Show details of Hyperopt results list-exchanges Print available exchanges. list-hyperopts Print available hyperopt classes. list-markets Print markets on exchange. list-pairs Print pairs on exchange. list-strategies Print available strategies. list-timeframes Print available timeframes for the exchange. show-trades Show trades. test-pairlist Test your pairlist configuration. install-ui Install FreqUI plot-dataframe Plot candles with indicators. plot-profit Generate plot showing profits. webserver Webserver module. optional arguments: -h, --help show this help message and exit -V, --version show program's version number and exit ```","title":"Bot commands"},{"location":"bot-usage/#bot-trading-commands","text":"``` usage: freqtrade trade [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--db-url PATH] [--sd-notify] [--dry-run] [--dry-run-wallet DRY_RUN_WALLET] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --sd-notify Notify systemd service manager. --dry-run Enforce dry-run for trading (removes Exchange secrets and simulates trades). --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ```","title":"Bot trading commands"},{"location":"bot-usage/#how-to-specify-which-configuration-file-be-used","text":"The bot allows you to select which configuration file you want to use by means of the -c/--config command line option: bash freqtrade trade -c path/far/far/away/config.json Per default, the bot loads the config.json configuration file from the current working directory.","title":"How to specify which configuration file be used?"},{"location":"bot-usage/#how-to-use-multiple-configuration-files","text":"The bot allows you to use multiple configuration files by specifying multiple -c/--config options in the command line. Configuration parameters defined in the latter configuration files override parameters with the same name defined in the previous configuration files specified in the command line earlier. For example, you can make a separate configuration file with your key and secret for the Exchange you use for trading, specify default configuration file with empty key and secret values while running in the Dry Mode (which does not actually require them): bash freqtrade trade -c ./config.json and specify both configuration files when running in the normal Live Trade Mode: bash freqtrade trade -c ./config.json -c path/to/secrets/keys.config.json This could help you hide your private Exchange key and Exchange secret on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet. See more details on this technique with examples in the documentation page on configuration .","title":"How to use multiple configuration files?"},{"location":"bot-usage/#where-to-store-custom-data","text":"Freqtrade allows the creation of a user-data directory using freqtrade create-userdir --userdir someDirectory . This directory will look as follows: user_data/ \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopts \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies You can add the entry \"user_data_dir\" setting to your configuration, to always point your bot to this directory. Alternatively, pass in --userdir to every command. The bot will fail to start if the directory does not exist, but will create necessary subdirectories. This directory should contain your custom strategies, custom hyperopts and hyperopt loss functions, backtesting historical data (downloaded using either backtesting command or the download script) and plot outputs. It is recommended to use version control to keep track of changes to your strategies.","title":"Where to store custom data"},{"location":"bot-usage/#how-to-use-strategy","text":"This parameter will allow you to load your custom strategy class. To test the bot installation, you can use the SampleStrategy installed by the create-userdir subcommand (usually user_data/strategy/sample_strategy.py ). The bot will search your strategy file within user_data/strategies . To use other directories, please read the next section about --strategy-path . To load a strategy, simply pass the class name (e.g.: CustomStrategy ) in this parameter. Example: In user_data/strategies you have a file my_awesome_strategy.py which has a strategy class called AwesomeStrategy to load it: bash freqtrade trade --strategy AwesomeStrategy If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code). Learn more about strategy file in Strategy Customization .","title":"How to use --strategy?"},{"location":"bot-usage/#how-to-use-strategy-path","text":"This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!): bash freqtrade trade --strategy AwesomeStrategy --strategy-path /some/directory","title":"How to use --strategy-path?"},{"location":"bot-usage/#how-to-install-a-strategy","text":"This is very simple. Copy paste your strategy file into the directory user_data/strategies or use --strategy-path . And voila, the bot is ready to use it.","title":"How to install a strategy?"},{"location":"bot-usage/#how-to-use-db-url","text":"When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using --db-url . This can also be used to specify a custom database in production mode. Example command: bash freqtrade trade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite","title":"How to use --db-url?"},{"location":"bot-usage/#next-step","text":"The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization .","title":"Next step"},{"location":"configuration/","text":"Configure the bot \u00b6 Freqtrade has many configurable features and possibilities. By default, these settings are configured via the configuration file (see below). The Freqtrade configuration file \u00b6 The bot uses a set of configuration parameters during its operation that all together conform to the bot configuration. It normally reads its configuration from a file (Freqtrade configuration file). Per default, the bot loads the configuration from the config.json file, located in the current working directory. You can specify a different configuration file used by the bot with the -c/--config command-line option. If you used the Quick start method for installing the bot, the installation script should have already created the default configuration file ( config.json ) for you. If the default configuration file is not created we recommend to use freqtrade new-config --config config.json to generate a basic configuration file. The Freqtrade configuration file is to be written in JSON format. Additionally to the standard JSON syntax, you may use one-line // ... and multi-line /* ... */ comments in your configuration files and trailing commas in the lists of parameters. Do not worry if you are not familiar with JSON format -- simply open the configuration file with an editor of your choice, make some changes to the parameters you need, save your changes and, finally, restart the bot or, if it was previously stopped, run it again with the changes you made to the configuration. The bot validates the syntax of the configuration file at startup and will warn you if you made any errors editing it, pointing out problematic lines. Environment variables \u00b6 Set options in the Freqtrade configuration via environment variables. This takes priority over the corresponding value in configuration or strategy. Environment variables must be prefixed with FREQTRADE__ to be loaded to the freqtrade configuration. __ serves as level separator, so the format used should correspond to FREQTRADE__{section}__{key} . As such - an environment variable defined as export FREQTRADE__STAKE_AMOUNT=200 would result in {stake_amount: 200} . A more complex example might be export FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> to keep your exchange key secret. This will move the value to the exchange.key section of the configuration. Using this scheme, all configuration settings will also be available as environment variables. Please note that Environment variables will overwrite corresponding settings in your configuration, but command line Arguments will always win. Common example: FREQTRADE__TELEGRAM__CHAT_ID=<telegramchatid> FREQTRADE__TELEGRAM__TOKEN=<telegramToken> FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> FREQTRADE__EXCHANGE__SECRET=<yourExchangeSecret> Note Environment variables detected are logged at startup - so if you can't find why a value is not what you think it should be based on the configuration, make sure it's not loaded from an environment variable. Multiple configuration files \u00b6 Multiple configuration files can be specified and used by the bot or the bot can read its configuration parameters from the process standard input stream. Use multiple configuration files to keep secrets secret You can use a 2 nd configuration file containing your secrets. That way you can share your \"primary\" configuration file, while still keeping your API keys for yourself. bash freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> The 2 nd file should only specify what you intend to override. If a key is in more than one of the configurations, then the \"last specified configuration\" wins (in the above example, config-private.json ). Configuration parameters \u00b6 The table below will list all configuration parameters available. Freqtrade can also load many options via command line (CLI) arguments (check out the commands --help output for details). The prevalence for all Options is as follows: CLI arguments override any other option Environment Variables Configuration files are used in sequence (the last file wins) and override Strategy configurations. Strategy configurations are only used if they are not set via configuration or command-line arguments. These options are marked with Strategy Override in the below table. Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description max_open_trades Required. Number of open trades your bot is allowed to have. Only one open trade per pair is possible, so the length of your pairlist is another limitation that can apply. If -1 then it is ignored (i.e. potentially unlimited open trades, limited by the pairlist). More information below . Datatype: Positive integer or -1. stake_currency Required. Crypto-currency used for trading. Datatype: String stake_amount Required. Amount of crypto-currency your bot will use for each trade. Set it to \"unlimited\" to allow the bot to use all available balance. More information below . Datatype: Positive float or \"unlimited\" . tradable_balance_ratio Ratio of the total account balance the bot is allowed to trade. More information below . Defaults to 0.99 99%). Datatype: Positive float between 0.1 and 1.0 . available_capital Available starting capital for the bot. Useful when running multiple bots on the same exchange account. More information below . Datatype: Positive float. amend_last_stake_amount Use reduced last stake amount if necessary. More information below . Defaults to false . Datatype: Boolean last_stake_amount_min_ratio Defines minimum stake amount that has to be left and executed. Applies only to the last stake amount when it's amended to a reduced value (i.e. if amend_last_stake_amount is set to true ). More information below . Defaults to 0.5 . Datatype: Float (as ratio) amount_reserve_percent Reserve some amount in min pair stake amount. The bot will reserve amount_reserve_percent + stoploss value when calculating min pair stake amount in order to avoid possible trade refusals. Defaults to 0.05 (5%). Datatype: Positive Float as ratio. timeframe The timeframe to use (e.g 1m , 5m , 15m , 30m , 1h ...). Strategy Override . Datatype: String fiat_display_currency Fiat currency used to show your profits. More information below . Datatype: String dry_run Required. Define if the bot must be in Dry Run or production mode. Defaults to true . Datatype: Boolean dry_run_wallet Define the starting amount in stake currency for the simulated wallet used by the bot running in Dry Run mode. Defaults to 1000 . Datatype: Float cancel_open_orders_on_exit Cancel open orders when the /stop RPC command is issued, Ctrl+C is pressed or the bot dies unexpectedly. When set to true , this allows you to use /stop to cancel unfilled and partially filled orders in the event of a market crash. It does not impact open positions. Defaults to false . Datatype: Boolean process_only_new_candles Enable processing of indicators only when new candles arrive. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override . Defaults to false . Datatype: Boolean minimal_roi Required. Set the threshold as ratio the bot will use to sell a trade. More information below . Strategy Override . Datatype: Dict stoploss Required. Value as ratio of the stoploss used by the bot. More details in the stoploss documentation . Strategy Override . Datatype: Float (as ratio) trailing_stop Enables trailing stoploss (based on stoploss in either configuration or strategy file). More details in the stoploss documentation . Strategy Override . Datatype: Boolean trailing_stop_positive Changes stoploss once profit has been reached. More details in the stoploss documentation . Strategy Override . Datatype: Float trailing_stop_positive_offset Offset on when to apply trailing_stop_positive . Percentage value which should be positive. More details in the stoploss documentation . Strategy Override . Defaults to 0.0 (no offset). Datatype: Float trailing_only_offset_is_reached Only apply trailing stoploss when the offset is reached. stoploss documentation . Strategy Override . Defaults to false . Datatype: Boolean fee Fee used during backtesting / dry-runs. Should normally not be configured, which has freqtrade fall back to the exchange default fee. Set as ratio (e.g. 0.001 = 0.1%). Fee is applied twice for each trade, once when buying, once when selling. Datatype: Float (as ratio) unfilledtimeout.buy Required. How long (in minutes or seconds) the bot will wait for an unfilled buy order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.sell Required. How long (in minutes or seconds) the bot will wait for an unfilled sell order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.unit Unit to use in unfilledtimeout setting. Note: If you set unfilledtimeout.unit to \"seconds\", \"internals.process_throttle_secs\" must be inferior or equal to timeout Strategy Override . Defaults to minutes . Datatype: String unfilledtimeout.exit_timeout_count How many times can exit orders time out. Once this number of timeouts is reached, an emergency sell is triggered. 0 to disable and allow unlimited order cancels. Strategy Override . Defaults to 0 . Datatype: Integer bid_strategy.price_side Select the side of the spread the bot should look at to get the buy rate. More information below . Defaults to bid . Datatype: String (either ask or bid ). bid_strategy.ask_last_balance Required. Interpolate the bidding price. More information below . bid_strategy.use_order_book Enable buying using the rates in Order Book Bids . Datatype: Boolean bid_strategy.order_book_top Bot will use the top N rate in Order Book \"price_side\" to buy. I.e. a value of 2 will allow the bot to pick the 2 nd bid rate in Order Book Bids . Defaults to 1 . Datatype: Positive Integer bid_strategy. check_depth_of_market.enabled Do not buy if the difference of buy orders and sell orders is met in Order Book. Check market depth . Defaults to false . Datatype: Boolean bid_strategy. check_depth_of_market.bids_to_ask_delta The difference ratio of buy orders and sell orders found in Order Book. A value below 1 means sell order size is greater, while value greater than 1 means buy order size is higher. Check market depth Defaults to 0 . Datatype: Float (as ratio) ask_strategy.price_side Select the side of the spread the bot should look at to get the sell rate. More information below . Defaults to ask . Datatype: String (either ask or bid ). ask_strategy.bid_last_balance Interpolate the selling price. More information below . ask_strategy.use_order_book Enable selling of open trades using Order Book Asks . Datatype: Boolean ask_strategy.order_book_top Bot will use the top N rate in Order Book \"price_side\" to sell. I.e. a value of 2 will allow the bot to pick the 2 nd ask rate in Order Book Asks Defaults to 1 . Datatype: Positive Integer use_sell_signal Use sell signals produced by the strategy in addition to the minimal_roi . Strategy Override . Defaults to true . Datatype: Boolean sell_profit_only Wait until the bot reaches sell_profit_offset before taking a sell decision. Strategy Override . Defaults to false . Datatype: Boolean sell_profit_offset Sell-signal is only active above this value. Only active in combination with sell_profit_only=True . Strategy Override . Defaults to 0.0 . Datatype: Float (as ratio) ignore_roi_if_buy_signal Do not sell if the buy signal is still active. This setting takes preference over minimal_roi and use_sell_signal . Strategy Override . Defaults to false . Datatype: Boolean ignore_buying_expired_candle_after Specifies the number of seconds until a buy signal is no longer used. Datatype: Integer order_types Configure order-types depending on the action ( \"buy\" , \"sell\" , \"stoploss\" , \"stoploss_on_exchange\" ). More information below . Strategy Override . Datatype: Dict order_time_in_force Configure time in force for buy and sell orders. More information below . Strategy Override . Datatype: Dict custom_price_max_distance_ratio Configure maximum distance ratio between current and custom entry or exit price. Defaults to 0.02 2%). Datatype: Positive float exchange.name Required. Name of the exchange class to use. List below . Datatype: String exchange.sandbox Use the 'sandbox' version of the exchange, where the exchange provides a sandbox for risk-free integration. See here in more details. Datatype: Boolean exchange.key API key to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.secret API secret to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.password API password to use for the exchange. Only required when you are in production mode and for exchanges that use password for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.uid API uid to use for the exchange. Only required when you are in production mode and for exchanges that use uid for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.pair_whitelist List of pairs to use by the bot for trading and to check for potential trades during backtesting. Supports regex pairs as .*/BTC . Not used by VolumePairList. More information . Datatype: List exchange.pair_blacklist List of pairs the bot must absolutely avoid for trading and backtesting. More information . Datatype: List exchange.ccxt_config Additional CCXT parameters passed to both ccxt instances (sync and async). This is usually the correct place for additional ccxt configurations. Parameters may differ from exchange to exchange and are documented in the ccxt documentation . Please avoid adding exchange secrets here (use the dedicated fields instead), as they may be contained in logs. Datatype: Dict exchange.ccxt_sync_config Additional CCXT parameters passed to the regular (sync) ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.ccxt_async_config Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.markets_refresh_interval The interval in minutes in which markets are reloaded. Defaults to 60 minutes. Datatype: Positive Integer exchange.skip_pair_validation Skip pairlist validation on startup. Defaults to false Datatype: * Boolean exchange.skip_open_order_update Skips open order updates on startup should the exchange cause problems. Only relevant in live conditions. Defaults to false Datatype: * Boolean exchange.unknown_fee_rate Fallback value to use when calculating trading fees. This can be useful for exchanges which have fees in non-tradable currencies. The value provided here will be multiplied with the \"fee cost\". Defaults to None Datatype: * float exchange.log_responses Log relevant exchange responses. For debug mode only - use with care. Defaults to false Datatype: * Boolean edge.* Please refer to edge configuration document for detailed explanation. experimental.block_bad_exchanges Block exchanges known to not work with freqtrade. Leave on default unless you want to test if that exchange works now. Defaults to true . Datatype: Boolean pairlists Define one or more pairlists to be used. More information . Defaults to StaticPairList . Datatype: List of Dicts protections Define one or more protections to be used. More information . Datatype: List of Dicts telegram.enabled Enable the usage of Telegram. Datatype: Boolean telegram.token Your Telegram bot token. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.chat_id Your personal Telegram account id. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.balance_dust_level Dust-level (in stake currency) - currencies with a balance below this will not be shown by /balance . Datatype: float webhook.enabled Enable usage of Webhook notifications Datatype: Boolean webhook.url URL for the webhook. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookbuy Payload to send on buy. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookbuycancel Payload to send on buy order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhooksell Payload to send on sell. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhooksellcancel Payload to send on sell order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookstatus Payload to send on status calls. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String api_server.enabled Enable usage of API Server. See the API Server documentation for more details. Datatype: Boolean api_server.listen_ip_address Bind IP address. See the API Server documentation for more details. Datatype: IPv4 api_server.listen_port Bind Port. See the API Server documentation for more details. Datatype: Integer between 1024 and 65535 api_server.verbosity Logging verbosity. info will print all RPC Calls, while \"error\" will only display errors. Datatype: Enum, either info or error . Defaults to info . api_server.username Username for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String api_server.password Password for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String bot_name Name of the bot. Passed via API to a client - can be shown to distinguish / name bots. Defaults to freqtrade Datatype: String db_url Declares database URL to use. NOTE: This defaults to sqlite:///tradesv3.dryrun.sqlite if dry_run is true , and to sqlite:///tradesv3.sqlite for production instances. Datatype: String, SQLAlchemy connect string initial_state Defines the initial application state. If set to stopped, then the bot has to be explicitly started via /start RPC command. Defaults to stopped . Datatype: Enum, either stopped or running forcebuy_enable Enables the RPC Commands to force a buy. More information below. Datatype: Boolean disable_dataframe_checks Disable checking the OHLCV dataframe returned from the strategy methods for correctness. Only use when intentionally changing the dataframe and understand what you are doing. Strategy Override . Defaults to False . Datatype: Boolean strategy Required Defines Strategy class to use. Recommended to be set via --strategy NAME . Datatype: ClassName strategy_path Adds an additional strategy lookup path (must be a directory). Datatype: String internals.process_throttle_secs Set the process throttle, or minimum loop duration for one bot iteration loop. Value in second. Defaults to 5 seconds. Datatype: Positive Integer internals.heartbeat_interval Print heartbeat message every N seconds. Set to 0 to disable heartbeat messages. Defaults to 60 seconds. Datatype: Positive Integer or 0 internals.sd_notify Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details. Datatype: Boolean logfile Specifies logfile name. Uses a rolling strategy for log file rotation for 10 files with the 1MB limit per file. Datatype: String user_data_dir Directory containing user data. Defaults to ./user_data/ . Datatype: String dataformat_ohlcv Data format to use to store historical candle (OHLCV) data. Defaults to json . Datatype: String dataformat_trades Data format to use to store historical trades data. Defaults to jsongz . Datatype: String position_adjustment_enable Enables the strategy to use position adjustments (additional buys or sells). More information here . Strategy Override . Defaults to false . Datatype: Boolean max_entry_position_adjustment Maximum additional order(s) for each open trade on top of the first entry Order. Set it to -1 for unlimited additional orders. More information here . Strategy Override . Defaults to -1 . Datatype: Positive Integer or -1 Parameters in the strategy \u00b6 The following parameters can be set in the configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy. minimal_roi timeframe stoploss trailing_stop trailing_stop_positive trailing_stop_positive_offset trailing_only_offset_is_reached use_custom_stoploss process_only_new_candles order_types order_time_in_force unfilledtimeout disable_dataframe_checks use_sell_signal sell_profit_only sell_profit_offset ignore_roi_if_buy_signal ignore_buying_expired_candle_after position_adjustment_enable max_entry_position_adjustment Configuring amount per trade \u00b6 There are several methods to configure how much of the stake currency the bot will use to enter a trade. All methods respect the available balance configuration as explained below. Minimum trade stake \u00b6 The minimum stake amount will depend on exchange and pair and is usually listed in the exchange support pages. Assuming the minimum tradable amount for XRP/USD is 20 XRP (given by the exchange), and the price is 0.6 \\(, the minimum stake amount to buy this pair is 20 * 0.6 ~= 12 . This exchange has also a limit on USD - where all orders must be > 10\\) - which however does not apply in this case. To guarantee safe execution, freqtrade will not allow buying with a stake-amount of 10.1$, instead, it'll make sure that there's enough space to place a stoploss below the pair (+ an offset, defined by amount_reserve_percent , which defaults to 5%). With a reserve of 5%, the minimum stake amount would be ~12.6$ ( 12 * (1 + 0.05) ). If we take into account a stoploss of 10% on top of that - we'd end up with a value of ~14$ ( 12.6 / (1 - 0.1) ). To limit this calculation in case of large stoploss values, the calculated minimum stake-limit will never be more than 50% above the real limit. Warning Since the limits on exchanges are usually stable and are not updated often, some pairs can show pretty high minimum limits, simply because the price increased a lot since the last limit adjustment by the exchange. Freqtrade adjusts the stake-amount to this value, unless it's > 30% more than the calculated/desired stake-amount - in which case the trade is rejected. Tradable balance \u00b6 By default, the bot assumes that the complete amount - 1% is at it's disposal, and when using dynamic stake amount , it will split the complete balance into max_open_trades buckets per trade. Freqtrade will reserve 1% for eventual fees when entering a trade and will therefore not touch that by default. You can configure the \"untouched\" amount by using the tradable_balance_ratio setting. For example, if you have 10 ETH available in your wallet on the exchange and tradable_balance_ratio=0.5 (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers this as an available balance. The rest of the wallet is untouched by the trades. Danger This setting should not be used when running multiple bots on the same account. Please look at Available Capital to the bot instead. Warning The tradable_balance_ratio setting applies to the current balance (free balance + tied up in trades). Therefore, assuming the starting balance of 1000, a configuration with tradable_balance_ratio=0.99 will not guarantee that 10 currency units will always remain available on the exchange. For example, the free amount may reduce to 5 units if the total balance is reduced to 500 (either by a losing streak or by withdrawing balance). Assign available Capital \u00b6 To fully utilize compounding profits when using multiple bots on the same exchange account, you'll want to limit each bot to a certain starting balance. This can be accomplished by setting available_capital to the desired starting balance. Assuming your account has 10.000 USDT and you want to run 2 different strategies on this exchange. You'd set available_capital=5000 - granting each bot an initial capital of 5000 USDT. The bot will then split this starting balance equally into max_open_trades buckets. Profitable trades will result in increased stake-sizes for this bot - without affecting the stake-sizes of the other bot. Incompatible with tradable_balance_ratio Setting this option will replace any configuration of tradable_balance_ratio . Amend last stake amount \u00b6 Assuming we have the tradable balance of 1000 USDT, stake_amount=400 , and max_open_trades=3 . The bot would open 2 trades and will be unable to fill the last trading slot, since the requested 400 USDT are no longer available since 800 USDT are already tied in other trades. To overcome this, the option amend_last_stake_amount can be set to True , which will enable the bot to reduce stake_amount to the available balance to fill the last trade slot. In the example above this would mean: Trade1: 400 USDT Trade2: 400 USDT Trade3: 200 USDT Note This option only applies with Static stake amount - since Dynamic stake amount divides the balances evenly. Note The minimum last stake amount can be configured using last_stake_amount_min_ratio - which defaults to 0.5 (50%). This means that the minimum stake amount that's ever used is stake_amount * 0.5 . This avoids very low stake amounts, that are close to the minimum tradable amount for the pair and can be refused by the exchange. Static stake amount \u00b6 The stake_amount configuration statically configures the amount of stake-currency your bot will use for each trade. The minimal configuration value is 0.0001, however, please check your exchange's trading minimums for the stake currency you're using to avoid problems. This setting works in combination with max_open_trades . The maximum capital engaged in trades is stake_amount * max_open_trades . For example, the bot will at most use (0.05 BTC x 3) = 0.15 BTC, assuming a configuration of max_open_trades=3 and stake_amount=0.05 . Note This setting respects the available balance configuration . Dynamic stake amount \u00b6 Alternatively, you can use a dynamic stake amount, which will use the available balance on the exchange, and divide that equally by the number of allowed trades ( max_open_trades ). To configure this, set stake_amount=\"unlimited\" . We also recommend to set tradable_balance_ratio=0.99 (99%) - to keep a minimum balance for eventual fees. In this case a trade amount is calculated as: python currency_balance / (max_open_trades - current_open_trades) To allow the bot to trade all the available stake_currency in your account (minus tradable_balance_ratio ) set json \"stake_amount\" : \"unlimited\", \"tradable_balance_ratio\": 0.99, Compounding profits This configuration will allow increasing/decreasing stakes depending on the performance of the bot (lower stake if the bot is losing, higher stakes if the bot has a winning record since higher balances are available), and will result in profit compounding. When using Dry-Run Mode When using \"stake_amount\" : \"unlimited\", in combination with Dry-Run, Backtesting or Hyperopt, the balance will be simulated starting with a stake of dry_run_wallet which will evolve. It is therefore important to set dry_run_wallet to a sensible value (like 0.05 or 0.01 for BTC and 1000 or 100 for USDT, for example), otherwise, it may simulate trades with 100 BTC (or more) or 0.05 USDT (or less) at once - which may not correspond to your real available balance or is less than the exchange minimal limit for the order amount for the stake currency. Dynamic stake amount with position adjustment \u00b6 When you want to use position adjustment with unlimited stakes, you must also implement custom_stake_amount to a return a value depending on your strategy. Typical value would be in the range of 25% - 50% of the proposed stakes, but depends highly on your strategy and how much you wish to leave into the wallet as position adjustment buffer. For example if your position adjustment assumes it can do 2 additional buys with the same stake amounts then your buffer should be 66.6667% of the initially proposed unlimited stake amount. Or another example if your position adjustment assumes it can do 1 additional buy with 3x the original stake amount then custom_stake_amount should return 25% of proposed stake amount and leave 75% for possible later position adjustments. Prices used for orders \u00b6 Prices for regular orders can be controlled via the parameter structures bid_strategy for buying and ask_strategy for selling. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders. Buy price \u00b6 Check depth of market \u00b6 When check depth of market is enabled ( bid_strategy.check_depth_of_market.enabled=True ), the buy signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the bid_strategy.check_depth_of_market.bids_to_ask_delta parameter. The buy order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side). Buy price side \u00b6 The configuration setting bid_strategy.price_side defines the side of the spread the bot looks for when buying. The following displays an orderbook. explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If bid_strategy.price_side is set to \"bid\" , then the bot will use 99 as buying price. In line with that, if bid_strategy.price_side is set to \"ask\" , then the bot will use 101 as buying price. Using ask price often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"ask\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price). Buy price with Orderbook enabled \u00b6 When buying with the orderbook enabled ( bid_strategy.use_order_book=True ), Freqtrade fetches the bid_strategy.order_book_top entries from the orderbook and uses the entry specified as bid_strategy.order_book_top on the configured side ( bid_strategy.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Buy price without Orderbook enabled \u00b6 The following section uses side as the configured bid_strategy.price_side (defaults to \"bid\" ). When not using orderbook ( bid_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on bid_strategy.ask_last_balance .. The bid_strategy.ask_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price. Sell price \u00b6 Sell price side \u00b6 The configuration setting ask_strategy.price_side defines the side of the spread the bot looks for when selling. The following displays an orderbook: explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If ask_strategy.price_side is set to \"ask\" , then the bot will use 101 as selling price. In line with that, if ask_strategy.price_side is set to \"bid\" , then the bot will use 99 as selling price. Sell price with Orderbook enabled \u00b6 When selling with the orderbook enabled ( ask_strategy.use_order_book=True ), Freqtrade fetches the ask_strategy.order_book_top entries in the orderbook and uses the entry specified as ask_strategy.order_book_top from the configured side ( ask_strategy.price_side ) as selling price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Sell price without Orderbook enabled \u00b6 The following section uses side as the configured ask_strategy.price_side (defaults to \"ask\" ). When not using orderbook ( ask_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on ask_strategy.bid_last_balance . The ask_strategy.bid_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price. Market order pricing \u00b6 When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both buy and sell are using market orders, a configuration similar to the following might be used jsonc \"order_types\": { \"buy\": \"market\", \"sell\": \"market\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used. Understand minimal_roi \u00b6 The minimal_roi configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI as a ratio. See the example below: json \"minimal_roi\": { \"40\": 0.0, # Sell after 40 minutes if the profit is not negative \"30\": 0.01, # Sell after 30 minutes if there is at least 1% profit \"20\": 0.02, # Sell after 20 minutes if there is at least 2% profit \"0\": 0.04 # Sell immediately if there is at least 4% profit }, Most of the strategy files already include the optimal minimal_roi value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the minimal_roi value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% {\"0\": 10} is used, and minimal ROI is disabled unless your trade generates 1000% profit. Special case to forcesell after a specific time A special case presents using \"<N>\": -1 as ROI. This forces the bot to sell a trade after N Minutes, no matter if it's positive or negative, so represents a time-limited force-sell. Understand forcebuy_enable \u00b6 The forcebuy_enable configuration parameter enables the usage of forcebuy commands via Telegram and REST API. For security reasons, it's disabled by default, and freqtrade will show a warning message on startup if enabled. For example, you can send /forcebuy ETH/BTC to the bot, which will result in freqtrade buying the pair and holds it until a regular sell-signal (ROI, stoploss, /forcesell) appears. This can be dangerous with some strategies, so use with care. See the telegram documentation for details on usage. Ignoring expired candles \u00b6 When working with larger timeframes (for example 1h or more) and using a low max_open_trades value, the last candle can be processed as soon as a trade slot becomes available. When processing the last candle, this can lead to a situation where it may not be desirable to use the buy signal on that candle. For example, when using a condition in your strategy where you use a cross-over, that point may have passed too long ago for you to start a trade on it. In these situations, you can enable the functionality to ignore candles that are beyond a specified period by setting ignore_buying_expired_candle_after to a positive number, indicating the number of seconds after which the buy signal becomes expired. For example, if your strategy is using a 1h timeframe, and you only want to buy within the first 5 minutes when a new candle comes in, you can add the following configuration to your strategy: json { //... \"ignore_buying_expired_candle_after\": 300, // ... } Note This setting resets with each new candle, so it will not prevent sticking-signals from executing on the 2 nd or 3 rd candle they're active. Best use a \"trigger\" selector for buy signals, which are only active for one candle. Understand order_types \u00b6 The order_types configuration parameter maps actions ( buy , sell , stoploss , emergencysell , forcesell , forcebuy ) to order-types ( market , limit , ...) as well as configures stoploss to be on the exchange and defines stoploss on exchange update interval in seconds. This allows to buy using limit orders, sell using limit-orders, and create stoplosses using market orders. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled. order_types set in the configuration file overwrites values set in the strategy as a whole, so you need to configure the whole order_types dictionary in one place. If this is configured, the following 4 values ( buy , sell , stoploss and stoploss_on_exchange ) need to be present, otherwise, the bot will fail to start. For information on ( emergencysell , forcesell , forcebuy , stoploss_on_exchange , stoploss_on_exchange_interval , stoploss_on_exchange_limit_ratio ) please see stop loss documentation stop loss on exchange Syntax for Strategy: python order_types = { \"buy\": \"limit\", \"sell\": \"limit\", \"emergencysell\": \"market\", \"forcebuy\": \"market\", \"forcesell\": \"market\", \"stoploss\": \"market\", \"stoploss_on_exchange\": False, \"stoploss_on_exchange_interval\": 60, \"stoploss_on_exchange_limit_ratio\": 0.99, } Configuration: json \"order_types\": { \"buy\": \"limit\", \"sell\": \"limit\", \"emergencysell\": \"market\", \"forcebuy\": \"market\", \"forcesell\": \"market\", \"stoploss\": \"market\", \"stoploss_on_exchange\": false, \"stoploss_on_exchange_interval\": 60 } Market order support Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: \"Exchange <yourexchange> does not support market orders.\" and the bot will refuse to start. Using market orders Please carefully read the section Market order pricing section when using market orders. Stoploss on exchange stoploss_on_exchange_interval is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please refer to the stoploss documentation . If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. Warning: stoploss_on_exchange failures If stoploss on exchange creation fails for some reason, then an \"emergency sell\" is initiated. By default, this will sell the asset using a market order. The order-type for the emergency-sell can be changed by setting the emergencysell value in the order_types dictionary - however, this is not advised. Understand order_time_in_force \u00b6 The order_time_in_force configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are: GTC (Good Till Canceled): This is most of the time the default time in force. It means the order will remain on exchange till it is cancelled by the user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled. FOK (Fill Or Kill): It means if the order is not executed immediately AND fully then it is cancelled by the exchange. IOC (Immediate Or Canceled): It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange. The order_time_in_force parameter contains a dict with buy and sell time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy. The possible values are: gtc (default), fok or ioc . python \"order_time_in_force\": { \"buy\": \"gtc\", \"sell\": \"gtc\" }, Warning This is ongoing work. For now, it is supported only for binance and kucoin. Please don't change the default value unless you know what you are doing and have researched the impact of using different values for your particular exchange. What values can be used for fiat_display_currency? \u00b6 The fiat_display_currency configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports. The valid values are: json \"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\", \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"ZAR\", \"USD\" In addition to fiat currencies, a range of crypto currencies is supported. The valid values are: json \"BTC\", \"ETH\", \"XRP\", \"LTC\", \"BCH\", \"USDT\" Using Dry-run mode \u00b6 We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode, the bot does not engage your money. It only runs a live simulation without creating trades on the exchange. Edit your config.json configuration file. Switch dry-run to true and specify db_url for a persistence database. json \"dry_run\": true, \"db_url\": \"sqlite:///tradesv3.dryrun.sqlite\", Remove your Exchange API key and secret (change them by empty values or fake credentials): json \"exchange\": { \"name\": \"bittrex\", \"key\": \"key\", \"secret\": \"secret\", ... } Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode. Note A simulated wallet is available during dry-run mode and will assume a starting capital of dry_run_wallet (defaults to 1000). Considerations for dry-run \u00b6 API-keys may or may not be provided. Only Read-Only operations (i.e. operations that do not alter account state) on the exchange are performed in dry-run mode. Wallets ( /balance ) are simulated based on dry_run_wallet . Orders are simulated, and will not be posted to the exchange. Market orders fill based on orderbook volume the moment the order is placed. Limit orders fill once the price reaches the defined level - or time out based on unfilledtimeout settings. In combination with stoploss_on_exchange , the stop_loss price is assumed to be filled. Open orders (not trades, which are stored in the database) are reset on bot restart. Switch to production mode \u00b6 In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode. When switching to Production mode, please make sure to use a different / fresh database to avoid dry-run trades messing with your exchange money and eventually tainting your statistics. Setup your exchange account \u00b6 You will need to create API Keys (usually you get key and secret , some exchanges require an additional password ) from the Exchange website and you'll need to insert this into the appropriate fields in the configuration or when asked by the freqtrade new-config command. API Keys are usually only required for live trading (trading for real money, bot running in \"production mode\", executing real orders on the exchange) and are not required for the bot running in dry-run (trade simulation) mode. When you set up the bot in dry-run mode, you may fill these fields with empty values. To switch your bot in production mode \u00b6 Edit your config.json file. Switch dry-run to false and don't forget to adapt your database URL if set: json \"dry_run\": false, Insert your Exchange API key (change them by fake API keys): json { \"exchange\": { \"name\": \"bittrex\", \"key\": \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\", \"secret\": \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\", //\"password\": \"\", // Optional, not needed by all exchanges) // ... } //... } You should also make sure to read the Exchanges section of the documentation to be aware of potential configuration details specific to your exchange. Keep your secrets secret To keep your secrets secret, we recommend using a 2 nd configuration for your API keys. Simply use the above snippet in a new configuration file (e.g. config-private.json ) and keep your settings in this file. You can then start the bot with freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> to have your keys loaded. NEVER share your private configuration file or your exchange keys with anyone! Using proxy with Freqtrade \u00b6 To use a proxy with freqtrade, add the kwarg \"aiohttp_trust_env\"=true to the \"ccxt_async_kwargs\" dict in the exchange section of the configuration. An example for this can be found in config_examples/config_full.example.json json \"ccxt_async_config\": { \"aiohttp_trust_env\": true } Then, export your proxy settings using the variables \"HTTP_PROXY\" and \"HTTPS_PROXY\" set to the appropriate values bash export HTTP_PROXY=\"http://addr:port\" export HTTPS_PROXY=\"http://addr:port\" freqtrade Next step \u00b6 Now you have configured your config.json, the next step is to start your bot .","title":"Configuration"},{"location":"configuration/#configure-the-bot","text":"Freqtrade has many configurable features and possibilities. By default, these settings are configured via the configuration file (see below).","title":"Configure the bot"},{"location":"configuration/#the-freqtrade-configuration-file","text":"The bot uses a set of configuration parameters during its operation that all together conform to the bot configuration. It normally reads its configuration from a file (Freqtrade configuration file). Per default, the bot loads the configuration from the config.json file, located in the current working directory. You can specify a different configuration file used by the bot with the -c/--config command-line option. If you used the Quick start method for installing the bot, the installation script should have already created the default configuration file ( config.json ) for you. If the default configuration file is not created we recommend to use freqtrade new-config --config config.json to generate a basic configuration file. The Freqtrade configuration file is to be written in JSON format. Additionally to the standard JSON syntax, you may use one-line // ... and multi-line /* ... */ comments in your configuration files and trailing commas in the lists of parameters. Do not worry if you are not familiar with JSON format -- simply open the configuration file with an editor of your choice, make some changes to the parameters you need, save your changes and, finally, restart the bot or, if it was previously stopped, run it again with the changes you made to the configuration. The bot validates the syntax of the configuration file at startup and will warn you if you made any errors editing it, pointing out problematic lines.","title":"The Freqtrade configuration file"},{"location":"configuration/#environment-variables","text":"Set options in the Freqtrade configuration via environment variables. This takes priority over the corresponding value in configuration or strategy. Environment variables must be prefixed with FREQTRADE__ to be loaded to the freqtrade configuration. __ serves as level separator, so the format used should correspond to FREQTRADE__{section}__{key} . As such - an environment variable defined as export FREQTRADE__STAKE_AMOUNT=200 would result in {stake_amount: 200} . A more complex example might be export FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> to keep your exchange key secret. This will move the value to the exchange.key section of the configuration. Using this scheme, all configuration settings will also be available as environment variables. Please note that Environment variables will overwrite corresponding settings in your configuration, but command line Arguments will always win. Common example: FREQTRADE__TELEGRAM__CHAT_ID=<telegramchatid> FREQTRADE__TELEGRAM__TOKEN=<telegramToken> FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> FREQTRADE__EXCHANGE__SECRET=<yourExchangeSecret> Note Environment variables detected are logged at startup - so if you can't find why a value is not what you think it should be based on the configuration, make sure it's not loaded from an environment variable.","title":"Environment variables"},{"location":"configuration/#multiple-configuration-files","text":"Multiple configuration files can be specified and used by the bot or the bot can read its configuration parameters from the process standard input stream. Use multiple configuration files to keep secrets secret You can use a 2 nd configuration file containing your secrets. That way you can share your \"primary\" configuration file, while still keeping your API keys for yourself. bash freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> The 2 nd file should only specify what you intend to override. If a key is in more than one of the configurations, then the \"last specified configuration\" wins (in the above example, config-private.json ).","title":"Multiple configuration files"},{"location":"configuration/#configuration-parameters","text":"The table below will list all configuration parameters available. Freqtrade can also load many options via command line (CLI) arguments (check out the commands --help output for details). The prevalence for all Options is as follows: CLI arguments override any other option Environment Variables Configuration files are used in sequence (the last file wins) and override Strategy configurations. Strategy configurations are only used if they are not set via configuration or command-line arguments. These options are marked with Strategy Override in the below table. Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description max_open_trades Required. Number of open trades your bot is allowed to have. Only one open trade per pair is possible, so the length of your pairlist is another limitation that can apply. If -1 then it is ignored (i.e. potentially unlimited open trades, limited by the pairlist). More information below . Datatype: Positive integer or -1. stake_currency Required. Crypto-currency used for trading. Datatype: String stake_amount Required. Amount of crypto-currency your bot will use for each trade. Set it to \"unlimited\" to allow the bot to use all available balance. More information below . Datatype: Positive float or \"unlimited\" . tradable_balance_ratio Ratio of the total account balance the bot is allowed to trade. More information below . Defaults to 0.99 99%). Datatype: Positive float between 0.1 and 1.0 . available_capital Available starting capital for the bot. Useful when running multiple bots on the same exchange account. More information below . Datatype: Positive float. amend_last_stake_amount Use reduced last stake amount if necessary. More information below . Defaults to false . Datatype: Boolean last_stake_amount_min_ratio Defines minimum stake amount that has to be left and executed. Applies only to the last stake amount when it's amended to a reduced value (i.e. if amend_last_stake_amount is set to true ). More information below . Defaults to 0.5 . Datatype: Float (as ratio) amount_reserve_percent Reserve some amount in min pair stake amount. The bot will reserve amount_reserve_percent + stoploss value when calculating min pair stake amount in order to avoid possible trade refusals. Defaults to 0.05 (5%). Datatype: Positive Float as ratio. timeframe The timeframe to use (e.g 1m , 5m , 15m , 30m , 1h ...). Strategy Override . Datatype: String fiat_display_currency Fiat currency used to show your profits. More information below . Datatype: String dry_run Required. Define if the bot must be in Dry Run or production mode. Defaults to true . Datatype: Boolean dry_run_wallet Define the starting amount in stake currency for the simulated wallet used by the bot running in Dry Run mode. Defaults to 1000 . Datatype: Float cancel_open_orders_on_exit Cancel open orders when the /stop RPC command is issued, Ctrl+C is pressed or the bot dies unexpectedly. When set to true , this allows you to use /stop to cancel unfilled and partially filled orders in the event of a market crash. It does not impact open positions. Defaults to false . Datatype: Boolean process_only_new_candles Enable processing of indicators only when new candles arrive. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override . Defaults to false . Datatype: Boolean minimal_roi Required. Set the threshold as ratio the bot will use to sell a trade. More information below . Strategy Override . Datatype: Dict stoploss Required. Value as ratio of the stoploss used by the bot. More details in the stoploss documentation . Strategy Override . Datatype: Float (as ratio) trailing_stop Enables trailing stoploss (based on stoploss in either configuration or strategy file). More details in the stoploss documentation . Strategy Override . Datatype: Boolean trailing_stop_positive Changes stoploss once profit has been reached. More details in the stoploss documentation . Strategy Override . Datatype: Float trailing_stop_positive_offset Offset on when to apply trailing_stop_positive . Percentage value which should be positive. More details in the stoploss documentation . Strategy Override . Defaults to 0.0 (no offset). Datatype: Float trailing_only_offset_is_reached Only apply trailing stoploss when the offset is reached. stoploss documentation . Strategy Override . Defaults to false . Datatype: Boolean fee Fee used during backtesting / dry-runs. Should normally not be configured, which has freqtrade fall back to the exchange default fee. Set as ratio (e.g. 0.001 = 0.1%). Fee is applied twice for each trade, once when buying, once when selling. Datatype: Float (as ratio) unfilledtimeout.buy Required. How long (in minutes or seconds) the bot will wait for an unfilled buy order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.sell Required. How long (in minutes or seconds) the bot will wait for an unfilled sell order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.unit Unit to use in unfilledtimeout setting. Note: If you set unfilledtimeout.unit to \"seconds\", \"internals.process_throttle_secs\" must be inferior or equal to timeout Strategy Override . Defaults to minutes . Datatype: String unfilledtimeout.exit_timeout_count How many times can exit orders time out. Once this number of timeouts is reached, an emergency sell is triggered. 0 to disable and allow unlimited order cancels. Strategy Override . Defaults to 0 . Datatype: Integer bid_strategy.price_side Select the side of the spread the bot should look at to get the buy rate. More information below . Defaults to bid . Datatype: String (either ask or bid ). bid_strategy.ask_last_balance Required. Interpolate the bidding price. More information below . bid_strategy.use_order_book Enable buying using the rates in Order Book Bids . Datatype: Boolean bid_strategy.order_book_top Bot will use the top N rate in Order Book \"price_side\" to buy. I.e. a value of 2 will allow the bot to pick the 2 nd bid rate in Order Book Bids . Defaults to 1 . Datatype: Positive Integer bid_strategy. check_depth_of_market.enabled Do not buy if the difference of buy orders and sell orders is met in Order Book. Check market depth . Defaults to false . Datatype: Boolean bid_strategy. check_depth_of_market.bids_to_ask_delta The difference ratio of buy orders and sell orders found in Order Book. A value below 1 means sell order size is greater, while value greater than 1 means buy order size is higher. Check market depth Defaults to 0 . Datatype: Float (as ratio) ask_strategy.price_side Select the side of the spread the bot should look at to get the sell rate. More information below . Defaults to ask . Datatype: String (either ask or bid ). ask_strategy.bid_last_balance Interpolate the selling price. More information below . ask_strategy.use_order_book Enable selling of open trades using Order Book Asks . Datatype: Boolean ask_strategy.order_book_top Bot will use the top N rate in Order Book \"price_side\" to sell. I.e. a value of 2 will allow the bot to pick the 2 nd ask rate in Order Book Asks Defaults to 1 . Datatype: Positive Integer use_sell_signal Use sell signals produced by the strategy in addition to the minimal_roi . Strategy Override . Defaults to true . Datatype: Boolean sell_profit_only Wait until the bot reaches sell_profit_offset before taking a sell decision. Strategy Override . Defaults to false . Datatype: Boolean sell_profit_offset Sell-signal is only active above this value. Only active in combination with sell_profit_only=True . Strategy Override . Defaults to 0.0 . Datatype: Float (as ratio) ignore_roi_if_buy_signal Do not sell if the buy signal is still active. This setting takes preference over minimal_roi and use_sell_signal . Strategy Override . Defaults to false . Datatype: Boolean ignore_buying_expired_candle_after Specifies the number of seconds until a buy signal is no longer used. Datatype: Integer order_types Configure order-types depending on the action ( \"buy\" , \"sell\" , \"stoploss\" , \"stoploss_on_exchange\" ). More information below . Strategy Override . Datatype: Dict order_time_in_force Configure time in force for buy and sell orders. More information below . Strategy Override . Datatype: Dict custom_price_max_distance_ratio Configure maximum distance ratio between current and custom entry or exit price. Defaults to 0.02 2%). Datatype: Positive float exchange.name Required. Name of the exchange class to use. List below . Datatype: String exchange.sandbox Use the 'sandbox' version of the exchange, where the exchange provides a sandbox for risk-free integration. See here in more details. Datatype: Boolean exchange.key API key to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.secret API secret to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.password API password to use for the exchange. Only required when you are in production mode and for exchanges that use password for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.uid API uid to use for the exchange. Only required when you are in production mode and for exchanges that use uid for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.pair_whitelist List of pairs to use by the bot for trading and to check for potential trades during backtesting. Supports regex pairs as .*/BTC . Not used by VolumePairList. More information . Datatype: List exchange.pair_blacklist List of pairs the bot must absolutely avoid for trading and backtesting. More information . Datatype: List exchange.ccxt_config Additional CCXT parameters passed to both ccxt instances (sync and async). This is usually the correct place for additional ccxt configurations. Parameters may differ from exchange to exchange and are documented in the ccxt documentation . Please avoid adding exchange secrets here (use the dedicated fields instead), as they may be contained in logs. Datatype: Dict exchange.ccxt_sync_config Additional CCXT parameters passed to the regular (sync) ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.ccxt_async_config Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.markets_refresh_interval The interval in minutes in which markets are reloaded. Defaults to 60 minutes. Datatype: Positive Integer exchange.skip_pair_validation Skip pairlist validation on startup. Defaults to false Datatype: * Boolean exchange.skip_open_order_update Skips open order updates on startup should the exchange cause problems. Only relevant in live conditions. Defaults to false Datatype: * Boolean exchange.unknown_fee_rate Fallback value to use when calculating trading fees. This can be useful for exchanges which have fees in non-tradable currencies. The value provided here will be multiplied with the \"fee cost\". Defaults to None Datatype: * float exchange.log_responses Log relevant exchange responses. For debug mode only - use with care. Defaults to false Datatype: * Boolean edge.* Please refer to edge configuration document for detailed explanation. experimental.block_bad_exchanges Block exchanges known to not work with freqtrade. Leave on default unless you want to test if that exchange works now. Defaults to true . Datatype: Boolean pairlists Define one or more pairlists to be used. More information . Defaults to StaticPairList . Datatype: List of Dicts protections Define one or more protections to be used. More information . Datatype: List of Dicts telegram.enabled Enable the usage of Telegram. Datatype: Boolean telegram.token Your Telegram bot token. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.chat_id Your personal Telegram account id. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.balance_dust_level Dust-level (in stake currency) - currencies with a balance below this will not be shown by /balance . Datatype: float webhook.enabled Enable usage of Webhook notifications Datatype: Boolean webhook.url URL for the webhook. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookbuy Payload to send on buy. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookbuycancel Payload to send on buy order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhooksell Payload to send on sell. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhooksellcancel Payload to send on sell order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookstatus Payload to send on status calls. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String api_server.enabled Enable usage of API Server. See the API Server documentation for more details. Datatype: Boolean api_server.listen_ip_address Bind IP address. See the API Server documentation for more details. Datatype: IPv4 api_server.listen_port Bind Port. See the API Server documentation for more details. Datatype: Integer between 1024 and 65535 api_server.verbosity Logging verbosity. info will print all RPC Calls, while \"error\" will only display errors. Datatype: Enum, either info or error . Defaults to info . api_server.username Username for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String api_server.password Password for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String bot_name Name of the bot. Passed via API to a client - can be shown to distinguish / name bots. Defaults to freqtrade Datatype: String db_url Declares database URL to use. NOTE: This defaults to sqlite:///tradesv3.dryrun.sqlite if dry_run is true , and to sqlite:///tradesv3.sqlite for production instances. Datatype: String, SQLAlchemy connect string initial_state Defines the initial application state. If set to stopped, then the bot has to be explicitly started via /start RPC command. Defaults to stopped . Datatype: Enum, either stopped or running forcebuy_enable Enables the RPC Commands to force a buy. More information below. Datatype: Boolean disable_dataframe_checks Disable checking the OHLCV dataframe returned from the strategy methods for correctness. Only use when intentionally changing the dataframe and understand what you are doing. Strategy Override . Defaults to False . Datatype: Boolean strategy Required Defines Strategy class to use. Recommended to be set via --strategy NAME . Datatype: ClassName strategy_path Adds an additional strategy lookup path (must be a directory). Datatype: String internals.process_throttle_secs Set the process throttle, or minimum loop duration for one bot iteration loop. Value in second. Defaults to 5 seconds. Datatype: Positive Integer internals.heartbeat_interval Print heartbeat message every N seconds. Set to 0 to disable heartbeat messages. Defaults to 60 seconds. Datatype: Positive Integer or 0 internals.sd_notify Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details. Datatype: Boolean logfile Specifies logfile name. Uses a rolling strategy for log file rotation for 10 files with the 1MB limit per file. Datatype: String user_data_dir Directory containing user data. Defaults to ./user_data/ . Datatype: String dataformat_ohlcv Data format to use to store historical candle (OHLCV) data. Defaults to json . Datatype: String dataformat_trades Data format to use to store historical trades data. Defaults to jsongz . Datatype: String position_adjustment_enable Enables the strategy to use position adjustments (additional buys or sells). More information here . Strategy Override . Defaults to false . Datatype: Boolean max_entry_position_adjustment Maximum additional order(s) for each open trade on top of the first entry Order. Set it to -1 for unlimited additional orders. More information here . Strategy Override . Defaults to -1 . Datatype: Positive Integer or -1","title":"Configuration parameters"},{"location":"configuration/#parameters-in-the-strategy","text":"The following parameters can be set in the configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy. minimal_roi timeframe stoploss trailing_stop trailing_stop_positive trailing_stop_positive_offset trailing_only_offset_is_reached use_custom_stoploss process_only_new_candles order_types order_time_in_force unfilledtimeout disable_dataframe_checks use_sell_signal sell_profit_only sell_profit_offset ignore_roi_if_buy_signal ignore_buying_expired_candle_after position_adjustment_enable max_entry_position_adjustment","title":"Parameters in the strategy"},{"location":"configuration/#configuring-amount-per-trade","text":"There are several methods to configure how much of the stake currency the bot will use to enter a trade. All methods respect the available balance configuration as explained below.","title":"Configuring amount per trade"},{"location":"configuration/#minimum-trade-stake","text":"The minimum stake amount will depend on exchange and pair and is usually listed in the exchange support pages. Assuming the minimum tradable amount for XRP/USD is 20 XRP (given by the exchange), and the price is 0.6 \\(, the minimum stake amount to buy this pair is 20 * 0.6 ~= 12 . This exchange has also a limit on USD - where all orders must be > 10\\) - which however does not apply in this case. To guarantee safe execution, freqtrade will not allow buying with a stake-amount of 10.1$, instead, it'll make sure that there's enough space to place a stoploss below the pair (+ an offset, defined by amount_reserve_percent , which defaults to 5%). With a reserve of 5%, the minimum stake amount would be ~12.6$ ( 12 * (1 + 0.05) ). If we take into account a stoploss of 10% on top of that - we'd end up with a value of ~14$ ( 12.6 / (1 - 0.1) ). To limit this calculation in case of large stoploss values, the calculated minimum stake-limit will never be more than 50% above the real limit. Warning Since the limits on exchanges are usually stable and are not updated often, some pairs can show pretty high minimum limits, simply because the price increased a lot since the last limit adjustment by the exchange. Freqtrade adjusts the stake-amount to this value, unless it's > 30% more than the calculated/desired stake-amount - in which case the trade is rejected.","title":"Minimum trade stake"},{"location":"configuration/#tradable-balance","text":"By default, the bot assumes that the complete amount - 1% is at it's disposal, and when using dynamic stake amount , it will split the complete balance into max_open_trades buckets per trade. Freqtrade will reserve 1% for eventual fees when entering a trade and will therefore not touch that by default. You can configure the \"untouched\" amount by using the tradable_balance_ratio setting. For example, if you have 10 ETH available in your wallet on the exchange and tradable_balance_ratio=0.5 (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers this as an available balance. The rest of the wallet is untouched by the trades. Danger This setting should not be used when running multiple bots on the same account. Please look at Available Capital to the bot instead. Warning The tradable_balance_ratio setting applies to the current balance (free balance + tied up in trades). Therefore, assuming the starting balance of 1000, a configuration with tradable_balance_ratio=0.99 will not guarantee that 10 currency units will always remain available on the exchange. For example, the free amount may reduce to 5 units if the total balance is reduced to 500 (either by a losing streak or by withdrawing balance).","title":"Tradable balance"},{"location":"configuration/#assign-available-capital","text":"To fully utilize compounding profits when using multiple bots on the same exchange account, you'll want to limit each bot to a certain starting balance. This can be accomplished by setting available_capital to the desired starting balance. Assuming your account has 10.000 USDT and you want to run 2 different strategies on this exchange. You'd set available_capital=5000 - granting each bot an initial capital of 5000 USDT. The bot will then split this starting balance equally into max_open_trades buckets. Profitable trades will result in increased stake-sizes for this bot - without affecting the stake-sizes of the other bot. Incompatible with tradable_balance_ratio Setting this option will replace any configuration of tradable_balance_ratio .","title":"Assign available Capital"},{"location":"configuration/#amend-last-stake-amount","text":"Assuming we have the tradable balance of 1000 USDT, stake_amount=400 , and max_open_trades=3 . The bot would open 2 trades and will be unable to fill the last trading slot, since the requested 400 USDT are no longer available since 800 USDT are already tied in other trades. To overcome this, the option amend_last_stake_amount can be set to True , which will enable the bot to reduce stake_amount to the available balance to fill the last trade slot. In the example above this would mean: Trade1: 400 USDT Trade2: 400 USDT Trade3: 200 USDT Note This option only applies with Static stake amount - since Dynamic stake amount divides the balances evenly. Note The minimum last stake amount can be configured using last_stake_amount_min_ratio - which defaults to 0.5 (50%). This means that the minimum stake amount that's ever used is stake_amount * 0.5 . This avoids very low stake amounts, that are close to the minimum tradable amount for the pair and can be refused by the exchange.","title":"Amend last stake amount"},{"location":"configuration/#static-stake-amount","text":"The stake_amount configuration statically configures the amount of stake-currency your bot will use for each trade. The minimal configuration value is 0.0001, however, please check your exchange's trading minimums for the stake currency you're using to avoid problems. This setting works in combination with max_open_trades . The maximum capital engaged in trades is stake_amount * max_open_trades . For example, the bot will at most use (0.05 BTC x 3) = 0.15 BTC, assuming a configuration of max_open_trades=3 and stake_amount=0.05 . Note This setting respects the available balance configuration .","title":"Static stake amount"},{"location":"configuration/#dynamic-stake-amount","text":"Alternatively, you can use a dynamic stake amount, which will use the available balance on the exchange, and divide that equally by the number of allowed trades ( max_open_trades ). To configure this, set stake_amount=\"unlimited\" . We also recommend to set tradable_balance_ratio=0.99 (99%) - to keep a minimum balance for eventual fees. In this case a trade amount is calculated as: python currency_balance / (max_open_trades - current_open_trades) To allow the bot to trade all the available stake_currency in your account (minus tradable_balance_ratio ) set json \"stake_amount\" : \"unlimited\", \"tradable_balance_ratio\": 0.99, Compounding profits This configuration will allow increasing/decreasing stakes depending on the performance of the bot (lower stake if the bot is losing, higher stakes if the bot has a winning record since higher balances are available), and will result in profit compounding. When using Dry-Run Mode When using \"stake_amount\" : \"unlimited\", in combination with Dry-Run, Backtesting or Hyperopt, the balance will be simulated starting with a stake of dry_run_wallet which will evolve. It is therefore important to set dry_run_wallet to a sensible value (like 0.05 or 0.01 for BTC and 1000 or 100 for USDT, for example), otherwise, it may simulate trades with 100 BTC (or more) or 0.05 USDT (or less) at once - which may not correspond to your real available balance or is less than the exchange minimal limit for the order amount for the stake currency.","title":"Dynamic stake amount"},{"location":"configuration/#dynamic-stake-amount-with-position-adjustment","text":"When you want to use position adjustment with unlimited stakes, you must also implement custom_stake_amount to a return a value depending on your strategy. Typical value would be in the range of 25% - 50% of the proposed stakes, but depends highly on your strategy and how much you wish to leave into the wallet as position adjustment buffer. For example if your position adjustment assumes it can do 2 additional buys with the same stake amounts then your buffer should be 66.6667% of the initially proposed unlimited stake amount. Or another example if your position adjustment assumes it can do 1 additional buy with 3x the original stake amount then custom_stake_amount should return 25% of proposed stake amount and leave 75% for possible later position adjustments.","title":"Dynamic stake amount with position adjustment"},{"location":"configuration/#prices-used-for-orders","text":"Prices for regular orders can be controlled via the parameter structures bid_strategy for buying and ask_strategy for selling. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders.","title":"Prices used for orders"},{"location":"configuration/#buy-price","text":"","title":"Buy price"},{"location":"configuration/#check-depth-of-market","text":"When check depth of market is enabled ( bid_strategy.check_depth_of_market.enabled=True ), the buy signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the bid_strategy.check_depth_of_market.bids_to_ask_delta parameter. The buy order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).","title":"Check depth of market"},{"location":"configuration/#buy-price-side","text":"The configuration setting bid_strategy.price_side defines the side of the spread the bot looks for when buying. The following displays an orderbook. explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If bid_strategy.price_side is set to \"bid\" , then the bot will use 99 as buying price. In line with that, if bid_strategy.price_side is set to \"ask\" , then the bot will use 101 as buying price. Using ask price often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"ask\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).","title":"Buy price side"},{"location":"configuration/#buy-price-with-orderbook-enabled","text":"When buying with the orderbook enabled ( bid_strategy.use_order_book=True ), Freqtrade fetches the bid_strategy.order_book_top entries from the orderbook and uses the entry specified as bid_strategy.order_book_top on the configured side ( bid_strategy.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Buy price with Orderbook enabled"},{"location":"configuration/#buy-price-without-orderbook-enabled","text":"The following section uses side as the configured bid_strategy.price_side (defaults to \"bid\" ). When not using orderbook ( bid_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on bid_strategy.ask_last_balance .. The bid_strategy.ask_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price.","title":"Buy price without Orderbook enabled"},{"location":"configuration/#sell-price","text":"","title":"Sell price"},{"location":"configuration/#sell-price-side","text":"The configuration setting ask_strategy.price_side defines the side of the spread the bot looks for when selling. The following displays an orderbook: explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If ask_strategy.price_side is set to \"ask\" , then the bot will use 101 as selling price. In line with that, if ask_strategy.price_side is set to \"bid\" , then the bot will use 99 as selling price.","title":"Sell price side"},{"location":"configuration/#sell-price-with-orderbook-enabled","text":"When selling with the orderbook enabled ( ask_strategy.use_order_book=True ), Freqtrade fetches the ask_strategy.order_book_top entries in the orderbook and uses the entry specified as ask_strategy.order_book_top from the configured side ( ask_strategy.price_side ) as selling price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Sell price with Orderbook enabled"},{"location":"configuration/#sell-price-without-orderbook-enabled","text":"The following section uses side as the configured ask_strategy.price_side (defaults to \"ask\" ). When not using orderbook ( ask_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on ask_strategy.bid_last_balance . The ask_strategy.bid_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price.","title":"Sell price without Orderbook enabled"},{"location":"configuration/#market-order-pricing","text":"When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both buy and sell are using market orders, a configuration similar to the following might be used jsonc \"order_types\": { \"buy\": \"market\", \"sell\": \"market\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Market order pricing"},{"location":"configuration/#understand-minimal_roi","text":"The minimal_roi configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI as a ratio. See the example below: json \"minimal_roi\": { \"40\": 0.0, # Sell after 40 minutes if the profit is not negative \"30\": 0.01, # Sell after 30 minutes if there is at least 1% profit \"20\": 0.02, # Sell after 20 minutes if there is at least 2% profit \"0\": 0.04 # Sell immediately if there is at least 4% profit }, Most of the strategy files already include the optimal minimal_roi value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the minimal_roi value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% {\"0\": 10} is used, and minimal ROI is disabled unless your trade generates 1000% profit. Special case to forcesell after a specific time A special case presents using \"<N>\": -1 as ROI. This forces the bot to sell a trade after N Minutes, no matter if it's positive or negative, so represents a time-limited force-sell.","title":"Understand minimal_roi"},{"location":"configuration/#understand-forcebuy_enable","text":"The forcebuy_enable configuration parameter enables the usage of forcebuy commands via Telegram and REST API. For security reasons, it's disabled by default, and freqtrade will show a warning message on startup if enabled. For example, you can send /forcebuy ETH/BTC to the bot, which will result in freqtrade buying the pair and holds it until a regular sell-signal (ROI, stoploss, /forcesell) appears. This can be dangerous with some strategies, so use with care. See the telegram documentation for details on usage.","title":"Understand forcebuy_enable"},{"location":"configuration/#ignoring-expired-candles","text":"When working with larger timeframes (for example 1h or more) and using a low max_open_trades value, the last candle can be processed as soon as a trade slot becomes available. When processing the last candle, this can lead to a situation where it may not be desirable to use the buy signal on that candle. For example, when using a condition in your strategy where you use a cross-over, that point may have passed too long ago for you to start a trade on it. In these situations, you can enable the functionality to ignore candles that are beyond a specified period by setting ignore_buying_expired_candle_after to a positive number, indicating the number of seconds after which the buy signal becomes expired. For example, if your strategy is using a 1h timeframe, and you only want to buy within the first 5 minutes when a new candle comes in, you can add the following configuration to your strategy: json { //... \"ignore_buying_expired_candle_after\": 300, // ... } Note This setting resets with each new candle, so it will not prevent sticking-signals from executing on the 2 nd or 3 rd candle they're active. Best use a \"trigger\" selector for buy signals, which are only active for one candle.","title":"Ignoring expired candles"},{"location":"configuration/#understand-order_types","text":"The order_types configuration parameter maps actions ( buy , sell , stoploss , emergencysell , forcesell , forcebuy ) to order-types ( market , limit , ...) as well as configures stoploss to be on the exchange and defines stoploss on exchange update interval in seconds. This allows to buy using limit orders, sell using limit-orders, and create stoplosses using market orders. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled. order_types set in the configuration file overwrites values set in the strategy as a whole, so you need to configure the whole order_types dictionary in one place. If this is configured, the following 4 values ( buy , sell , stoploss and stoploss_on_exchange ) need to be present, otherwise, the bot will fail to start. For information on ( emergencysell , forcesell , forcebuy , stoploss_on_exchange , stoploss_on_exchange_interval , stoploss_on_exchange_limit_ratio ) please see stop loss documentation stop loss on exchange Syntax for Strategy: python order_types = { \"buy\": \"limit\", \"sell\": \"limit\", \"emergencysell\": \"market\", \"forcebuy\": \"market\", \"forcesell\": \"market\", \"stoploss\": \"market\", \"stoploss_on_exchange\": False, \"stoploss_on_exchange_interval\": 60, \"stoploss_on_exchange_limit_ratio\": 0.99, } Configuration: json \"order_types\": { \"buy\": \"limit\", \"sell\": \"limit\", \"emergencysell\": \"market\", \"forcebuy\": \"market\", \"forcesell\": \"market\", \"stoploss\": \"market\", \"stoploss_on_exchange\": false, \"stoploss_on_exchange_interval\": 60 } Market order support Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: \"Exchange <yourexchange> does not support market orders.\" and the bot will refuse to start. Using market orders Please carefully read the section Market order pricing section when using market orders. Stoploss on exchange stoploss_on_exchange_interval is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please refer to the stoploss documentation . If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. Warning: stoploss_on_exchange failures If stoploss on exchange creation fails for some reason, then an \"emergency sell\" is initiated. By default, this will sell the asset using a market order. The order-type for the emergency-sell can be changed by setting the emergencysell value in the order_types dictionary - however, this is not advised.","title":"Understand order_types"},{"location":"configuration/#understand-order_time_in_force","text":"The order_time_in_force configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are: GTC (Good Till Canceled): This is most of the time the default time in force. It means the order will remain on exchange till it is cancelled by the user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled. FOK (Fill Or Kill): It means if the order is not executed immediately AND fully then it is cancelled by the exchange. IOC (Immediate Or Canceled): It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange. The order_time_in_force parameter contains a dict with buy and sell time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy. The possible values are: gtc (default), fok or ioc . python \"order_time_in_force\": { \"buy\": \"gtc\", \"sell\": \"gtc\" }, Warning This is ongoing work. For now, it is supported only for binance and kucoin. Please don't change the default value unless you know what you are doing and have researched the impact of using different values for your particular exchange.","title":"Understand order_time_in_force"},{"location":"configuration/#what-values-can-be-used-for-fiat_display_currency","text":"The fiat_display_currency configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports. The valid values are: json \"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\", \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"ZAR\", \"USD\" In addition to fiat currencies, a range of crypto currencies is supported. The valid values are: json \"BTC\", \"ETH\", \"XRP\", \"LTC\", \"BCH\", \"USDT\"","title":"What values can be used for fiat_display_currency?"},{"location":"configuration/#using-dry-run-mode","text":"We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode, the bot does not engage your money. It only runs a live simulation without creating trades on the exchange. Edit your config.json configuration file. Switch dry-run to true and specify db_url for a persistence database. json \"dry_run\": true, \"db_url\": \"sqlite:///tradesv3.dryrun.sqlite\", Remove your Exchange API key and secret (change them by empty values or fake credentials): json \"exchange\": { \"name\": \"bittrex\", \"key\": \"key\", \"secret\": \"secret\", ... } Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode. Note A simulated wallet is available during dry-run mode and will assume a starting capital of dry_run_wallet (defaults to 1000).","title":"Using Dry-run mode"},{"location":"configuration/#considerations-for-dry-run","text":"API-keys may or may not be provided. Only Read-Only operations (i.e. operations that do not alter account state) on the exchange are performed in dry-run mode. Wallets ( /balance ) are simulated based on dry_run_wallet . Orders are simulated, and will not be posted to the exchange. Market orders fill based on orderbook volume the moment the order is placed. Limit orders fill once the price reaches the defined level - or time out based on unfilledtimeout settings. In combination with stoploss_on_exchange , the stop_loss price is assumed to be filled. Open orders (not trades, which are stored in the database) are reset on bot restart.","title":"Considerations for dry-run"},{"location":"configuration/#switch-to-production-mode","text":"In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode. When switching to Production mode, please make sure to use a different / fresh database to avoid dry-run trades messing with your exchange money and eventually tainting your statistics.","title":"Switch to production mode"},{"location":"configuration/#setup-your-exchange-account","text":"You will need to create API Keys (usually you get key and secret , some exchanges require an additional password ) from the Exchange website and you'll need to insert this into the appropriate fields in the configuration or when asked by the freqtrade new-config command. API Keys are usually only required for live trading (trading for real money, bot running in \"production mode\", executing real orders on the exchange) and are not required for the bot running in dry-run (trade simulation) mode. When you set up the bot in dry-run mode, you may fill these fields with empty values.","title":"Setup your exchange account"},{"location":"configuration/#to-switch-your-bot-in-production-mode","text":"Edit your config.json file. Switch dry-run to false and don't forget to adapt your database URL if set: json \"dry_run\": false, Insert your Exchange API key (change them by fake API keys): json { \"exchange\": { \"name\": \"bittrex\", \"key\": \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\", \"secret\": \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\", //\"password\": \"\", // Optional, not needed by all exchanges) // ... } //... } You should also make sure to read the Exchanges section of the documentation to be aware of potential configuration details specific to your exchange. Keep your secrets secret To keep your secrets secret, we recommend using a 2 nd configuration for your API keys. Simply use the above snippet in a new configuration file (e.g. config-private.json ) and keep your settings in this file. You can then start the bot with freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> to have your keys loaded. NEVER share your private configuration file or your exchange keys with anyone!","title":"To switch your bot in production mode"},{"location":"configuration/#using-proxy-with-freqtrade","text":"To use a proxy with freqtrade, add the kwarg \"aiohttp_trust_env\"=true to the \"ccxt_async_kwargs\" dict in the exchange section of the configuration. An example for this can be found in config_examples/config_full.example.json json \"ccxt_async_config\": { \"aiohttp_trust_env\": true } Then, export your proxy settings using the variables \"HTTP_PROXY\" and \"HTTPS_PROXY\" set to the appropriate values bash export HTTP_PROXY=\"http://addr:port\" export HTTPS_PROXY=\"http://addr:port\" freqtrade","title":"Using proxy with Freqtrade"},{"location":"configuration/#next-step","text":"Now you have configured your config.json, the next step is to start your bot .","title":"Next step"},{"location":"data-analysis/","text":"Analyzing bot data with Jupyter notebooks \u00b6 You can analyze the results of backtests and trading history easily using Jupyter notebooks. Sample notebooks are located at user_data/notebooks/ after initializing the user directory with freqtrade create-userdir --userdir user_data . Quick start with docker \u00b6 Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a dockercontainer running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. For more information, Please visit the Data analysis with Docker section. Pro tips \u00b6 See jupyter.org for usage instructions. Don't forget to start a Jupyter notebook server from within your conda or venv environment or use nb_conda_kernels * Copy the example notebook before use so your changes don't get overwritten with the next freqtrade update. Using virtual environment with system-wide Jupyter installation \u00b6 Sometimes it can be desired to use a system-wide installation of Jupyter notebook, and use a jupyter kernel from the virtual environment. This prevents you from installing the full jupyter suite multiple times per system, and provides an easy way to switch between tasks (freqtrade / other analytics tasks). For this to work, first activate your virtual environment and run the following commands: ``` bash Activate virtual environment \u00b6 source .env/bin/activate pip install ipykernel ipython kernel install --user --name=freqtrade Restart jupyter (lab / notebook) \u00b6 select kernel \"freqtrade\" in the notebook \u00b6 ``` Note This section is provided for completeness, the Freqtrade Team won't provide full support for problems with this setup and will recommend to install Jupyter in the virtual environment directly, as that is the easiest way to get jupyter notebooks up and running. For help with this setup please refer to the Project Jupyter documentation or help channels . Warning Some tasks don't work especially well in notebooks. For example, anything using asynchronous execution is a problem for Jupyter. Also, freqtrade's primary entry point is the shell cli, so using pure python in a notebook bypasses arguments that provide required objects and parameters to helper functions. You may need to set those values or create expected objects manually. Recommended workflow \u00b6 Task Tool Bot operations CLI Repetitive tasks Shell scripts Data analysis & visualization Notebook Use the CLI to * download historical data * run a backtest * run with real-time data * export results Collect these actions in shell scripts * save complicated commands with arguments * execute multi-step operations * automate testing strategies and preparing data for analysis Use a notebook to * visualize data * mangle and plot to generate insights Example utility snippets \u00b6 Change directory to root \u00b6 Jupyter notebooks execute from the notebook directory. The following snippet searches for the project root, so relative paths remain consistent. ```python import os from pathlib import Path Change directory \u00b6 Modify this cell to insure that the output shows the correct path. \u00b6 Define all paths relative to the project root shown in the cell output \u00b6 project_root = \"somedir/freqtrade\" i=0 try: os.chdirdir(project_root) assert Path('LICENSE').is_file() except: while i<4 and (not Path('LICENSE').is_file()): os.chdir(Path(Path.cwd(), '../')) i+=1 project_root = Path.cwd() print(Path.cwd()) ``` Load multiple configuration files \u00b6 This option can be useful to inspect the results of passing in multiple configs. This will also run through the whole Configuration initialization, so the configuration is completely initialized to be passed to other methods. ``` python import json from freqtrade.configuration import Configuration Load config from multiple files \u00b6 config = Configuration.from_files([\"config1.json\", \"config2.json\"]) Show the config in memory \u00b6 print(json.dumps(config['original_config'], indent=2)) ``` For Interactive environments, have an additional configuration specifying user_data_dir and pass this in last, so you don't have to change directories while running the bot. Best avoid relative paths, since this starts at the storage location of the jupyter notebook, unless the directory is changed. json { \"user_data_dir\": \"~/.freqtrade/\" } Further Data analysis documentation \u00b6 Strategy debugging - also available as Jupyter notebook ( user_data/notebooks/strategy_analysis_example.ipynb ) Plotting Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Jupyter Notebooks"},{"location":"data-analysis/#analyzing-bot-data-with-jupyter-notebooks","text":"You can analyze the results of backtests and trading history easily using Jupyter notebooks. Sample notebooks are located at user_data/notebooks/ after initializing the user directory with freqtrade create-userdir --userdir user_data .","title":"Analyzing bot data with Jupyter notebooks"},{"location":"data-analysis/#quick-start-with-docker","text":"Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a dockercontainer running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. For more information, Please visit the Data analysis with Docker section.","title":"Quick start with docker"},{"location":"data-analysis/#pro-tips","text":"See jupyter.org for usage instructions. Don't forget to start a Jupyter notebook server from within your conda or venv environment or use nb_conda_kernels * Copy the example notebook before use so your changes don't get overwritten with the next freqtrade update.","title":"Pro tips"},{"location":"data-analysis/#using-virtual-environment-with-system-wide-jupyter-installation","text":"Sometimes it can be desired to use a system-wide installation of Jupyter notebook, and use a jupyter kernel from the virtual environment. This prevents you from installing the full jupyter suite multiple times per system, and provides an easy way to switch between tasks (freqtrade / other analytics tasks). For this to work, first activate your virtual environment and run the following commands: ``` bash","title":"Using virtual environment with system-wide Jupyter installation"},{"location":"data-analysis/#activate-virtual-environment","text":"source .env/bin/activate pip install ipykernel ipython kernel install --user --name=freqtrade","title":"Activate virtual environment"},{"location":"data-analysis/#restart-jupyter-lab-notebook","text":"","title":"Restart jupyter (lab / notebook)"},{"location":"data-analysis/#select-kernel-freqtrade-in-the-notebook","text":"``` Note This section is provided for completeness, the Freqtrade Team won't provide full support for problems with this setup and will recommend to install Jupyter in the virtual environment directly, as that is the easiest way to get jupyter notebooks up and running. For help with this setup please refer to the Project Jupyter documentation or help channels . Warning Some tasks don't work especially well in notebooks. For example, anything using asynchronous execution is a problem for Jupyter. Also, freqtrade's primary entry point is the shell cli, so using pure python in a notebook bypasses arguments that provide required objects and parameters to helper functions. You may need to set those values or create expected objects manually.","title":"select kernel \"freqtrade\" in the notebook"},{"location":"data-analysis/#recommended-workflow","text":"Task Tool Bot operations CLI Repetitive tasks Shell scripts Data analysis & visualization Notebook Use the CLI to * download historical data * run a backtest * run with real-time data * export results Collect these actions in shell scripts * save complicated commands with arguments * execute multi-step operations * automate testing strategies and preparing data for analysis Use a notebook to * visualize data * mangle and plot to generate insights","title":"Recommended workflow"},{"location":"data-analysis/#example-utility-snippets","text":"","title":"Example utility snippets"},{"location":"data-analysis/#change-directory-to-root","text":"Jupyter notebooks execute from the notebook directory. The following snippet searches for the project root, so relative paths remain consistent. ```python import os from pathlib import Path","title":"Change directory to root"},{"location":"data-analysis/#change-directory","text":"","title":"Change directory"},{"location":"data-analysis/#modify-this-cell-to-insure-that-the-output-shows-the-correct-path","text":"","title":"Modify this cell to insure that the output shows the correct path."},{"location":"data-analysis/#define-all-paths-relative-to-the-project-root-shown-in-the-cell-output","text":"project_root = \"somedir/freqtrade\" i=0 try: os.chdirdir(project_root) assert Path('LICENSE').is_file() except: while i<4 and (not Path('LICENSE').is_file()): os.chdir(Path(Path.cwd(), '../')) i+=1 project_root = Path.cwd() print(Path.cwd()) ```","title":"Define all paths relative to the project root shown in the cell output"},{"location":"data-analysis/#load-multiple-configuration-files","text":"This option can be useful to inspect the results of passing in multiple configs. This will also run through the whole Configuration initialization, so the configuration is completely initialized to be passed to other methods. ``` python import json from freqtrade.configuration import Configuration","title":"Load multiple configuration files"},{"location":"data-analysis/#load-config-from-multiple-files","text":"config = Configuration.from_files([\"config1.json\", \"config2.json\"])","title":"Load config from multiple files"},{"location":"data-analysis/#show-the-config-in-memory","text":"print(json.dumps(config['original_config'], indent=2)) ``` For Interactive environments, have an additional configuration specifying user_data_dir and pass this in last, so you don't have to change directories while running the bot. Best avoid relative paths, since this starts at the storage location of the jupyter notebook, unless the directory is changed. json { \"user_data_dir\": \"~/.freqtrade/\" }","title":"Show the config in memory"},{"location":"data-analysis/#further-data-analysis-documentation","text":"Strategy debugging - also available as Jupyter notebook ( user_data/notebooks/strategy_analysis_example.ipynb ) Plotting Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Further Data analysis documentation"},{"location":"data-download/","text":"Data Downloading \u00b6 Getting data for backtesting and hyperopt \u00b6 To download data (candles / OHLCV) needed for backtesting and hyperoptimization use the freqtrade download-data command. If no additional parameter is specified, freqtrade will download data for \"1m\" and \"5m\" timeframes for the last 30 days. Exchange and pairs will come from config.json (if specified using -c/--config ). Otherwise --exchange becomes mandatory. You can use a relative timerange ( --days 20 ) or an absolute starting point ( --timerange 20200101- ). For incremental downloads, the relative approach should be used. Tip: Updating existing data If you already have backtesting data available in your data-directory and would like to refresh this data up to today, freqtrade will automatically calculate the data missing for the existing pairs and the download will occur from the latest available point until \"now\", neither --days or --timerange parameters are required. Freqtrade will keep the available data and only download the missing data. If you are updating existing data after inserting new pairs that you have no data for, use --new-pairs-days xx parameter. Specified number of days will be downloaded for new pairs while old pairs will be updated with missing data only. If you use --days xx parameter alone - data for specified number of days will be downloaded for all pairs. Be careful, if specified number of days is smaller than gap between now and last downloaded candle - freqtrade will delete all existing data to avoid gaps in candle data. Usage \u00b6 ``` usage: freqtrade download-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [--pairs-file FILE] [--days INT] [--new-pairs-days INT] [--include-inactive-pairs] [--timerange TIMERANGE] [--dl-trades] [--exchange EXCHANGE] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--erase] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --pairs-file FILE File containing a list of pairs to download. --days INT Download data for given number of days. --new-pairs-days INT Download data of new pairs for given number of days. Default: None . --include-inactive-pairs Also download data from inactive pairs. --timerange TIMERANGE Specify what timerange of data to use. --dl-trades Download trades instead of OHLCV data. The bot will resample trades to the desired timeframe as specified as --timeframes/-t. --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . --erase Clean all existing data for the selected exchange/pairs/timeframes. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: jsongz ). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Startup period download-data is a strategy-independent command. The idea is to download a big chunk of data once, and then iteratively increase the amount of data stored. For that reason, download-data does not care about the \"startup-period\" defined in a strategy. It's up to the user to download additional days if the backtest should start at a specific point in time (while respecting startup period). Pairs file \u00b6 In alternative to the whitelist from config.json , a pairs.json file can be used. If you are using Binance for example: create a directory user_data/data/binance and copy or create the pairs.json file in that directory. update the pairs.json file to contain the currency pairs you are interested in. bash mkdir -p user_data/data/binance touch user_data/data/binance/pairs.json The format of the pairs.json file is a simple json list. Mixing different stake-currencies is allowed for this file, since it's only used for downloading. json [ \"ETH/BTC\", \"ETH/USDT\", \"BTC/USDT\", \"XRP/ETH\" ] Downloading all data for one quote currency Often, you'll want to download data for all pairs of a specific quote-currency. In such cases, you can use the following shorthand: freqtrade download-data --exchange binance --pairs .*/USDT <...> . The provided \"pairs\" string will be expanded to contain all active pairs on the exchange. To also download data for inactive (delisted) pairs, add --include-inactive-pairs to the command. Permission denied errors If your configuration directory user_data was made by docker, you may get the following error: cp: cannot create regular file 'user_data/data/binance/pairs.json': Permission denied You can fix the permissions of your user-data directory as follows: sudo chown -R $UID:$GID user_data Start download \u00b6 Then run: bash freqtrade download-data --exchange binance This will download historical candle (OHLCV) data for all the currency pairs you defined in pairs.json . Alternatively, specify the pairs directly bash freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT or as regex (to download all active USDT pairs) bash freqtrade download-data --exchange binance --pairs .*/USDT Other Notes \u00b6 To use a different directory than the exchange specific default, use --datadir user_data/data/some_directory . To change the exchange used to download the historical data from, please use a different configuration file (you'll probably need to adjust rate limits etc.) To use pairs.json from some other directory, use --pairs-file some_other_dir/pairs.json . To download historical candle (OHLCV) data for only 10 days, use --days 10 (defaults to 30 days). To download historical candle (OHLCV) data from a fixed starting point, use --timerange 20200101- - which will download all data from January 1 st , 2020. Eventually set end dates are ignored. Use --timeframes to specify what timeframe download the historical candle (OHLCV) data for. Default is --timeframes 1m 5m which will download 1-minute and 5-minute data. To use exchange, timeframe and list of pairs as defined in your configuration file, use the -c/--config option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine -c/--config with most other options. Data format \u00b6 Freqtrade currently supports 3 data-formats for both OHLCV and trades data: json (plain \"text\" json files) jsongz (a gzip-zipped version of json files) hdf5 (a high performance datastore) By default, OHLCV data is stored as json data, while trades data is stored as jsongz data. This can be changed via the --data-format-ohlcv and --data-format-trades command line arguments respectively. To persist this change, you can should also add the following snippet to your configuration, so you don't have to insert the above arguments each time: jsonc // ... \"dataformat_ohlcv\": \"hdf5\", \"dataformat_trades\": \"hdf5\", // ... If the default data-format has been changed during download, then the keys dataformat_ohlcv and dataformat_trades in the configuration file need to be adjusted to the selected dataformat as well. Note You can convert between data-formats using the convert-data and convert-trade-data methods. Sub-command convert data \u00b6 ``` usage: freqtrade convert-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example converting data \u00b6 The following command will convert all candle (OHLCV) data available in ~/.freqtrade/data/binance from json to jsongz, saving diskspace in the process. It'll also remove original json data files ( --erase parameter). bash freqtrade convert-data --format-from json --format-to jsongz --datadir ~/.freqtrade/data/binance -t 5m 15m --erase Sub-command convert trade data \u00b6 ``` usage: freqtrade convert-trade-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example converting trades \u00b6 The following command will convert all available trade-data in ~/.freqtrade/data/kraken from jsongz to json. It'll also remove original jsongz data files ( --erase parameter). bash freqtrade convert-trade-data --format-from jsongz --format-to json --datadir ~/.freqtrade/data/kraken --erase Sub-command trades to ohlcv \u00b6 When you need to use --dl-trades (kraken only) to download data, conversion of trades data to ohlcv data is the last step. This command will allow you to repeat this last step for additional timeframes without re-downloading the data. ``` usage: freqtrade trades-to-ohlcv [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: jsongz ). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example trade-to-ohlcv conversion \u00b6 bash freqtrade trades-to-ohlcv --exchange kraken -t 5m 1h 1d --pairs BTC/EUR ETH/EUR Sub-command list-data \u00b6 You can get a list of downloaded data using the list-data sub-command. ``` usage: freqtrade list-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [-p PAIRS [PAIRS ...]] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example list-data \u00b6 ```bash freqtrade list-data --userdir ~/.freqtrade/user_data/ Found 33 pair / timeframe combinations. pairs timeframe ADA/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ADA/ETH 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/USDT 5m, 15m, 30m, 1h, 2h, 4h ``` Trades (tick) data \u00b6 By default, download-data sub-command downloads Candles (OHLCV) data. Some exchanges also provide historic trade-data via their API. This data can be useful if you need many different timeframes, since it is only downloaded once, and then resampled locally to the desired timeframes. Since this data is large by default, the files use gzip by default. They are stored in your data-directory with the naming convention of <pair>-trades.json.gz ( ETH_BTC-trades.json.gz ). Incremental mode is also supported, as for historic OHLCV data, so downloading the data once per week with --days 8 will create an incremental data-repository. To use this mode, simply add --dl-trades to your call. This will swap the download method to download trades, and resamples the data locally. do not use You should not use this unless you're a kraken user. Most other exchanges provide OHLCV data with sufficient history. Example call: bash freqtrade download-data --exchange kraken --pairs XRP/EUR ETH/EUR --days 20 --dl-trades Note While this method uses async calls, it will be slow, since it requires the result of the previous call to generate the next request to the exchange. Warning The historic trades are not available during Freqtrade dry-run and live trade modes because all exchanges tested provide this data with a delay of few 100 candles, so it's not suitable for real-time trading. Kraken user Kraken users should read this before starting to download data. Next step \u00b6 Great, you now have backtest data downloaded, so you can now start backtesting your strategy.","title":"Data Downloading"},{"location":"data-download/#data-downloading","text":"","title":"Data Downloading"},{"location":"data-download/#getting-data-for-backtesting-and-hyperopt","text":"To download data (candles / OHLCV) needed for backtesting and hyperoptimization use the freqtrade download-data command. If no additional parameter is specified, freqtrade will download data for \"1m\" and \"5m\" timeframes for the last 30 days. Exchange and pairs will come from config.json (if specified using -c/--config ). Otherwise --exchange becomes mandatory. You can use a relative timerange ( --days 20 ) or an absolute starting point ( --timerange 20200101- ). For incremental downloads, the relative approach should be used. Tip: Updating existing data If you already have backtesting data available in your data-directory and would like to refresh this data up to today, freqtrade will automatically calculate the data missing for the existing pairs and the download will occur from the latest available point until \"now\", neither --days or --timerange parameters are required. Freqtrade will keep the available data and only download the missing data. If you are updating existing data after inserting new pairs that you have no data for, use --new-pairs-days xx parameter. Specified number of days will be downloaded for new pairs while old pairs will be updated with missing data only. If you use --days xx parameter alone - data for specified number of days will be downloaded for all pairs. Be careful, if specified number of days is smaller than gap between now and last downloaded candle - freqtrade will delete all existing data to avoid gaps in candle data.","title":"Getting data for backtesting and hyperopt"},{"location":"data-download/#usage","text":"``` usage: freqtrade download-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [--pairs-file FILE] [--days INT] [--new-pairs-days INT] [--include-inactive-pairs] [--timerange TIMERANGE] [--dl-trades] [--exchange EXCHANGE] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--erase] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --pairs-file FILE File containing a list of pairs to download. --days INT Download data for given number of days. --new-pairs-days INT Download data of new pairs for given number of days. Default: None . --include-inactive-pairs Also download data from inactive pairs. --timerange TIMERANGE Specify what timerange of data to use. --dl-trades Download trades instead of OHLCV data. The bot will resample trades to the desired timeframe as specified as --timeframes/-t. --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . --erase Clean all existing data for the selected exchange/pairs/timeframes. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: jsongz ). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Startup period download-data is a strategy-independent command. The idea is to download a big chunk of data once, and then iteratively increase the amount of data stored. For that reason, download-data does not care about the \"startup-period\" defined in a strategy. It's up to the user to download additional days if the backtest should start at a specific point in time (while respecting startup period).","title":"Usage"},{"location":"data-download/#pairs-file","text":"In alternative to the whitelist from config.json , a pairs.json file can be used. If you are using Binance for example: create a directory user_data/data/binance and copy or create the pairs.json file in that directory. update the pairs.json file to contain the currency pairs you are interested in. bash mkdir -p user_data/data/binance touch user_data/data/binance/pairs.json The format of the pairs.json file is a simple json list. Mixing different stake-currencies is allowed for this file, since it's only used for downloading. json [ \"ETH/BTC\", \"ETH/USDT\", \"BTC/USDT\", \"XRP/ETH\" ] Downloading all data for one quote currency Often, you'll want to download data for all pairs of a specific quote-currency. In such cases, you can use the following shorthand: freqtrade download-data --exchange binance --pairs .*/USDT <...> . The provided \"pairs\" string will be expanded to contain all active pairs on the exchange. To also download data for inactive (delisted) pairs, add --include-inactive-pairs to the command. Permission denied errors If your configuration directory user_data was made by docker, you may get the following error: cp: cannot create regular file 'user_data/data/binance/pairs.json': Permission denied You can fix the permissions of your user-data directory as follows: sudo chown -R $UID:$GID user_data","title":"Pairs file"},{"location":"data-download/#start-download","text":"Then run: bash freqtrade download-data --exchange binance This will download historical candle (OHLCV) data for all the currency pairs you defined in pairs.json . Alternatively, specify the pairs directly bash freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT or as regex (to download all active USDT pairs) bash freqtrade download-data --exchange binance --pairs .*/USDT","title":"Start download"},{"location":"data-download/#other-notes","text":"To use a different directory than the exchange specific default, use --datadir user_data/data/some_directory . To change the exchange used to download the historical data from, please use a different configuration file (you'll probably need to adjust rate limits etc.) To use pairs.json from some other directory, use --pairs-file some_other_dir/pairs.json . To download historical candle (OHLCV) data for only 10 days, use --days 10 (defaults to 30 days). To download historical candle (OHLCV) data from a fixed starting point, use --timerange 20200101- - which will download all data from January 1 st , 2020. Eventually set end dates are ignored. Use --timeframes to specify what timeframe download the historical candle (OHLCV) data for. Default is --timeframes 1m 5m which will download 1-minute and 5-minute data. To use exchange, timeframe and list of pairs as defined in your configuration file, use the -c/--config option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine -c/--config with most other options.","title":"Other Notes"},{"location":"data-download/#data-format","text":"Freqtrade currently supports 3 data-formats for both OHLCV and trades data: json (plain \"text\" json files) jsongz (a gzip-zipped version of json files) hdf5 (a high performance datastore) By default, OHLCV data is stored as json data, while trades data is stored as jsongz data. This can be changed via the --data-format-ohlcv and --data-format-trades command line arguments respectively. To persist this change, you can should also add the following snippet to your configuration, so you don't have to insert the above arguments each time: jsonc // ... \"dataformat_ohlcv\": \"hdf5\", \"dataformat_trades\": \"hdf5\", // ... If the default data-format has been changed during download, then the keys dataformat_ohlcv and dataformat_trades in the configuration file need to be adjusted to the selected dataformat as well. Note You can convert between data-formats using the convert-data and convert-trade-data methods.","title":"Data format"},{"location":"data-download/#sub-command-convert-data","text":"``` usage: freqtrade convert-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Sub-command convert data"},{"location":"data-download/#example-converting-data","text":"The following command will convert all candle (OHLCV) data available in ~/.freqtrade/data/binance from json to jsongz, saving diskspace in the process. It'll also remove original json data files ( --erase parameter). bash freqtrade convert-data --format-from json --format-to jsongz --datadir ~/.freqtrade/data/binance -t 5m 15m --erase","title":"Example converting data"},{"location":"data-download/#sub-command-convert-trade-data","text":"``` usage: freqtrade convert-trade-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Sub-command convert trade data"},{"location":"data-download/#example-converting-trades","text":"The following command will convert all available trade-data in ~/.freqtrade/data/kraken from jsongz to json. It'll also remove original jsongz data files ( --erase parameter). bash freqtrade convert-trade-data --format-from jsongz --format-to json --datadir ~/.freqtrade/data/kraken --erase","title":"Example converting trades"},{"location":"data-download/#sub-command-trades-to-ohlcv","text":"When you need to use --dl-trades (kraken only) to download data, conversion of trades data to ohlcv data is the last step. This command will allow you to repeat this last step for additional timeframes without re-downloading the data. ``` usage: freqtrade trades-to-ohlcv [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: 1m 5m . --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: jsongz ). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Sub-command trades to ohlcv"},{"location":"data-download/#example-trade-to-ohlcv-conversion","text":"bash freqtrade trades-to-ohlcv --exchange kraken -t 5m 1h 1d --pairs BTC/EUR ETH/EUR","title":"Example trade-to-ohlcv conversion"},{"location":"data-download/#sub-command-list-data","text":"You can get a list of downloaded data using the list-data sub-command. ``` usage: freqtrade list-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [-p PAIRS [PAIRS ...]] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Sub-command list-data"},{"location":"data-download/#example-list-data","text":"```bash freqtrade list-data --userdir ~/.freqtrade/user_data/ Found 33 pair / timeframe combinations. pairs timeframe ADA/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ADA/ETH 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/USDT 5m, 15m, 30m, 1h, 2h, 4h ```","title":"Example list-data"},{"location":"data-download/#trades-tick-data","text":"By default, download-data sub-command downloads Candles (OHLCV) data. Some exchanges also provide historic trade-data via their API. This data can be useful if you need many different timeframes, since it is only downloaded once, and then resampled locally to the desired timeframes. Since this data is large by default, the files use gzip by default. They are stored in your data-directory with the naming convention of <pair>-trades.json.gz ( ETH_BTC-trades.json.gz ). Incremental mode is also supported, as for historic OHLCV data, so downloading the data once per week with --days 8 will create an incremental data-repository. To use this mode, simply add --dl-trades to your call. This will swap the download method to download trades, and resamples the data locally. do not use You should not use this unless you're a kraken user. Most other exchanges provide OHLCV data with sufficient history. Example call: bash freqtrade download-data --exchange kraken --pairs XRP/EUR ETH/EUR --days 20 --dl-trades Note While this method uses async calls, it will be slow, since it requires the result of the previous call to generate the next request to the exchange. Warning The historic trades are not available during Freqtrade dry-run and live trade modes because all exchanges tested provide this data with a delay of few 100 candles, so it's not suitable for real-time trading. Kraken user Kraken users should read this before starting to download data.","title":"Trades (tick) data"},{"location":"data-download/#next-step","text":"Great, you now have backtest data downloaded, so you can now start backtesting your strategy.","title":"Next step"},{"location":"deprecated/","text":"Deprecated features \u00b6 This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration. Removed features \u00b6 the --refresh-pairs-cached command line option \u00b6 --refresh-pairs-cached in the context of backtesting, hyperopt and edge allows to refresh candle data for backtesting. Since this leads to much confusion, and slows down backtesting (while not being part of backtesting) this has been singled out as a separate freqtrade sub-command freqtrade download-data . This command line option was deprecated in 2019.7-dev (develop branch) and removed in 2019.9. The --dynamic-whitelist command line option \u00b6 This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7. Please refer to pairlists instead. the --live command line option \u00b6 --live in the context of backtesting allowed to download the latest tick data for backtesting. Did only download the latest 500 candles, so was ineffective in getting good backtest data. Removed in 2019-7-dev (develop branch) and in freqtrade 2019.8. ticker_interval (now timeframe ) \u00b6 Support for ticker_interval terminology was deprecated in 2020.6 in favor of timeframe - and compatibility code was removed in 2022.3. Allow running multiple pairlists in sequence \u00b6 The former \"pairlist\" section in the configuration has been removed, and is replaced by \"pairlists\" - being a list to specify a sequence of pairlists. The old section of configuration parameters ( \"pairlist\" ) has been deprecated in 2019.11 and has been removed in 2020.4. deprecation of bidVolume and askVolume from volume-pairlist \u00b6 Since only quoteVolume can be compared between assets, the other options (bidVolume, askVolume) have been deprecated in 2020.4, and have been removed in 2020.9. Using order book steps for sell price \u00b6 Using order_book_min and order_book_max used to allow stepping the orderbook and trying to find the next ROI slot - trying to place sell-orders early. As this does however increase risk and provides no benefit, it's been removed for maintainability purposes in 2021.7. Legacy Hyperopt mode \u00b6 Using separate hyperopt files was deprecated in 2021.4 and was removed in 2021.9. Please switch to the new Parametrized Strategies to benefit from the new hyperopt interface.","title":"Deprecated Features"},{"location":"deprecated/#deprecated-features","text":"This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration.","title":"Deprecated features"},{"location":"deprecated/#removed-features","text":"","title":"Removed features"},{"location":"deprecated/#the-refresh-pairs-cached-command-line-option","text":"--refresh-pairs-cached in the context of backtesting, hyperopt and edge allows to refresh candle data for backtesting. Since this leads to much confusion, and slows down backtesting (while not being part of backtesting) this has been singled out as a separate freqtrade sub-command freqtrade download-data . This command line option was deprecated in 2019.7-dev (develop branch) and removed in 2019.9.","title":"the --refresh-pairs-cached command line option"},{"location":"deprecated/#the-dynamic-whitelist-command-line-option","text":"This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7. Please refer to pairlists instead.","title":"The --dynamic-whitelist command line option"},{"location":"deprecated/#the-live-command-line-option","text":"--live in the context of backtesting allowed to download the latest tick data for backtesting. Did only download the latest 500 candles, so was ineffective in getting good backtest data. Removed in 2019-7-dev (develop branch) and in freqtrade 2019.8.","title":"the --live command line option"},{"location":"deprecated/#ticker_interval-now-timeframe","text":"Support for ticker_interval terminology was deprecated in 2020.6 in favor of timeframe - and compatibility code was removed in 2022.3.","title":"ticker_interval (now timeframe)"},{"location":"deprecated/#allow-running-multiple-pairlists-in-sequence","text":"The former \"pairlist\" section in the configuration has been removed, and is replaced by \"pairlists\" - being a list to specify a sequence of pairlists. The old section of configuration parameters ( \"pairlist\" ) has been deprecated in 2019.11 and has been removed in 2020.4.","title":"Allow running multiple pairlists in sequence"},{"location":"deprecated/#deprecation-of-bidvolume-and-askvolume-from-volume-pairlist","text":"Since only quoteVolume can be compared between assets, the other options (bidVolume, askVolume) have been deprecated in 2020.4, and have been removed in 2020.9.","title":"deprecation of bidVolume and askVolume from volume-pairlist"},{"location":"deprecated/#using-order-book-steps-for-sell-price","text":"Using order_book_min and order_book_max used to allow stepping the orderbook and trying to find the next ROI slot - trying to place sell-orders early. As this does however increase risk and provides no benefit, it's been removed for maintainability purposes in 2021.7.","title":"Using order book steps for sell price"},{"location":"deprecated/#legacy-hyperopt-mode","text":"Using separate hyperopt files was deprecated in 2021.4 and was removed in 2021.9. Please switch to the new Parametrized Strategies to benefit from the new hyperopt interface.","title":"Legacy Hyperopt mode"},{"location":"developer/","text":"Development Help \u00b6 This page is intended for developers of Freqtrade, people who want to contribute to the Freqtrade codebase or documentation, or people who want to understand the source code of the application they're running. All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel on discord where you can ask questions. Documentation \u00b6 Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR. Special fields for the documentation (like Note boxes, ...) can be found here . To test the documentation locally use the following commands. bash pip install -r docs/requirements-docs.txt mkdocs serve This will spin up a local server (usually on port 8000) so you can see if everything looks as you'd like it to. Developer setup \u00b6 To configure a development environment, you can either use the provided DevContainer , or use the setup.sh script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (e.g. if your system is not supported by the setup.sh script), follow the manual installation process and run pip3 install -e .[all] . This will install all required tools for development, including pytest , flake8 , mypy , and coveralls . Before opening a pull request, please familiarize yourself with our Contributing Guidelines . Devcontainer setup \u00b6 The fastest and easiest way to get started is to use VSCode with the Remote container extension. This gives developers the ability to start the bot with all required dependencies without needing to install any freqtrade specific dependencies on your local machine. Devcontainer dependencies \u00b6 VSCode docker Remote container extension documentation For more information about the Remote container extension , best consult the documentation. Tests \u00b6 New code should be covered by basic unittests. Depending on the complexity of the feature, Reviewers may request more in-depth unittests. If necessary, the Freqtrade team can assist and give guidance with writing good tests (however please don't expect anyone to write the tests for you). Checking log content in tests \u00b6 Freqtrade uses 2 main methods to check log content in tests, log_has() and log_has_re() (to check using regex, in case of dynamic log-messages). These are available from conftest.py and can be imported in any test module. A sample check looks as follows: ``` python from tests.conftest import log_has, log_has_re def test_method_to_test(caplog): method_to_test() assert log_has(\"This event happened\", caplog) # Check regex with trailing number ... assert log_has_re(r\"This dynamic event happened and produced \\d+\", caplog) ``` ErrorHandling \u00b6 Freqtrade Exceptions all inherit from FreqtradeException . This general class of error should however not be used directly. Instead, multiple specialized sub-Exceptions exist. Below is an outline of exception inheritance hierarchy: + FreqtradeException | +---+ OperationalException | +---+ DependencyException | | | +---+ PricingError | | | +---+ ExchangeError | | | +---+ TemporaryError | | | +---+ DDosProtection | | | +---+ InvalidOrderException | | | +---+ RetryableOrderError | | | +---+ InsufficientFundsError | +---+ StrategyError Plugins \u00b6 Pairlists \u00b6 You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream. Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist Handler. First of all, have a look at the VolumePairList Handler, and best copy this file with a name of your new Pairlist Handler. This is a simple Handler, which however serves as a good example on how to start developing. Next, modify the class-name of the Handler (ideally align this with the module filename). The base-class provides an instance of the exchange ( self._exchange ) the pairlist manager ( self._pairlistmanager ), as well as the main configuration ( self._config ), the pairlist dedicated configuration ( self._pairlistconfig ) and the absolute position within the list of pairlists. python self._exchange = exchange self._pairlistmanager = pairlistmanager self._config = config self._pairlistconfig = pairlistconfig self._pairlist_pos = pairlist_pos Tip Don't forget to register your pairlist in constants.py under the variable AVAILABLE_PAIRLISTS - otherwise it will not be selectable. Now, let's step through the methods which require actions: Pairlist configuration \u00b6 Configuration for the chain of Pairlist Handlers is done in the bot configuration file in the element \"pairlists\" , an array of configuration parameters for each Pairlist Handlers in the chain. By convention, \"number_assets\" is used to specify the maximum number of pairs to keep in the pairlist. Please follow this to ensure a consistent user experience. Additional parameters can be configured as needed. For instance, VolumePairList uses \"sort_key\" to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successful and dynamic. short_desc \u00b6 Returns a description used for Telegram messages. This should contain the name of the Pairlist Handler, as well as a short description containing the number of assets. Please follow the format \"PairlistName - top/bottom X pairs\" . gen_pairlist \u00b6 Override this method if the Pairlist Handler can be used as the leading Pairlist Handler in the chain, defining the initial pairlist which is then handled by all Pairlist Handlers in the chain. Examples are StaticPairList and VolumePairList . This is called with each iteration of the bot (only if the Pairlist Handler is at the first location) - so consider implementing caching for compute/network heavy calculations. It must return the resulting pairlist (which may then be passed into the chain of Pairlist Handlers). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filtering. Use this if you limit your result to a certain number of pairs - so the end-result is not shorter than expected. filter_pairlist \u00b6 This method is called for each Pairlist Handler in the chain by the pairlist manager. This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations. It gets passed a pairlist (which can be the result of previous pairlists) as well as tickers , a pre-fetched version of get_tickers() . The default implementation in the base class simply calls the _validate_pair() method for each pair in the pairlist, but you may override it. So you should either implement the _validate_pair() in your Pairlist Handler or override filter_pairlist() to do something else. If overridden, it must return the resulting pairlist (which may then be passed into the next Pairlist Handler in the chain). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filters. Use this if you limit your result to a certain number of pairs - so the end result is not shorter than expected. In VolumePairList , this implements different methods of sorting, does early validation so only the expected number of pairs is returned. sample \u00b6 python def filter_pairlist(self, pairlist: List[str], tickers: Dict) -> List[str]: # Generate dynamic whitelist pairs = self._calculate_pairlist(pairlist, tickers) return pairs Protections \u00b6 Best read the Protection documentation to understand protections. This Guide is directed towards Developers who want to develop a new protection. No protection should use datetime directly, but use the provided date_now variable for date calculations. This preserves the ability to backtest protections. Writing a new Protection Best copy one of the existing Protections to have a good example. Don't forget to register your protection in constants.py under the variable AVAILABLE_PROTECTIONS - otherwise it will not be selectable. Implementation of a new protection \u00b6 All Protection implementations must have IProtection as parent class. For that reason, they must implement the following methods: short_desc() global_stop() stop_per_pair() . global_stop() and stop_per_pair() must return a ProtectionReturn tuple, which consists of: lock pair - boolean lock until - datetime - until when should the pair be locked (will be rounded up to the next new candle) reason - string, used for logging and storage in the database The until portion should be calculated using the provided calculate_lock_end() method. All Protections should use \"stop_duration\" / \"stop_duration_candles\" to define how long a a pair (or all pairs) should be locked. The content of this is made available as self._stop_duration to the each Protection. If your protection requires a look-back period, please use \"lookback_period\" / \"lockback_period_candles\" to keep all protections aligned. Global vs. local stops \u00b6 Protections can have 2 different ways to stop trading for a limited : Per pair (local) For all Pairs (globally) Protections - per pair \u00b6 Protections that implement the per pair approach must set has_local_stop=True . The method stop_per_pair() will be called whenever a trade closed (sell order completed). Protections - global protection \u00b6 These Protections should do their evaluation across all pairs, and consequently will also lock all pairs from trading (called a global PairLock). Global protection must set has_global_stop=True to be evaluated for global stops. The method global_stop() will be called whenever a trade closed (sell order completed). Protections - calculating lock end time \u00b6 Protections should calculate the lock end time based on the last trade it considers. This avoids re-locking should the lookback-period be longer than the actual lock period. The IProtection parent class provides a helper method for this in calculate_lock_end() . Implement a new Exchange (WIP) \u00b6 Note This section is a Work in Progress and is not a complete guide on how to test a new exchange with Freqtrade. Note Make sure to use an up-to-date version of CCXT before running any of the below tests. You can get the latest version of ccxt by running pip install -U ccxt with activated virtual environment. Native docker is not supported for these tests, however the available dev-container will support all required actions and eventually necessary changes. Most exchanges supported by CCXT should work out of the box. To quickly test the public endpoints of an exchange, add a configuration for your exchange to test_ccxt_compat.py and run these tests with pytest --longrun tests/exchange/test_ccxt_compat.py . Completing these tests successfully a good basis point (it's a requirement, actually), however these won't guarantee correct exchange functioning, as this only tests public endpoints, but no private endpoint (like generate order or similar). Also try to use freqtrade download-data for an extended timerange (multiple months) and verify that the data downloaded correctly (no holes, the specified timerange was actually downloaded). These are prerequisites to have an exchange listed as either Supported or Community tested (listed on the homepage). The below are \"extras\", which will make an exchange better (feature-complete) - but are not absolutely necessary for either of the 2 categories. Additional tests / steps to complete: Verify data provided by fetch_ohlcv() - and eventually adjust ohlcv_candle_limit for this exchange Check L2 orderbook limit range (API documentation) - and eventually set as necessary Check if balance shows correctly (*) Create market order (*) Create limit order (*) Complete trade (buy + sell) (*) Compare result calculation between exchange and bot Ensure fees are applied correctly (check the database against the exchange) (*) Requires API keys and Balance on the exchange. Stoploss On Exchange \u00b6 Check if the new exchange supports Stoploss on Exchange orders through their API. Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselves. Best look at binance.py for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects. Incomplete candles \u00b6 While fetching candle (OHLCV) data, we may end up getting incomplete candles (depending on the exchange). To demonstrate this, we'll use daily candles ( \"1d\" ) to keep things simple. We query the api ( ct.fetch_ohlcv() ) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete. To check how the new exchange behaves, you can use the following snippet: ``` python import ccxt from datetime import datetime from freqtrade.data.converter import ohlcv_to_dataframe ct = ccxt.binance() timeframe = \"1d\" pair = \"XLM/BTC\" # Make sure to use a pair that exists on that exchange! raw = ct.fetch_ohlcv(pair, timeframe=timeframe) convert to dataframe \u00b6 df1 = ohlcv_to_dataframe(raw, timeframe, pair=pair, drop_incomplete=False) print(df1.tail(1)) print(datetime.utcnow()) ``` output date open high low close volume 499 2019-06-08 00:00:00+00:00 0.000007 0.000007 0.000007 0.000007 26264344.0 2019-06-09 12:30:27.873327 The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting \"ohlcv_partial_candle\" from the exchange-class untouched / True). Otherwise, set \"ohlcv_partial_candle\" to False to not drop Candles (shown in the example above). Another way is to run this command multiple times in a row and observe if the volume is changing (while the date remains the same). Updating example notebooks \u00b6 To keep the jupyter notebooks aligned with the documentation, the following should be ran after updating a example notebook. bash jupyter nbconvert --ClearOutputPreprocessor.enabled=True --inplace freqtrade/templates/strategy_analysis_example.ipynb jupyter nbconvert --ClearOutputPreprocessor.enabled=True --to markdown freqtrade/templates/strategy_analysis_example.ipynb --stdout > docs/strategy_analysis_example.md Continuous integration \u00b6 This documents some decisions taken for the CI Pipeline. CI runs on all OS variants, Linux (ubuntu), macOS and Windows. Docker images are build for the branches stable and develop , and are built as multiarch builds, supporting multiple platforms via the same tag. Docker images containing Plot dependencies are also available as stable_plot and develop_plot . Docker images contain a file, /freqtrade/freqtrade_commit containing the commit this image is based of. Full docker image rebuilds are run once a week via schedule. Deployments run on ubuntu. ta-lib binaries are contained in the build_helpers directory to avoid fails related to external unavailability. All tests must pass for a PR to be merged to stable or develop . Creating a release \u00b6 This part of the documentation is aimed at maintainers, and shows how to create a release. Create release branch \u00b6 First, pick a commit that's about one week old (to not include latest additions to releases). ``` bash create new branch \u00b6 git checkout -b new_release ``` Determine if crucial bugfixes have been made between this commit and the current state, and eventually cherry-pick these. Merge the release branch (stable) into this branch. Edit freqtrade/__init__.py and add the version matching the current date (for example 2019.7 for July 2019). Minor versions can be 2019.7.1 should we need to do a second release that month. Version numbers must follow allowed versions from PEP0440 to avoid failures pushing to pypi. Commit this part push that branch to the remote and create a PR against the stable branch Create changelog from git commits \u00b6 Note Make sure that the stable branch is up-to-date! ``` bash Needs to be done before merging / pulling that branch. \u00b6 git log --oneline --no-decorate --no-merges stable..new_release ``` To keep the release-log short, best wrap the full git changelog into a collapsible details section. ```markdown Expand full changelog ... Full git changelog ``` Create github release / tag \u00b6 Once the PR against stable is merged (best right after merging): Use the button \"Draft a new release\" in the Github UI (subsection releases). Use the version-number specified as tag. Use \"stable\" as reference (this step comes after the above PR is merged). Use the above changelog as release comment (as codeblock) Releases \u00b6 pypi \u00b6 Note This process is now automated as part of Github Actions. To create a pypi release, please run the following commands: Additional requirement: wheel , twine (for uploading), account on pypi with proper permissions. ``` bash python setup.py sdist bdist_wheel For pypi test (to check if some change to the installation did work) \u00b6 twine upload --repository-url https://test.pypi.org/legacy/ dist/* For production: \u00b6 twine upload dist/* ``` Please don't push non-releases to the productive / real pypi instance.","title":"Contributors Guide"},{"location":"developer/#development-help","text":"This page is intended for developers of Freqtrade, people who want to contribute to the Freqtrade codebase or documentation, or people who want to understand the source code of the application they're running. All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel on discord where you can ask questions.","title":"Development Help"},{"location":"developer/#documentation","text":"Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR. Special fields for the documentation (like Note boxes, ...) can be found here . To test the documentation locally use the following commands. bash pip install -r docs/requirements-docs.txt mkdocs serve This will spin up a local server (usually on port 8000) so you can see if everything looks as you'd like it to.","title":"Documentation"},{"location":"developer/#developer-setup","text":"To configure a development environment, you can either use the provided DevContainer , or use the setup.sh script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (e.g. if your system is not supported by the setup.sh script), follow the manual installation process and run pip3 install -e .[all] . This will install all required tools for development, including pytest , flake8 , mypy , and coveralls . Before opening a pull request, please familiarize yourself with our Contributing Guidelines .","title":"Developer setup"},{"location":"developer/#devcontainer-setup","text":"The fastest and easiest way to get started is to use VSCode with the Remote container extension. This gives developers the ability to start the bot with all required dependencies without needing to install any freqtrade specific dependencies on your local machine.","title":"Devcontainer setup"},{"location":"developer/#devcontainer-dependencies","text":"VSCode docker Remote container extension documentation For more information about the Remote container extension , best consult the documentation.","title":"Devcontainer dependencies"},{"location":"developer/#tests","text":"New code should be covered by basic unittests. Depending on the complexity of the feature, Reviewers may request more in-depth unittests. If necessary, the Freqtrade team can assist and give guidance with writing good tests (however please don't expect anyone to write the tests for you).","title":"Tests"},{"location":"developer/#checking-log-content-in-tests","text":"Freqtrade uses 2 main methods to check log content in tests, log_has() and log_has_re() (to check using regex, in case of dynamic log-messages). These are available from conftest.py and can be imported in any test module. A sample check looks as follows: ``` python from tests.conftest import log_has, log_has_re def test_method_to_test(caplog): method_to_test() assert log_has(\"This event happened\", caplog) # Check regex with trailing number ... assert log_has_re(r\"This dynamic event happened and produced \\d+\", caplog) ```","title":"Checking log content in tests"},{"location":"developer/#errorhandling","text":"Freqtrade Exceptions all inherit from FreqtradeException . This general class of error should however not be used directly. Instead, multiple specialized sub-Exceptions exist. Below is an outline of exception inheritance hierarchy: + FreqtradeException | +---+ OperationalException | +---+ DependencyException | | | +---+ PricingError | | | +---+ ExchangeError | | | +---+ TemporaryError | | | +---+ DDosProtection | | | +---+ InvalidOrderException | | | +---+ RetryableOrderError | | | +---+ InsufficientFundsError | +---+ StrategyError","title":"ErrorHandling"},{"location":"developer/#plugins","text":"","title":"Plugins"},{"location":"developer/#pairlists","text":"You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream. Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist Handler. First of all, have a look at the VolumePairList Handler, and best copy this file with a name of your new Pairlist Handler. This is a simple Handler, which however serves as a good example on how to start developing. Next, modify the class-name of the Handler (ideally align this with the module filename). The base-class provides an instance of the exchange ( self._exchange ) the pairlist manager ( self._pairlistmanager ), as well as the main configuration ( self._config ), the pairlist dedicated configuration ( self._pairlistconfig ) and the absolute position within the list of pairlists. python self._exchange = exchange self._pairlistmanager = pairlistmanager self._config = config self._pairlistconfig = pairlistconfig self._pairlist_pos = pairlist_pos Tip Don't forget to register your pairlist in constants.py under the variable AVAILABLE_PAIRLISTS - otherwise it will not be selectable. Now, let's step through the methods which require actions:","title":"Pairlists"},{"location":"developer/#pairlist-configuration","text":"Configuration for the chain of Pairlist Handlers is done in the bot configuration file in the element \"pairlists\" , an array of configuration parameters for each Pairlist Handlers in the chain. By convention, \"number_assets\" is used to specify the maximum number of pairs to keep in the pairlist. Please follow this to ensure a consistent user experience. Additional parameters can be configured as needed. For instance, VolumePairList uses \"sort_key\" to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successful and dynamic.","title":"Pairlist configuration"},{"location":"developer/#short_desc","text":"Returns a description used for Telegram messages. This should contain the name of the Pairlist Handler, as well as a short description containing the number of assets. Please follow the format \"PairlistName - top/bottom X pairs\" .","title":"short_desc"},{"location":"developer/#gen_pairlist","text":"Override this method if the Pairlist Handler can be used as the leading Pairlist Handler in the chain, defining the initial pairlist which is then handled by all Pairlist Handlers in the chain. Examples are StaticPairList and VolumePairList . This is called with each iteration of the bot (only if the Pairlist Handler is at the first location) - so consider implementing caching for compute/network heavy calculations. It must return the resulting pairlist (which may then be passed into the chain of Pairlist Handlers). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filtering. Use this if you limit your result to a certain number of pairs - so the end-result is not shorter than expected.","title":"gen_pairlist"},{"location":"developer/#filter_pairlist","text":"This method is called for each Pairlist Handler in the chain by the pairlist manager. This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations. It gets passed a pairlist (which can be the result of previous pairlists) as well as tickers , a pre-fetched version of get_tickers() . The default implementation in the base class simply calls the _validate_pair() method for each pair in the pairlist, but you may override it. So you should either implement the _validate_pair() in your Pairlist Handler or override filter_pairlist() to do something else. If overridden, it must return the resulting pairlist (which may then be passed into the next Pairlist Handler in the chain). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filters. Use this if you limit your result to a certain number of pairs - so the end result is not shorter than expected. In VolumePairList , this implements different methods of sorting, does early validation so only the expected number of pairs is returned.","title":"filter_pairlist"},{"location":"developer/#sample","text":"python def filter_pairlist(self, pairlist: List[str], tickers: Dict) -> List[str]: # Generate dynamic whitelist pairs = self._calculate_pairlist(pairlist, tickers) return pairs","title":"sample"},{"location":"developer/#protections","text":"Best read the Protection documentation to understand protections. This Guide is directed towards Developers who want to develop a new protection. No protection should use datetime directly, but use the provided date_now variable for date calculations. This preserves the ability to backtest protections. Writing a new Protection Best copy one of the existing Protections to have a good example. Don't forget to register your protection in constants.py under the variable AVAILABLE_PROTECTIONS - otherwise it will not be selectable.","title":"Protections"},{"location":"developer/#implementation-of-a-new-protection","text":"All Protection implementations must have IProtection as parent class. For that reason, they must implement the following methods: short_desc() global_stop() stop_per_pair() . global_stop() and stop_per_pair() must return a ProtectionReturn tuple, which consists of: lock pair - boolean lock until - datetime - until when should the pair be locked (will be rounded up to the next new candle) reason - string, used for logging and storage in the database The until portion should be calculated using the provided calculate_lock_end() method. All Protections should use \"stop_duration\" / \"stop_duration_candles\" to define how long a a pair (or all pairs) should be locked. The content of this is made available as self._stop_duration to the each Protection. If your protection requires a look-back period, please use \"lookback_period\" / \"lockback_period_candles\" to keep all protections aligned.","title":"Implementation of a new protection"},{"location":"developer/#global-vs-local-stops","text":"Protections can have 2 different ways to stop trading for a limited : Per pair (local) For all Pairs (globally)","title":"Global vs. local stops"},{"location":"developer/#protections-per-pair","text":"Protections that implement the per pair approach must set has_local_stop=True . The method stop_per_pair() will be called whenever a trade closed (sell order completed).","title":"Protections - per pair"},{"location":"developer/#protections-global-protection","text":"These Protections should do their evaluation across all pairs, and consequently will also lock all pairs from trading (called a global PairLock). Global protection must set has_global_stop=True to be evaluated for global stops. The method global_stop() will be called whenever a trade closed (sell order completed).","title":"Protections - global protection"},{"location":"developer/#protections-calculating-lock-end-time","text":"Protections should calculate the lock end time based on the last trade it considers. This avoids re-locking should the lookback-period be longer than the actual lock period. The IProtection parent class provides a helper method for this in calculate_lock_end() .","title":"Protections - calculating lock end time"},{"location":"developer/#implement-a-new-exchange-wip","text":"Note This section is a Work in Progress and is not a complete guide on how to test a new exchange with Freqtrade. Note Make sure to use an up-to-date version of CCXT before running any of the below tests. You can get the latest version of ccxt by running pip install -U ccxt with activated virtual environment. Native docker is not supported for these tests, however the available dev-container will support all required actions and eventually necessary changes. Most exchanges supported by CCXT should work out of the box. To quickly test the public endpoints of an exchange, add a configuration for your exchange to test_ccxt_compat.py and run these tests with pytest --longrun tests/exchange/test_ccxt_compat.py . Completing these tests successfully a good basis point (it's a requirement, actually), however these won't guarantee correct exchange functioning, as this only tests public endpoints, but no private endpoint (like generate order or similar). Also try to use freqtrade download-data for an extended timerange (multiple months) and verify that the data downloaded correctly (no holes, the specified timerange was actually downloaded). These are prerequisites to have an exchange listed as either Supported or Community tested (listed on the homepage). The below are \"extras\", which will make an exchange better (feature-complete) - but are not absolutely necessary for either of the 2 categories. Additional tests / steps to complete: Verify data provided by fetch_ohlcv() - and eventually adjust ohlcv_candle_limit for this exchange Check L2 orderbook limit range (API documentation) - and eventually set as necessary Check if balance shows correctly (*) Create market order (*) Create limit order (*) Complete trade (buy + sell) (*) Compare result calculation between exchange and bot Ensure fees are applied correctly (check the database against the exchange) (*) Requires API keys and Balance on the exchange.","title":"Implement a new Exchange (WIP)"},{"location":"developer/#stoploss-on-exchange","text":"Check if the new exchange supports Stoploss on Exchange orders through their API. Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselves. Best look at binance.py for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects.","title":"Stoploss On Exchange"},{"location":"developer/#incomplete-candles","text":"While fetching candle (OHLCV) data, we may end up getting incomplete candles (depending on the exchange). To demonstrate this, we'll use daily candles ( \"1d\" ) to keep things simple. We query the api ( ct.fetch_ohlcv() ) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete. To check how the new exchange behaves, you can use the following snippet: ``` python import ccxt from datetime import datetime from freqtrade.data.converter import ohlcv_to_dataframe ct = ccxt.binance() timeframe = \"1d\" pair = \"XLM/BTC\" # Make sure to use a pair that exists on that exchange! raw = ct.fetch_ohlcv(pair, timeframe=timeframe)","title":"Incomplete candles"},{"location":"developer/#convert-to-dataframe","text":"df1 = ohlcv_to_dataframe(raw, timeframe, pair=pair, drop_incomplete=False) print(df1.tail(1)) print(datetime.utcnow()) ``` output date open high low close volume 499 2019-06-08 00:00:00+00:00 0.000007 0.000007 0.000007 0.000007 26264344.0 2019-06-09 12:30:27.873327 The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting \"ohlcv_partial_candle\" from the exchange-class untouched / True). Otherwise, set \"ohlcv_partial_candle\" to False to not drop Candles (shown in the example above). Another way is to run this command multiple times in a row and observe if the volume is changing (while the date remains the same).","title":"convert to dataframe"},{"location":"developer/#updating-example-notebooks","text":"To keep the jupyter notebooks aligned with the documentation, the following should be ran after updating a example notebook. bash jupyter nbconvert --ClearOutputPreprocessor.enabled=True --inplace freqtrade/templates/strategy_analysis_example.ipynb jupyter nbconvert --ClearOutputPreprocessor.enabled=True --to markdown freqtrade/templates/strategy_analysis_example.ipynb --stdout > docs/strategy_analysis_example.md","title":"Updating example notebooks"},{"location":"developer/#continuous-integration","text":"This documents some decisions taken for the CI Pipeline. CI runs on all OS variants, Linux (ubuntu), macOS and Windows. Docker images are build for the branches stable and develop , and are built as multiarch builds, supporting multiple platforms via the same tag. Docker images containing Plot dependencies are also available as stable_plot and develop_plot . Docker images contain a file, /freqtrade/freqtrade_commit containing the commit this image is based of. Full docker image rebuilds are run once a week via schedule. Deployments run on ubuntu. ta-lib binaries are contained in the build_helpers directory to avoid fails related to external unavailability. All tests must pass for a PR to be merged to stable or develop .","title":"Continuous integration"},{"location":"developer/#creating-a-release","text":"This part of the documentation is aimed at maintainers, and shows how to create a release.","title":"Creating a release"},{"location":"developer/#create-release-branch","text":"First, pick a commit that's about one week old (to not include latest additions to releases). ``` bash","title":"Create release branch"},{"location":"developer/#create-new-branch","text":"git checkout -b new_release ``` Determine if crucial bugfixes have been made between this commit and the current state, and eventually cherry-pick these. Merge the release branch (stable) into this branch. Edit freqtrade/__init__.py and add the version matching the current date (for example 2019.7 for July 2019). Minor versions can be 2019.7.1 should we need to do a second release that month. Version numbers must follow allowed versions from PEP0440 to avoid failures pushing to pypi. Commit this part push that branch to the remote and create a PR against the stable branch","title":"create new branch"},{"location":"developer/#create-changelog-from-git-commits","text":"Note Make sure that the stable branch is up-to-date! ``` bash","title":"Create changelog from git commits"},{"location":"developer/#needs-to-be-done-before-merging-pulling-that-branch","text":"git log --oneline --no-decorate --no-merges stable..new_release ``` To keep the release-log short, best wrap the full git changelog into a collapsible details section. ```markdown Expand full changelog ... Full git changelog ```","title":"Needs to be done before merging / pulling that branch."},{"location":"developer/#create-github-release-tag","text":"Once the PR against stable is merged (best right after merging): Use the button \"Draft a new release\" in the Github UI (subsection releases). Use the version-number specified as tag. Use \"stable\" as reference (this step comes after the above PR is merged). Use the above changelog as release comment (as codeblock)","title":"Create github release / tag"},{"location":"developer/#releases","text":"","title":"Releases"},{"location":"developer/#pypi","text":"Note This process is now automated as part of Github Actions. To create a pypi release, please run the following commands: Additional requirement: wheel , twine (for uploading), account on pypi with proper permissions. ``` bash python setup.py sdist bdist_wheel","title":"pypi"},{"location":"developer/#for-pypi-test-to-check-if-some-change-to-the-installation-did-work","text":"twine upload --repository-url https://test.pypi.org/legacy/ dist/*","title":"For pypi test (to check if some change to the installation did work)"},{"location":"developer/#for-production","text":"twine upload dist/* ``` Please don't push non-releases to the productive / real pypi instance.","title":"For production:"},{"location":"docker_quickstart/","text":"Using Freqtrade with Docker \u00b6 This page explains how to run the bot with Docker. It is not meant to work out of the box. You'll still need to read through the documentation and understand how to properly configure it. Install Docker \u00b6 Start by downloading and installing Docker CE for your platform: Mac Windows Linux To simplify running freqtrade, docker-compose should be installed and available to follow the below docker quick start guide . Freqtrade with docker-compose \u00b6 Freqtrade provides an official Docker image on Dockerhub , as well as a docker-compose file ready for usage. Note The following section assumes that docker and docker-compose are installed and available to the logged in user. All below commands use relative directories and will have to be executed from the directory containing the docker-compose.yml file. Docker quick start \u00b6 Create a new directory and place the docker-compose file in this directory. ``` bash mkdir ft_userdata cd ft_userdata/ Download the docker-compose file from the repository \u00b6 curl https://raw.githubusercontent.com/freqtrade/freqtrade/stable/docker-compose.yml -o docker-compose.yml Pull the freqtrade image \u00b6 docker-compose pull Create user directory structure \u00b6 docker-compose run --rm freqtrade create-userdir --userdir user_data Create configuration - Requires answering interactive questions \u00b6 docker-compose run --rm freqtrade new-config --config user_data/config.json ``` The above snippet creates a new directory called ft_userdata , downloads the latest compose file and pulls the freqtrade image. The last 2 steps in the snippet create the directory with user_data , as well as (interactively) the default configuration based on your selections. How to edit the bot configuration? You can edit the configuration at any time, which is available as user_data/config.json (within the directory ft_userdata ) when using the above configuration. You can also change the both Strategy and commands by editing the command section of your docker-compose.yml file. Adding a custom strategy \u00b6 The configuration is now available as user_data/config.json Copy a custom strategy to the directory user_data/strategies/ Add the Strategy' class name to the docker-compose.yml file The SampleStrategy is run by default. SampleStrategy is just a demo! The SampleStrategy is there for your reference and give you ideas for your own strategy. Please always backtest your strategy and use dry-run for some time before risking real money! You will find more information about Strategy development in the Strategy documentation . Once this is done, you're ready to launch the bot in trading mode (Dry-run or Live-trading, depending on your answer to the corresponding question you made above). bash docker-compose up -d Default configuration While the configuration generated will be mostly functional, you will still need to verify that all options correspond to what you want (like Pricing, pairlist, ...) before starting the bot. Accessing the UI \u00b6 If you've selected to enable FreqUI in the new-config step, you will have freqUI available at port localhost:8080 . You can now access the UI by typing localhost:8080 in your browser. UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. Please also read the API configuration with docker section to learn more about this configuration. Monitoring the bot \u00b6 You can check for running instances with docker-compose ps . This should list the service freqtrade as running . If that's not the case, best check the logs (see next point). Docker-compose logs \u00b6 Logs will be written to: user_data/logs/freqtrade.log . You can also check the latest log with the command docker-compose logs -f . Database \u00b6 The database will be located at: user_data/tradesv3.sqlite Updating freqtrade with docker-compose \u00b6 Updating freqtrade when using docker-compose is as simple as running the following 2 commands: ``` bash Download the latest image \u00b6 docker-compose pull Restart the image \u00b6 docker-compose up -d ``` This will first pull the latest image, and will then restart the container with the just pulled version. Check the Changelog You should always check the changelog for breaking changes / manual interventions required and make sure the bot starts correctly after the update. Editing the docker-compose file \u00b6 Advanced users may edit the docker-compose file further to include all possible options or arguments. All freqtrade arguments will be available by running docker-compose run --rm freqtrade <command> <optional arguments> . docker-compose for trade commands Trade commands ( freqtrade trade <...> ) should not be ran via docker-compose run - but should use docker-compose up -d instead. This makes sure that the container is properly started (including port forwardings) and will make sure that the container will restart after a system reboot. If you intend to use freqUI, please also ensure to adjust the configuration accordingly , otherwise the UI will not be available. docker-compose run --rm Including --rm will remove the container after completion, and is highly recommended for all modes except trading mode (running with freqtrade trade command). Using docker without docker-compose \" docker-compose run --rm \" will require a compose file to be provided. Some freqtrade commands that don't require authentication such as list-pairs can be run with \" docker run --rm \" instead. For example docker run --rm freqtradeorg/freqtrade:stable list-pairs --exchange binance --quote BTC --print-json . This can be useful for fetching exchange information to add to your config.json without affecting your running containers. Example: Download data with docker-compose \u00b6 Download backtesting data for 5 days for the pair ETH/BTC and 1h timeframe from Binance. The data will be stored in the directory user_data/data/ on the host. bash docker-compose run --rm freqtrade download-data --pairs ETH/BTC --exchange binance --days 5 -t 1h Head over to the Data Downloading Documentation for more details on downloading data. Example: Backtest with docker-compose \u00b6 Run backtesting in docker-containers for SampleStrategy and specified timerange of historical data, on 5m timeframe: bash docker-compose run --rm freqtrade backtesting --config user_data/config.json --strategy SampleStrategy --timerange 20190801-20191001 -i 5m Head over to the Backtesting Documentation to learn more. Additional dependencies with docker-compose \u00b6 If your strategy requires dependencies not included in the default image - it will be necessary to build the image on your host. For this, please create a Dockerfile containing installation steps for the additional dependencies (have a look at docker/Dockerfile.custom for an example). You'll then also need to modify the docker-compose.yml file and uncomment the build step, as well as rename the image to avoid naming collisions. yaml image: freqtrade_custom build: context: . dockerfile: \"./Dockerfile.<yourextension>\" You can then run docker-compose build --pull to build the docker image, and run it using the commands described above. Plotting with docker-compose \u00b6 Commands freqtrade plot-profit and freqtrade plot-dataframe ( Documentation ) are available by changing the image to *_plot in your docker-compose.yml file. You can then use these commands as follows: bash docker-compose run --rm freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805 The output will be stored in the user_data/plot directory, and can be opened with any modern browser. Data analysis using docker compose \u00b6 Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: bash docker-compose -f docker/docker-compose-jupyter.yml up This will create a docker-container running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. Since part of this image is built on your machine, it is recommended to rebuild the image from time to time to keep freqtrade (and dependencies) up-to-date. bash docker-compose -f docker/docker-compose-jupyter.yml build --no-cache Troubleshooting \u00b6 Docker on Windows \u00b6 Error: \"Timestamp for this request is outside of the recvWindow.\" The market api requests require a synchronized clock but the time in the docker container shifts a bit over time into the past. To fix this issue temporarily you need to run wsl --shutdown and restart docker again (a popup on windows 10 will ask you to do so). A permanent solution is either to host the docker container on a linux host or restart the wsl from time to time with the scheduler. bash taskkill /IM \"Docker Desktop.exe\" /F wsl --shutdown start \"\" \"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\" Warning Due to the above, we do not recommend the usage of docker on windows for production setups, but only for experimentation, datadownload and backtesting. Best use a linux-VPS for running freqtrade reliably.","title":"Quickstart with Docker"},{"location":"docker_quickstart/#using-freqtrade-with-docker","text":"This page explains how to run the bot with Docker. It is not meant to work out of the box. You'll still need to read through the documentation and understand how to properly configure it.","title":"Using Freqtrade with Docker"},{"location":"docker_quickstart/#install-docker","text":"Start by downloading and installing Docker CE for your platform: Mac Windows Linux To simplify running freqtrade, docker-compose should be installed and available to follow the below docker quick start guide .","title":"Install Docker"},{"location":"docker_quickstart/#freqtrade-with-docker-compose","text":"Freqtrade provides an official Docker image on Dockerhub , as well as a docker-compose file ready for usage. Note The following section assumes that docker and docker-compose are installed and available to the logged in user. All below commands use relative directories and will have to be executed from the directory containing the docker-compose.yml file.","title":"Freqtrade with docker-compose"},{"location":"docker_quickstart/#docker-quick-start","text":"Create a new directory and place the docker-compose file in this directory. ``` bash mkdir ft_userdata cd ft_userdata/","title":"Docker quick start"},{"location":"docker_quickstart/#download-the-docker-compose-file-from-the-repository","text":"curl https://raw.githubusercontent.com/freqtrade/freqtrade/stable/docker-compose.yml -o docker-compose.yml","title":"Download the docker-compose file from the repository"},{"location":"docker_quickstart/#pull-the-freqtrade-image","text":"docker-compose pull","title":"Pull the freqtrade image"},{"location":"docker_quickstart/#create-user-directory-structure","text":"docker-compose run --rm freqtrade create-userdir --userdir user_data","title":"Create user directory structure"},{"location":"docker_quickstart/#create-configuration-requires-answering-interactive-questions","text":"docker-compose run --rm freqtrade new-config --config user_data/config.json ``` The above snippet creates a new directory called ft_userdata , downloads the latest compose file and pulls the freqtrade image. The last 2 steps in the snippet create the directory with user_data , as well as (interactively) the default configuration based on your selections. How to edit the bot configuration? You can edit the configuration at any time, which is available as user_data/config.json (within the directory ft_userdata ) when using the above configuration. You can also change the both Strategy and commands by editing the command section of your docker-compose.yml file.","title":"Create configuration - Requires answering interactive questions"},{"location":"docker_quickstart/#adding-a-custom-strategy","text":"The configuration is now available as user_data/config.json Copy a custom strategy to the directory user_data/strategies/ Add the Strategy' class name to the docker-compose.yml file The SampleStrategy is run by default. SampleStrategy is just a demo! The SampleStrategy is there for your reference and give you ideas for your own strategy. Please always backtest your strategy and use dry-run for some time before risking real money! You will find more information about Strategy development in the Strategy documentation . Once this is done, you're ready to launch the bot in trading mode (Dry-run or Live-trading, depending on your answer to the corresponding question you made above). bash docker-compose up -d Default configuration While the configuration generated will be mostly functional, you will still need to verify that all options correspond to what you want (like Pricing, pairlist, ...) before starting the bot.","title":"Adding a custom strategy"},{"location":"docker_quickstart/#accessing-the-ui","text":"If you've selected to enable FreqUI in the new-config step, you will have freqUI available at port localhost:8080 . You can now access the UI by typing localhost:8080 in your browser. UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. Please also read the API configuration with docker section to learn more about this configuration.","title":"Accessing the UI"},{"location":"docker_quickstart/#monitoring-the-bot","text":"You can check for running instances with docker-compose ps . This should list the service freqtrade as running . If that's not the case, best check the logs (see next point).","title":"Monitoring the bot"},{"location":"docker_quickstart/#docker-compose-logs","text":"Logs will be written to: user_data/logs/freqtrade.log . You can also check the latest log with the command docker-compose logs -f .","title":"Docker-compose logs"},{"location":"docker_quickstart/#database","text":"The database will be located at: user_data/tradesv3.sqlite","title":"Database"},{"location":"docker_quickstart/#updating-freqtrade-with-docker-compose","text":"Updating freqtrade when using docker-compose is as simple as running the following 2 commands: ``` bash","title":"Updating freqtrade with docker-compose"},{"location":"docker_quickstart/#download-the-latest-image","text":"docker-compose pull","title":"Download the latest image"},{"location":"docker_quickstart/#restart-the-image","text":"docker-compose up -d ``` This will first pull the latest image, and will then restart the container with the just pulled version. Check the Changelog You should always check the changelog for breaking changes / manual interventions required and make sure the bot starts correctly after the update.","title":"Restart the image"},{"location":"docker_quickstart/#editing-the-docker-compose-file","text":"Advanced users may edit the docker-compose file further to include all possible options or arguments. All freqtrade arguments will be available by running docker-compose run --rm freqtrade <command> <optional arguments> . docker-compose for trade commands Trade commands ( freqtrade trade <...> ) should not be ran via docker-compose run - but should use docker-compose up -d instead. This makes sure that the container is properly started (including port forwardings) and will make sure that the container will restart after a system reboot. If you intend to use freqUI, please also ensure to adjust the configuration accordingly , otherwise the UI will not be available. docker-compose run --rm Including --rm will remove the container after completion, and is highly recommended for all modes except trading mode (running with freqtrade trade command). Using docker without docker-compose \" docker-compose run --rm \" will require a compose file to be provided. Some freqtrade commands that don't require authentication such as list-pairs can be run with \" docker run --rm \" instead. For example docker run --rm freqtradeorg/freqtrade:stable list-pairs --exchange binance --quote BTC --print-json . This can be useful for fetching exchange information to add to your config.json without affecting your running containers.","title":"Editing the docker-compose file"},{"location":"docker_quickstart/#example-download-data-with-docker-compose","text":"Download backtesting data for 5 days for the pair ETH/BTC and 1h timeframe from Binance. The data will be stored in the directory user_data/data/ on the host. bash docker-compose run --rm freqtrade download-data --pairs ETH/BTC --exchange binance --days 5 -t 1h Head over to the Data Downloading Documentation for more details on downloading data.","title":"Example: Download data with docker-compose"},{"location":"docker_quickstart/#example-backtest-with-docker-compose","text":"Run backtesting in docker-containers for SampleStrategy and specified timerange of historical data, on 5m timeframe: bash docker-compose run --rm freqtrade backtesting --config user_data/config.json --strategy SampleStrategy --timerange 20190801-20191001 -i 5m Head over to the Backtesting Documentation to learn more.","title":"Example: Backtest with docker-compose"},{"location":"docker_quickstart/#additional-dependencies-with-docker-compose","text":"If your strategy requires dependencies not included in the default image - it will be necessary to build the image on your host. For this, please create a Dockerfile containing installation steps for the additional dependencies (have a look at docker/Dockerfile.custom for an example). You'll then also need to modify the docker-compose.yml file and uncomment the build step, as well as rename the image to avoid naming collisions. yaml image: freqtrade_custom build: context: . dockerfile: \"./Dockerfile.<yourextension>\" You can then run docker-compose build --pull to build the docker image, and run it using the commands described above.","title":"Additional dependencies with docker-compose"},{"location":"docker_quickstart/#plotting-with-docker-compose","text":"Commands freqtrade plot-profit and freqtrade plot-dataframe ( Documentation ) are available by changing the image to *_plot in your docker-compose.yml file. You can then use these commands as follows: bash docker-compose run --rm freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805 The output will be stored in the user_data/plot directory, and can be opened with any modern browser.","title":"Plotting with docker-compose"},{"location":"docker_quickstart/#data-analysis-using-docker-compose","text":"Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: bash docker-compose -f docker/docker-compose-jupyter.yml up This will create a docker-container running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. Since part of this image is built on your machine, it is recommended to rebuild the image from time to time to keep freqtrade (and dependencies) up-to-date. bash docker-compose -f docker/docker-compose-jupyter.yml build --no-cache","title":"Data analysis using docker compose"},{"location":"docker_quickstart/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"docker_quickstart/#docker-on-windows","text":"Error: \"Timestamp for this request is outside of the recvWindow.\" The market api requests require a synchronized clock but the time in the docker container shifts a bit over time into the past. To fix this issue temporarily you need to run wsl --shutdown and restart docker again (a popup on windows 10 will ask you to do so). A permanent solution is either to host the docker container on a linux host or restart the wsl from time to time with the scheduler. bash taskkill /IM \"Docker Desktop.exe\" /F wsl --shutdown start \"\" \"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\" Warning Due to the above, we do not recommend the usage of docker on windows for production setups, but only for experimentation, datadownload and backtesting. Best use a linux-VPS for running freqtrade reliably.","title":"Docker on Windows"},{"location":"edge/","text":"Edge positioning \u00b6 The Edge Positioning module uses probability to calculate your win rate and risk reward ratio. It will use these statistics to control your strategy trade entry points, position size and, stoploss. Warning When using Edge positioning with a dynamic whitelist (VolumePairList), make sure to also use AgeFilter and set it to at least calculate_since_number_of_days to avoid problems with missing data. Note Edge Positioning only considers its own buy/sell/stoploss signals. It ignores the stoploss, trailing stoploss, and ROI settings in the strategy configuration file. Edge Positioning improves the performance of some trading strategies and decreases the performance of others. Introduction \u00b6 Trading strategies are not perfect. They are frameworks that are susceptible to the market and its indicators. Because the market is not at all predictable, sometimes a strategy will win and sometimes the same strategy will lose. To obtain an edge in the market, a strategy has to make more money than it loses. Making money in trading is not only about how often the strategy makes or loses money. It doesn't matter how often, but how much! A bad strategy might make 1 penny in ten transactions but lose 1 dollar in one transaction. If one only checks the number of winning trades, it would be misleading to think that the strategy is actually making a profit. The Edge Positioning module seeks to improve a strategy's winning probability and the money that the strategy will make on the long run . We raise the following question 1 : Which trade is a better option? a) A trade with 80% of chance of losing 100$ and 20% chance of winning 200$ b) A trade with 100% of chance of losing 30$ Answer The expected value of a) is smaller than the expected value of b) . Hence, b ) represents a smaller loss in the long run. However, the answer is: it depends Another way to look at it is to ask a similar question: Which trade is a better option? a) A trade with 80% of chance of winning 100$ and 20% chance of losing 200$ b) A trade with 100% of chance of winning 30$ Edge positioning tries to answer the hard questions about risk/reward and position size automatically, seeking to minimizes the chances of losing of a given strategy. Trading, winning and losing \u00b6 Let's call \\(o\\) the return of a single transaction \\(o\\) where \\(o \\in \\mathbb{R}\\) . The collection \\(O = \\{o_1, o_2, ..., o_N\\}\\) is the set of all returns of transactions made during a trading session. We say that \\(N\\) is the cardinality of \\(O\\) , or, in lay terms, it is the number of transactions made in a trading session. Example In a session where a strategy made three transactions we can say that \\(O = \\{3.5, -1, 15\\}\\) . That means that \\(N = 3\\) and \\(o_1 = 3.5\\) , \\(o_2 = -1\\) , \\(o_3 = 15\\) . A winning trade is a trade where a strategy made money. Making money means that the strategy closed the position in a value that returned a profit, after all deducted fees. Formally, a winning trade will have a return \\(o_i > 0\\) . Similarly, a losing trade will have a return \\(o_j \\leq 0\\) . With that, we can discover the set of all winning trades, \\(T_{win}\\) , as follows: \\[ T_{win} = \\{ o \\in O | o > 0 \\} \\] Similarly, we can discover the set of losing trades \\(T_{lose}\\) as follows: \\[ T_{lose} = \\{o \\in O | o \\leq 0\\} \\] Example In a section where a strategy made four transactions \\(O = \\{3.5, -1, 15, 0\\}\\) : \\(T_{win} = \\{3.5, 15\\}\\) \\(T_{lose} = \\{-1, 0\\}\\) Win Rate and Lose Rate \u00b6 The win rate \\(W\\) is the proportion of winning trades with respect to all the trades made by a strategy. We use the following function to compute the win rate: \\[W = \\frac{|T_{win}|}{N}\\] Where \\(W\\) is the win rate, \\(N\\) is the number of trades and, \\(T_{win}\\) is the set of all trades where the strategy made money. Similarly, we can compute the rate of losing trades: \\[ L = \\frac{|T_{lose}|}{N} \\] Where \\(L\\) is the lose rate, \\(N\\) is the amount of trades made and, \\(T_{lose}\\) is the set of all trades where the strategy lost money. Note that the above formula is the same as calculating \\(L = 1 \u2013 W\\) or \\(W = 1 \u2013 L\\) Risk Reward Ratio \u00b6 Risk Reward Ratio ( \\(R\\) ) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose. Formally: \\[ R = \\frac{\\text{potential_profit}}{\\text{potential_loss}} \\] Worked example of \\(R\\) calculation Let's say that you think that the price of stonecoin today is 10.0$. You believe that, because they will start mining stonecoin, it will go up to 15.0$ tomorrow. There is the risk that the stone is too hard, and the GPUs can't mine it, so the price might go to 0$ tomorrow. You are planning to invest 100$, which will give you 10 shares (100 / 10). Your potential profit is calculated as: \\(\\begin{aligned} \\text{potential_profit} &= (\\text{potential_price} - \\text{entry_price}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (15 - 10) * (100 / 10) \\\\ &= 50 \\end{aligned}\\) Since the price might go to 0$, the 100$ dollars invested could turn into 0. We do however use a stoploss of 15% - so in the worst case, we'll sell 15% below entry price (or at 8.5$). \\(\\begin{aligned} \\text{potential_loss} &= (\\text{entry_price} - \\text{stoploss}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (10 - 8.5) * (100 / 10)\\\\ &= 15 \\end{aligned}\\) We can compute the Risk Reward Ratio as follows: \\(\\begin{aligned} R &= \\frac{\\text{potential_profit}}{\\text{potential_loss}}\\\\ &= \\frac{50}{15}\\\\ &= 3.33 \\end{aligned}\\) What it effectively means is that the strategy have the potential to make 3.33$ for each 1$ invested. On a long horizon, that is, on many trades, we can calculate the risk reward by dividing the strategy' average profit on winning trades by the strategy' average loss on losing trades. We can calculate the average profit, \\(\\mu_{win}\\) , as follows: \\[ \\text{average_profit} = \\mu_{win} = \\frac{\\text{sum_of_profits}}{\\text{count_winning_trades}} = \\frac{\\sum^{o \\in T_{win}} o}{|T_{win}|} \\] Similarly, we can calculate the average loss, \\(\\mu_{lose}\\) , as follows: \\[ \\text{average_loss} = \\mu_{lose} = \\frac{\\text{sum_of_losses}}{\\text{count_losing_trades}} = \\frac{\\sum^{o \\in T_{lose}} o}{|T_{lose}|} \\] Finally, we can calculate the Risk Reward ratio, \\(R\\) , as follows: \\[ R = \\frac{\\text{average_profit}}{\\text{average_loss}} = \\frac{\\mu_{win}}{\\mu_{lose}}\\\\ \\] Worked example of \\(R\\) calculation using mean profit/loss Let's say the strategy that we are using makes an average win \\(\\mu_{win} = 2.06\\) and an average loss \\(\\mu_{loss} = 4.11\\) . We calculate the risk reward ratio as follows: \\(R = \\frac{\\mu_{win}}{\\mu_{loss}} = \\frac{2.06}{4.11} = 0.5012...\\) Expectancy \u00b6 By combining the Win Rate \\(W\\) and and the Risk Reward ratio \\(R\\) to create an expectancy ratio \\(E\\) . A expectance ratio is the expected return of the investment made in a trade. We can compute the value of \\(E\\) as follows: \\[E = R * W - L\\] Calculating \\(E\\) Let's say that a strategy has a win rate \\(W = 0.28\\) and a risk reward ratio \\(R = 5\\) . What this means is that the strategy is expected to make 5 times the investment around on 28% of the trades it makes. Working out the example: \\(E = R * W - L = 5 * 0.28 - 0.72 = 0.68\\) The expectancy worked out in the example above means that, on average, this strategy' trades will return 1.68 times the size of its losses. Said another way, the strategy makes 1.68$ for every 1$ it loses, on average. This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ. It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future. You can also use this value to evaluate the effectiveness of modifications to this system. Note It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades. How does it work? \u00b6 Edge combines dynamic stoploss, dynamic positions, and whitelist generation into one isolated module which is then applied to the trading strategy. If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example: Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at \\(3%\\) leads to the maximum expectancy according to historical data. Edge module then forces stoploss value it evaluated to your strategy dynamically. Position size \u00b6 Edge dictates the amount at stake for each trade to the bot according to the following factors: Allowed capital at risk Stoploss Allowed capital at risk is calculated as follows: Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade) Stoploss is calculated as described above with respect to historical data. The position size is calculated as follows: Position size = (Allowed capital at risk) / Stoploss Example: Let's say the stake currency is ETH and there is \\(10\\) ETH on the wallet. The capital available percentage is \\(50%\\) and the allowed risk per trade is \\(1\\%\\) . Thus, the available capital for trading is \\(10 * 0.5 = 5\\) ETH and the allowed capital at risk would be \\(5 * 0.01 = 0.05\\) ETH . Trade 1: The strategy detects a new buy signal in the XLM/ETH market. Edge Positioning calculates a stoploss of \\(2\\%\\) and a position of \\(0.05 / 0.02 = 2.5\\) ETH . The bot takes a position of \\(2.5\\) ETH in the XLM/ETH market. Trade 2: The strategy detects a buy signal on the BTC/ETH market while Trade 1 is still open. Edge Positioning calculates the stoploss of \\(4\\%\\) on this market. Thus, Trade 2 position size is \\(0.05 / 0.04 = 1.25\\) ETH . Available Capital \\(\\neq\\) Available in wallet The available capital for trading didn't change in Trade 2 even with Trade 1 still open. The available capital is not the free amount in the wallet. Trade 3: The strategy detects a buy signal in the ADA/ETH market. Edge Positioning calculates a stoploss of \\(1\\%\\) and a position of \\(0.05 / 0.01 = 5\\) ETH . Since Trade 1 has \\(2.5\\) ETH blocked and Trade 2 has \\(1.25\\) ETH blocked, there is only \\(5 - 1.25 - 2.5 = 1.25\\) ETH available. Hence, the position size of Trade 3 is \\(1.25\\) ETH . Available Capital Updates The available capital does not change before a position is sold. After a trade is closed the Available Capital goes up if the trade was profitable or goes down if the trade was a loss. The strategy detects a sell signal in the XLM/ETH market. The bot exits Trade 1 for a profit of \\(1\\) ETH . The total capital in the wallet becomes \\(11\\) ETH and the available capital for trading becomes \\(5.5\\) ETH . Trade 4 The strategy detects a new buy signal int the XLM/ETH market. Edge Positioning calculates the stoploss of \\(2\\%\\) , and the position size of \\(0.055 / 0.02 = 2.75\\) ETH . Edge command reference \u00b6 ``` usage: freqtrade edge [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--stoplosses STOPLOSS_RANGE] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: None ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --stoplosses STOPLOSS_RANGE Defines a range of stoploss values against which edge will assess the strategy. The format is \"min,max,step\" (without any space). Example: --stoplosses=-0.01,-0.1,-0.001 Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` Configurations \u00b6 Edge module has following configuration options: Parameter Description enabled If true, then Edge will run periodically. Defaults to false . Datatype: Boolean process_throttle_secs How often should Edge run in seconds. Defaults to 3600 (once per hour). Datatype: Integer calculate_since_number_of_days Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy. Note that it downloads historical data so increasing this number would lead to slowing down the bot. Defaults to 7 . Datatype: Integer allowed_risk Ratio of allowed risk per trade. Defaults to 0.01 (1%)). Datatype: Float stoploss_range_min Minimum stoploss. Defaults to -0.01 . Datatype: Float stoploss_range_max Maximum stoploss. Defaults to -0.10 . Datatype: Float stoploss_range_step As an example if this is set to -0.01 then Edge will test the strategy for [-0.01, -0,02, -0,03 ..., -0.09, -0.10] ranges. Note than having a smaller step means having a bigger range which could lead to slow calculation. If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10. Defaults to -0.001 . Datatype: Float minimum_winrate It filters out pairs which don't have at least minimum_winrate. This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio. Defaults to 0.60 . Datatype: Float minimum_expectancy It filters out pairs which have the expectancy lower than this number. Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return. Defaults to 0.20 . Datatype: Float min_trade_number When calculating W , R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable. Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something. Defaults to 10 (it is highly recommended not to decrease this number). Datatype: Integer max_trade_duration_minute Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign. NOTICE: While configuring this value, you should take into consideration your timeframe. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.). Defaults to 1440 (one day). Datatype: Integer remove_pumps Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off. Defaults to false . Datatype: Boolean Running Edge independently \u00b6 You can run Edge independently in order to see in details the result. Here is an example: bash freqtrade edge An example of its output: pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59 Edge produced the above table by comparing calculate_since_number_of_days to minimum_expectancy to find min_trade_number historical information based on the config file. The timerange Edge uses for its comparisons can be further limited by using the --timerange switch. In live and dry-run modes, after the process_throttle_secs has passed, Edge will again process calculate_since_number_of_days against minimum_expectancy to find min_trade_number . If no min_trade_number is found, the bot will return \"whitelist empty\". Depending on the trade strategy being deployed, \"whitelist empty\" may be return much of the time - or all of the time. The use of Edge may also cause trading to occur in bursts, though this is rare. If you encounter \"whitelist empty\" a lot, condsider tuning calculate_since_number_of_days , minimum_expectancy and min_trade_number to align to the trading frequency of your strategy. Update cached pairs with the latest data \u00b6 Edge requires historic data the same way as backtesting does. Please refer to the Data Downloading section of the documentation for details. Precising stoploss range \u00b6 bash freqtrade edge --stoplosses=-0.01,-0.1,-0.001 #min,max,step Advanced use of timerange \u00b6 bash freqtrade edge --timerange=20181110-20181113 Doing --timerange=-20190901 will get all available data until September 1 st (excluding September 1 st 2019). The full timerange specification: Use tickframes till 2018/01/31: --timerange=-20180131 Use tickframes since 2018/01/31: --timerange=20180131- Use tickframes since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use tickframes between POSIX timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Question extracted from MIT Opencourseware S096 - Mathematics with applications in Finance: https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/ \u21a9","title":"Edge Positioning"},{"location":"edge/#edge-positioning","text":"The Edge Positioning module uses probability to calculate your win rate and risk reward ratio. It will use these statistics to control your strategy trade entry points, position size and, stoploss. Warning When using Edge positioning with a dynamic whitelist (VolumePairList), make sure to also use AgeFilter and set it to at least calculate_since_number_of_days to avoid problems with missing data. Note Edge Positioning only considers its own buy/sell/stoploss signals. It ignores the stoploss, trailing stoploss, and ROI settings in the strategy configuration file. Edge Positioning improves the performance of some trading strategies and decreases the performance of others.","title":"Edge positioning"},{"location":"edge/#introduction","text":"Trading strategies are not perfect. They are frameworks that are susceptible to the market and its indicators. Because the market is not at all predictable, sometimes a strategy will win and sometimes the same strategy will lose. To obtain an edge in the market, a strategy has to make more money than it loses. Making money in trading is not only about how often the strategy makes or loses money. It doesn't matter how often, but how much! A bad strategy might make 1 penny in ten transactions but lose 1 dollar in one transaction. If one only checks the number of winning trades, it would be misleading to think that the strategy is actually making a profit. The Edge Positioning module seeks to improve a strategy's winning probability and the money that the strategy will make on the long run . We raise the following question 1 : Which trade is a better option? a) A trade with 80% of chance of losing 100$ and 20% chance of winning 200$ b) A trade with 100% of chance of losing 30$ Answer The expected value of a) is smaller than the expected value of b) . Hence, b ) represents a smaller loss in the long run. However, the answer is: it depends Another way to look at it is to ask a similar question: Which trade is a better option? a) A trade with 80% of chance of winning 100$ and 20% chance of losing 200$ b) A trade with 100% of chance of winning 30$ Edge positioning tries to answer the hard questions about risk/reward and position size automatically, seeking to minimizes the chances of losing of a given strategy.","title":"Introduction"},{"location":"edge/#trading-winning-and-losing","text":"Let's call \\(o\\) the return of a single transaction \\(o\\) where \\(o \\in \\mathbb{R}\\) . The collection \\(O = \\{o_1, o_2, ..., o_N\\}\\) is the set of all returns of transactions made during a trading session. We say that \\(N\\) is the cardinality of \\(O\\) , or, in lay terms, it is the number of transactions made in a trading session. Example In a session where a strategy made three transactions we can say that \\(O = \\{3.5, -1, 15\\}\\) . That means that \\(N = 3\\) and \\(o_1 = 3.5\\) , \\(o_2 = -1\\) , \\(o_3 = 15\\) . A winning trade is a trade where a strategy made money. Making money means that the strategy closed the position in a value that returned a profit, after all deducted fees. Formally, a winning trade will have a return \\(o_i > 0\\) . Similarly, a losing trade will have a return \\(o_j \\leq 0\\) . With that, we can discover the set of all winning trades, \\(T_{win}\\) , as follows: \\[ T_{win} = \\{ o \\in O | o > 0 \\} \\] Similarly, we can discover the set of losing trades \\(T_{lose}\\) as follows: \\[ T_{lose} = \\{o \\in O | o \\leq 0\\} \\] Example In a section where a strategy made four transactions \\(O = \\{3.5, -1, 15, 0\\}\\) : \\(T_{win} = \\{3.5, 15\\}\\) \\(T_{lose} = \\{-1, 0\\}\\)","title":"Trading, winning and losing"},{"location":"edge/#win-rate-and-lose-rate","text":"The win rate \\(W\\) is the proportion of winning trades with respect to all the trades made by a strategy. We use the following function to compute the win rate: \\[W = \\frac{|T_{win}|}{N}\\] Where \\(W\\) is the win rate, \\(N\\) is the number of trades and, \\(T_{win}\\) is the set of all trades where the strategy made money. Similarly, we can compute the rate of losing trades: \\[ L = \\frac{|T_{lose}|}{N} \\] Where \\(L\\) is the lose rate, \\(N\\) is the amount of trades made and, \\(T_{lose}\\) is the set of all trades where the strategy lost money. Note that the above formula is the same as calculating \\(L = 1 \u2013 W\\) or \\(W = 1 \u2013 L\\)","title":"Win Rate and Lose Rate"},{"location":"edge/#risk-reward-ratio","text":"Risk Reward Ratio ( \\(R\\) ) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose. Formally: \\[ R = \\frac{\\text{potential_profit}}{\\text{potential_loss}} \\] Worked example of \\(R\\) calculation Let's say that you think that the price of stonecoin today is 10.0$. You believe that, because they will start mining stonecoin, it will go up to 15.0$ tomorrow. There is the risk that the stone is too hard, and the GPUs can't mine it, so the price might go to 0$ tomorrow. You are planning to invest 100$, which will give you 10 shares (100 / 10). Your potential profit is calculated as: \\(\\begin{aligned} \\text{potential_profit} &= (\\text{potential_price} - \\text{entry_price}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (15 - 10) * (100 / 10) \\\\ &= 50 \\end{aligned}\\) Since the price might go to 0$, the 100$ dollars invested could turn into 0. We do however use a stoploss of 15% - so in the worst case, we'll sell 15% below entry price (or at 8.5$). \\(\\begin{aligned} \\text{potential_loss} &= (\\text{entry_price} - \\text{stoploss}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (10 - 8.5) * (100 / 10)\\\\ &= 15 \\end{aligned}\\) We can compute the Risk Reward Ratio as follows: \\(\\begin{aligned} R &= \\frac{\\text{potential_profit}}{\\text{potential_loss}}\\\\ &= \\frac{50}{15}\\\\ &= 3.33 \\end{aligned}\\) What it effectively means is that the strategy have the potential to make 3.33$ for each 1$ invested. On a long horizon, that is, on many trades, we can calculate the risk reward by dividing the strategy' average profit on winning trades by the strategy' average loss on losing trades. We can calculate the average profit, \\(\\mu_{win}\\) , as follows: \\[ \\text{average_profit} = \\mu_{win} = \\frac{\\text{sum_of_profits}}{\\text{count_winning_trades}} = \\frac{\\sum^{o \\in T_{win}} o}{|T_{win}|} \\] Similarly, we can calculate the average loss, \\(\\mu_{lose}\\) , as follows: \\[ \\text{average_loss} = \\mu_{lose} = \\frac{\\text{sum_of_losses}}{\\text{count_losing_trades}} = \\frac{\\sum^{o \\in T_{lose}} o}{|T_{lose}|} \\] Finally, we can calculate the Risk Reward ratio, \\(R\\) , as follows: \\[ R = \\frac{\\text{average_profit}}{\\text{average_loss}} = \\frac{\\mu_{win}}{\\mu_{lose}}\\\\ \\] Worked example of \\(R\\) calculation using mean profit/loss Let's say the strategy that we are using makes an average win \\(\\mu_{win} = 2.06\\) and an average loss \\(\\mu_{loss} = 4.11\\) . We calculate the risk reward ratio as follows: \\(R = \\frac{\\mu_{win}}{\\mu_{loss}} = \\frac{2.06}{4.11} = 0.5012...\\)","title":"Risk Reward Ratio"},{"location":"edge/#expectancy","text":"By combining the Win Rate \\(W\\) and and the Risk Reward ratio \\(R\\) to create an expectancy ratio \\(E\\) . A expectance ratio is the expected return of the investment made in a trade. We can compute the value of \\(E\\) as follows: \\[E = R * W - L\\] Calculating \\(E\\) Let's say that a strategy has a win rate \\(W = 0.28\\) and a risk reward ratio \\(R = 5\\) . What this means is that the strategy is expected to make 5 times the investment around on 28% of the trades it makes. Working out the example: \\(E = R * W - L = 5 * 0.28 - 0.72 = 0.68\\) The expectancy worked out in the example above means that, on average, this strategy' trades will return 1.68 times the size of its losses. Said another way, the strategy makes 1.68$ for every 1$ it loses, on average. This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ. It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future. You can also use this value to evaluate the effectiveness of modifications to this system. Note It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades.","title":"Expectancy"},{"location":"edge/#how-does-it-work","text":"Edge combines dynamic stoploss, dynamic positions, and whitelist generation into one isolated module which is then applied to the trading strategy. If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example: Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at \\(3%\\) leads to the maximum expectancy according to historical data. Edge module then forces stoploss value it evaluated to your strategy dynamically.","title":"How does it work?"},{"location":"edge/#position-size","text":"Edge dictates the amount at stake for each trade to the bot according to the following factors: Allowed capital at risk Stoploss Allowed capital at risk is calculated as follows: Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade) Stoploss is calculated as described above with respect to historical data. The position size is calculated as follows: Position size = (Allowed capital at risk) / Stoploss Example: Let's say the stake currency is ETH and there is \\(10\\) ETH on the wallet. The capital available percentage is \\(50%\\) and the allowed risk per trade is \\(1\\%\\) . Thus, the available capital for trading is \\(10 * 0.5 = 5\\) ETH and the allowed capital at risk would be \\(5 * 0.01 = 0.05\\) ETH . Trade 1: The strategy detects a new buy signal in the XLM/ETH market. Edge Positioning calculates a stoploss of \\(2\\%\\) and a position of \\(0.05 / 0.02 = 2.5\\) ETH . The bot takes a position of \\(2.5\\) ETH in the XLM/ETH market. Trade 2: The strategy detects a buy signal on the BTC/ETH market while Trade 1 is still open. Edge Positioning calculates the stoploss of \\(4\\%\\) on this market. Thus, Trade 2 position size is \\(0.05 / 0.04 = 1.25\\) ETH . Available Capital \\(\\neq\\) Available in wallet The available capital for trading didn't change in Trade 2 even with Trade 1 still open. The available capital is not the free amount in the wallet. Trade 3: The strategy detects a buy signal in the ADA/ETH market. Edge Positioning calculates a stoploss of \\(1\\%\\) and a position of \\(0.05 / 0.01 = 5\\) ETH . Since Trade 1 has \\(2.5\\) ETH blocked and Trade 2 has \\(1.25\\) ETH blocked, there is only \\(5 - 1.25 - 2.5 = 1.25\\) ETH available. Hence, the position size of Trade 3 is \\(1.25\\) ETH . Available Capital Updates The available capital does not change before a position is sold. After a trade is closed the Available Capital goes up if the trade was profitable or goes down if the trade was a loss. The strategy detects a sell signal in the XLM/ETH market. The bot exits Trade 1 for a profit of \\(1\\) ETH . The total capital in the wallet becomes \\(11\\) ETH and the available capital for trading becomes \\(5.5\\) ETH . Trade 4 The strategy detects a new buy signal int the XLM/ETH market. Edge Positioning calculates the stoploss of \\(2\\%\\) , and the position size of \\(0.055 / 0.02 = 2.75\\) ETH .","title":"Position size"},{"location":"edge/#edge-command-reference","text":"``` usage: freqtrade edge [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--stoplosses STOPLOSS_RANGE] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: None ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --stoplosses STOPLOSS_RANGE Defines a range of stoploss values against which edge will assess the strategy. The format is \"min,max,step\" (without any space). Example: --stoplosses=-0.01,-0.1,-0.001 Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ```","title":"Edge command reference"},{"location":"edge/#configurations","text":"Edge module has following configuration options: Parameter Description enabled If true, then Edge will run periodically. Defaults to false . Datatype: Boolean process_throttle_secs How often should Edge run in seconds. Defaults to 3600 (once per hour). Datatype: Integer calculate_since_number_of_days Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy. Note that it downloads historical data so increasing this number would lead to slowing down the bot. Defaults to 7 . Datatype: Integer allowed_risk Ratio of allowed risk per trade. Defaults to 0.01 (1%)). Datatype: Float stoploss_range_min Minimum stoploss. Defaults to -0.01 . Datatype: Float stoploss_range_max Maximum stoploss. Defaults to -0.10 . Datatype: Float stoploss_range_step As an example if this is set to -0.01 then Edge will test the strategy for [-0.01, -0,02, -0,03 ..., -0.09, -0.10] ranges. Note than having a smaller step means having a bigger range which could lead to slow calculation. If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10. Defaults to -0.001 . Datatype: Float minimum_winrate It filters out pairs which don't have at least minimum_winrate. This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio. Defaults to 0.60 . Datatype: Float minimum_expectancy It filters out pairs which have the expectancy lower than this number. Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return. Defaults to 0.20 . Datatype: Float min_trade_number When calculating W , R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable. Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something. Defaults to 10 (it is highly recommended not to decrease this number). Datatype: Integer max_trade_duration_minute Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign. NOTICE: While configuring this value, you should take into consideration your timeframe. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.). Defaults to 1440 (one day). Datatype: Integer remove_pumps Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off. Defaults to false . Datatype: Boolean","title":"Configurations"},{"location":"edge/#running-edge-independently","text":"You can run Edge independently in order to see in details the result. Here is an example: bash freqtrade edge An example of its output: pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59 Edge produced the above table by comparing calculate_since_number_of_days to minimum_expectancy to find min_trade_number historical information based on the config file. The timerange Edge uses for its comparisons can be further limited by using the --timerange switch. In live and dry-run modes, after the process_throttle_secs has passed, Edge will again process calculate_since_number_of_days against minimum_expectancy to find min_trade_number . If no min_trade_number is found, the bot will return \"whitelist empty\". Depending on the trade strategy being deployed, \"whitelist empty\" may be return much of the time - or all of the time. The use of Edge may also cause trading to occur in bursts, though this is rare. If you encounter \"whitelist empty\" a lot, condsider tuning calculate_since_number_of_days , minimum_expectancy and min_trade_number to align to the trading frequency of your strategy.","title":"Running Edge independently"},{"location":"edge/#update-cached-pairs-with-the-latest-data","text":"Edge requires historic data the same way as backtesting does. Please refer to the Data Downloading section of the documentation for details.","title":"Update cached pairs with the latest data"},{"location":"edge/#precising-stoploss-range","text":"bash freqtrade edge --stoplosses=-0.01,-0.1,-0.001 #min,max,step","title":"Precising stoploss range"},{"location":"edge/#advanced-use-of-timerange","text":"bash freqtrade edge --timerange=20181110-20181113 Doing --timerange=-20190901 will get all available data until September 1 st (excluding September 1 st 2019). The full timerange specification: Use tickframes till 2018/01/31: --timerange=-20180131 Use tickframes since 2018/01/31: --timerange=20180131- Use tickframes since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use tickframes between POSIX timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Question extracted from MIT Opencourseware S096 - Mathematics with applications in Finance: https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/ \u21a9","title":"Advanced use of timerange"},{"location":"exchanges/","text":"Exchange-specific Notes \u00b6 This page combines common gotchas and informations which are exchange-specific and most likely don't apply to other exchanges. Exchange configuration \u00b6 Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage . However, the bot was tested by the development team with only a few exchanges. A current list of these can be found in the \"Home\" section of this documentation. Feel free to test other exchanges and submit your feedback or PR to improve the bot or confirm exchanges that work flawlessly.. Some exchanges require special configuration, which can be found below. Sample exchange configuration \u00b6 A exchange configuration for \"binance\" would look as follows: json \"exchange\": { \"name\": \"binance\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"ccxt_config\": {}, \"ccxt_async_config\": {}, // ... Setting rate limits \u00b6 Usually, rate limits set by CCXT are reliable and work well. In case of problems related to rate-limits (usually DDOS Exceptions in your logs), it's easy to change rateLimit settings to other values. json \"exchange\": { \"name\": \"kraken\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"ccxt_config\": {\"enableRateLimit\": true}, \"ccxt_async_config\": { \"enableRateLimit\": true, \"rateLimit\": 3100 }, This configuration enables kraken, as well as rate-limiting to avoid bans from the exchange. \"rateLimit\": 3100 defines a wait-event of 3.1s between each call. This can also be completely disabled by setting \"enableRateLimit\" to false. Note Optimal settings for rate-limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that \"enableRateLimit\" is enabled and increase the \"rateLimit\" parameter step by step. Binance \u00b6 Binance supports time_in_force . Stoploss on Exchange Binance supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Binance Blacklist \u00b6 For Binance, please add \"BNB/<STAKE>\" to your blacklist to avoid issues. Accounts having BNB accounts use this to pay for fees - if your first trade happens to be on BNB , further trades will consume this position and make the initial BNB trade unsellable as the expected amount is not there anymore. Binance sites \u00b6 Binance has been split into 2, and users must use the correct ccxt exchange ID for their exchange, otherwise API keys are not recognized. binance.com - International users. Use exchange id: binance . binance.us - US based users. Use exchange id: binanceus . Kraken \u00b6 Stoploss on Exchange Kraken supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type to use. Historic Kraken data \u00b6 The Kraken API does only provide 720 historic candles, which is sufficient for Freqtrade dry-run and live trade modes, but is a problem for backtesting. To download data for the Kraken exchange, using --dl-trades is mandatory, otherwise the bot will download the same 720 candles over and over, and you'll not have enough backtest data. Due to the heavy rate-limiting applied by Kraken, the following configuration section should be used to download data: json \"ccxt_async_config\": { \"enableRateLimit\": true, \"rateLimit\": 3100 }, Downloading data from kraken Downloading kraken data will require significantly more memory (RAM) than any other exchange, as the trades-data needs to be converted into candles on your machine. It will also take a long time, as freqtrade will need to download every single trade that happened on the exchange for the pair / timerange combination, therefore please be patient. rateLimit tuning Please pay attention that rateLimit configuration entry holds delay in milliseconds between requests, NOT requests\\sec rate. So, in order to mitigate Kraken API \"Rate limit exceeded\" exception, this configuration should be increased, NOT decreased. Bittrex \u00b6 Order types \u00b6 Bittrex does not support market orders. If you have a message at the bot startup about this, you should change order type values set in your configuration and/or in the strategy from \"market\" to \"limit\" . See some more details on this here in the FAQ . Bittrex also does not support VolumePairlist due to limited / split API constellation at the moment. Please use StaticPairlist . Other pairlists (other than VolumePairlist ) should not be affected. Volume pairlist \u00b6 Bittrex does not support the direct usage of VolumePairList. This can however be worked around by using the advanced mode with lookback_days: 1 (or more), which will emulate 24h volume. Read more in the pairlist documentation . Restricted markets \u00b6 Bittrex split its exchange into US and International versions. The International version has more pairs available, however the API always returns all pairs, so there is currently no automated way to detect if you're affected by the restriction. If you have restricted pairs in your whitelist, you'll get a warning message in the log on Freqtrade startup for each restricted pair. The warning message will look similar to the following: output [...] Message: bittrex {\"success\":false,\"message\":\"RESTRICTED_MARKET\",\"result\":null,\"explanation\":null}\" If you're an \"International\" customer on the Bittrex exchange, then this warning will probably not impact you. If you're a US customer, the bot will fail to create orders for these pairs, and you should remove them from your whitelist. You can get a list of restricted markets by using the following snippet: ``` python import ccxt ct = ccxt.bittrex() lm = ct.load_markets() res = [p for p, x in lm.items() if 'US' in x['info']['prohibitedIn']] print(res) ``` FTX \u00b6 Stoploss on Exchange FTX supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used. Using subaccounts \u00b6 To use subaccounts with FTX, you need to edit the configuration and add the following: json \"exchange\": { \"ccxt_config\": { \"headers\": { \"FTX-SUBACCOUNT\": \"name\" } }, } Kucoin \u00b6 Kucoin requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: json \"exchange\": { \"name\": \"kucoin\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"password\": \"your_exchange_api_key_password\", // ... } Kucoin supports time_in_force . Stoploss on Exchange Kucoin supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used. Kucoin Blacklists \u00b6 For Kucoin, please add \"KCS/<STAKE>\" to your blacklist to avoid issues. Accounts having KCS accounts use this to pay for fees - if your first trade happens to be on KCS , further trades will consume this position and make the initial KCS trade unsellable as the expected amount is not there anymore. Huobi \u00b6 Stoploss on Exchange Huobi supports stoploss_on_exchange and uses stop-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange. OKX (former OKEX) \u00b6 OKX requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: json \"exchange\": { \"name\": \"okx\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"password\": \"your_exchange_api_key_password\", // ... } Warning OKX only provides 100 candles per api call. Therefore, the strategy will only have a pretty low amount of data available in backtesting mode. Gate.io \u00b6 Stoploss on Exchange Gate.io supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Gate.io allows the use of POINT to pay for fees. As this is not a tradable currency (no regular market available), automatic fee calculations will fail (and default to a fee of 0). The configuration parameter exchange.unknown_fee_rate can be used to specify the exchange rate between Point and the stake currency. Obviously, changing the stake-currency will also require changes to this value. All exchanges \u00b6 Should you experience constant errors with Nonce (like InvalidNonce ), it is best to regenerate the API keys. Resetting Nonce is difficult and it's usually easier to regenerate the API keys. Random notes for other exchanges \u00b6 The Ocean (exchange id: theocean ) exchange uses Web3 functionality and requires web3 python package to be installed: shell $ pip3 install web3 Getting latest price / Incomplete candles \u00b6 Most exchanges return current incomplete candle via their OHLCV/klines API interface. By default, Freqtrade assumes that incomplete candle is fetched from the exchange and removes the last candle assuming it's the incomplete candle. Whether your exchange returns incomplete candles or not can be checked using the helper script from the Contributor documentation. Due to the danger of repainting, Freqtrade does not allow you to use this incomplete candle. However, if it is based on the need for the latest price for your strategy - then this requirement can be acquired using the data provider from within the strategy. Advanced Freqtrade Exchange configuration \u00b6 Advanced options can be configured using the _ft_has_params setting, which will override Defaults and exchange-specific behavior. Available options are listed in the exchange-class as _ft_has_default . For example, to test the order type FOK with Kraken, and modify candle limit to 200 (so you only get 200 candles per API call): json \"exchange\": { \"name\": \"kraken\", \"_ft_has_params\": { \"order_time_in_force\": [\"gtc\", \"fok\"], \"ohlcv_candle_limit\": 200 } //... } Warning Please make sure to fully understand the impacts of these settings before modifying them.","title":"Exchange-specific Notes"},{"location":"exchanges/#exchange-specific-notes","text":"This page combines common gotchas and informations which are exchange-specific and most likely don't apply to other exchanges.","title":"Exchange-specific Notes"},{"location":"exchanges/#exchange-configuration","text":"Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage . However, the bot was tested by the development team with only a few exchanges. A current list of these can be found in the \"Home\" section of this documentation. Feel free to test other exchanges and submit your feedback or PR to improve the bot or confirm exchanges that work flawlessly.. Some exchanges require special configuration, which can be found below.","title":"Exchange configuration"},{"location":"exchanges/#sample-exchange-configuration","text":"A exchange configuration for \"binance\" would look as follows: json \"exchange\": { \"name\": \"binance\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"ccxt_config\": {}, \"ccxt_async_config\": {}, // ...","title":"Sample exchange configuration"},{"location":"exchanges/#setting-rate-limits","text":"Usually, rate limits set by CCXT are reliable and work well. In case of problems related to rate-limits (usually DDOS Exceptions in your logs), it's easy to change rateLimit settings to other values. json \"exchange\": { \"name\": \"kraken\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"ccxt_config\": {\"enableRateLimit\": true}, \"ccxt_async_config\": { \"enableRateLimit\": true, \"rateLimit\": 3100 }, This configuration enables kraken, as well as rate-limiting to avoid bans from the exchange. \"rateLimit\": 3100 defines a wait-event of 3.1s between each call. This can also be completely disabled by setting \"enableRateLimit\" to false. Note Optimal settings for rate-limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that \"enableRateLimit\" is enabled and increase the \"rateLimit\" parameter step by step.","title":"Setting rate limits"},{"location":"exchanges/#binance","text":"Binance supports time_in_force . Stoploss on Exchange Binance supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange..","title":"Binance"},{"location":"exchanges/#binance-blacklist","text":"For Binance, please add \"BNB/<STAKE>\" to your blacklist to avoid issues. Accounts having BNB accounts use this to pay for fees - if your first trade happens to be on BNB , further trades will consume this position and make the initial BNB trade unsellable as the expected amount is not there anymore.","title":"Binance Blacklist"},{"location":"exchanges/#binance-sites","text":"Binance has been split into 2, and users must use the correct ccxt exchange ID for their exchange, otherwise API keys are not recognized. binance.com - International users. Use exchange id: binance . binance.us - US based users. Use exchange id: binanceus .","title":"Binance sites"},{"location":"exchanges/#kraken","text":"Stoploss on Exchange Kraken supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type to use.","title":"Kraken"},{"location":"exchanges/#historic-kraken-data","text":"The Kraken API does only provide 720 historic candles, which is sufficient for Freqtrade dry-run and live trade modes, but is a problem for backtesting. To download data for the Kraken exchange, using --dl-trades is mandatory, otherwise the bot will download the same 720 candles over and over, and you'll not have enough backtest data. Due to the heavy rate-limiting applied by Kraken, the following configuration section should be used to download data: json \"ccxt_async_config\": { \"enableRateLimit\": true, \"rateLimit\": 3100 }, Downloading data from kraken Downloading kraken data will require significantly more memory (RAM) than any other exchange, as the trades-data needs to be converted into candles on your machine. It will also take a long time, as freqtrade will need to download every single trade that happened on the exchange for the pair / timerange combination, therefore please be patient. rateLimit tuning Please pay attention that rateLimit configuration entry holds delay in milliseconds between requests, NOT requests\\sec rate. So, in order to mitigate Kraken API \"Rate limit exceeded\" exception, this configuration should be increased, NOT decreased.","title":"Historic Kraken data"},{"location":"exchanges/#bittrex","text":"","title":"Bittrex"},{"location":"exchanges/#order-types","text":"Bittrex does not support market orders. If you have a message at the bot startup about this, you should change order type values set in your configuration and/or in the strategy from \"market\" to \"limit\" . See some more details on this here in the FAQ . Bittrex also does not support VolumePairlist due to limited / split API constellation at the moment. Please use StaticPairlist . Other pairlists (other than VolumePairlist ) should not be affected.","title":"Order types"},{"location":"exchanges/#volume-pairlist","text":"Bittrex does not support the direct usage of VolumePairList. This can however be worked around by using the advanced mode with lookback_days: 1 (or more), which will emulate 24h volume. Read more in the pairlist documentation .","title":"Volume pairlist"},{"location":"exchanges/#restricted-markets","text":"Bittrex split its exchange into US and International versions. The International version has more pairs available, however the API always returns all pairs, so there is currently no automated way to detect if you're affected by the restriction. If you have restricted pairs in your whitelist, you'll get a warning message in the log on Freqtrade startup for each restricted pair. The warning message will look similar to the following: output [...] Message: bittrex {\"success\":false,\"message\":\"RESTRICTED_MARKET\",\"result\":null,\"explanation\":null}\" If you're an \"International\" customer on the Bittrex exchange, then this warning will probably not impact you. If you're a US customer, the bot will fail to create orders for these pairs, and you should remove them from your whitelist. You can get a list of restricted markets by using the following snippet: ``` python import ccxt ct = ccxt.bittrex() lm = ct.load_markets() res = [p for p, x in lm.items() if 'US' in x['info']['prohibitedIn']] print(res) ```","title":"Restricted markets"},{"location":"exchanges/#ftx","text":"Stoploss on Exchange FTX supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used.","title":"FTX"},{"location":"exchanges/#using-subaccounts","text":"To use subaccounts with FTX, you need to edit the configuration and add the following: json \"exchange\": { \"ccxt_config\": { \"headers\": { \"FTX-SUBACCOUNT\": \"name\" } }, }","title":"Using subaccounts"},{"location":"exchanges/#kucoin","text":"Kucoin requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: json \"exchange\": { \"name\": \"kucoin\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"password\": \"your_exchange_api_key_password\", // ... } Kucoin supports time_in_force . Stoploss on Exchange Kucoin supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used.","title":"Kucoin"},{"location":"exchanges/#kucoin-blacklists","text":"For Kucoin, please add \"KCS/<STAKE>\" to your blacklist to avoid issues. Accounts having KCS accounts use this to pay for fees - if your first trade happens to be on KCS , further trades will consume this position and make the initial KCS trade unsellable as the expected amount is not there anymore.","title":"Kucoin Blacklists"},{"location":"exchanges/#huobi","text":"Stoploss on Exchange Huobi supports stoploss_on_exchange and uses stop-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.","title":"Huobi"},{"location":"exchanges/#okx-former-okex","text":"OKX requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: json \"exchange\": { \"name\": \"okx\", \"key\": \"your_exchange_key\", \"secret\": \"your_exchange_secret\", \"password\": \"your_exchange_api_key_password\", // ... } Warning OKX only provides 100 candles per api call. Therefore, the strategy will only have a pretty low amount of data available in backtesting mode.","title":"OKX (former OKEX)"},{"location":"exchanges/#gateio","text":"Stoploss on Exchange Gate.io supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Gate.io allows the use of POINT to pay for fees. As this is not a tradable currency (no regular market available), automatic fee calculations will fail (and default to a fee of 0). The configuration parameter exchange.unknown_fee_rate can be used to specify the exchange rate between Point and the stake currency. Obviously, changing the stake-currency will also require changes to this value.","title":"Gate.io"},{"location":"exchanges/#all-exchanges","text":"Should you experience constant errors with Nonce (like InvalidNonce ), it is best to regenerate the API keys. Resetting Nonce is difficult and it's usually easier to regenerate the API keys.","title":"All exchanges"},{"location":"exchanges/#random-notes-for-other-exchanges","text":"The Ocean (exchange id: theocean ) exchange uses Web3 functionality and requires web3 python package to be installed: shell $ pip3 install web3","title":"Random notes for other exchanges"},{"location":"exchanges/#getting-latest-price-incomplete-candles","text":"Most exchanges return current incomplete candle via their OHLCV/klines API interface. By default, Freqtrade assumes that incomplete candle is fetched from the exchange and removes the last candle assuming it's the incomplete candle. Whether your exchange returns incomplete candles or not can be checked using the helper script from the Contributor documentation. Due to the danger of repainting, Freqtrade does not allow you to use this incomplete candle. However, if it is based on the need for the latest price for your strategy - then this requirement can be acquired using the data provider from within the strategy.","title":"Getting latest price / Incomplete candles"},{"location":"exchanges/#advanced-freqtrade-exchange-configuration","text":"Advanced options can be configured using the _ft_has_params setting, which will override Defaults and exchange-specific behavior. Available options are listed in the exchange-class as _ft_has_default . For example, to test the order type FOK with Kraken, and modify candle limit to 200 (so you only get 200 candles per API call): json \"exchange\": { \"name\": \"kraken\", \"_ft_has_params\": { \"order_time_in_force\": [\"gtc\", \"fok\"], \"ohlcv_candle_limit\": 200 } //... } Warning Please make sure to fully understand the impacts of these settings before modifying them.","title":"Advanced Freqtrade Exchange configuration"},{"location":"faq/","text":"Freqtrade FAQ \u00b6 Supported Markets \u00b6 Freqtrade supports spot trading only. Can I open short positions? \u00b6 No, Freqtrade does not support trading with margin / leverage, and cannot open short positions. In some cases, your exchange may provide leveraged spot tokens which can be traded with Freqtrade eg. BTCUP/USD, BTCDOWN/USD, ETHBULL/USD, ETHBEAR/USD, etc... Can I trade options or futures? \u00b6 No, options and futures trading are not supported. Beginner Tips & Tricks \u00b6 When you work with your strategy & hyperopt file you should use a proper code editor like VSCode or PyCharm. A good code editor will provide syntax highlighting as well as line numbers, making it easy to find syntax errors (most likely pointed out by Freqtrade during startup). Freqtrade common issues \u00b6 The bot does not start \u00b6 Running the bot with freqtrade trade --config config.json shows the output freqtrade: command not found . This could be caused by the following reasons: The virtual environment is not active. Run source .env/bin/activate to activate the virtual environment. The installation did not work correctly. Please check the Installation documentation . I have waited 5 minutes, why hasn't the bot made any trades yet? \u00b6 Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find a good entry position for a trade. Be patient! It may be because of a configuration error. It's best to check the logs, they usually tell you if the bot is simply not getting buy signals (only heartbeat messages), or if there is something wrong (errors / exceptions in the log). I have made 12 trades already, why is my total profit negative? \u00b6 I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that the current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades. I\u2019d like to make changes to the config. Can I do that without having to kill the bot? \u00b6 Yes. You can edit your config and use the /reload_config command to reload the configuration. The bot will stop, reload the configuration and strategy and will restart with the new configuration and strategy. Why does my bot not sell everything it bought? \u00b6 This is called \"coin dust\" and can happen on all exchanges. It happens because many exchanges subtract fees from the \"receiving currency\" - so you buy 100 COIN - but you only get 99.9 COIN. As COIN is trading in full lot sizes (1COIN steps), you cannot sell 0.9 COIN (or 99.9 COIN) - but you need to round down to 99 COIN. This is not a bot-problem, but will also happen while manual trading. While freqtrade can handle this (it'll sell 99 COIN), fees are often below the minimum tradable lot-size (you can only trade full COIN, not 0.9 COIN). Leaving the dust (0.9 COIN) on the exchange makes usually sense, as the next time freqtrade buys COIN, it'll eat into the remaining small balance, this time selling everything it bought, and therefore slowly declining the dust balance (although it most likely will never reach exactly 0). Where possible (e.g. on binance), the use of the exchange's dedicated fee currency will fix this. On binance, it's sufficient to have BNB in your account, and have \"Pay fees in BNB\" enabled in your profile. Your BNB balance will slowly decline (as it's used to pay fees) - but you'll no longer encounter dust (Freqtrade will include the fees in the profit calculations). Other exchanges don't offer such possibilities, where it's simply something you'll have to accept or move to a different exchange. I want to use incomplete candles \u00b6 Freqtrade will not provide incomplete candles to strategies. Using incomplete candles will lead to repainting and consequently to strategies with \"ghost\" buys, which are impossible to both backtest, and verify after they happened. You can use \"current\" market data by using the dataprovider 's orderbook or ticker methods - which however cannot be used during backtesting. Is there a setting to only SELL the coins being held and not perform anymore BUYS? \u00b6 You can use the /stopbuy command in Telegram to prevent future buys, followed by /forcesell all (sell all open trades). I want to run multiple bots on the same machine \u00b6 Please look at the advanced setup documentation Page . I'm getting \"Missing data fillup\" messages in the log \u00b6 This message is just a warning that the latest candles had missing candles in them. Depending on the exchange, this can indicate that the pair didn't have a trade for the timeframe you are using - and the exchange does only return candles with volume. On low volume pairs, this is a rather common occurrence. If this happens for all pairs in the pairlist, this might indicate a recent exchange downtime. Please check your exchange's public channels for details. Irrespectively of the reason, Freqtrade will fill up these candles with \"empty\" candles, where open, high, low and close are set to the previous candle close - and volume is empty. In a chart, this will look like a _ - and is aligned with how exchanges usually represent 0 volume candles. I'm getting \"Outdated history for pair xxx\" in the log \u00b6 The bot is trying to tell you that it got an outdated last candle (not the last complete candle). As a consequence, Freqtrade will not enter a trade for this pair - as trading on old information is usually not what is desired. This warning can point to one of the below problems: Exchange downtime -> Check your exchange status page / blog / twitter feed for details. Wrong system time -> Ensure your system-time is correct. Barely traded pair -> Check the pair on the exchange webpage, look at the timeframe your strategy uses. If the pair does not have any volume in some candles (usually visualized with a \"volume 0\" bar, and a \"_\" as candle), this pair did not have any trades in this timeframe. These pairs should ideally be avoided, as they can cause problems with order-filling. API problem -> API returns wrong data (this only here for completeness, and should not happen with supported exchanges). I'm getting the \"RESTRICTED_MARKET\" message in the log \u00b6 Currently known to happen for US Bittrex users. Read the Bittrex section about restricted markets for more information. I'm getting the \"Exchange XXX does not support market orders.\" message and cannot run my strategy \u00b6 As the message says, your exchange does not support market orders and you have one of the order types set to \"market\". Your strategy was probably written with other exchanges in mind and sets \"market\" orders for \"stoploss\" orders, which is correct and preferable for most of the exchanges supporting market orders (but not for Bittrex and Gate.io). To fix this, redefine order types in the strategy to use \"limit\" instead of \"market\": order_types = { ... 'stoploss': 'limit', ... } The same fix should be applied in the configuration file, if order types are defined in your custom config rather than in the strategy. How do I search the bot logs for something? \u00b6 By default, the bot writes its log into stderr stream. This is implemented this way so that you can easily separate the bot's diagnostics messages from Backtesting, Edge and Hyperopt results, output from other various Freqtrade utility sub-commands, as well as from the output of your custom print() 's you may have inserted into your strategy. So if you need to search the log messages with the grep utility, you need to redirect stderr to stdout and disregard stdout. In unix shells, this normally can be done as simple as: shell $ freqtrade --some-options 2>&1 >/dev/null | grep 'something' (note, 2>&1 and >/dev/null should be written in this order) Bash interpreter also supports so called process substitution syntax, you can grep the log for a string with it as: shell $ freqtrade --some-options 2> >(grep 'something') >/dev/null or shell $ freqtrade --some-options 2> >(grep -v 'something' 1>&2) You can also write the copy of Freqtrade log messages to a file with the --logfile option: shell $ freqtrade --logfile /path/to/mylogfile.log --some-options and then grep it as: shell $ cat /path/to/mylogfile.log | grep 'something' or even on the fly, as the bot works and the log file grows: shell $ tail -f /path/to/mylogfile.log | grep 'something' from a separate terminal window. On Windows, the --logfile option is also supported by Freqtrade and you can use the findstr command to search the log for the string of interest: ``` type \\path\\to\\mylogfile.log | findstr \"something\" ``` Hyperopt module \u00b6 Why does freqtrade not have GPU support? \u00b6 First of all, most indicator libraries don't have GPU support - as such, there would be little benefit for indicator calculations. The GPU improvements would only apply to pandas-native calculations - or ones written by yourself. For hyperopt, freqtrade is using scikit-optimize, which is built on top of scikit-learn. Their statement about GPU support is pretty clear . GPU's also are only good at crunching numbers (floating point operations). For hyperopt, we need both number-crunching (find next parameters) and running python code (running backtesting). As such, GPU's are not too well suited for most parts of hyperopt. The benefit of using GPU would therefore be pretty slim - and will not justify the complexity introduced by trying to add GPU support. There is however nothing preventing you from using GPU-enabled indicators within your strategy if you think you must have this - you will however probably be disappointed by the slim gain that will give you (compared to the complexity). How many epochs do I need to get a good Hyperopt result? \u00b6 Per default Hyperopt called without the -e / --epochs command line option will only run 100 epochs, means 100 evaluations of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10000 or more. But it will take an eternity to compute. Since hyperopt uses Bayesian search, running for too many epochs may not produce greater results. It's therefore recommended to run between 500-1000 epochs over and over until you hit at least 10000 epochs in total (or are satisfied with the result). You can best judge by looking at the results - if the bot keeps discovering better strategies, it's best to keep on going. bash freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy SampleStrategy -e 1000 Why does it take a long time to run hyperopt? \u00b6 Discovering a great strategy with Hyperopt takes time. Study www.freqtrade.io , the Freqtrade Documentation page, join the Freqtrade discord community . While you patiently wait for the most advanced, free crypto bot in the world, to hand you a possible golden strategy specially designed just for you. If you wonder why it can take from 20 minutes to days to do 1000 epochs here are some answers: This answer was written during the release 0.15.1, when we had: 8 triggers 9 guards: let's say we evaluate even 10 values from each 1 stoploss calculation: let's say we want 10 values from that too to be evaluated The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evaluations. Did you run 100 000 evaluations? Congrats, you've done roughly 1 / 100 000 th of the search space, assuming that the bot never tests the same parameters more than once. The time it takes to run 1000 hyperopt epochs depends on things like: The available cpu, hard-disk, ram, timeframe, timerange, indicator settings, indicator count, amount of coins that hyperopt test strategies on and the resulting trade count - which can be 650 trades in a year or 100000 trades depending if the strategy aims for big profits by trading rarely or for many low profit trades. Example: 4% profit 650 times vs 0,3% profit a trade 10000 times in a year. If we assume you set the --timerange to 365 days. Example: freqtrade --config config.json --strategy SampleStrategy --hyperopt SampleHyperopt -e 1000 --timerange 20190601-20200601 Edge module \u00b6 Edge implements interesting approach for controlling position size, is there any theory behind it? \u00b6 The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members. You can find further info on expectancy, win rate, risk management and position size in the following sources: https://www.tradeciety.com/ultimate-math-guide-for-traders/ http://www.vantharp.com/tharp-concepts/expectancy.asp https://samuraitradingacademy.com/trading-expectancy/ https://www.learningmarkets.com/determining-expectancy-in-your-trading/ http://www.lonestocktrader.com/make-money-trading-positive-expectancy/ https://www.babypips.com/trading/trade-expectancy-matter","title":"FAQ"},{"location":"faq/#freqtrade-faq","text":"","title":"Freqtrade FAQ"},{"location":"faq/#supported-markets","text":"Freqtrade supports spot trading only.","title":"Supported Markets"},{"location":"faq/#can-i-open-short-positions","text":"No, Freqtrade does not support trading with margin / leverage, and cannot open short positions. In some cases, your exchange may provide leveraged spot tokens which can be traded with Freqtrade eg. BTCUP/USD, BTCDOWN/USD, ETHBULL/USD, ETHBEAR/USD, etc...","title":"Can I open short positions?"},{"location":"faq/#can-i-trade-options-or-futures","text":"No, options and futures trading are not supported.","title":"Can I trade options or futures?"},{"location":"faq/#beginner-tips-tricks","text":"When you work with your strategy & hyperopt file you should use a proper code editor like VSCode or PyCharm. A good code editor will provide syntax highlighting as well as line numbers, making it easy to find syntax errors (most likely pointed out by Freqtrade during startup).","title":"Beginner Tips &amp; Tricks"},{"location":"faq/#freqtrade-common-issues","text":"","title":"Freqtrade common issues"},{"location":"faq/#the-bot-does-not-start","text":"Running the bot with freqtrade trade --config config.json shows the output freqtrade: command not found . This could be caused by the following reasons: The virtual environment is not active. Run source .env/bin/activate to activate the virtual environment. The installation did not work correctly. Please check the Installation documentation .","title":"The bot does not start"},{"location":"faq/#i-have-waited-5-minutes-why-hasnt-the-bot-made-any-trades-yet","text":"Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find a good entry position for a trade. Be patient! It may be because of a configuration error. It's best to check the logs, they usually tell you if the bot is simply not getting buy signals (only heartbeat messages), or if there is something wrong (errors / exceptions in the log).","title":"I have waited 5 minutes, why hasn't the bot made any trades yet?"},{"location":"faq/#i-have-made-12-trades-already-why-is-my-total-profit-negative","text":"I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that the current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades.","title":"I have made 12 trades already, why is my total profit negative?"},{"location":"faq/#id-like-to-make-changes-to-the-config-can-i-do-that-without-having-to-kill-the-bot","text":"Yes. You can edit your config and use the /reload_config command to reload the configuration. The bot will stop, reload the configuration and strategy and will restart with the new configuration and strategy.","title":"I\u2019d like to make changes to the config. Can I do that without having to kill the bot?"},{"location":"faq/#why-does-my-bot-not-sell-everything-it-bought","text":"This is called \"coin dust\" and can happen on all exchanges. It happens because many exchanges subtract fees from the \"receiving currency\" - so you buy 100 COIN - but you only get 99.9 COIN. As COIN is trading in full lot sizes (1COIN steps), you cannot sell 0.9 COIN (or 99.9 COIN) - but you need to round down to 99 COIN. This is not a bot-problem, but will also happen while manual trading. While freqtrade can handle this (it'll sell 99 COIN), fees are often below the minimum tradable lot-size (you can only trade full COIN, not 0.9 COIN). Leaving the dust (0.9 COIN) on the exchange makes usually sense, as the next time freqtrade buys COIN, it'll eat into the remaining small balance, this time selling everything it bought, and therefore slowly declining the dust balance (although it most likely will never reach exactly 0). Where possible (e.g. on binance), the use of the exchange's dedicated fee currency will fix this. On binance, it's sufficient to have BNB in your account, and have \"Pay fees in BNB\" enabled in your profile. Your BNB balance will slowly decline (as it's used to pay fees) - but you'll no longer encounter dust (Freqtrade will include the fees in the profit calculations). Other exchanges don't offer such possibilities, where it's simply something you'll have to accept or move to a different exchange.","title":"Why does my bot not sell everything it bought?"},{"location":"faq/#i-want-to-use-incomplete-candles","text":"Freqtrade will not provide incomplete candles to strategies. Using incomplete candles will lead to repainting and consequently to strategies with \"ghost\" buys, which are impossible to both backtest, and verify after they happened. You can use \"current\" market data by using the dataprovider 's orderbook or ticker methods - which however cannot be used during backtesting.","title":"I want to use incomplete candles"},{"location":"faq/#is-there-a-setting-to-only-sell-the-coins-being-held-and-not-perform-anymore-buys","text":"You can use the /stopbuy command in Telegram to prevent future buys, followed by /forcesell all (sell all open trades).","title":"Is there a setting to only SELL the coins being held and not perform anymore BUYS?"},{"location":"faq/#i-want-to-run-multiple-bots-on-the-same-machine","text":"Please look at the advanced setup documentation Page .","title":"I want to run multiple bots on the same machine"},{"location":"faq/#im-getting-missing-data-fillup-messages-in-the-log","text":"This message is just a warning that the latest candles had missing candles in them. Depending on the exchange, this can indicate that the pair didn't have a trade for the timeframe you are using - and the exchange does only return candles with volume. On low volume pairs, this is a rather common occurrence. If this happens for all pairs in the pairlist, this might indicate a recent exchange downtime. Please check your exchange's public channels for details. Irrespectively of the reason, Freqtrade will fill up these candles with \"empty\" candles, where open, high, low and close are set to the previous candle close - and volume is empty. In a chart, this will look like a _ - and is aligned with how exchanges usually represent 0 volume candles.","title":"I'm getting \"Missing data fillup\" messages in the log"},{"location":"faq/#im-getting-outdated-history-for-pair-xxx-in-the-log","text":"The bot is trying to tell you that it got an outdated last candle (not the last complete candle). As a consequence, Freqtrade will not enter a trade for this pair - as trading on old information is usually not what is desired. This warning can point to one of the below problems: Exchange downtime -> Check your exchange status page / blog / twitter feed for details. Wrong system time -> Ensure your system-time is correct. Barely traded pair -> Check the pair on the exchange webpage, look at the timeframe your strategy uses. If the pair does not have any volume in some candles (usually visualized with a \"volume 0\" bar, and a \"_\" as candle), this pair did not have any trades in this timeframe. These pairs should ideally be avoided, as they can cause problems with order-filling. API problem -> API returns wrong data (this only here for completeness, and should not happen with supported exchanges).","title":"I'm getting \"Outdated history for pair xxx\" in the log"},{"location":"faq/#im-getting-the-restricted_market-message-in-the-log","text":"Currently known to happen for US Bittrex users. Read the Bittrex section about restricted markets for more information.","title":"I'm getting the \"RESTRICTED_MARKET\" message in the log"},{"location":"faq/#im-getting-the-exchange-xxx-does-not-support-market-orders-message-and-cannot-run-my-strategy","text":"As the message says, your exchange does not support market orders and you have one of the order types set to \"market\". Your strategy was probably written with other exchanges in mind and sets \"market\" orders for \"stoploss\" orders, which is correct and preferable for most of the exchanges supporting market orders (but not for Bittrex and Gate.io). To fix this, redefine order types in the strategy to use \"limit\" instead of \"market\": order_types = { ... 'stoploss': 'limit', ... } The same fix should be applied in the configuration file, if order types are defined in your custom config rather than in the strategy.","title":"I'm getting the \"Exchange XXX does not support market orders.\" message and cannot run my strategy"},{"location":"faq/#how-do-i-search-the-bot-logs-for-something","text":"By default, the bot writes its log into stderr stream. This is implemented this way so that you can easily separate the bot's diagnostics messages from Backtesting, Edge and Hyperopt results, output from other various Freqtrade utility sub-commands, as well as from the output of your custom print() 's you may have inserted into your strategy. So if you need to search the log messages with the grep utility, you need to redirect stderr to stdout and disregard stdout. In unix shells, this normally can be done as simple as: shell $ freqtrade --some-options 2>&1 >/dev/null | grep 'something' (note, 2>&1 and >/dev/null should be written in this order) Bash interpreter also supports so called process substitution syntax, you can grep the log for a string with it as: shell $ freqtrade --some-options 2> >(grep 'something') >/dev/null or shell $ freqtrade --some-options 2> >(grep -v 'something' 1>&2) You can also write the copy of Freqtrade log messages to a file with the --logfile option: shell $ freqtrade --logfile /path/to/mylogfile.log --some-options and then grep it as: shell $ cat /path/to/mylogfile.log | grep 'something' or even on the fly, as the bot works and the log file grows: shell $ tail -f /path/to/mylogfile.log | grep 'something' from a separate terminal window. On Windows, the --logfile option is also supported by Freqtrade and you can use the findstr command to search the log for the string of interest: ``` type \\path\\to\\mylogfile.log | findstr \"something\" ```","title":"How do I search the bot logs for something?"},{"location":"faq/#hyperopt-module","text":"","title":"Hyperopt module"},{"location":"faq/#why-does-freqtrade-not-have-gpu-support","text":"First of all, most indicator libraries don't have GPU support - as such, there would be little benefit for indicator calculations. The GPU improvements would only apply to pandas-native calculations - or ones written by yourself. For hyperopt, freqtrade is using scikit-optimize, which is built on top of scikit-learn. Their statement about GPU support is pretty clear . GPU's also are only good at crunching numbers (floating point operations). For hyperopt, we need both number-crunching (find next parameters) and running python code (running backtesting). As such, GPU's are not too well suited for most parts of hyperopt. The benefit of using GPU would therefore be pretty slim - and will not justify the complexity introduced by trying to add GPU support. There is however nothing preventing you from using GPU-enabled indicators within your strategy if you think you must have this - you will however probably be disappointed by the slim gain that will give you (compared to the complexity).","title":"Why does freqtrade not have GPU support?"},{"location":"faq/#how-many-epochs-do-i-need-to-get-a-good-hyperopt-result","text":"Per default Hyperopt called without the -e / --epochs command line option will only run 100 epochs, means 100 evaluations of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10000 or more. But it will take an eternity to compute. Since hyperopt uses Bayesian search, running for too many epochs may not produce greater results. It's therefore recommended to run between 500-1000 epochs over and over until you hit at least 10000 epochs in total (or are satisfied with the result). You can best judge by looking at the results - if the bot keeps discovering better strategies, it's best to keep on going. bash freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy SampleStrategy -e 1000","title":"How many epochs do I need to get a good Hyperopt result?"},{"location":"faq/#why-does-it-take-a-long-time-to-run-hyperopt","text":"Discovering a great strategy with Hyperopt takes time. Study www.freqtrade.io , the Freqtrade Documentation page, join the Freqtrade discord community . While you patiently wait for the most advanced, free crypto bot in the world, to hand you a possible golden strategy specially designed just for you. If you wonder why it can take from 20 minutes to days to do 1000 epochs here are some answers: This answer was written during the release 0.15.1, when we had: 8 triggers 9 guards: let's say we evaluate even 10 values from each 1 stoploss calculation: let's say we want 10 values from that too to be evaluated The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evaluations. Did you run 100 000 evaluations? Congrats, you've done roughly 1 / 100 000 th of the search space, assuming that the bot never tests the same parameters more than once. The time it takes to run 1000 hyperopt epochs depends on things like: The available cpu, hard-disk, ram, timeframe, timerange, indicator settings, indicator count, amount of coins that hyperopt test strategies on and the resulting trade count - which can be 650 trades in a year or 100000 trades depending if the strategy aims for big profits by trading rarely or for many low profit trades. Example: 4% profit 650 times vs 0,3% profit a trade 10000 times in a year. If we assume you set the --timerange to 365 days. Example: freqtrade --config config.json --strategy SampleStrategy --hyperopt SampleHyperopt -e 1000 --timerange 20190601-20200601","title":"Why does it take a long time to run hyperopt?"},{"location":"faq/#edge-module","text":"","title":"Edge module"},{"location":"faq/#edge-implements-interesting-approach-for-controlling-position-size-is-there-any-theory-behind-it","text":"The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members. You can find further info on expectancy, win rate, risk management and position size in the following sources: https://www.tradeciety.com/ultimate-math-guide-for-traders/ http://www.vantharp.com/tharp-concepts/expectancy.asp https://samuraitradingacademy.com/trading-expectancy/ https://www.learningmarkets.com/determining-expectancy-in-your-trading/ http://www.lonestocktrader.com/make-money-trading-positive-expectancy/ https://www.babypips.com/trading/trade-expectancy-matter","title":"Edge implements interesting approach for controlling position size, is there any theory behind it?"},{"location":"hyperopt/","text":"Hyperopt \u00b6 This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses algorithms included in the scikit-optimize package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time. In general, the search for best parameters starts with a few random combinations (see below for more details) and then uses Bayesian search with a ML regressor algorithm (currently ExtraTreesRegressor) to quickly find a combination of parameters in the search hyperspace that minimizes the value of the loss function . Hyperopt requires historic data to be available, just as backtesting does (hyperopt runs backtesting many times with different parameters). To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Bug Hyperopt can crash when used with only 1 CPU Core as found out in Issue #1133 Note Since 2021.4 release you no longer have to write a separate hyperopt class, but can configure the parameters directly in the strategy. The legacy method is still supported, but it is no longer the recommended way of setting up hyperopt. The legacy documentation is available at Legacy Hyperopt . Install hyperopt dependencies \u00b6 Since Hyperopt dependencies are not needed to run the bot itself, are heavy, can not be easily built on some platforms (like Raspberry PI), they are not installed by default. Before you run Hyperopt, you need to install the corresponding dependencies, as described in this section below. Note Since Hyperopt is a resource intensive process, running it on a Raspberry Pi is not recommended nor supported. Docker \u00b6 The docker-image includes hyperopt dependencies, no further action needed. Easy installation script (setup.sh) / Manual installation \u00b6 bash source .env/bin/activate pip install -r requirements-hyperopt.txt Hyperopt command reference \u00b6 ``` usage: freqtrade hyperopt [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--hyperopt-path PATH] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [-e INT] [--spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...]] [--print-all] [--no-color] [--print-json] [-j JOBS] [--random-state INT] [--min-trades INT] [--hyperopt-loss NAME] [--disable-param-export] [--ignore-missing-spaces] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --hyperopt-path PATH Specify additional lookup path for Hyperopt Loss functions. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying max_open_trades during backtest (same as setting max_open_trades to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. -e INT, --epochs INT Specify number of epochs (default: 100). --spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...] Specify which parameters to hyperopt. Space-separated list. --print-all Print all results, not only the best ones. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. -j JOBS, --job-workers JOBS The number of concurrently running jobs for hyperoptimization (hyperopt worker processes). If -1 (default), all CPUs are used, for -2, all CPUs but one are used, etc. If 1 is given, no parallel computing code is used at all. --random-state INT Set random state to some positive integer for reproducible hyperopt results. --min-trades INT Set minimal desired number of trades for evaluations in the hyperopt optimization path (default: 1). --hyperopt-loss NAME, --hyperoptloss NAME Specify the class name of the hyperopt loss function class (IHyperOptLoss). Different functions can generate completely different results, since the target for optimization is different. Built-in Hyperopt-loss-functions are: ShortTradeDurHyperOptLoss, OnlyProfitHyperOptLoss, SharpeHyperOptLoss, SharpeHyperOptLossDaily, SortinoHyperOptLoss, SortinoHyperOptLossDaily, CalmarHyperOptLoss, MaxDrawDownHyperOptLoss, ProfitDrawDownHyperOptLoss --disable-param-export Disable automatic hyperopt parameter export. --ignore-missing-spaces, --ignore-unparameterized-spaces Suppress errors for any requested Hyperopt spaces that do not contain any parameters. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` Hyperopt checklist \u00b6 Checklist on all tasks / possibilities in hyperopt Depending on the space you want to optimize, only some of the below are required: define parameters with space='buy' - for buy signal optimization define parameters with space='sell' - for sell signal optimization Note populate_indicators needs to create all indicators any of the spaces may use, otherwise hyperopt will not work. Rarely you may also need to create a nested class named HyperOpt and implement roi_space - for custom ROI optimization (if you need the ranges for the ROI parameters in the optimization hyperspace that differ from default) generate_roi_table - for custom ROI optimization (if you need the ranges for the values in the ROI table that differ from default or the number of entries (steps) in the ROI table which differs from the default 4 steps) stoploss_space - for custom stoploss optimization (if you need the range for the stoploss parameter in the optimization hyperspace that differs from default) trailing_space - for custom trailing stop optimization (if you need the ranges for the trailing stop parameters in the optimization hyperspace that differ from default) Quickly optimize ROI, stoploss and trailing stoploss You can quickly optimize the spaces roi , stoploss and trailing without changing anything in your strategy. ``` bash Have a working strategy at hand. \u00b6 freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --spaces roi stoploss trailing --strategy MyWorkingStrategy --config config.json -e 100 ``` Hyperopt execution logic \u00b6 Hyperopt will first load your data into memory and will then run populate_indicators() once per Pair to generate all indicators. Hyperopt will then spawn into different processes (number of processors, or -j <n> ), and run backtesting over and over again, changing the parameters that are part of the --spaces defined. For every new set of parameters, freqtrade will run first populate_buy_trend() followed by populate_sell_trend() , and then run the regular backtesting process to simulate trades. After backtesting, the results are passed into the loss function , which will evaluate if this result was better or worse than previous results. Based on the loss function result, hyperopt will determine the next set of parameters to try in the next round of backtesting. Configure your Guards and Triggers \u00b6 There are two places you need to change in your strategy file to add a new buy hyperopt for testing: Define the parameters at the class level hyperopt shall be optimizing. Within populate_buy_trend() - use defined parameter values instead of raw constants. There you have two different types of indicators: 1. guards and 2. triggers . Guards are conditions like \"never buy if ADX < 10\", or never buy if current price is over EMA10. Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower Bollinger band\". Guards and Triggers Technically, there is no difference between Guards and Triggers. However, this guide will make this distinction to make it clear that signals should not be \"sticking\". Sticking signals are signals that are active for multiple candles. This can lead into buying a signal late (right before the signal disappears - which means that the chance of success is a lot lower than right at the beginning). Hyper-optimization will, for each epoch round, pick one trigger and possibly multiple guards. Sell optimization \u00b6 Similar to the buy-signal above, sell-signals can also be optimized. Place the corresponding settings into the following methods Define the parameters at the class level hyperopt shall be optimizing, either naming them sell_* , or by explicitly defining space='sell' . Within populate_sell_trend() - use defined parameter values instead of raw constants. The configuration and rules are the same than for buy signals. Solving a Mystery \u00b6 Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your buys. And you also wonder should you use RSI or ADX to help with those buy decisions. If you decide to use RSI or ADX, which values should I use for them? So let's use hyperparameter optimization to solve this mystery. Defining indicators to be used \u00b6 We start by calculating the indicators our strategy is going to use. ``` python class MyAwesomeStrategy(IStrategy): def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Generate all indicators used by the strategy \"\"\" dataframe['adx'] = ta.ADX(dataframe) dataframe['rsi'] = ta.RSI(dataframe) macd = ta.MACD(dataframe) dataframe['macd'] = macd['macd'] dataframe['macdsignal'] = macd['macdsignal'] dataframe['macdhist'] = macd['macdhist'] bollinger = ta.BBANDS(dataframe, timeperiod=20, nbdevup=2.0, nbdevdn=2.0) dataframe['bb_lowerband'] = bollinger['lowerband'] dataframe['bb_middleband'] = bollinger['middleband'] dataframe['bb_upperband'] = bollinger['upperband'] return dataframe ``` Hyperoptable parameters \u00b6 We continue to define hyperoptable parameters: python class MyAwesomeStrategy(IStrategy): buy_adx = DecimalParameter(20, 40, decimals=1, default=30.1, space=\"buy\") buy_rsi = IntParameter(20, 40, default=30, space=\"buy\") buy_adx_enabled = BooleanParameter(default=True, space=\"buy\") buy_rsi_enabled = CategoricalParameter([True, False], default=False, space=\"buy\") buy_trigger = CategoricalParameter([\"bb_lower\", \"macd_cross_signal\"], default=\"bb_lower\", space=\"buy\") The above definition says: I have five parameters I want to randomly combine to find the best combination. buy_rsi is an integer parameter, which will be tested between 20 and 40. This space has a size of 20. buy_adx is a decimal parameter, which will be evaluated between 20 and 40 with 1 decimal place (so values are 20.1, 20.2, ...). This space has a size of 200. Then we have three category variables. First two are either True or False . We use these to either enable or disable the ADX and RSI guards. The last one we call trigger and use it to decide which buy trigger we want to use. Parameter space assignment Parameters must either be assigned to a variable named buy_* or sell_* - or contain space='buy' | space='sell' to be assigned to a space correctly. If no parameter is available for a space, you'll receive the error that no space was found when running hyperopt. So let's write the buy strategy using these values: ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] # GUARDS AND TRENDS if self.buy_adx_enabled.value: conditions.append(dataframe['adx'] > self.buy_adx.value) if self.buy_rsi_enabled.value: conditions.append(dataframe['rsi'] < self.buy_rsi.value) # TRIGGERS if self.buy_trigger.value == 'bb_lower': conditions.append(dataframe['close'] < dataframe['bb_lowerband']) if self.buy_trigger.value == 'macd_cross_signal': conditions.append(qtpylib.crossed_above( dataframe['macd'], dataframe['macdsignal'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'buy'] = 1 return dataframe ``` Hyperopt will now call populate_buy_trend() many times ( epochs ) with different value combinations. It will use the given historical data and simulate buys based on the buy signals generated with the above function. Based on the results, hyperopt will tell you which parameter combination produced the best results (based on the configured loss function ). Note The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the populate_indicators() method in your strategy or hyperopt file. Parameter types \u00b6 There are four parameter types each suited for different purposes. IntParameter - defines an integral parameter with upper and lower boundaries of search space. DecimalParameter - defines a floating point parameter with a limited number of decimals (default 3). Should be preferred instead of RealParameter in most cases. RealParameter - defines a floating point parameter with upper and lower boundaries and no precision limit. Rarely used as it creates a space with a near infinite number of possibilities. CategoricalParameter - defines a parameter with a predetermined number of choices. BooleanParameter - Shorthand for CategoricalParameter([True, False]) - great for \"enable\" parameters. Disabling parameter optimization Each parameter takes two boolean parameters: * load - when set to False it will not load values configured in buy_params and sell_params . * optimize - when set to False parameter will not be included in optimization process. Use these parameters to quickly prototype various ideas. Warning Hyperoptable parameters cannot be used in populate_indicators - as hyperopt does not recalculate indicators for each epoch, so the starting value would be used in this case. Optimizing an indicator parameter \u00b6 Assuming you have a simple strategy in mind - a EMA cross strategy (2 Moving averages crossing) - and you'd like to find the ideal parameters for this strategy. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces buy_ema_short = IntParameter(3, 50, default=5) buy_ema_long = IntParameter(15, 200, default=50) def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\"Generate all indicators used by the strategy\"\"\" # Calculate all ema_short values for val in self.buy_ema_short.range: dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val) # Calculate all ema_long values for val in self.buy_ema_long.range: dataframe[f'ema_long_{val}'] = ta.EMA(dataframe, timeperiod=val) return dataframe def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] conditions.append(qtpylib.crossed_above( dataframe[f'ema_short_{self.buy_ema_short.value}'], dataframe[f'ema_long_{self.buy_ema_long.value}'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'buy'] = 1 return dataframe def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] conditions.append(qtpylib.crossed_above( dataframe[f'ema_long_{self.buy_ema_long.value}'], dataframe[f'ema_short_{self.buy_ema_short.value}'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'sell'] = 1 return dataframe ``` Breaking it down: Using self.buy_ema_short.range will return a range object containing all entries between the Parameters low and high value. In this case ( IntParameter(3, 50, default=5) ), the loop would run for all numbers between 3 and 50 ( [3, 4, 5, ... 49, 50] ). By using this in a loop, hyperopt will generate 48 new columns ( ['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50'] ). Hyperopt itself will then use the selected value to create the buy and sell signals While this strategy is most likely too simple to provide consistent profit, it should serve as an example how optimize indicator parameters. Note self.buy_ema_short.range will act differently between hyperopt and other modes. For hyperopt, the above example may generate 48 new columns, however for all other modes (backtesting, dry/live), it will only generate the column for the selected value. You should therefore avoid using the resulting column with explicit values (values other than self.buy_ema_short.value ). Note range property may also be used with DecimalParameter and CategoricalParameter . RealParameter does not provide this property due to infinite search space. Performance tip By doing the calculation of all possible indicators in populate_indicators() , the calculation of the indicator happens only once for every parameter. While this may slow down the hyperopt startup speed, the overall performance will increase as the Hyperopt execution itself may pick the same value for multiple epochs (changing other values). You should however try to use space ranges as small as possible. Every new column will require more memory, and every possibility hyperopt can try will increase the search space. Optimizing protections \u00b6 Freqtrade can also optimize protections. How you optimize protections is up to you, and the following should be considered as example only. The strategy will simply need to define the \"protections\" entry as property returning a list of protection configurations. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces cooldown_lookback = IntParameter(2, 48, default=5, space=\"protection\", optimize=True) stop_duration = IntParameter(12, 200, default=5, space=\"protection\", optimize=True) use_stop_protection = BooleanParameter(default=True, space=\"protection\", optimize=True) @property def protections(self): prot = [] prot.append({ \"method\": \"CooldownPeriod\", \"stop_duration_candles\": self.cooldown_lookback.value }) if self.use_stop_protection.value: prot.append({ \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24 * 3, \"trade_limit\": 4, \"stop_duration_candles\": self.stop_duration.value, \"only_per_pair\": False }) return prot def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # ... ``` You can then run hyperopt as follows: freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection Note The protection space is not part of the default space, and is only available with the Parameters Hyperopt interface, not with the legacy hyperopt interface (which required separate hyperopt files). Freqtrade will also automatically change the \"--enable-protections\" flag if the protection space is selected. Warning If protections are defined as property, entries from the configuration will be ignored. It is therefore recommended to not define protections in the configuration. Migrating from previous property setups \u00b6 A migration from a previous setup is pretty simple, and can be accomplished by converting the protections entry to a property. In simple terms, the following configuration will be converted to the below. python class MyAwesomeStrategy(IStrategy): protections = [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 4 } ] Result ``` python class MyAwesomeStrategy(IStrategy): @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 4 } ] ``` You will then obviously also change potential interesting entries to parameters to allow hyper-optimization. Optimizing max_entry_position_adjustment \u00b6 While max_entry_position_adjustment is not a separate space, it can still be used in hyperopt by using the property approach shown above. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces max_epa = CategoricalParameter([-1, 0, 1, 3, 5, 10], default=1, space=\"buy\", optimize=True) @property def max_entry_position_adjustment(self): return self.max_epa.value def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # ... ``` Using IntParameter You can also use the IntParameter for this optimization, but you must explicitly return an integer: ``` python max_epa = IntParameter(-1, 10, default=1, space=\"buy\", optimize=True) @property def max_entry_position_adjustment(self): return int(self.max_epa.value) ``` Loss-functions \u00b6 Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results. A loss function must be specified via the --hyperopt-loss <Class-name> argument (or optionally via the configuration under the \"hyperopt_loss\" key). This class should be in its own file within the user_data/hyperopts/ directory. Currently, the following loss functions are builtin: ShortTradeDurHyperOptLoss - (default legacy Freqtrade hyperoptimization loss function) - Mostly for short trade duration and avoiding losses. OnlyProfitHyperOptLoss - takes only amount of profit into consideration. SharpeHyperOptLoss - optimizes Sharpe Ratio calculated on trade returns relative to standard deviation. SharpeHyperOptLossDaily - optimizes Sharpe Ratio calculated on daily trade returns relative to standard deviation. SortinoHyperOptLoss - optimizes Sortino Ratio calculated on trade returns relative to downside standard deviation. SortinoHyperOptLossDaily - optimizes Sortino Ratio calculated on daily trade returns relative to downside standard deviation. MaxDrawDownHyperOptLoss - Optimizes Maximum drawdown. CalmarHyperOptLoss - Optimizes Calmar Ratio calculated on trade returns relative to max drawdown. ProfitDrawDownHyperOptLoss - Optimizes by max Profit & min Drawdown objective. DRAWDOWN_MULT variable within the hyperoptloss file can be adjusted to be stricter or more flexible on drawdown purposes. Creation of a custom loss function is covered in the Advanced Hyperopt part of the documentation. Execute Hyperopt \u00b6 Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result. We strongly recommend to use screen or tmux to prevent any connection loss. bash freqtrade hyperopt --config config.json --hyperopt-loss <hyperoptlossname> --strategy <strategyname> -e 500 --spaces all The -e option will set how many evaluations hyperopt will do. Since hyperopt uses Bayesian search, running too many epochs at once may not produce greater results. Experience has shown that best results are usually not improving much after 500-1000 epochs. Doing multiple runs (executions) with a few 1000 epochs and different random state will most likely produce different results. The --spaces all option determines that all possible parameters should be optimized. Possibilities are listed below. Note Hyperopt will store hyperopt results with the timestamp of the hyperopt start time. Reading commands ( hyperopt-list , hyperopt-show ) can use --hyperopt-filename <filename> to read and display older hyperopt results. You can find a list of filenames with ls -l user_data/hyperopt_results/ . Execute Hyperopt with different historical data source \u00b6 If you would like to hyperopt parameters using an alternate historical data set that you have on-disk, use the --datadir PATH option. By default, hyperopt uses data from directory user_data/data . Running Hyperopt with a smaller test-set \u00b6 Use the --timerange argument to change how much of the test-set you want to use. For example, to use one month of data, pass --timerange 20210101-20210201 (from january 2021 - february 2021) to the hyperopt call. Full command: bash freqtrade hyperopt --strategy <strategyname> --timerange 20210101-20210201 Running Hyperopt with Smaller Search Space \u00b6 Use the --spaces option to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have. Legal values are: all : optimize everything buy : just search for a new buy strategy sell : just search for a new sell strategy roi : just optimize the minimal profit table for your strategy stoploss : search for the best stoploss value trailing : search for the best trailing stop values protection : search for the best protection parameters (read the protections section on how to properly define these) default : all except trailing and protection space-separated list of any of the above values for example --spaces roi stoploss The default Hyperopt Search Space, used when no --space command line option is specified, does not include the trailing hyperspace. We recommend you to run optimization for the trailing hyperspace separately, when the best parameters for other hyperspaces were found, validated and pasted into your custom strategy. Understand the Hyperopt Result \u00b6 Once Hyperopt is completed you can use the result to update your strategy. Given the following result from hyperopt: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } ``` You should understand this result like: The buy trigger that worked best was bb_lower . You should not use ADX because 'buy_adx_enabled': False . You should consider using the RSI indicator ( 'buy_rsi_enabled': True ) and the best value is 29.0 ( 'buy_rsi': 29.0 ) Automatic parameter application to the strategy \u00b6 When using Hyperoptable parameters, the result of your hyperopt-run will be written to a json file next to your strategy (so for MyAwesomeStrategy.py , the file would be MyAwesomeStrategy.json ). This file is also updated when using the hyperopt-show sub-command, unless --disable-param-export is provided to either of the 2 commands. Your strategy class can also contain these results explicitly. Simply copy hyperopt results block and paste them at class level, replacing old parameters (if any). New parameters will automatically be loaded next time strategy is executed. Transferring your whole hyperopt result to your strategy would then look like: python class MyAwesomeStrategy(IStrategy): # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } Note Values in the configuration file will overwrite Parameter-file level parameters - and both will overwrite parameters within the strategy. The prevalence is therefore: config > parameter file > strategy Understand Hyperopt ROI results \u00b6 If you are optimizing ROI (i.e. if optimization search-space contains 'all', 'default' or 'roi'), your result will look as follows and include a ROI table: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # ROI table: minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } ``` In order to use this best ROI table found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the minimal_roi attribute of your custom strategy: # Minimal ROI designed for the strategy. # This attribute will be overridden if the config file contains \"minimal_roi\" minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } As stated in the comment, you can also use it as the value of the minimal_roi setting in the configuration file. Default ROI Search Space \u00b6 If you are optimizing ROI, Freqtrade creates the 'roi' optimization hyperspace for you -- it's the hyperspace of components for the ROI tables. By default, each ROI table generated by the Freqtrade consists of 4 rows (steps). Hyperopt implements adaptive ranges for ROI tables with ranges for values in the ROI steps that depend on the timeframe used. By default the values vary in the following ranges (for some of the most used timeframes, values are rounded to 3 digits after the decimal point): # step 1m 5m 1h 1d 1 0 0.011...0.119 0 0.03...0.31 0 0.068...0.711 0 0.121...1.258 2 2...8 0.007...0.042 10...40 0.02...0.11 120...480 0.045...0.252 2880...11520 0.081...0.446 3 4...20 0.003...0.015 20...100 0.01...0.04 240...1200 0.022...0.091 5760...28800 0.040...0.162 4 6...44 0.0 30...220 0.0 360...2640 0.0 8640...63360 0.0 These ranges should be sufficient in most cases. The minutes in the steps (ROI dict keys) are scaled linearly depending on the timeframe used. The ROI values in the steps (ROI dict values) are scaled logarithmically depending on the timeframe used. If you have the generate_roi_table() and roi_space() methods in your custom hyperopt, remove them in order to utilize these adaptive ROI tables and the ROI hyperoptimization space generated by Freqtrade by default. Override the roi_space() method if you need components of the ROI tables to vary in other ranges. Override the generate_roi_table() and roi_space() methods and implement your own custom approach for generation of the ROI tables during hyperoptimization if you need a different structure of the ROI tables or other amount of rows (steps). A sample for these methods can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Understand Hyperopt Stoploss results \u00b6 If you are optimizing stoploss values (i.e. if optimization search-space contains 'all', 'default' or 'stoploss'), your result will look as follows and include stoploss: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } stoploss: -0.27996 ``` In order to use this best stoploss value found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the stoploss attribute of your custom strategy: python # Optimal stoploss designed for the strategy # This attribute will be overridden if the config file contains \"stoploss\" stoploss = -0.27996 As stated in the comment, you can also use it as the value of the stoploss setting in the configuration file. Default Stoploss Search Space \u00b6 If you are optimizing stoploss values, Freqtrade creates the 'stoploss' optimization hyperspace for you. By default, the stoploss values in that hyperspace vary in the range -0.35...-0.02, which is sufficient in most cases. If you have the stoploss_space() method in your custom hyperopt file, remove it in order to utilize Stoploss hyperoptimization space generated by Freqtrade by default. Override the stoploss_space() method and define the desired range in it if you need stoploss values to vary in other range during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Understand Hyperopt Trailing Stop results \u00b6 If you are optimizing trailing stop values (i.e. if optimization search-space contains 'all' or 'trailing'), your result will look as follows and include trailing stop parameters: ``` Best result: 45/100: 606 trades. Avg profit 1.04%. Total profit 0.31555614 BTC ( 630.48%). Avg duration 150.3 mins. Objective: -1.10161 # Trailing stop: trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True ``` In order to use these best trailing stop parameters found by Hyperopt in backtesting and for live trades/dry-run, copy-paste them as the values of the corresponding attributes of your custom strategy: python # Trailing stop # These attributes will be overridden if the config file contains corresponding values. trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True As stated in the comment, you can also use it as the values of the corresponding settings in the configuration file. Default Trailing Stop Search Space \u00b6 If you are optimizing trailing stop values, Freqtrade creates the 'trailing' optimization hyperspace for you. By default, the trailing_stop parameter is always set to True in that hyperspace, the value of the trailing_only_offset_is_reached vary between True and False, the values of the trailing_stop_positive and trailing_stop_positive_offset parameters vary in the ranges 0.02...0.35 and 0.01...0.1 correspondingly, which is sufficient in most cases. Override the trailing_space() method and define the desired range in it if you need values of the trailing stop parameters to vary in other ranges during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Reproducible results \u00b6 The search for optimal parameters starts with a few (currently 30) random combinations in the hyperspace of parameters, random Hyperopt epochs. These random epochs are marked with an asterisk character ( * ) in the first column in the Hyperopt output. The initial state for generation of these random values (random state) is controlled by the value of the --random-state command line option. You can set it to some arbitrary value of your choice to obtain reproducible results. If you have not set this value explicitly in the command line options, Hyperopt seeds the random state with some random value for you. The random state value for each Hyperopt run is shown in the log, so you can copy and paste it into the --random-state command line option to repeat the set of the initial random epochs used. If you have not changed anything in the command line options, configuration, timerange, Strategy and Hyperopt classes, historical data and the Loss Function -- you should obtain same hyper-optimization results with same random state value used. Output formatting \u00b6 By default, hyperopt prints colorized results -- epochs with positive profit are printed in the green color. This highlighting helps you find epochs that can be interesting for later analysis. Epochs with zero total profit or with negative profits (losses) are printed in the normal color. If you do not need colorization of results (for instance, when you are redirecting hyperopt output to a file) you can switch colorization off by specifying the --no-color option in the command line. You can use the --print-all command line option if you would like to see all results in the hyperopt output, not only the best ones. When --print-all is used, current best results are also colorized by default -- they are printed in bold (bright) style. This can also be switched off with the --no-color command line option. Windows and color output Windows does not support color-output natively, therefore it is automatically disabled. To have color-output for hyperopt running under windows, please consider using WSL. Position stacking and disabling max market positions \u00b6 In some situations, you may need to run Hyperopt (and Backtesting) with the --eps / --enable-position-staking and --dmmp / --disable-max-market-positions arguments. By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs is also limited by the max_open_trades setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previously open trades. The --eps / --enable-position-stacking argument allows emulation of buying the same pair multiple times, while --dmmp / --disable-max-market-positions disables applying max_open_trades during Hyperopt/Backtesting (which is equal to setting max_open_trades to a very high number). Note Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality. You can also enable position stacking in the configuration file by explicitly setting \"position_stacking\"=true . Out of Memory errors \u00b6 As hyperopt consumes a lot of memory (the complete data needs to be in memory once per parallel backtesting process), it's likely that you run into \"out of memory\" errors. To combat these, you have multiple options: reduce the amount of pairs reduce the timerange used ( --timerange <timerange> ) reduce the number of parallel processes ( -j <n> ) Increase the memory of your machine Show details of Hyperopt results \u00b6 After you run Hyperopt for the desired amount of epochs, you can later list all results for analysis, select only best or profitable once, and show the details for any of the epochs previously evaluated. This can be done with the hyperopt-list and hyperopt-show sub-commands. The usage of these sub-commands is described in the Utils chapter. Validate backtesting results \u00b6 Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected. To achieve same the results (number of trades, their durations, profit, etc.) as during Hyperopt, please use the same configuration and parameters (timerange, timeframe, ...) used for hyperopt --dmmp / --disable-max-market-positions and --eps / --enable-position-stacking for Backtesting. Should results not match, please double-check to make sure you transferred all conditions correctly. Pay special care to the stoploss (and trailing stoploss) parameters, as these are often set in configuration files, which override changes to the strategy. You should also carefully review the log of your backtest to ensure that there were no parameters inadvertently set by the configuration (like stoploss or trailing_stop ).","title":"Hyperopt"},{"location":"hyperopt/#hyperopt","text":"This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses algorithms included in the scikit-optimize package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time. In general, the search for best parameters starts with a few random combinations (see below for more details) and then uses Bayesian search with a ML regressor algorithm (currently ExtraTreesRegressor) to quickly find a combination of parameters in the search hyperspace that minimizes the value of the loss function . Hyperopt requires historic data to be available, just as backtesting does (hyperopt runs backtesting many times with different parameters). To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Bug Hyperopt can crash when used with only 1 CPU Core as found out in Issue #1133 Note Since 2021.4 release you no longer have to write a separate hyperopt class, but can configure the parameters directly in the strategy. The legacy method is still supported, but it is no longer the recommended way of setting up hyperopt. The legacy documentation is available at Legacy Hyperopt .","title":"Hyperopt"},{"location":"hyperopt/#install-hyperopt-dependencies","text":"Since Hyperopt dependencies are not needed to run the bot itself, are heavy, can not be easily built on some platforms (like Raspberry PI), they are not installed by default. Before you run Hyperopt, you need to install the corresponding dependencies, as described in this section below. Note Since Hyperopt is a resource intensive process, running it on a Raspberry Pi is not recommended nor supported.","title":"Install hyperopt dependencies"},{"location":"hyperopt/#docker","text":"The docker-image includes hyperopt dependencies, no further action needed.","title":"Docker"},{"location":"hyperopt/#easy-installation-script-setupsh-manual-installation","text":"bash source .env/bin/activate pip install -r requirements-hyperopt.txt","title":"Easy installation script (setup.sh) / Manual installation"},{"location":"hyperopt/#hyperopt-command-reference","text":"``` usage: freqtrade hyperopt [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--hyperopt-path PATH] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [-e INT] [--spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...]] [--print-all] [--no-color] [--print-json] [-j JOBS] [--random-state INT] [--min-trades INT] [--hyperopt-loss NAME] [--disable-param-export] [--ignore-missing-spaces] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: json ). --max-open-trades INT Override the value of the max_open_trades configuration setting. --stake-amount STAKE_AMOUNT Override the value of the stake_amount configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --hyperopt-path PATH Specify additional lookup path for Hyperopt Loss functions. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying max_open_trades during backtest (same as setting max_open_trades to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. -e INT, --epochs INT Specify number of epochs (default: 100). --spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...] Specify which parameters to hyperopt. Space-separated list. --print-all Print all results, not only the best ones. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. -j JOBS, --job-workers JOBS The number of concurrently running jobs for hyperoptimization (hyperopt worker processes). If -1 (default), all CPUs are used, for -2, all CPUs but one are used, etc. If 1 is given, no parallel computing code is used at all. --random-state INT Set random state to some positive integer for reproducible hyperopt results. --min-trades INT Set minimal desired number of trades for evaluations in the hyperopt optimization path (default: 1). --hyperopt-loss NAME, --hyperoptloss NAME Specify the class name of the hyperopt loss function class (IHyperOptLoss). Different functions can generate completely different results, since the target for optimization is different. Built-in Hyperopt-loss-functions are: ShortTradeDurHyperOptLoss, OnlyProfitHyperOptLoss, SharpeHyperOptLoss, SharpeHyperOptLossDaily, SortinoHyperOptLoss, SortinoHyperOptLossDaily, CalmarHyperOptLoss, MaxDrawDownHyperOptLoss, ProfitDrawDownHyperOptLoss --disable-param-export Disable automatic hyperopt parameter export. --ignore-missing-spaces, --ignore-unparameterized-spaces Suppress errors for any requested Hyperopt spaces that do not contain any parameters. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ```","title":"Hyperopt command reference"},{"location":"hyperopt/#hyperopt-checklist","text":"Checklist on all tasks / possibilities in hyperopt Depending on the space you want to optimize, only some of the below are required: define parameters with space='buy' - for buy signal optimization define parameters with space='sell' - for sell signal optimization Note populate_indicators needs to create all indicators any of the spaces may use, otherwise hyperopt will not work. Rarely you may also need to create a nested class named HyperOpt and implement roi_space - for custom ROI optimization (if you need the ranges for the ROI parameters in the optimization hyperspace that differ from default) generate_roi_table - for custom ROI optimization (if you need the ranges for the values in the ROI table that differ from default or the number of entries (steps) in the ROI table which differs from the default 4 steps) stoploss_space - for custom stoploss optimization (if you need the range for the stoploss parameter in the optimization hyperspace that differs from default) trailing_space - for custom trailing stop optimization (if you need the ranges for the trailing stop parameters in the optimization hyperspace that differ from default) Quickly optimize ROI, stoploss and trailing stoploss You can quickly optimize the spaces roi , stoploss and trailing without changing anything in your strategy. ``` bash","title":"Hyperopt checklist"},{"location":"hyperopt/#have-a-working-strategy-at-hand","text":"freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --spaces roi stoploss trailing --strategy MyWorkingStrategy --config config.json -e 100 ```","title":"Have a working strategy at hand."},{"location":"hyperopt/#hyperopt-execution-logic","text":"Hyperopt will first load your data into memory and will then run populate_indicators() once per Pair to generate all indicators. Hyperopt will then spawn into different processes (number of processors, or -j <n> ), and run backtesting over and over again, changing the parameters that are part of the --spaces defined. For every new set of parameters, freqtrade will run first populate_buy_trend() followed by populate_sell_trend() , and then run the regular backtesting process to simulate trades. After backtesting, the results are passed into the loss function , which will evaluate if this result was better or worse than previous results. Based on the loss function result, hyperopt will determine the next set of parameters to try in the next round of backtesting.","title":"Hyperopt execution logic"},{"location":"hyperopt/#configure-your-guards-and-triggers","text":"There are two places you need to change in your strategy file to add a new buy hyperopt for testing: Define the parameters at the class level hyperopt shall be optimizing. Within populate_buy_trend() - use defined parameter values instead of raw constants. There you have two different types of indicators: 1. guards and 2. triggers . Guards are conditions like \"never buy if ADX < 10\", or never buy if current price is over EMA10. Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower Bollinger band\". Guards and Triggers Technically, there is no difference between Guards and Triggers. However, this guide will make this distinction to make it clear that signals should not be \"sticking\". Sticking signals are signals that are active for multiple candles. This can lead into buying a signal late (right before the signal disappears - which means that the chance of success is a lot lower than right at the beginning). Hyper-optimization will, for each epoch round, pick one trigger and possibly multiple guards.","title":"Configure your Guards and Triggers"},{"location":"hyperopt/#sell-optimization","text":"Similar to the buy-signal above, sell-signals can also be optimized. Place the corresponding settings into the following methods Define the parameters at the class level hyperopt shall be optimizing, either naming them sell_* , or by explicitly defining space='sell' . Within populate_sell_trend() - use defined parameter values instead of raw constants. The configuration and rules are the same than for buy signals.","title":"Sell optimization"},{"location":"hyperopt/#solving-a-mystery","text":"Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your buys. And you also wonder should you use RSI or ADX to help with those buy decisions. If you decide to use RSI or ADX, which values should I use for them? So let's use hyperparameter optimization to solve this mystery.","title":"Solving a Mystery"},{"location":"hyperopt/#defining-indicators-to-be-used","text":"We start by calculating the indicators our strategy is going to use. ``` python class MyAwesomeStrategy(IStrategy): def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Generate all indicators used by the strategy \"\"\" dataframe['adx'] = ta.ADX(dataframe) dataframe['rsi'] = ta.RSI(dataframe) macd = ta.MACD(dataframe) dataframe['macd'] = macd['macd'] dataframe['macdsignal'] = macd['macdsignal'] dataframe['macdhist'] = macd['macdhist'] bollinger = ta.BBANDS(dataframe, timeperiod=20, nbdevup=2.0, nbdevdn=2.0) dataframe['bb_lowerband'] = bollinger['lowerband'] dataframe['bb_middleband'] = bollinger['middleband'] dataframe['bb_upperband'] = bollinger['upperband'] return dataframe ```","title":"Defining indicators to be used"},{"location":"hyperopt/#hyperoptable-parameters","text":"We continue to define hyperoptable parameters: python class MyAwesomeStrategy(IStrategy): buy_adx = DecimalParameter(20, 40, decimals=1, default=30.1, space=\"buy\") buy_rsi = IntParameter(20, 40, default=30, space=\"buy\") buy_adx_enabled = BooleanParameter(default=True, space=\"buy\") buy_rsi_enabled = CategoricalParameter([True, False], default=False, space=\"buy\") buy_trigger = CategoricalParameter([\"bb_lower\", \"macd_cross_signal\"], default=\"bb_lower\", space=\"buy\") The above definition says: I have five parameters I want to randomly combine to find the best combination. buy_rsi is an integer parameter, which will be tested between 20 and 40. This space has a size of 20. buy_adx is a decimal parameter, which will be evaluated between 20 and 40 with 1 decimal place (so values are 20.1, 20.2, ...). This space has a size of 200. Then we have three category variables. First two are either True or False . We use these to either enable or disable the ADX and RSI guards. The last one we call trigger and use it to decide which buy trigger we want to use. Parameter space assignment Parameters must either be assigned to a variable named buy_* or sell_* - or contain space='buy' | space='sell' to be assigned to a space correctly. If no parameter is available for a space, you'll receive the error that no space was found when running hyperopt. So let's write the buy strategy using these values: ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] # GUARDS AND TRENDS if self.buy_adx_enabled.value: conditions.append(dataframe['adx'] > self.buy_adx.value) if self.buy_rsi_enabled.value: conditions.append(dataframe['rsi'] < self.buy_rsi.value) # TRIGGERS if self.buy_trigger.value == 'bb_lower': conditions.append(dataframe['close'] < dataframe['bb_lowerband']) if self.buy_trigger.value == 'macd_cross_signal': conditions.append(qtpylib.crossed_above( dataframe['macd'], dataframe['macdsignal'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'buy'] = 1 return dataframe ``` Hyperopt will now call populate_buy_trend() many times ( epochs ) with different value combinations. It will use the given historical data and simulate buys based on the buy signals generated with the above function. Based on the results, hyperopt will tell you which parameter combination produced the best results (based on the configured loss function ). Note The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the populate_indicators() method in your strategy or hyperopt file.","title":"Hyperoptable parameters"},{"location":"hyperopt/#parameter-types","text":"There are four parameter types each suited for different purposes. IntParameter - defines an integral parameter with upper and lower boundaries of search space. DecimalParameter - defines a floating point parameter with a limited number of decimals (default 3). Should be preferred instead of RealParameter in most cases. RealParameter - defines a floating point parameter with upper and lower boundaries and no precision limit. Rarely used as it creates a space with a near infinite number of possibilities. CategoricalParameter - defines a parameter with a predetermined number of choices. BooleanParameter - Shorthand for CategoricalParameter([True, False]) - great for \"enable\" parameters. Disabling parameter optimization Each parameter takes two boolean parameters: * load - when set to False it will not load values configured in buy_params and sell_params . * optimize - when set to False parameter will not be included in optimization process. Use these parameters to quickly prototype various ideas. Warning Hyperoptable parameters cannot be used in populate_indicators - as hyperopt does not recalculate indicators for each epoch, so the starting value would be used in this case.","title":"Parameter types"},{"location":"hyperopt/#optimizing-an-indicator-parameter","text":"Assuming you have a simple strategy in mind - a EMA cross strategy (2 Moving averages crossing) - and you'd like to find the ideal parameters for this strategy. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces buy_ema_short = IntParameter(3, 50, default=5) buy_ema_long = IntParameter(15, 200, default=50) def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\"Generate all indicators used by the strategy\"\"\" # Calculate all ema_short values for val in self.buy_ema_short.range: dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val) # Calculate all ema_long values for val in self.buy_ema_long.range: dataframe[f'ema_long_{val}'] = ta.EMA(dataframe, timeperiod=val) return dataframe def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] conditions.append(qtpylib.crossed_above( dataframe[f'ema_short_{self.buy_ema_short.value}'], dataframe[f'ema_long_{self.buy_ema_long.value}'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'buy'] = 1 return dataframe def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: conditions = [] conditions.append(qtpylib.crossed_above( dataframe[f'ema_long_{self.buy_ema_long.value}'], dataframe[f'ema_short_{self.buy_ema_short.value}'] )) # Check that volume is not 0 conditions.append(dataframe['volume'] > 0) if conditions: dataframe.loc[ reduce(lambda x, y: x & y, conditions), 'sell'] = 1 return dataframe ``` Breaking it down: Using self.buy_ema_short.range will return a range object containing all entries between the Parameters low and high value. In this case ( IntParameter(3, 50, default=5) ), the loop would run for all numbers between 3 and 50 ( [3, 4, 5, ... 49, 50] ). By using this in a loop, hyperopt will generate 48 new columns ( ['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50'] ). Hyperopt itself will then use the selected value to create the buy and sell signals While this strategy is most likely too simple to provide consistent profit, it should serve as an example how optimize indicator parameters. Note self.buy_ema_short.range will act differently between hyperopt and other modes. For hyperopt, the above example may generate 48 new columns, however for all other modes (backtesting, dry/live), it will only generate the column for the selected value. You should therefore avoid using the resulting column with explicit values (values other than self.buy_ema_short.value ). Note range property may also be used with DecimalParameter and CategoricalParameter . RealParameter does not provide this property due to infinite search space. Performance tip By doing the calculation of all possible indicators in populate_indicators() , the calculation of the indicator happens only once for every parameter. While this may slow down the hyperopt startup speed, the overall performance will increase as the Hyperopt execution itself may pick the same value for multiple epochs (changing other values). You should however try to use space ranges as small as possible. Every new column will require more memory, and every possibility hyperopt can try will increase the search space.","title":"Optimizing an indicator parameter"},{"location":"hyperopt/#optimizing-protections","text":"Freqtrade can also optimize protections. How you optimize protections is up to you, and the following should be considered as example only. The strategy will simply need to define the \"protections\" entry as property returning a list of protection configurations. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces cooldown_lookback = IntParameter(2, 48, default=5, space=\"protection\", optimize=True) stop_duration = IntParameter(12, 200, default=5, space=\"protection\", optimize=True) use_stop_protection = BooleanParameter(default=True, space=\"protection\", optimize=True) @property def protections(self): prot = [] prot.append({ \"method\": \"CooldownPeriod\", \"stop_duration_candles\": self.cooldown_lookback.value }) if self.use_stop_protection.value: prot.append({ \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24 * 3, \"trade_limit\": 4, \"stop_duration_candles\": self.stop_duration.value, \"only_per_pair\": False }) return prot def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # ... ``` You can then run hyperopt as follows: freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection Note The protection space is not part of the default space, and is only available with the Parameters Hyperopt interface, not with the legacy hyperopt interface (which required separate hyperopt files). Freqtrade will also automatically change the \"--enable-protections\" flag if the protection space is selected. Warning If protections are defined as property, entries from the configuration will be ignored. It is therefore recommended to not define protections in the configuration.","title":"Optimizing protections"},{"location":"hyperopt/#migrating-from-previous-property-setups","text":"A migration from a previous setup is pretty simple, and can be accomplished by converting the protections entry to a property. In simple terms, the following configuration will be converted to the below. python class MyAwesomeStrategy(IStrategy): protections = [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 4 } ] Result ``` python class MyAwesomeStrategy(IStrategy): @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 4 } ] ``` You will then obviously also change potential interesting entries to parameters to allow hyper-optimization.","title":"Migrating from previous property setups"},{"location":"hyperopt/#optimizing-max_entry_position_adjustment","text":"While max_entry_position_adjustment is not a separate space, it can still be used in hyperopt by using the property approach shown above. ``` python from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, IStrategy, IntParameter) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy(IStrategy): stoploss = -0.05 timeframe = '15m' # Define the parameter spaces max_epa = CategoricalParameter([-1, 0, 1, 3, 5, 10], default=1, space=\"buy\", optimize=True) @property def max_entry_position_adjustment(self): return self.max_epa.value def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # ... ``` Using IntParameter You can also use the IntParameter for this optimization, but you must explicitly return an integer: ``` python max_epa = IntParameter(-1, 10, default=1, space=\"buy\", optimize=True) @property def max_entry_position_adjustment(self): return int(self.max_epa.value) ```","title":"Optimizing max_entry_position_adjustment"},{"location":"hyperopt/#loss-functions","text":"Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results. A loss function must be specified via the --hyperopt-loss <Class-name> argument (or optionally via the configuration under the \"hyperopt_loss\" key). This class should be in its own file within the user_data/hyperopts/ directory. Currently, the following loss functions are builtin: ShortTradeDurHyperOptLoss - (default legacy Freqtrade hyperoptimization loss function) - Mostly for short trade duration and avoiding losses. OnlyProfitHyperOptLoss - takes only amount of profit into consideration. SharpeHyperOptLoss - optimizes Sharpe Ratio calculated on trade returns relative to standard deviation. SharpeHyperOptLossDaily - optimizes Sharpe Ratio calculated on daily trade returns relative to standard deviation. SortinoHyperOptLoss - optimizes Sortino Ratio calculated on trade returns relative to downside standard deviation. SortinoHyperOptLossDaily - optimizes Sortino Ratio calculated on daily trade returns relative to downside standard deviation. MaxDrawDownHyperOptLoss - Optimizes Maximum drawdown. CalmarHyperOptLoss - Optimizes Calmar Ratio calculated on trade returns relative to max drawdown. ProfitDrawDownHyperOptLoss - Optimizes by max Profit & min Drawdown objective. DRAWDOWN_MULT variable within the hyperoptloss file can be adjusted to be stricter or more flexible on drawdown purposes. Creation of a custom loss function is covered in the Advanced Hyperopt part of the documentation.","title":"Loss-functions"},{"location":"hyperopt/#execute-hyperopt","text":"Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result. We strongly recommend to use screen or tmux to prevent any connection loss. bash freqtrade hyperopt --config config.json --hyperopt-loss <hyperoptlossname> --strategy <strategyname> -e 500 --spaces all The -e option will set how many evaluations hyperopt will do. Since hyperopt uses Bayesian search, running too many epochs at once may not produce greater results. Experience has shown that best results are usually not improving much after 500-1000 epochs. Doing multiple runs (executions) with a few 1000 epochs and different random state will most likely produce different results. The --spaces all option determines that all possible parameters should be optimized. Possibilities are listed below. Note Hyperopt will store hyperopt results with the timestamp of the hyperopt start time. Reading commands ( hyperopt-list , hyperopt-show ) can use --hyperopt-filename <filename> to read and display older hyperopt results. You can find a list of filenames with ls -l user_data/hyperopt_results/ .","title":"Execute Hyperopt"},{"location":"hyperopt/#execute-hyperopt-with-different-historical-data-source","text":"If you would like to hyperopt parameters using an alternate historical data set that you have on-disk, use the --datadir PATH option. By default, hyperopt uses data from directory user_data/data .","title":"Execute Hyperopt with different historical data source"},{"location":"hyperopt/#running-hyperopt-with-a-smaller-test-set","text":"Use the --timerange argument to change how much of the test-set you want to use. For example, to use one month of data, pass --timerange 20210101-20210201 (from january 2021 - february 2021) to the hyperopt call. Full command: bash freqtrade hyperopt --strategy <strategyname> --timerange 20210101-20210201","title":"Running Hyperopt with a smaller test-set"},{"location":"hyperopt/#running-hyperopt-with-smaller-search-space","text":"Use the --spaces option to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have. Legal values are: all : optimize everything buy : just search for a new buy strategy sell : just search for a new sell strategy roi : just optimize the minimal profit table for your strategy stoploss : search for the best stoploss value trailing : search for the best trailing stop values protection : search for the best protection parameters (read the protections section on how to properly define these) default : all except trailing and protection space-separated list of any of the above values for example --spaces roi stoploss The default Hyperopt Search Space, used when no --space command line option is specified, does not include the trailing hyperspace. We recommend you to run optimization for the trailing hyperspace separately, when the best parameters for other hyperspaces were found, validated and pasted into your custom strategy.","title":"Running Hyperopt with Smaller Search Space"},{"location":"hyperopt/#understand-the-hyperopt-result","text":"Once Hyperopt is completed you can use the result to update your strategy. Given the following result from hyperopt: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } ``` You should understand this result like: The buy trigger that worked best was bb_lower . You should not use ADX because 'buy_adx_enabled': False . You should consider using the RSI indicator ( 'buy_rsi_enabled': True ) and the best value is 29.0 ( 'buy_rsi': 29.0 )","title":"Understand the Hyperopt Result"},{"location":"hyperopt/#automatic-parameter-application-to-the-strategy","text":"When using Hyperoptable parameters, the result of your hyperopt-run will be written to a json file next to your strategy (so for MyAwesomeStrategy.py , the file would be MyAwesomeStrategy.json ). This file is also updated when using the hyperopt-show sub-command, unless --disable-param-export is provided to either of the 2 commands. Your strategy class can also contain these results explicitly. Simply copy hyperopt results block and paste them at class level, replacing old parameters (if any). New parameters will automatically be loaded next time strategy is executed. Transferring your whole hyperopt result to your strategy would then look like: python class MyAwesomeStrategy(IStrategy): # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } Note Values in the configuration file will overwrite Parameter-file level parameters - and both will overwrite parameters within the strategy. The prevalence is therefore: config > parameter file > strategy","title":"Automatic parameter application to the strategy"},{"location":"hyperopt/#understand-hyperopt-roi-results","text":"If you are optimizing ROI (i.e. if optimization search-space contains 'all', 'default' or 'roi'), your result will look as follows and include a ROI table: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # ROI table: minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } ``` In order to use this best ROI table found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the minimal_roi attribute of your custom strategy: # Minimal ROI designed for the strategy. # This attribute will be overridden if the config file contains \"minimal_roi\" minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } As stated in the comment, you can also use it as the value of the minimal_roi setting in the configuration file.","title":"Understand Hyperopt ROI results"},{"location":"hyperopt/#default-roi-search-space","text":"If you are optimizing ROI, Freqtrade creates the 'roi' optimization hyperspace for you -- it's the hyperspace of components for the ROI tables. By default, each ROI table generated by the Freqtrade consists of 4 rows (steps). Hyperopt implements adaptive ranges for ROI tables with ranges for values in the ROI steps that depend on the timeframe used. By default the values vary in the following ranges (for some of the most used timeframes, values are rounded to 3 digits after the decimal point): # step 1m 5m 1h 1d 1 0 0.011...0.119 0 0.03...0.31 0 0.068...0.711 0 0.121...1.258 2 2...8 0.007...0.042 10...40 0.02...0.11 120...480 0.045...0.252 2880...11520 0.081...0.446 3 4...20 0.003...0.015 20...100 0.01...0.04 240...1200 0.022...0.091 5760...28800 0.040...0.162 4 6...44 0.0 30...220 0.0 360...2640 0.0 8640...63360 0.0 These ranges should be sufficient in most cases. The minutes in the steps (ROI dict keys) are scaled linearly depending on the timeframe used. The ROI values in the steps (ROI dict values) are scaled logarithmically depending on the timeframe used. If you have the generate_roi_table() and roi_space() methods in your custom hyperopt, remove them in order to utilize these adaptive ROI tables and the ROI hyperoptimization space generated by Freqtrade by default. Override the roi_space() method if you need components of the ROI tables to vary in other ranges. Override the generate_roi_table() and roi_space() methods and implement your own custom approach for generation of the ROI tables during hyperoptimization if you need a different structure of the ROI tables or other amount of rows (steps). A sample for these methods can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default ROI Search Space"},{"location":"hyperopt/#understand-hyperopt-stoploss-results","text":"If you are optimizing stoploss values (i.e. if optimization search-space contains 'all', 'default' or 'stoploss'), your result will look as follows and include stoploss: ``` Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } stoploss: -0.27996 ``` In order to use this best stoploss value found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the stoploss attribute of your custom strategy: python # Optimal stoploss designed for the strategy # This attribute will be overridden if the config file contains \"stoploss\" stoploss = -0.27996 As stated in the comment, you can also use it as the value of the stoploss setting in the configuration file.","title":"Understand Hyperopt Stoploss results"},{"location":"hyperopt/#default-stoploss-search-space","text":"If you are optimizing stoploss values, Freqtrade creates the 'stoploss' optimization hyperspace for you. By default, the stoploss values in that hyperspace vary in the range -0.35...-0.02, which is sufficient in most cases. If you have the stoploss_space() method in your custom hyperopt file, remove it in order to utilize Stoploss hyperoptimization space generated by Freqtrade by default. Override the stoploss_space() method and define the desired range in it if you need stoploss values to vary in other range during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default Stoploss Search Space"},{"location":"hyperopt/#understand-hyperopt-trailing-stop-results","text":"If you are optimizing trailing stop values (i.e. if optimization search-space contains 'all' or 'trailing'), your result will look as follows and include trailing stop parameters: ``` Best result: 45/100: 606 trades. Avg profit 1.04%. Total profit 0.31555614 BTC ( 630.48%). Avg duration 150.3 mins. Objective: -1.10161 # Trailing stop: trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True ``` In order to use these best trailing stop parameters found by Hyperopt in backtesting and for live trades/dry-run, copy-paste them as the values of the corresponding attributes of your custom strategy: python # Trailing stop # These attributes will be overridden if the config file contains corresponding values. trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True As stated in the comment, you can also use it as the values of the corresponding settings in the configuration file.","title":"Understand Hyperopt Trailing Stop results"},{"location":"hyperopt/#default-trailing-stop-search-space","text":"If you are optimizing trailing stop values, Freqtrade creates the 'trailing' optimization hyperspace for you. By default, the trailing_stop parameter is always set to True in that hyperspace, the value of the trailing_only_offset_is_reached vary between True and False, the values of the trailing_stop_positive and trailing_stop_positive_offset parameters vary in the ranges 0.02...0.35 and 0.01...0.1 correspondingly, which is sufficient in most cases. Override the trailing_space() method and define the desired range in it if you need values of the trailing stop parameters to vary in other ranges during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default Trailing Stop Search Space"},{"location":"hyperopt/#reproducible-results","text":"The search for optimal parameters starts with a few (currently 30) random combinations in the hyperspace of parameters, random Hyperopt epochs. These random epochs are marked with an asterisk character ( * ) in the first column in the Hyperopt output. The initial state for generation of these random values (random state) is controlled by the value of the --random-state command line option. You can set it to some arbitrary value of your choice to obtain reproducible results. If you have not set this value explicitly in the command line options, Hyperopt seeds the random state with some random value for you. The random state value for each Hyperopt run is shown in the log, so you can copy and paste it into the --random-state command line option to repeat the set of the initial random epochs used. If you have not changed anything in the command line options, configuration, timerange, Strategy and Hyperopt classes, historical data and the Loss Function -- you should obtain same hyper-optimization results with same random state value used.","title":"Reproducible results"},{"location":"hyperopt/#output-formatting","text":"By default, hyperopt prints colorized results -- epochs with positive profit are printed in the green color. This highlighting helps you find epochs that can be interesting for later analysis. Epochs with zero total profit or with negative profits (losses) are printed in the normal color. If you do not need colorization of results (for instance, when you are redirecting hyperopt output to a file) you can switch colorization off by specifying the --no-color option in the command line. You can use the --print-all command line option if you would like to see all results in the hyperopt output, not only the best ones. When --print-all is used, current best results are also colorized by default -- they are printed in bold (bright) style. This can also be switched off with the --no-color command line option. Windows and color output Windows does not support color-output natively, therefore it is automatically disabled. To have color-output for hyperopt running under windows, please consider using WSL.","title":"Output formatting"},{"location":"hyperopt/#position-stacking-and-disabling-max-market-positions","text":"In some situations, you may need to run Hyperopt (and Backtesting) with the --eps / --enable-position-staking and --dmmp / --disable-max-market-positions arguments. By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs is also limited by the max_open_trades setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previously open trades. The --eps / --enable-position-stacking argument allows emulation of buying the same pair multiple times, while --dmmp / --disable-max-market-positions disables applying max_open_trades during Hyperopt/Backtesting (which is equal to setting max_open_trades to a very high number). Note Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality. You can also enable position stacking in the configuration file by explicitly setting \"position_stacking\"=true .","title":"Position stacking and disabling max market positions"},{"location":"hyperopt/#out-of-memory-errors","text":"As hyperopt consumes a lot of memory (the complete data needs to be in memory once per parallel backtesting process), it's likely that you run into \"out of memory\" errors. To combat these, you have multiple options: reduce the amount of pairs reduce the timerange used ( --timerange <timerange> ) reduce the number of parallel processes ( -j <n> ) Increase the memory of your machine","title":"Out of Memory errors"},{"location":"hyperopt/#show-details-of-hyperopt-results","text":"After you run Hyperopt for the desired amount of epochs, you can later list all results for analysis, select only best or profitable once, and show the details for any of the epochs previously evaluated. This can be done with the hyperopt-list and hyperopt-show sub-commands. The usage of these sub-commands is described in the Utils chapter.","title":"Show details of Hyperopt results"},{"location":"hyperopt/#validate-backtesting-results","text":"Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected. To achieve same the results (number of trades, their durations, profit, etc.) as during Hyperopt, please use the same configuration and parameters (timerange, timeframe, ...) used for hyperopt --dmmp / --disable-max-market-positions and --eps / --enable-position-stacking for Backtesting. Should results not match, please double-check to make sure you transferred all conditions correctly. Pay special care to the stoploss (and trailing stoploss) parameters, as these are often set in configuration files, which override changes to the strategy. You should also carefully review the log of your backtest to ensure that there were no parameters inadvertently set by the configuration (like stoploss or trailing_stop ).","title":"Validate backtesting results"},{"location":"installation/","text":"Installation \u00b6 This page explains how to prepare your environment for running the bot. The freqtrade documentation describes various ways to install freqtrade Docker images (separate page) Script Installation Manual Installation Installation with Conda Please consider using the prebuilt docker images to get started quickly while evaluating how freqtrade works. Information \u00b6 For Windows installation, please use the windows installation guide . The easiest way to install and run Freqtrade is to clone the bot Github repository and then run the ./setup.sh script, if it's available for your platform. Version considerations When cloning the repository the default working branch has the name develop . This branch contains all last features (can be considered as relatively stable, thanks to automated tests). The stable branch contains the code of the last release (done usually once per month on an approximately one week old snapshot of the develop branch to prevent packaging bugs, so potentially it's more stable). Note Python3.8 or higher and the corresponding pip are assumed to be available. The install-script will warn you and stop if that's not the case. git is also needed to clone the Freqtrade repository. Also, python headers ( python<yourversion>-dev / python<yourversion>-devel ) must be available for the installation to complete successfully. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges. Requirements \u00b6 These requirements apply to both Script Installation and Manual Installation . ARM64 systems If you are running an ARM64 system (like a MacOS M1 or an Oracle VM), please use docker to run freqtrade. While native installation is possible with some manual effort, this is not supported at the moment. Install guide \u00b6 Python >= 3.8.x pip git virtualenv (Recommended) TA-Lib (install instructions below ) Install code \u00b6 We've included/collected install instructions for Ubuntu, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the Common section below is necessary for all systems. Note Python3.8 or higher and the corresponding pip are assumed to be available. Debian/Ubuntu RaspberryPi/Raspbian Install necessary dependencies \u00b6 ```bash update repository \u00b6 sudo apt-get update install packages \u00b6 sudo apt install -y python3-pip python3-venv python3-dev python3-pandas git curl ``` The following assumes the latest Raspbian Buster lite image . This image comes with python3.9 preinstalled, making it easy to get freqtrade up and running. Tested using a Raspberry Pi 3 with the Raspbian Buster lite image, all updates applied. ```bash sudo apt-get install python3-venv libatlas-base-dev cmake curl Use pywheels.org to speed up installation \u00b6 sudo echo \"[global]\\nextra-index-url= https://www.piwheels.org/simple \" > tee /etc/pip.conf git clone https://github.com/freqtrade/freqtrade.git cd freqtrade bash setup.sh -i ``` Installation duration Depending on your internet speed and the Raspberry Pi version, installation can take multiple hours to complete. Due to this, we recommend to use the pre-build docker-image for Raspberry, by following the Docker quickstart documentation Note The above does not install hyperopt dependencies. To install these, please use python3 -m pip install -e .[hyperopt] . We do not advise to run hyperopt on a Raspberry Pi, since this is a very resource-heavy operation, which should be done on powerful machine. Freqtrade repository \u00b6 Freqtrade is an open source crypto-currency trading bot, whose code is hosted on github.com ```bash Download develop branch of freqtrade repository \u00b6 git clone https://github.com/freqtrade/freqtrade.git Enter downloaded directory \u00b6 cd freqtrade your choice (1): novice user \u00b6 git checkout stable your choice (2): advanced user \u00b6 git checkout develop ``` (1) This command switches the cloned repository to the use of the stable branch. It's not needed, if you wish to stay on the (2) develop branch. You may later switch between branches at any time with the git checkout stable / git checkout develop commands. Install from pypi An alternative way to install Freqtrade is from pypi . The downside is that this method requires ta-lib to be correctly installed beforehand, and is therefore currently not the recommended way to install Freqtrade. bash pip install freqtrade Script Installation \u00b6 First of the ways to install Freqtrade, is to use provided the Linux/MacOS ./setup.sh script, which install all dependencies and help you configure the bot. Make sure you fulfill the Requirements and have downloaded the Freqtrade repository . Use /setup.sh -install (Linux/MacOS) \u00b6 If you are on Debian, Ubuntu or MacOS, freqtrade provides the script to install freqtrade. ```bash --install, Install freqtrade from scratch \u00b6 ./setup.sh -i ``` Activate your virtual environment \u00b6 Each time you open a new terminal, you must run source .env/bin/activate to activate your virtual environment. ```bash then activate your .env \u00b6 source ./.env/bin/activate ``` Congratulations \u00b6 You are ready , and run the bot Other options of /setup.sh script \u00b6 You can as well update, configure and reset the codebase of your bot with ./script.sh ```bash --update, Command git pull to update. \u00b6 ./setup.sh -u --reset, Hard reset your develop/stable branch. \u00b6 ./setup.sh -r ``` ``` --install With this option, the script will install the bot and most dependencies: You will need to have git and python3.8+ installed beforehand for this to work. Mandatory software as: ta-lib Setup your virtualenv under .env/ This option is a combination of installation tasks and --reset --update This option will pull the last version of your current branch and update your virtualenv. Run the script with this option periodically to update your bot. --reset This option will hard reset your branch (only if you are on either stable or develop ) and recreate your virtualenv. ``` Manual Installation \u00b6 Make sure you fulfill the Requirements and have downloaded the Freqtrade repository . Install TA-Lib \u00b6 TA-Lib script installation \u00b6 bash sudo ./build_helpers/install_ta-lib.sh Note This will use the ta-lib tar.gz included in this repository. TA-Lib manual installation \u00b6 Official webpage: https://mrjbq7.github.io/ta-lib/install.html ```bash wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz tar xvzf ta-lib-0.4.0-src.tar.gz cd ta-lib sed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h ./configure --prefix=/usr/local make sudo make install On debian based systems (debian, ubuntu, ...) - updating ldconfig might be necessary. \u00b6 sudo ldconfig cd .. rm -rf ./ta-lib* ``` Setup Python virtual environment (virtualenv) \u00b6 You will run freqtrade in separated virtual environment ```bash create virtualenv in directory /freqtrade/.env \u00b6 python3 -m venv .env run virtualenv \u00b6 source .env/bin/activate ``` Install python dependencies \u00b6 bash python3 -m pip install --upgrade pip python3 -m pip install -e . Congratulations \u00b6 You are ready , and run the bot (Optional) Post-installation Tasks \u00b6 Note If you run the bot on a server, you should consider using Docker or a terminal multiplexer like screen or tmux to avoid that the bot is stopped on logout. On Linux with software suite systemd , as an optional post-installation task, you may wish to setup the bot to run as a systemd service or configure it to send the log messages to the syslog / rsyslog or journald daemons. See Advanced Logging for details. Installation with Conda \u00b6 Freqtrade can also be installed with Miniconda or Anaconda. We recommend using Miniconda as it's installation footprint is smaller. Conda will automatically prepare and manage the extensive library-dependencies of the Freqtrade program. What is Conda? \u00b6 Conda is a package, dependency and environment manager for multiple programming languages: conda docs Installation with conda \u00b6 Install Conda \u00b6 Installing on linux Installing on windows Answer all questions. After installation, it is mandatory to turn your terminal OFF and ON again. Freqtrade download \u00b6 Download and install freqtrade. ```bash download freqtrade \u00b6 git clone https://github.com/freqtrade/freqtrade.git enter downloaded directory 'freqtrade' \u00b6 cd freqtrade ``` Freqtrade install: Conda Environment \u00b6 Prepare conda-freqtrade environment, using file environment.yml , which exist in main freqtrade directory bash conda env create -n freqtrade-conda -f environment.yml Creating Conda Environment The conda command create -n automatically installs all nested dependencies for the selected libraries, general structure of installation command is: ```bash choose your own packages \u00b6 conda env create -n [name of the environment] [python version] [packages] point to file with packages \u00b6 conda env create -n [name of the environment] -f [file] ``` Enter/exit freqtrade-conda environment \u00b6 To check available environments, type bash conda env list Enter installed environment ```bash enter conda environment \u00b6 conda activate freqtrade-conda exit conda environment - don't do it now \u00b6 conda deactivate ``` Install last python dependencies with pip bash python3 -m pip install --upgrade pip python3 -m pip install -e . Congratulations \u00b6 You are ready , and run the bot Important shortcuts \u00b6 ```bash list installed conda environments \u00b6 conda env list activate base environment \u00b6 conda activate activate freqtrade-conda environment \u00b6 conda activate freqtrade-conda deactivate any conda environments \u00b6 conda deactivate ``` Further info on anaconda \u00b6 New heavy packages It may happen that creating a new Conda environment, populated with selected packages at the moment of creation takes less time than installing a large, heavy library or application, into previously set environment. pip install within conda The documentation of conda says that pip should NOT be used within conda, because internal problems can occur. However, they are rare. Anaconda Blogpost Nevertheless, that is why, the conda-forge channel is preferred: more libraries are available (less need for pip ) conda-forge works better with pip the libraries are newer Happy trading! You are ready \u00b6 You've made it this far, so you have successfully installed freqtrade. Initialize the configuration \u00b6 ```bash Step 1 - Initialize user folder \u00b6 freqtrade create-userdir --userdir user_data Step 2 - Create a new configuration file \u00b6 freqtrade new-config --config config.json ``` You are ready to run, read Bot Configuration , remember to start with dry_run: True and verify that everything is working. To learn how to setup your configuration, please refer to the Bot Configuration documentation page. Start the Bot \u00b6 bash freqtrade trade --config config.json --strategy SampleStrategy Warning You should read through the rest of the documentation, backtest the strategy you're going to use, and use dry-run before enabling trading with real money. Troubleshooting \u00b6 Common problem: \"command not found\" \u00b6 If you used (1) Script or (2) Manual installation, you need to run the bot in virtual environment. If you get error as below, make sure venv is active. ```bash if: \u00b6 bash: freqtrade: command not found then activate your .env \u00b6 source ./.env/bin/activate ``` MacOS installation error \u00b6 Newer versions of MacOS may have installation failed with errors like error: command 'g++' failed with exit status 1 . This error will require explicit installation of the SDK Headers, which are not installed by default in this version of MacOS. For MacOS 10.14, this can be accomplished with the below command. bash open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg If this file is inexistent, then you're probably on a different version of MacOS, so you may need to consult the internet for specific resolution details.","title":"Linux/MacOS/Raspberry"},{"location":"installation/#installation","text":"This page explains how to prepare your environment for running the bot. The freqtrade documentation describes various ways to install freqtrade Docker images (separate page) Script Installation Manual Installation Installation with Conda Please consider using the prebuilt docker images to get started quickly while evaluating how freqtrade works.","title":"Installation"},{"location":"installation/#information","text":"For Windows installation, please use the windows installation guide . The easiest way to install and run Freqtrade is to clone the bot Github repository and then run the ./setup.sh script, if it's available for your platform. Version considerations When cloning the repository the default working branch has the name develop . This branch contains all last features (can be considered as relatively stable, thanks to automated tests). The stable branch contains the code of the last release (done usually once per month on an approximately one week old snapshot of the develop branch to prevent packaging bugs, so potentially it's more stable). Note Python3.8 or higher and the corresponding pip are assumed to be available. The install-script will warn you and stop if that's not the case. git is also needed to clone the Freqtrade repository. Also, python headers ( python<yourversion>-dev / python<yourversion>-devel ) must be available for the installation to complete successfully. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.","title":"Information"},{"location":"installation/#requirements","text":"These requirements apply to both Script Installation and Manual Installation . ARM64 systems If you are running an ARM64 system (like a MacOS M1 or an Oracle VM), please use docker to run freqtrade. While native installation is possible with some manual effort, this is not supported at the moment.","title":"Requirements"},{"location":"installation/#install-guide","text":"Python >= 3.8.x pip git virtualenv (Recommended) TA-Lib (install instructions below )","title":"Install guide"},{"location":"installation/#install-code","text":"We've included/collected install instructions for Ubuntu, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the Common section below is necessary for all systems. Note Python3.8 or higher and the corresponding pip are assumed to be available. Debian/Ubuntu RaspberryPi/Raspbian","title":"Install code"},{"location":"installation/#install-necessary-dependencies","text":"```bash","title":"Install necessary dependencies"},{"location":"installation/#update-repository","text":"sudo apt-get update","title":"update repository"},{"location":"installation/#install-packages","text":"sudo apt install -y python3-pip python3-venv python3-dev python3-pandas git curl ``` The following assumes the latest Raspbian Buster lite image . This image comes with python3.9 preinstalled, making it easy to get freqtrade up and running. Tested using a Raspberry Pi 3 with the Raspbian Buster lite image, all updates applied. ```bash sudo apt-get install python3-venv libatlas-base-dev cmake curl","title":"install packages"},{"location":"installation/#use-pywheelsorg-to-speed-up-installation","text":"sudo echo \"[global]\\nextra-index-url= https://www.piwheels.org/simple \" > tee /etc/pip.conf git clone https://github.com/freqtrade/freqtrade.git cd freqtrade bash setup.sh -i ``` Installation duration Depending on your internet speed and the Raspberry Pi version, installation can take multiple hours to complete. Due to this, we recommend to use the pre-build docker-image for Raspberry, by following the Docker quickstart documentation Note The above does not install hyperopt dependencies. To install these, please use python3 -m pip install -e .[hyperopt] . We do not advise to run hyperopt on a Raspberry Pi, since this is a very resource-heavy operation, which should be done on powerful machine.","title":"Use pywheels.org to speed up installation"},{"location":"installation/#freqtrade-repository","text":"Freqtrade is an open source crypto-currency trading bot, whose code is hosted on github.com ```bash","title":"Freqtrade repository"},{"location":"installation/#download-develop-branch-of-freqtrade-repository","text":"git clone https://github.com/freqtrade/freqtrade.git","title":"Download develop branch of freqtrade repository"},{"location":"installation/#enter-downloaded-directory","text":"cd freqtrade","title":"Enter downloaded directory"},{"location":"installation/#your-choice-1-novice-user","text":"git checkout stable","title":"your choice (1): novice user"},{"location":"installation/#your-choice-2-advanced-user","text":"git checkout develop ``` (1) This command switches the cloned repository to the use of the stable branch. It's not needed, if you wish to stay on the (2) develop branch. You may later switch between branches at any time with the git checkout stable / git checkout develop commands. Install from pypi An alternative way to install Freqtrade is from pypi . The downside is that this method requires ta-lib to be correctly installed beforehand, and is therefore currently not the recommended way to install Freqtrade. bash pip install freqtrade","title":"your choice (2): advanced user"},{"location":"installation/#script-installation","text":"First of the ways to install Freqtrade, is to use provided the Linux/MacOS ./setup.sh script, which install all dependencies and help you configure the bot. Make sure you fulfill the Requirements and have downloaded the Freqtrade repository .","title":"Script Installation"},{"location":"installation/#use-setupsh-install-linuxmacos","text":"If you are on Debian, Ubuntu or MacOS, freqtrade provides the script to install freqtrade. ```bash","title":"Use /setup.sh -install (Linux/MacOS)"},{"location":"installation/#-install-install-freqtrade-from-scratch","text":"./setup.sh -i ```","title":"--install, Install freqtrade from scratch"},{"location":"installation/#activate-your-virtual-environment","text":"Each time you open a new terminal, you must run source .env/bin/activate to activate your virtual environment. ```bash","title":"Activate your virtual environment"},{"location":"installation/#then-activate-your-env","text":"source ./.env/bin/activate ```","title":"then activate your .env"},{"location":"installation/#congratulations","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#other-options-of-setupsh-script","text":"You can as well update, configure and reset the codebase of your bot with ./script.sh ```bash","title":"Other options of /setup.sh script"},{"location":"installation/#-update-command-git-pull-to-update","text":"./setup.sh -u","title":"--update, Command git pull to update."},{"location":"installation/#-reset-hard-reset-your-developstable-branch","text":"./setup.sh -r ``` ``` --install With this option, the script will install the bot and most dependencies: You will need to have git and python3.8+ installed beforehand for this to work. Mandatory software as: ta-lib Setup your virtualenv under .env/ This option is a combination of installation tasks and --reset --update This option will pull the last version of your current branch and update your virtualenv. Run the script with this option periodically to update your bot. --reset This option will hard reset your branch (only if you are on either stable or develop ) and recreate your virtualenv. ```","title":"--reset, Hard reset your develop/stable branch."},{"location":"installation/#manual-installation","text":"Make sure you fulfill the Requirements and have downloaded the Freqtrade repository .","title":"Manual Installation"},{"location":"installation/#install-ta-lib","text":"","title":"Install TA-Lib"},{"location":"installation/#ta-lib-script-installation","text":"bash sudo ./build_helpers/install_ta-lib.sh Note This will use the ta-lib tar.gz included in this repository.","title":"TA-Lib script installation"},{"location":"installation/#ta-lib-manual-installation","text":"Official webpage: https://mrjbq7.github.io/ta-lib/install.html ```bash wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz tar xvzf ta-lib-0.4.0-src.tar.gz cd ta-lib sed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h ./configure --prefix=/usr/local make sudo make install","title":"TA-Lib manual installation"},{"location":"installation/#on-debian-based-systems-debian-ubuntu-updating-ldconfig-might-be-necessary","text":"sudo ldconfig cd .. rm -rf ./ta-lib* ```","title":"On debian based systems (debian, ubuntu, ...) - updating ldconfig might be necessary."},{"location":"installation/#setup-python-virtual-environment-virtualenv","text":"You will run freqtrade in separated virtual environment ```bash","title":"Setup Python virtual environment (virtualenv)"},{"location":"installation/#create-virtualenv-in-directory-freqtradeenv","text":"python3 -m venv .env","title":"create virtualenv in directory /freqtrade/.env"},{"location":"installation/#run-virtualenv","text":"source .env/bin/activate ```","title":"run virtualenv"},{"location":"installation/#install-python-dependencies","text":"bash python3 -m pip install --upgrade pip python3 -m pip install -e .","title":"Install python dependencies"},{"location":"installation/#congratulations_1","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#optional-post-installation-tasks","text":"Note If you run the bot on a server, you should consider using Docker or a terminal multiplexer like screen or tmux to avoid that the bot is stopped on logout. On Linux with software suite systemd , as an optional post-installation task, you may wish to setup the bot to run as a systemd service or configure it to send the log messages to the syslog / rsyslog or journald daemons. See Advanced Logging for details.","title":"(Optional) Post-installation Tasks"},{"location":"installation/#installation-with-conda","text":"Freqtrade can also be installed with Miniconda or Anaconda. We recommend using Miniconda as it's installation footprint is smaller. Conda will automatically prepare and manage the extensive library-dependencies of the Freqtrade program.","title":"Installation with Conda"},{"location":"installation/#what-is-conda","text":"Conda is a package, dependency and environment manager for multiple programming languages: conda docs","title":"What is Conda?"},{"location":"installation/#installation-with-conda_1","text":"","title":"Installation with conda"},{"location":"installation/#install-conda","text":"Installing on linux Installing on windows Answer all questions. After installation, it is mandatory to turn your terminal OFF and ON again.","title":"Install Conda"},{"location":"installation/#freqtrade-download","text":"Download and install freqtrade. ```bash","title":"Freqtrade download"},{"location":"installation/#download-freqtrade","text":"git clone https://github.com/freqtrade/freqtrade.git","title":"download freqtrade"},{"location":"installation/#enter-downloaded-directory-freqtrade","text":"cd freqtrade ```","title":"enter downloaded directory 'freqtrade'"},{"location":"installation/#freqtrade-install-conda-environment","text":"Prepare conda-freqtrade environment, using file environment.yml , which exist in main freqtrade directory bash conda env create -n freqtrade-conda -f environment.yml Creating Conda Environment The conda command create -n automatically installs all nested dependencies for the selected libraries, general structure of installation command is: ```bash","title":"Freqtrade install: Conda Environment"},{"location":"installation/#choose-your-own-packages","text":"conda env create -n [name of the environment] [python version] [packages]","title":"choose your own packages"},{"location":"installation/#point-to-file-with-packages","text":"conda env create -n [name of the environment] -f [file] ```","title":"point to file with packages"},{"location":"installation/#enterexit-freqtrade-conda-environment","text":"To check available environments, type bash conda env list Enter installed environment ```bash","title":"Enter/exit freqtrade-conda environment"},{"location":"installation/#enter-conda-environment","text":"conda activate freqtrade-conda","title":"enter conda environment"},{"location":"installation/#exit-conda-environment-dont-do-it-now","text":"conda deactivate ``` Install last python dependencies with pip bash python3 -m pip install --upgrade pip python3 -m pip install -e .","title":"exit conda environment - don't do it now"},{"location":"installation/#congratulations_2","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#important-shortcuts","text":"```bash","title":"Important shortcuts"},{"location":"installation/#list-installed-conda-environments","text":"conda env list","title":"list installed conda environments"},{"location":"installation/#activate-base-environment","text":"conda activate","title":"activate base environment"},{"location":"installation/#activate-freqtrade-conda-environment","text":"conda activate freqtrade-conda","title":"activate freqtrade-conda environment"},{"location":"installation/#deactivate-any-conda-environments","text":"conda deactivate ```","title":"deactivate any conda environments"},{"location":"installation/#further-info-on-anaconda","text":"New heavy packages It may happen that creating a new Conda environment, populated with selected packages at the moment of creation takes less time than installing a large, heavy library or application, into previously set environment. pip install within conda The documentation of conda says that pip should NOT be used within conda, because internal problems can occur. However, they are rare. Anaconda Blogpost Nevertheless, that is why, the conda-forge channel is preferred: more libraries are available (less need for pip ) conda-forge works better with pip the libraries are newer Happy trading!","title":"Further info on anaconda"},{"location":"installation/#you-are-ready","text":"You've made it this far, so you have successfully installed freqtrade.","title":"You are ready"},{"location":"installation/#initialize-the-configuration","text":"```bash","title":"Initialize the configuration"},{"location":"installation/#step-1-initialize-user-folder","text":"freqtrade create-userdir --userdir user_data","title":"Step 1 - Initialize user folder"},{"location":"installation/#step-2-create-a-new-configuration-file","text":"freqtrade new-config --config config.json ``` You are ready to run, read Bot Configuration , remember to start with dry_run: True and verify that everything is working. To learn how to setup your configuration, please refer to the Bot Configuration documentation page.","title":"Step 2 - Create a new configuration file"},{"location":"installation/#start-the-bot","text":"bash freqtrade trade --config config.json --strategy SampleStrategy Warning You should read through the rest of the documentation, backtest the strategy you're going to use, and use dry-run before enabling trading with real money.","title":"Start the Bot"},{"location":"installation/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"installation/#common-problem-command-not-found","text":"If you used (1) Script or (2) Manual installation, you need to run the bot in virtual environment. If you get error as below, make sure venv is active. ```bash","title":"Common problem: \"command not found\""},{"location":"installation/#if","text":"bash: freqtrade: command not found","title":"if:"},{"location":"installation/#then-activate-your-env_1","text":"source ./.env/bin/activate ```","title":"then activate your .env"},{"location":"installation/#macos-installation-error","text":"Newer versions of MacOS may have installation failed with errors like error: command 'g++' failed with exit status 1 . This error will require explicit installation of the SDK Headers, which are not installed by default in this version of MacOS. For MacOS 10.14, this can be accomplished with the below command. bash open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg If this file is inexistent, then you're probably on a different version of MacOS, so you may need to consult the internet for specific resolution details.","title":"MacOS installation error"},{"location":"plotting/","text":"Plotting \u00b6 This page explains how to plot prices, indicators and profits. Installation / Setup \u00b6 Plotting modules use the Plotly library. You can install / upgrade this by running the following command: bash pip install -U -r requirements-plot.txt Plot price and indicators \u00b6 The freqtrade plot-dataframe subcommand shows an interactive graph with three subplots: Main plot with candlestics and indicators following price (sma/ema) Volume bars Additional indicators as specified by --indicators2 Possible arguments: ``` usage: freqtrade plot-dataframe [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--indicators1 INDICATORS1 [INDICATORS1 ...]] [--indicators2 INDICATORS2 [INDICATORS2 ...]] [--plot-limit INT] [--db-url PATH] [--trade-source {DB,file}] [--export EXPORT] [--export-filename PATH] [--timerange TIMERANGE] [-i TIMEFRAME] [--no-trades] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --indicators1 INDICATORS1 [INDICATORS1 ...] Set indicators from your strategy you want in the first row of the graph. Space-separated list. Example: ema3 ema5 . Default: ['sma', 'ema3', 'ema5'] . --indicators2 INDICATORS2 [INDICATORS2 ...] Set indicators from your strategy you want in the third row of the graph. Space-separated list. Example: fastd fastk . Default: ['macd', 'macdsignal'] . --plot-limit INT Specify tick limit for plotting. Notice: too high values cause huge files. Default: 750. --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file --export EXPORT Export backtest results, argument are: trades. Example: --export=trades --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --timerange TIMERANGE Specify what timerange of data to use. -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --no-trades Skip using trades from backtesting file and DB. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` Example: bash freqtrade plot-dataframe -p BTC/ETH The -p/--pairs argument can be used to specify pairs you would like to plot. Note The freqtrade plot-dataframe subcommand generates one plot-file per pair. Specify custom indicators. Use --indicators1 for the main plot and --indicators2 for the subplot below (if values are in a different range than prices). Tip You will almost certainly want to specify a custom strategy! This can be done by adding -s Classname / --strategy ClassName to the command. bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --indicators1 sma ema --indicators2 macd Further usage examples \u00b6 To plot multiple pairs, separate them with a space: bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH XRP/ETH To plot a timerange (to zoom in) bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805 To plot trades stored in a database use --db-url in combination with --trade-source DB : bash freqtrade plot-dataframe --strategy AwesomeStrategy --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB To plot trades from a backtesting result, use --export-filename <filename> bash freqtrade plot-dataframe --strategy AwesomeStrategy --export-filename user_data/backtest_results/backtest-result.json -p BTC/ETH Plot dataframe basics \u00b6 The plot-dataframe subcommand requires backtesting data, a strategy and either a backtesting-results file or a database, containing trades corresponding to the strategy. The resulting plot will have the following elements: Green triangles: Buy signals from the strategy. (Note: not every buy signal generates a trade, compare to cyan circles.) Red triangles: Sell signals from the strategy. (Also, not every sell signal terminates a trade, compare to red and green squares.) Cyan circles: Trade entry points. Red squares: Trade exit points for trades with loss or 0% profit. Green squares: Trade exit points for profitable trades. Indicators with values corresponding to the candle scale (e.g. SMA/EMA), as specified with --indicators1 . Volume (bar chart at the bottom of the main chart). Indicators with values in different scales (e.g. MACD, RSI) below the volume bars, as specified with --indicators2 . Bollinger Bands Bollinger bands are automatically added to the plot if the columns bb_lowerband and bb_upperband exist, and are painted as a light blue area spanning from the lower band to the upper band. Advanced plot configuration \u00b6 An advanced plot configuration can be specified in the strategy in the plot_config parameter. Additional features when using plot_config include: Specify colors per indicator Specify additional subplots Specify indicator pairs to fill area in between The sample plot configuration below specifies fixed colors for the indicators. Otherwise, consecutive plots may produce different color schemes each time, making comparisons difficult. It also allows multiple subplots to display both MACD and RSI at the same time. Plot type can be configured using type key. Possible types are: scatter corresponding to plotly.graph_objects.Scatter class (default). bar corresponding to plotly.graph_objects.Bar class. Extra parameters to plotly.graph_objects.* constructor can be specified in plotly dict. Sample configuration with inline comments explaining the process: ``` python @property def plot_config(self): \"\"\" There are a lot of solutions how to build the return dictionary. The only important point is the return value. Example: plot_config = {'main_plot': {}, 'subplots': {}} \"\"\" plot_config = {} plot_config['main_plot'] = { # Configuration for main plot indicators. # Assumes 2 parameters, emashort and emalong to be specified. f'ema_{self.emashort.value}': {'color': 'red'}, f'ema_{self.emalong.value}': {'color': '#CCCCCC'}, # By omitting color, a random color is selected. 'sar': {}, # fill area between senkou_a and senkou_b 'senkou_a': { 'color': 'green', #optional 'fill_to': 'senkou_b', 'fill_label': 'Ichimoku Cloud', #optional 'fill_color': 'rgba(255,76,46,0.2)', #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b': {} } plot_config['subplots'] = { # Create subplot MACD \"MACD\": { 'macd': {'color': 'blue', 'fill_to': 'macdhist'}, 'macdsignal': {'color': 'orange'}, 'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}} }, # Additional subplot RSI \"RSI\": { 'rsi': {'color': 'red'} } } return plot_config ``` As attribute (former method) Assigning plot_config is also possible as Attribute (this used to be the default way). This has the disadvantage that strategy parameters are not available, preventing certain configurations from working. `` python plot_config = { 'main_plot': { # Configuration for main plot indicators. # Specifies ema10 to be red, and ema50` to be a shade of gray 'ema10': {'color': 'red'}, 'ema50': {'color': '#CCCCCC'}, # By omitting color, a random color is selected. 'sar': {}, # fill area between senkou_a and senkou_b 'senkou_a': { 'color': 'green', #optional 'fill_to': 'senkou_b', 'fill_label': 'Ichimoku Cloud', #optional 'fill_color': 'rgba(255,76,46,0.2)', #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b': {} }, 'subplots': { # Create subplot MACD \"MACD\": { 'macd': {'color': 'blue', 'fill_to': 'macdhist'}, 'macdsignal': {'color': 'orange'}, 'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}} }, # Additional subplot RSI \"RSI\": { 'rsi': {'color': 'red'} } } } ``` Note The above configuration assumes that ema10 , ema50 , senkou_a , senkou_b , macd , macdsignal , macdhist and rsi are columns in the DataFrame created by the strategy. Warning plotly arguments are only supported with plotly library and will not work with freq-ui. Trade position adjustments If position_adjustment_enable / adjust_trade_position() is used, the trade initial buy price is averaged over multiple orders and the trade start price will most likely appear outside the candle range. Plot profit \u00b6 The plot-profit subcommand shows an interactive graph with three plots: Average closing price for all pairs. The summarized profit made by backtesting. Note that this is not the real-world profit, but more of an estimate. Profit for each individual pair. Parallelism of trades. Underwater (Periods of drawdown). The first graph is good to get a grip of how the overall market progresses. The second graph will show if your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less often, but makes big swings. This graph will also highlight the start (and end) of the Max drawdown period. The third graph can be useful to spot outliers, events in pairs that cause profit spikes. The forth graph can help you analyze trade parallelism, showing how often max_open_trades have been maxed out. Possible options for the freqtrade plot-profit subcommand: ``` usage: freqtrade plot-profit [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--timerange TIMERANGE] [--export EXPORT] [--export-filename PATH] [--db-url PATH] [--trade-source {DB,file}] [-i TIMEFRAME] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --timerange TIMERANGE Specify what timerange of data to use. --export EXPORT Export backtest results, argument are: trades. Example: --export=trades --export-filename PATH, --backtest-filename PATH Use backtest results from this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --auto-open Automatically open generated plot. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` The -p/--pairs argument, can be used to limit the pairs that are considered for this calculation. Examples: Use custom backtest-export file bash freqtrade plot-profit -p LTC/BTC --export-filename user_data/backtest_results/backtest-result.json Use custom database bash freqtrade plot-profit -p LTC/BTC --db-url sqlite:///tradesv3.sqlite --trade-source DB bash freqtrade --datadir user_data/data/binance_save/ plot-profit -p LTC/BTC","title":"Plotting"},{"location":"plotting/#plotting","text":"This page explains how to plot prices, indicators and profits.","title":"Plotting"},{"location":"plotting/#installation-setup","text":"Plotting modules use the Plotly library. You can install / upgrade this by running the following command: bash pip install -U -r requirements-plot.txt","title":"Installation / Setup"},{"location":"plotting/#plot-price-and-indicators","text":"The freqtrade plot-dataframe subcommand shows an interactive graph with three subplots: Main plot with candlestics and indicators following price (sma/ema) Volume bars Additional indicators as specified by --indicators2 Possible arguments: ``` usage: freqtrade plot-dataframe [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--indicators1 INDICATORS1 [INDICATORS1 ...]] [--indicators2 INDICATORS2 [INDICATORS2 ...]] [--plot-limit INT] [--db-url PATH] [--trade-source {DB,file}] [--export EXPORT] [--export-filename PATH] [--timerange TIMERANGE] [-i TIMEFRAME] [--no-trades] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --indicators1 INDICATORS1 [INDICATORS1 ...] Set indicators from your strategy you want in the first row of the graph. Space-separated list. Example: ema3 ema5 . Default: ['sma', 'ema3', 'ema5'] . --indicators2 INDICATORS2 [INDICATORS2 ...] Set indicators from your strategy you want in the third row of the graph. Space-separated list. Example: fastd fastk . Default: ['macd', 'macdsignal'] . --plot-limit INT Specify tick limit for plotting. Notice: too high values cause huge files. Default: 750. --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file --export EXPORT Export backtest results, argument are: trades. Example: --export=trades --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --timerange TIMERANGE Specify what timerange of data to use. -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --no-trades Skip using trades from backtesting file and DB. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` Example: bash freqtrade plot-dataframe -p BTC/ETH The -p/--pairs argument can be used to specify pairs you would like to plot. Note The freqtrade plot-dataframe subcommand generates one plot-file per pair. Specify custom indicators. Use --indicators1 for the main plot and --indicators2 for the subplot below (if values are in a different range than prices). Tip You will almost certainly want to specify a custom strategy! This can be done by adding -s Classname / --strategy ClassName to the command. bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --indicators1 sma ema --indicators2 macd","title":"Plot price and indicators"},{"location":"plotting/#further-usage-examples","text":"To plot multiple pairs, separate them with a space: bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH XRP/ETH To plot a timerange (to zoom in) bash freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805 To plot trades stored in a database use --db-url in combination with --trade-source DB : bash freqtrade plot-dataframe --strategy AwesomeStrategy --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB To plot trades from a backtesting result, use --export-filename <filename> bash freqtrade plot-dataframe --strategy AwesomeStrategy --export-filename user_data/backtest_results/backtest-result.json -p BTC/ETH","title":"Further usage examples"},{"location":"plotting/#plot-dataframe-basics","text":"The plot-dataframe subcommand requires backtesting data, a strategy and either a backtesting-results file or a database, containing trades corresponding to the strategy. The resulting plot will have the following elements: Green triangles: Buy signals from the strategy. (Note: not every buy signal generates a trade, compare to cyan circles.) Red triangles: Sell signals from the strategy. (Also, not every sell signal terminates a trade, compare to red and green squares.) Cyan circles: Trade entry points. Red squares: Trade exit points for trades with loss or 0% profit. Green squares: Trade exit points for profitable trades. Indicators with values corresponding to the candle scale (e.g. SMA/EMA), as specified with --indicators1 . Volume (bar chart at the bottom of the main chart). Indicators with values in different scales (e.g. MACD, RSI) below the volume bars, as specified with --indicators2 . Bollinger Bands Bollinger bands are automatically added to the plot if the columns bb_lowerband and bb_upperband exist, and are painted as a light blue area spanning from the lower band to the upper band.","title":"Plot dataframe basics"},{"location":"plotting/#advanced-plot-configuration","text":"An advanced plot configuration can be specified in the strategy in the plot_config parameter. Additional features when using plot_config include: Specify colors per indicator Specify additional subplots Specify indicator pairs to fill area in between The sample plot configuration below specifies fixed colors for the indicators. Otherwise, consecutive plots may produce different color schemes each time, making comparisons difficult. It also allows multiple subplots to display both MACD and RSI at the same time. Plot type can be configured using type key. Possible types are: scatter corresponding to plotly.graph_objects.Scatter class (default). bar corresponding to plotly.graph_objects.Bar class. Extra parameters to plotly.graph_objects.* constructor can be specified in plotly dict. Sample configuration with inline comments explaining the process: ``` python @property def plot_config(self): \"\"\" There are a lot of solutions how to build the return dictionary. The only important point is the return value. Example: plot_config = {'main_plot': {}, 'subplots': {}} \"\"\" plot_config = {} plot_config['main_plot'] = { # Configuration for main plot indicators. # Assumes 2 parameters, emashort and emalong to be specified. f'ema_{self.emashort.value}': {'color': 'red'}, f'ema_{self.emalong.value}': {'color': '#CCCCCC'}, # By omitting color, a random color is selected. 'sar': {}, # fill area between senkou_a and senkou_b 'senkou_a': { 'color': 'green', #optional 'fill_to': 'senkou_b', 'fill_label': 'Ichimoku Cloud', #optional 'fill_color': 'rgba(255,76,46,0.2)', #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b': {} } plot_config['subplots'] = { # Create subplot MACD \"MACD\": { 'macd': {'color': 'blue', 'fill_to': 'macdhist'}, 'macdsignal': {'color': 'orange'}, 'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}} }, # Additional subplot RSI \"RSI\": { 'rsi': {'color': 'red'} } } return plot_config ``` As attribute (former method) Assigning plot_config is also possible as Attribute (this used to be the default way). This has the disadvantage that strategy parameters are not available, preventing certain configurations from working. `` python plot_config = { 'main_plot': { # Configuration for main plot indicators. # Specifies ema10 to be red, and ema50` to be a shade of gray 'ema10': {'color': 'red'}, 'ema50': {'color': '#CCCCCC'}, # By omitting color, a random color is selected. 'sar': {}, # fill area between senkou_a and senkou_b 'senkou_a': { 'color': 'green', #optional 'fill_to': 'senkou_b', 'fill_label': 'Ichimoku Cloud', #optional 'fill_color': 'rgba(255,76,46,0.2)', #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b': {} }, 'subplots': { # Create subplot MACD \"MACD\": { 'macd': {'color': 'blue', 'fill_to': 'macdhist'}, 'macdsignal': {'color': 'orange'}, 'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}} }, # Additional subplot RSI \"RSI\": { 'rsi': {'color': 'red'} } } } ``` Note The above configuration assumes that ema10 , ema50 , senkou_a , senkou_b , macd , macdsignal , macdhist and rsi are columns in the DataFrame created by the strategy. Warning plotly arguments are only supported with plotly library and will not work with freq-ui. Trade position adjustments If position_adjustment_enable / adjust_trade_position() is used, the trade initial buy price is averaged over multiple orders and the trade start price will most likely appear outside the candle range.","title":"Advanced plot configuration"},{"location":"plotting/#plot-profit","text":"The plot-profit subcommand shows an interactive graph with three plots: Average closing price for all pairs. The summarized profit made by backtesting. Note that this is not the real-world profit, but more of an estimate. Profit for each individual pair. Parallelism of trades. Underwater (Periods of drawdown). The first graph is good to get a grip of how the overall market progresses. The second graph will show if your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less often, but makes big swings. This graph will also highlight the start (and end) of the Max drawdown period. The third graph can be useful to spot outliers, events in pairs that cause profit spikes. The forth graph can help you analyze trade parallelism, showing how often max_open_trades have been maxed out. Possible options for the freqtrade plot-profit subcommand: ``` usage: freqtrade plot-profit [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--timerange TIMERANGE] [--export EXPORT] [--export-filename PATH] [--db-url PATH] [--trade-source {DB,file}] [-i TIMEFRAME] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --timerange TIMERANGE Specify what timerange of data to use. --export EXPORT Export backtest results, argument are: trades. Example: --export=trades --export-filename PATH, --backtest-filename PATH Use backtest results from this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe ( 1m , 5m , 30m , 1h , 1d ). --auto-open Automatically open generated plot. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. ``` The -p/--pairs argument, can be used to limit the pairs that are considered for this calculation. Examples: Use custom backtest-export file bash freqtrade plot-profit -p LTC/BTC --export-filename user_data/backtest_results/backtest-result.json Use custom database bash freqtrade plot-profit -p LTC/BTC --db-url sqlite:///tradesv3.sqlite --trade-source DB bash freqtrade --datadir user_data/data/binance_save/ plot-profit -p LTC/BTC","title":"Plot profit"},{"location":"plugins/","text":"Plugins \u00b6 Pairlists and Pairlist Handlers \u00b6 Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist. Pair blacklist \u00b6 The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!) Available Pairlist Handlers \u00b6 StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly. Static Pair List \u00b6 By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . json \"pairlists\": [ {\"method\": \"StaticPairList\"} ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist. Volume Pair List \u00b6 VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange. VolumePairList Advanced mode \u00b6 VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 3600, \"lookback_timeframe\": \"1h\", \"lookback_period\": 72 } ], Note VolumePairList does not support backtesting mode. AgeFilter \u00b6 Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed . OffsetFilter \u00b6 Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist: json \"pairlists\": [ // ... { \"method\": \"OffsetFilter\", \"offset\": 10 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger then the total length of the incoming pairlist will result in an empty pairlist. PerformanceFilter \u00b6 Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. json \"pairlists\": [ // ... { \"method\": \"PerformanceFilter\", \"minutes\": 1440, // rolling 24h \"min_profit\": 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode. PrecisionFilter \u00b6 Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies. PriceFilter \u00b6 The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding. ShuffleFilter \u00b6 Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set. SpreadFilter \u00b6 Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out. RangeStabilityFilter \u00b6 Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. json \"pairlists\": [ { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"max_rate_of_change\": 0.99, \"refresh_period\": 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time. VolatilityFilter \u00b6 Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. json \"pairlists\": [ { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 } ] Full example of Pairlist Handlers \u00b6 The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. json \"exchange\": { \"pair_whitelist\": [], \"pair_blacklist\": [\"BNB/BTC\"] }, \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\" }, {\"method\": \"AgeFilter\", \"min_days_listed\": 10}, {\"method\": \"PrecisionFilter\"}, {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01}, {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005}, { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"refresh_period\": 1440 }, { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 }, {\"method\": \"ShuffleFilter\", \"seed\": 42} ], Protections \u00b6 Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property . Available Protections \u00b6 StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade. Common settings to all Protections \u00b6 Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition. Stoploss Guard \u00b6 StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. python @property def protections(self): return [ { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 4, \"only_per_pair\": False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy. MaxDrawdown \u00b6 MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. python @property def protections(self): return [ { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 12, \"max_allowed_drawdown\": 0.2 }, ] Low Profit Pairs \u00b6 LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. python @property def protections(self): return [ { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration\": 60, \"required_profit\": 0.02 } ] Cooldown Period \u00b6 CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". python @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade. Full example of Protections \u00b6 All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. ``` python from freqtrade.strategy import IStrategy class AwesomeStrategy(IStrategy) timeframe = '1h' @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 5 }, { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 4, \"max_allowed_drawdown\": 0.2 }, { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"only_per_pair\": False }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration_candles\": 60, \"required_profit\": 0.02 }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"required_profit\": 0.01 } ] # ... ```","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"plugins/#pairlists-and-pairlist-handlers","text":"Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist.","title":"Pairlists and Pairlist Handlers"},{"location":"plugins/#pair-blacklist","text":"The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!)","title":"Pair blacklist"},{"location":"plugins/#available-pairlist-handlers","text":"StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly.","title":"Available Pairlist Handlers"},{"location":"plugins/#static-pair-list","text":"By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . json \"pairlists\": [ {\"method\": \"StaticPairList\"} ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist.","title":"Static Pair List"},{"location":"plugins/#volume-pair-list","text":"VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange.","title":"Volume Pair List"},{"location":"plugins/#volumepairlist-advanced-mode","text":"VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 3600, \"lookback_timeframe\": \"1h\", \"lookback_period\": 72 } ], Note VolumePairList does not support backtesting mode.","title":"VolumePairList Advanced mode"},{"location":"plugins/#agefilter","text":"Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed .","title":"AgeFilter"},{"location":"plugins/#offsetfilter","text":"Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist: json \"pairlists\": [ // ... { \"method\": \"OffsetFilter\", \"offset\": 10 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger then the total length of the incoming pairlist will result in an empty pairlist.","title":"OffsetFilter"},{"location":"plugins/#performancefilter","text":"Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. json \"pairlists\": [ // ... { \"method\": \"PerformanceFilter\", \"minutes\": 1440, // rolling 24h \"min_profit\": 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode.","title":"PerformanceFilter"},{"location":"plugins/#precisionfilter","text":"Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies.","title":"PrecisionFilter"},{"location":"plugins/#pricefilter","text":"The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.","title":"PriceFilter"},{"location":"plugins/#shufflefilter","text":"Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set.","title":"ShuffleFilter"},{"location":"plugins/#spreadfilter","text":"Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out.","title":"SpreadFilter"},{"location":"plugins/#rangestabilityfilter","text":"Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. json \"pairlists\": [ { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"max_rate_of_change\": 0.99, \"refresh_period\": 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.","title":"RangeStabilityFilter"},{"location":"plugins/#volatilityfilter","text":"Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. json \"pairlists\": [ { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 } ]","title":"VolatilityFilter"},{"location":"plugins/#full-example-of-pairlist-handlers","text":"The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. json \"exchange\": { \"pair_whitelist\": [], \"pair_blacklist\": [\"BNB/BTC\"] }, \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\" }, {\"method\": \"AgeFilter\", \"min_days_listed\": 10}, {\"method\": \"PrecisionFilter\"}, {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01}, {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005}, { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"refresh_period\": 1440 }, { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 }, {\"method\": \"ShuffleFilter\", \"seed\": 42} ],","title":"Full example of Pairlist Handlers"},{"location":"plugins/#protections","text":"Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property .","title":"Protections"},{"location":"plugins/#available-protections","text":"StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade.","title":"Available Protections"},{"location":"plugins/#common-settings-to-all-protections","text":"Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.","title":"Common settings to all Protections"},{"location":"plugins/#stoploss-guard","text":"StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. python @property def protections(self): return [ { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 4, \"only_per_pair\": False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy.","title":"Stoploss Guard"},{"location":"plugins/#maxdrawdown","text":"MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. python @property def protections(self): return [ { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 12, \"max_allowed_drawdown\": 0.2 }, ]","title":"MaxDrawdown"},{"location":"plugins/#low-profit-pairs","text":"LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. python @property def protections(self): return [ { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration\": 60, \"required_profit\": 0.02 } ]","title":"Low Profit Pairs"},{"location":"plugins/#cooldown-period","text":"CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". python @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade.","title":"Cooldown Period"},{"location":"plugins/#full-example-of-protections","text":"All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. ``` python from freqtrade.strategy import IStrategy class AwesomeStrategy(IStrategy) timeframe = '1h' @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 5 }, { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 4, \"max_allowed_drawdown\": 0.2 }, { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"only_per_pair\": False }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration_candles\": 60, \"required_profit\": 0.02 }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"required_profit\": 0.01 } ] # ... ```","title":"Full example of Protections"},{"location":"rest-api/","text":"REST API & FreqUI \u00b6 FreqUI \u00b6 Freqtrade provides a builtin webserver, which can serve FreqUI , the freqtrade UI. By default, the UI is not included in the installation (except for docker images), and must be installed explicitly with freqtrade install-ui . This same command can also be used to update freqUI, should there be a new release. Once the bot is started in trade / dry-run mode (with freqtrade trade ) - the UI will be available under the configured port below (usually http://127.0.0.1:8080 ). Alpha release FreqUI is still considered an alpha release - if you encounter bugs or inconsistencies please open a FreqUI issue . developers Developers should not use this method, but instead use the method described in the freqUI repository to get the source-code of freqUI. Configuration \u00b6 Enable the rest API by adding the api_server section to your configuration and setting api_server.enabled to true . Sample configuration: json \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"127.0.0.1\", \"listen_port\": 8080, \"verbosity\": \"error\", \"enable_openapi\": false, \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [], \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\" }, Security warning By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot. API/UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. You can then access the API by going to http://127.0.0.1:8080/api/v1/ping in a browser to check if the API is running correctly. This should return the response: output {\"status\":\"pong\"} All other endpoints return sensitive info and require authentication and are therefore not available through a web browser. Security \u00b6 To generate a secure password, best use a password manager, or use the below code. python import secrets secrets.token_hex() JWT token Use the same method to also generate a JWT secret key ( jwt_secret_key ). Password selection Please make sure to select a very strong, unique password to protect your bot from unauthorized access. Also change jwt_secret_key to something random (no need to remember this, but it'll be used to encrypt your session, so it better be something unique!). Configuration with docker \u00b6 If you run your bot using docker, you'll need to have the bot listen to incoming connections. The security is then handled by docker. json \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"0.0.0.0\", \"listen_port\": 8080, \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\", //... }, Make sure that the following 2 lines are available in your docker-compose file: yml ports: - \"127.0.0.1:8080:8080\" Security warning By using 8080:8080 in the docker port mapping, the API will be available to everyone connecting to the server under the correct port, so others may be able to control your bot. Rest API \u00b6 Consuming the API \u00b6 You can consume the API by using the script scripts/rest_client.py . The client script only requires the requests module, so Freqtrade does not need to be installed on the system. bash python3 scripts/rest_client.py <command> [optional parameters] By default, the script assumes 127.0.0.1 (localhost) and port 8080 to be used, however you can specify a configuration file to override this behaviour. Minimalistic client config \u00b6 json { \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"0.0.0.0\", \"listen_port\": 8080, \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\", //... } } bash python3 scripts/rest_client.py --config rest_config.json <command> [optional parameters] Available endpoints \u00b6 Command Description ping Simple command testing the API Readiness - requires no authentication. start Starts the trader. stop Stops the trader. stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. reload_config Reloads the configuration file. trades List last trades. Limited to 500 trades per call. trade/<tradeid> Get specific trade. delete_trade <trade_id> Remove trade from the database. Tries to close open orders. Requires manual handling of this trade on the exchange. show_config Shows part of the current configuration with relevant settings to operation. logs Shows last log messages. status Lists all open trades. count Displays number of trades used and available. locks Displays currently locked pairs. delete_lock <lock_id> Deletes (disables) the lock by id. profit Display a summary of your profit/loss from close trades and some stats about your performance. forcesell <trade_id> Instantly sells the given trade (Ignoring minimum_roi ). forcesell all Instantly sells all open trades (Ignoring minimum_roi ). forcebuy <pair> [rate] Instantly buys the given pair. Rate is optional. ( forcebuy_enable must be set to True) performance Show performance of each finished trade grouped by pair. balance Show account balance per currency. daily <n> Shows profit or loss per day, over the last n days (n defaults to 7). stats Display a summary of profit / loss reasons as well as average holding times. whitelist Show the current whitelist. blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. edge Show validated pairs by Edge if it is enabled. pair_candles Returns dataframe for a pair / timeframe combination while the bot is running. Alpha pair_history Returns an analyzed dataframe for a given timerange, analyzed by a given strategy. Alpha plot_config Get plot config from the strategy (or nothing if not configured). Alpha strategies List strategies in strategy directory. Alpha strategy <strategy> Get specific Strategy content. Alpha available_pairs List available backtest data. Alpha version Show version. Alpha status Endpoints labeled with Alpha status above may change at any time without notice. Possible commands can be listed from the rest-client script using the help command. bash python3 scripts/rest_client.py help ``` output Possible commands: available_pairs Return available pair (backtest data) based on timeframe / stake_currency selection :param timeframe: Only pairs with this timeframe available. :param stake_currency: Only pairs that include this timeframe balance Get the account balance. blacklist Show the current blacklist. :param add: List of coins to add (example: \"BNB/BTC\") count Return the amount of open trades. daily Return the profits for each day, and amount of trades. delete_lock Delete (disable) lock from the database. :param lock_id: ID for the lock to delete delete_trade Delete trade from the database. Tries to close open orders. Requires manual handling of this asset on the exchange. :param trade_id: Deletes the trade with this ID from the database. edge Return information about edge. forcebuy Buy an asset. :param pair: Pair to buy (ETH/BTC) :param price: Optional - price to buy forcesell Force-sell a trade. :param tradeid: Id of the trade (can be received via status command) locks Return current locks logs Show latest logs. :param limit: Limits log messages to the last <limit> logs. No limit to get the entire log. pair_candles Return live dataframe for . :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param limit: Limit result to the last n candles. pair_history Return historic, analyzed dataframe :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param strategy: Strategy to analyze and get values for :param timerange: Timerange to get data for (same format than --timerange endpoints) performance Return the performance of the different coins. ping simple ping plot_config Return plot configuration if the strategy defines one. profit Return the profit summary. reload_config Reload configuration. show_config Returns part of the configuration, relevant for trading operations. start Start the bot if it's in the stopped state. stats Return the stats report (durations, sell-reasons). status Get the status of open trades. stop Stop the bot. Use start to restart. stopbuy Stop buying (but handle sells gracefully). Use reload_config to reset. strategies Lists available strategies strategy Get strategy details :param strategy: Strategy class name trade Return specific trade :param trade_id: Specify which trade to get. trades Return trades history, sorted by id :param limit: Limits trades to the X last trades. Max 500 trades. :param offset: Offset by this amount of trades. version Return the version of the bot. whitelist Show the current whitelist. ``` OpenAPI interface \u00b6 To enable the builtin openAPI interface (Swagger UI), specify \"enable_openapi\": true in the api_server configuration. This will enable the Swagger UI at the /docs endpoint. By default, that's running at http://localhost:8080/docs/ - but it'll depend on your settings. Advanced API usage using JWT tokens \u00b6 Note The below should be done in an application (a Freqtrade REST API client, which fetches info via API), and is not intended to be used on a regular basis. Freqtrade's REST API also offers JWT (JSON Web Tokens). You can login using the following command, and subsequently use the resulting access_token. ``` bash curl -X POST --user Freqtrader http://localhost:8080/api/v1/token/login access_token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\" Use access_token for authentication \u00b6 curl -X GET --header \"Authorization: Bearer ${access_token}\" http://localhost:8080/api/v1/count ``` Since the access token has a short timeout (15 min) - the token/refresh request should be used periodically to get a fresh access token: ``` bash curl -X POST --header \"Authorization: Bearer ${refresh_token}\" http://localhost:8080/api/v1/token/refresh {\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk5NzQsIm5iZiI6MTU4OTExOTk3NCwianRpIjoiMDBjNTlhMWUtMjBmYS00ZTk0LTliZjAtNWQwNTg2MTdiZDIyIiwiZXhwIjoxNTg5MTIwODc0LCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.1seHlII3WprjjclY6DpRhen0rqdF4j6jbvxIhUFaSbs\"} ``` CORS \u00b6 This whole section is only necessary in cross-origin cases (where you multiple bot API's running on localhost:8081 , localhost:8082 , ...), and want to combine them into one FreqUI instance. Technical explanation All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows * CORS policies for requests with credentials, so this setting must be set appropriately. Users can allow access from different origin URL's to the bot API via the CORS_origins configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API. Assuming your application is deployed as https://frequi.freqtrade.io/home/ - this would mean that the following configuration becomes necessary: jsonc { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"https://frequi.freqtrade.io\"], //... } In the following (pretty common) case, FreqUI is accessible on http://localhost:8080/trade (this is what you see in your navbar when navigating to freqUI). The correct configuration for this case is http://localhost:8080 - the main part of the URL including the port. jsonc { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"http://localhost:8080\"], //... } Note We strongly recommend to also set jwt_secret_key to something random and known only to yourself to avoid unauthorized access to your bot.","title":"REST API & FreqUI"},{"location":"rest-api/#rest-api-frequi","text":"","title":"REST API &amp; FreqUI"},{"location":"rest-api/#frequi","text":"Freqtrade provides a builtin webserver, which can serve FreqUI , the freqtrade UI. By default, the UI is not included in the installation (except for docker images), and must be installed explicitly with freqtrade install-ui . This same command can also be used to update freqUI, should there be a new release. Once the bot is started in trade / dry-run mode (with freqtrade trade ) - the UI will be available under the configured port below (usually http://127.0.0.1:8080 ). Alpha release FreqUI is still considered an alpha release - if you encounter bugs or inconsistencies please open a FreqUI issue . developers Developers should not use this method, but instead use the method described in the freqUI repository to get the source-code of freqUI.","title":"FreqUI"},{"location":"rest-api/#configuration","text":"Enable the rest API by adding the api_server section to your configuration and setting api_server.enabled to true . Sample configuration: json \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"127.0.0.1\", \"listen_port\": 8080, \"verbosity\": \"error\", \"enable_openapi\": false, \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [], \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\" }, Security warning By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot. API/UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. You can then access the API by going to http://127.0.0.1:8080/api/v1/ping in a browser to check if the API is running correctly. This should return the response: output {\"status\":\"pong\"} All other endpoints return sensitive info and require authentication and are therefore not available through a web browser.","title":"Configuration"},{"location":"rest-api/#security","text":"To generate a secure password, best use a password manager, or use the below code. python import secrets secrets.token_hex() JWT token Use the same method to also generate a JWT secret key ( jwt_secret_key ). Password selection Please make sure to select a very strong, unique password to protect your bot from unauthorized access. Also change jwt_secret_key to something random (no need to remember this, but it'll be used to encrypt your session, so it better be something unique!).","title":"Security"},{"location":"rest-api/#configuration-with-docker","text":"If you run your bot using docker, you'll need to have the bot listen to incoming connections. The security is then handled by docker. json \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"0.0.0.0\", \"listen_port\": 8080, \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\", //... }, Make sure that the following 2 lines are available in your docker-compose file: yml ports: - \"127.0.0.1:8080:8080\" Security warning By using 8080:8080 in the docker port mapping, the API will be available to everyone connecting to the server under the correct port, so others may be able to control your bot.","title":"Configuration with docker"},{"location":"rest-api/#rest-api","text":"","title":"Rest API"},{"location":"rest-api/#consuming-the-api","text":"You can consume the API by using the script scripts/rest_client.py . The client script only requires the requests module, so Freqtrade does not need to be installed on the system. bash python3 scripts/rest_client.py <command> [optional parameters] By default, the script assumes 127.0.0.1 (localhost) and port 8080 to be used, however you can specify a configuration file to override this behaviour.","title":"Consuming the API"},{"location":"rest-api/#minimalistic-client-config","text":"json { \"api_server\": { \"enabled\": true, \"listen_ip_address\": \"0.0.0.0\", \"listen_port\": 8080, \"username\": \"Freqtrader\", \"password\": \"SuperSecret1!\", //... } } bash python3 scripts/rest_client.py --config rest_config.json <command> [optional parameters]","title":"Minimalistic client config"},{"location":"rest-api/#available-endpoints","text":"Command Description ping Simple command testing the API Readiness - requires no authentication. start Starts the trader. stop Stops the trader. stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. reload_config Reloads the configuration file. trades List last trades. Limited to 500 trades per call. trade/<tradeid> Get specific trade. delete_trade <trade_id> Remove trade from the database. Tries to close open orders. Requires manual handling of this trade on the exchange. show_config Shows part of the current configuration with relevant settings to operation. logs Shows last log messages. status Lists all open trades. count Displays number of trades used and available. locks Displays currently locked pairs. delete_lock <lock_id> Deletes (disables) the lock by id. profit Display a summary of your profit/loss from close trades and some stats about your performance. forcesell <trade_id> Instantly sells the given trade (Ignoring minimum_roi ). forcesell all Instantly sells all open trades (Ignoring minimum_roi ). forcebuy <pair> [rate] Instantly buys the given pair. Rate is optional. ( forcebuy_enable must be set to True) performance Show performance of each finished trade grouped by pair. balance Show account balance per currency. daily <n> Shows profit or loss per day, over the last n days (n defaults to 7). stats Display a summary of profit / loss reasons as well as average holding times. whitelist Show the current whitelist. blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. edge Show validated pairs by Edge if it is enabled. pair_candles Returns dataframe for a pair / timeframe combination while the bot is running. Alpha pair_history Returns an analyzed dataframe for a given timerange, analyzed by a given strategy. Alpha plot_config Get plot config from the strategy (or nothing if not configured). Alpha strategies List strategies in strategy directory. Alpha strategy <strategy> Get specific Strategy content. Alpha available_pairs List available backtest data. Alpha version Show version. Alpha status Endpoints labeled with Alpha status above may change at any time without notice. Possible commands can be listed from the rest-client script using the help command. bash python3 scripts/rest_client.py help ``` output Possible commands: available_pairs Return available pair (backtest data) based on timeframe / stake_currency selection :param timeframe: Only pairs with this timeframe available. :param stake_currency: Only pairs that include this timeframe balance Get the account balance. blacklist Show the current blacklist. :param add: List of coins to add (example: \"BNB/BTC\") count Return the amount of open trades. daily Return the profits for each day, and amount of trades. delete_lock Delete (disable) lock from the database. :param lock_id: ID for the lock to delete delete_trade Delete trade from the database. Tries to close open orders. Requires manual handling of this asset on the exchange. :param trade_id: Deletes the trade with this ID from the database. edge Return information about edge. forcebuy Buy an asset. :param pair: Pair to buy (ETH/BTC) :param price: Optional - price to buy forcesell Force-sell a trade. :param tradeid: Id of the trade (can be received via status command) locks Return current locks logs Show latest logs. :param limit: Limits log messages to the last <limit> logs. No limit to get the entire log. pair_candles Return live dataframe for . :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param limit: Limit result to the last n candles. pair_history Return historic, analyzed dataframe :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param strategy: Strategy to analyze and get values for :param timerange: Timerange to get data for (same format than --timerange endpoints) performance Return the performance of the different coins. ping simple ping plot_config Return plot configuration if the strategy defines one. profit Return the profit summary. reload_config Reload configuration. show_config Returns part of the configuration, relevant for trading operations. start Start the bot if it's in the stopped state. stats Return the stats report (durations, sell-reasons). status Get the status of open trades. stop Stop the bot. Use start to restart. stopbuy Stop buying (but handle sells gracefully). Use reload_config to reset. strategies Lists available strategies strategy Get strategy details :param strategy: Strategy class name trade Return specific trade :param trade_id: Specify which trade to get. trades Return trades history, sorted by id :param limit: Limits trades to the X last trades. Max 500 trades. :param offset: Offset by this amount of trades. version Return the version of the bot. whitelist Show the current whitelist. ```","title":"Available endpoints"},{"location":"rest-api/#openapi-interface","text":"To enable the builtin openAPI interface (Swagger UI), specify \"enable_openapi\": true in the api_server configuration. This will enable the Swagger UI at the /docs endpoint. By default, that's running at http://localhost:8080/docs/ - but it'll depend on your settings.","title":"OpenAPI interface"},{"location":"rest-api/#advanced-api-usage-using-jwt-tokens","text":"Note The below should be done in an application (a Freqtrade REST API client, which fetches info via API), and is not intended to be used on a regular basis. Freqtrade's REST API also offers JWT (JSON Web Tokens). You can login using the following command, and subsequently use the resulting access_token. ``` bash curl -X POST --user Freqtrader http://localhost:8080/api/v1/token/login access_token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\"","title":"Advanced API usage using JWT tokens"},{"location":"rest-api/#use-access_token-for-authentication","text":"curl -X GET --header \"Authorization: Bearer ${access_token}\" http://localhost:8080/api/v1/count ``` Since the access token has a short timeout (15 min) - the token/refresh request should be used periodically to get a fresh access token: ``` bash curl -X POST --header \"Authorization: Bearer ${refresh_token}\" http://localhost:8080/api/v1/token/refresh {\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk5NzQsIm5iZiI6MTU4OTExOTk3NCwianRpIjoiMDBjNTlhMWUtMjBmYS00ZTk0LTliZjAtNWQwNTg2MTdiZDIyIiwiZXhwIjoxNTg5MTIwODc0LCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.1seHlII3WprjjclY6DpRhen0rqdF4j6jbvxIhUFaSbs\"} ```","title":"Use access_token for authentication"},{"location":"rest-api/#cors","text":"This whole section is only necessary in cross-origin cases (where you multiple bot API's running on localhost:8081 , localhost:8082 , ...), and want to combine them into one FreqUI instance. Technical explanation All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows * CORS policies for requests with credentials, so this setting must be set appropriately. Users can allow access from different origin URL's to the bot API via the CORS_origins configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API. Assuming your application is deployed as https://frequi.freqtrade.io/home/ - this would mean that the following configuration becomes necessary: jsonc { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"https://frequi.freqtrade.io\"], //... } In the following (pretty common) case, FreqUI is accessible on http://localhost:8080/trade (this is what you see in your navbar when navigating to freqUI). The correct configuration for this case is http://localhost:8080 - the main part of the URL including the port. jsonc { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"http://localhost:8080\"], //... } Note We strongly recommend to also set jwt_secret_key to something random and known only to yourself to avoid unauthorized access to your bot.","title":"CORS"},{"location":"sandbox-testing/","text":"Sandbox API testing \u00b6 Some exchanges provide sandboxes or testbeds for risk-free testing, while running the bot against a real exchange. With some configuration, freqtrade (in combination with ccxt) provides access to these. This document is an overview to configure Freqtrade to be used with sandboxes. This can be useful to developers and trader alike. Warning Sandboxes usually have very low volume, and either a very wide spread, or no orders available at all. Therefore, sandboxes will usually not do a good job of showing you how a strategy would work in real trading. Exchanges known to have a sandbox / testnet \u00b6 binance coinbasepro gemini huobipro kucoin phemex Note We did not test correct functioning of all of the above testnets. Please report your experiences with each sandbox. Configure a Sandbox account \u00b6 When testing your API connectivity, make sure to use the appropriate sandbox / testnet URL. In general, you should follow these steps to enable an exchange's sandbox: Figure out if an exchange has a sandbox (most likely by using google or the exchange's support documents) Create a sandbox account (often the sandbox-account requires separate registration) Add some test assets to account Create API keys Add test funds \u00b6 Usually, sandbox exchanges allow depositing funds directly via web-interface. You should make sure to have a realistic amount of funds available to your test-account, so results are representable of your real account funds. Warning Test exchanges will NEVER require your real credit card or banking details! Configure freqtrade to use a exchange's sandbox \u00b6 Sandbox URLs \u00b6 Freqtrade makes use of CCXT which in turn provides a list of URLs to Freqtrade. These include ['test'] and ['api'] . [Test] if available will point to an Exchanges sandbox. [Api] normally used, and resolves to live API target on the exchange. To make use of sandbox / test add \"sandbox\": true, to your config.json json \"exchange\": { \"name\": \"coinbasepro\", \"sandbox\": true, \"key\": \"5wowfxemogxeowo;heiohgmd\", \"secret\": \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\", \"password\": \"1bkjfkhfhfu6sr\", \"outdated_offset\": 5 \"pair_whitelist\": [ \"BTC/USD\" ] }, \"datadir\": \"user_data/data/coinbasepro_sandbox\" Also the following information: api-key (created for the sandbox webpage) api-secret (noted earlier) password (the passphrase - noted earlier) Different data directory We also recommend to set datadir to something identifying downloaded data as sandbox data, to avoid having sandbox data mixed with data from the real exchange. This can be done by adding the \"datadir\" key to the configuration. Now, whenever you use this configuration, your data directory will be set to this directory. You should now be ready to test your sandbox \u00b6 Ensure Freqtrade logs show the sandbox URL, and trades made are shown in sandbox. Also make sure to select a pair which shows at least some decent value (which very often is BTC/ ). Common problems with sandbox exchanges \u00b6 Sandbox exchange instances often have very low volume, which can cause some problems which usually are not seen on a real exchange instance. Old Candles problem \u00b6 Since Sandboxes often have low volume, candles can be quite old and show no volume. To disable the error \"Outdated history for pair ...\", best increase the parameter \"outdated_offset\" to a number that seems realistic for the sandbox you're using. Unfilled orders \u00b6 Sandboxes often have very low volumes - which means that many trades can go unfilled, or can go unfilled for a very long time. To mitigate this, you can try to match the first order on the opposite orderbook side using the following configuration: jsonc \"order_types\": { \"buy\": \"limit\", \"sell\": \"limit\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, The configuration is similar to the suggested configuration for market orders - however by using limit-orders you can avoid moving the price too much, and you can set the worst price you might get.","title":"Sandbox Testing"},{"location":"sandbox-testing/#sandbox-api-testing","text":"Some exchanges provide sandboxes or testbeds for risk-free testing, while running the bot against a real exchange. With some configuration, freqtrade (in combination with ccxt) provides access to these. This document is an overview to configure Freqtrade to be used with sandboxes. This can be useful to developers and trader alike. Warning Sandboxes usually have very low volume, and either a very wide spread, or no orders available at all. Therefore, sandboxes will usually not do a good job of showing you how a strategy would work in real trading.","title":"Sandbox API testing"},{"location":"sandbox-testing/#exchanges-known-to-have-a-sandbox-testnet","text":"binance coinbasepro gemini huobipro kucoin phemex Note We did not test correct functioning of all of the above testnets. Please report your experiences with each sandbox.","title":"Exchanges known to have a sandbox / testnet"},{"location":"sandbox-testing/#configure-a-sandbox-account","text":"When testing your API connectivity, make sure to use the appropriate sandbox / testnet URL. In general, you should follow these steps to enable an exchange's sandbox: Figure out if an exchange has a sandbox (most likely by using google or the exchange's support documents) Create a sandbox account (often the sandbox-account requires separate registration) Add some test assets to account Create API keys","title":"Configure a Sandbox account"},{"location":"sandbox-testing/#add-test-funds","text":"Usually, sandbox exchanges allow depositing funds directly via web-interface. You should make sure to have a realistic amount of funds available to your test-account, so results are representable of your real account funds. Warning Test exchanges will NEVER require your real credit card or banking details!","title":"Add test funds"},{"location":"sandbox-testing/#configure-freqtrade-to-use-a-exchanges-sandbox","text":"","title":"Configure freqtrade to use a exchange's sandbox"},{"location":"sandbox-testing/#sandbox-urls","text":"Freqtrade makes use of CCXT which in turn provides a list of URLs to Freqtrade. These include ['test'] and ['api'] . [Test] if available will point to an Exchanges sandbox. [Api] normally used, and resolves to live API target on the exchange. To make use of sandbox / test add \"sandbox\": true, to your config.json json \"exchange\": { \"name\": \"coinbasepro\", \"sandbox\": true, \"key\": \"5wowfxemogxeowo;heiohgmd\", \"secret\": \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\", \"password\": \"1bkjfkhfhfu6sr\", \"outdated_offset\": 5 \"pair_whitelist\": [ \"BTC/USD\" ] }, \"datadir\": \"user_data/data/coinbasepro_sandbox\" Also the following information: api-key (created for the sandbox webpage) api-secret (noted earlier) password (the passphrase - noted earlier) Different data directory We also recommend to set datadir to something identifying downloaded data as sandbox data, to avoid having sandbox data mixed with data from the real exchange. This can be done by adding the \"datadir\" key to the configuration. Now, whenever you use this configuration, your data directory will be set to this directory.","title":"Sandbox URLs"},{"location":"sandbox-testing/#you-should-now-be-ready-to-test-your-sandbox","text":"Ensure Freqtrade logs show the sandbox URL, and trades made are shown in sandbox. Also make sure to select a pair which shows at least some decent value (which very often is BTC/ ).","title":"You should now be ready to test your sandbox"},{"location":"sandbox-testing/#common-problems-with-sandbox-exchanges","text":"Sandbox exchange instances often have very low volume, which can cause some problems which usually are not seen on a real exchange instance.","title":"Common problems with sandbox exchanges"},{"location":"sandbox-testing/#old-candles-problem","text":"Since Sandboxes often have low volume, candles can be quite old and show no volume. To disable the error \"Outdated history for pair ...\", best increase the parameter \"outdated_offset\" to a number that seems realistic for the sandbox you're using.","title":"Old Candles problem"},{"location":"sandbox-testing/#unfilled-orders","text":"Sandboxes often have very low volumes - which means that many trades can go unfilled, or can go unfilled for a very long time. To mitigate this, you can try to match the first order on the opposite orderbook side using the following configuration: jsonc \"order_types\": { \"buy\": \"limit\", \"sell\": \"limit\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, The configuration is similar to the suggested configuration for market orders - however by using limit-orders you can avoid moving the price too much, and you can set the worst price you might get.","title":"Unfilled orders"},{"location":"sql_cheatsheet/","text":"SQL Helper \u00b6 This page contains some help if you want to edit your sqlite db. Install sqlite3 \u00b6 Sqlite3 is a terminal based sqlite application. Feel free to use a visual Database editor like SqliteBrowser if you feel more comfortable with that. Ubuntu/Debian installation \u00b6 bash sudo apt-get install sqlite3 Using sqlite3 via docker-compose \u00b6 The freqtrade docker image does contain sqlite3, so you can edit the database without having to install anything on the host system. bash docker-compose exec freqtrade /bin/bash sqlite3 <database-file>.sqlite Open the DB \u00b6 bash sqlite3 .open <filepath> Table structure \u00b6 List tables \u00b6 bash .tables Display table structure \u00b6 bash .schema <table_name> Get all trades in the table \u00b6 sql SELECT * FROM trades; Fix trade still open after a manual sell on the exchange \u00b6 Warning Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, forcesell should be used to accomplish the same thing. It is strongly advised to backup your database file before making any manual changes. Note This should not be necessary after /forcesell, as forcesell orders are closed automatically by the bot on the next iteration. sql UPDATE trades SET is_open=0, close_date=<close_date>, close_rate=<close_rate>, close_profit = close_rate / open_rate - 1, close_profit_abs = (amount * <close_rate> * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))), sell_reason=<sell_reason> WHERE id=<trade_ID_to_update>; Example \u00b6 sql UPDATE trades SET is_open=0, close_date='2020-06-20 03:08:45.103418', close_rate=0.19638016, close_profit=0.0496, close_profit_abs = (amount * 0.19638016 * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))), sell_reason='force_sell' WHERE id=31; Remove trade from the database \u00b6 Use RPC Methods to delete trades Consider using /delete <tradeid> via telegram or rest API. That's the recommended way to deleting trades. If you'd still like to remove a trade from the database directly, you can use the below query. sql DELETE FROM trades WHERE id = <tradeid>; sql DELETE FROM trades WHERE id = 31; Warning This will remove this trade from the database. Please make sure you got the correct id and NEVER run this query without the where clause. Use a different database system \u00b6 Warning By using one of the below database systems, you acknowledge that you know how to manage such a system. Freqtrade will not provide any support with setup or maintenance (or backups) of the below database systems. PostgreSQL \u00b6 Freqtrade supports PostgreSQL by using SQLAlchemy, which supports multiple different database systems. Installation: pip install psycopg2-binary Usage: ... --db-url postgresql+psycopg2://<username>:<password>@localhost:5432/<database> Freqtrade will automatically create the tables necessary upon startup. If you're running different instances of Freqtrade, you must either setup one database per Instance or use different users / schemas for your connections. MariaDB / MySQL \u00b6 Freqtrade supports MariaDB by using SQLAlchemy, which supports multiple different database systems. Installation: pip install pymysql Usage: ... --db-url mysql+pymysql://<username>:<password>@localhost:3306/<database>","title":"SQL Cheat-sheet"},{"location":"sql_cheatsheet/#sql-helper","text":"This page contains some help if you want to edit your sqlite db.","title":"SQL Helper"},{"location":"sql_cheatsheet/#install-sqlite3","text":"Sqlite3 is a terminal based sqlite application. Feel free to use a visual Database editor like SqliteBrowser if you feel more comfortable with that.","title":"Install sqlite3"},{"location":"sql_cheatsheet/#ubuntudebian-installation","text":"bash sudo apt-get install sqlite3","title":"Ubuntu/Debian installation"},{"location":"sql_cheatsheet/#using-sqlite3-via-docker-compose","text":"The freqtrade docker image does contain sqlite3, so you can edit the database without having to install anything on the host system. bash docker-compose exec freqtrade /bin/bash sqlite3 <database-file>.sqlite","title":"Using sqlite3 via docker-compose"},{"location":"sql_cheatsheet/#open-the-db","text":"bash sqlite3 .open <filepath>","title":"Open the DB"},{"location":"sql_cheatsheet/#table-structure","text":"","title":"Table structure"},{"location":"sql_cheatsheet/#list-tables","text":"bash .tables","title":"List tables"},{"location":"sql_cheatsheet/#display-table-structure","text":"bash .schema <table_name>","title":"Display table structure"},{"location":"sql_cheatsheet/#get-all-trades-in-the-table","text":"sql SELECT * FROM trades;","title":"Get all trades in the table"},{"location":"sql_cheatsheet/#fix-trade-still-open-after-a-manual-sell-on-the-exchange","text":"Warning Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, forcesell should be used to accomplish the same thing. It is strongly advised to backup your database file before making any manual changes. Note This should not be necessary after /forcesell, as forcesell orders are closed automatically by the bot on the next iteration. sql UPDATE trades SET is_open=0, close_date=<close_date>, close_rate=<close_rate>, close_profit = close_rate / open_rate - 1, close_profit_abs = (amount * <close_rate> * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))), sell_reason=<sell_reason> WHERE id=<trade_ID_to_update>;","title":"Fix trade still open after a manual sell on the exchange"},{"location":"sql_cheatsheet/#example","text":"sql UPDATE trades SET is_open=0, close_date='2020-06-20 03:08:45.103418', close_rate=0.19638016, close_profit=0.0496, close_profit_abs = (amount * 0.19638016 * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))), sell_reason='force_sell' WHERE id=31;","title":"Example"},{"location":"sql_cheatsheet/#remove-trade-from-the-database","text":"Use RPC Methods to delete trades Consider using /delete <tradeid> via telegram or rest API. That's the recommended way to deleting trades. If you'd still like to remove a trade from the database directly, you can use the below query. sql DELETE FROM trades WHERE id = <tradeid>; sql DELETE FROM trades WHERE id = 31; Warning This will remove this trade from the database. Please make sure you got the correct id and NEVER run this query without the where clause.","title":"Remove trade from the database"},{"location":"sql_cheatsheet/#use-a-different-database-system","text":"Warning By using one of the below database systems, you acknowledge that you know how to manage such a system. Freqtrade will not provide any support with setup or maintenance (or backups) of the below database systems.","title":"Use a different database system"},{"location":"sql_cheatsheet/#postgresql","text":"Freqtrade supports PostgreSQL by using SQLAlchemy, which supports multiple different database systems. Installation: pip install psycopg2-binary Usage: ... --db-url postgresql+psycopg2://<username>:<password>@localhost:5432/<database> Freqtrade will automatically create the tables necessary upon startup. If you're running different instances of Freqtrade, you must either setup one database per Instance or use different users / schemas for your connections.","title":"PostgreSQL"},{"location":"sql_cheatsheet/#mariadb-mysql","text":"Freqtrade supports MariaDB by using SQLAlchemy, which supports multiple different database systems. Installation: pip install pymysql Usage: ... --db-url mysql+pymysql://<username>:<password>@localhost:3306/<database>","title":"MariaDB / MySQL"},{"location":"stoploss/","text":"Stop Loss \u00b6 The stoploss configuration parameter is loss as ratio that should trigger a sale. For example, value -0.10 will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional. Stoploss calculations do include fees, so a stoploss of -10% is placed exactly 10% below the entry point. Most of the strategy files already include the optimal stoploss value. Info All stoploss properties mentioned in this file can be set in the Strategy, or in the configuration. Configuration values will override the strategy values. Stop Loss On-Exchange/Freqtrade \u00b6 Those stoploss modes can be on exchange or off exchange . These modes can be configured with these values: python 'emergencysell': 'market', 'stoploss_on_exchange': False 'stoploss_on_exchange_interval': 60, 'stoploss_on_exchange_limit_ratio': 0.99 Note Stoploss on exchange is only supported for Binance (stop-loss-limit), Huobi (stop-limit), Kraken (stop-loss-market, stop-loss-limit), FTX (stop limit and stop-market) Gateio (stop-limit), and Kucoin (stop-limit and stop-market) as of now. Do not set too low/tight stoploss value if using stop loss on exchange! If set to low/tight then you have greater risk of missing fill on the order and stoploss will not work. stoploss_on_exchange and stoploss_on_exchange_limit_ratio \u00b6 Enable or Disable stop loss on exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order fills. This will protect you against sudden crashes in market, as the order execution happens purely within the exchange, and has no potential network overhead. If stoploss_on_exchange uses limit orders, the exchange needs 2 prices, the stoploss_price and the Limit price. stoploss defines the stop-price where the limit order is placed - and limit should be slightly below this. If an exchange supports both limit and market stoploss orders, then the value of stoploss will be used to determine the stoploss type. Calculation example: we bought the asset at 100$. Stop-price is 95$, then limit would be 95 * 0.99 = 94.05$ - so the limit order fill can happen between 95$ and 94.05$. For example, assuming the stoploss is on exchange, and trailing stoploss is enabled, and the market is going up, then the bot automatically cancels the previous stoploss order and puts a new one with a stop value higher than the previous stoploss order. Note If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. stoploss_on_exchange_interval \u00b6 In case of stoploss on exchange there is another parameter called stoploss_on_exchange_interval . This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. The bot cannot do these every 5 seconds (at each iteration), otherwise it would get banned by the exchange. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute). This same logic will reapply a stoploss order on the exchange should you cancel it accidentally. forcesell \u00b6 forcesell is an optional value, which defaults to the same value as sell and is used when sending a /forcesell command from Telegram or from the Rest API. forcebuy \u00b6 forcebuy is an optional value, which defaults to the same value as buy and is used when sending a /forcebuy command from Telegram or from the Rest API. emergencysell \u00b6 emergencysell is an optional value, which defaults to market and is used when creating stop loss on exchange orders fails. The below is the default which is used if not changed in strategy or configuration file. Example from strategy file: python order_types = { 'buy': 'limit', 'sell': 'limit', 'emergencysell': 'market', 'stoploss': 'market', 'stoploss_on_exchange': True, 'stoploss_on_exchange_interval': 60, 'stoploss_on_exchange_limit_ratio': 0.99 } Stop Loss Types \u00b6 At this stage the bot contains the following stoploss support modes: Static stop loss. Trailing stop loss. Trailing stop loss, custom positive loss. Trailing stop loss only once the trade has reached a certain offset. Custom stoploss function Static Stop Loss \u00b6 This is very simple, you define a stop loss of x (as a ratio of price, i.e. x * 100% of price). This will try to sell the asset once the loss exceeds the defined loss. Example of stop loss: python stoploss = -0.10 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ Trailing Stop Loss \u00b6 The initial value for this is stoploss , just as you would define your static Stop loss. To enable trailing stoploss: python stoploss = -0.10 trailing_stop = True This will now activate an algorithm, which automatically moves the stop loss up every time the price of your asset increases. For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -10% of 102$ = 91.8$ now the asset drops in value to 101$, the stop loss will still be 91.8$ and would trigger at 91.8$. In summary: The stoploss will be adjusted to be always be -10% of the highest observed price. Trailing stop loss, custom positive loss \u00b6 It is also possible to have a default stop loss, when you are in the red with your buy (buy - fee), but once you hit positive result the system will utilize a new stop loss, which can have a different value. For example, your default stop loss is -10%, but once you have more than 0% profit (example 0.1%) a different trailing stoploss will be used. Note If you want the stoploss to only be changed when you break even of making a profit (what most users want) please refer to next section with offset enabled . Both values require trailing_stop to be set to true and trailing_stop_positive with a value. python stoploss = -0.10 trailing_stop = True trailing_stop_positive = 0.02 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -2% of 102$ = 99.96$ (99.96$ stop loss will be locked in and will follow asset price increments with -2%) now the asset drops in value to 101$, the stop loss will still be 99.96$ and would trigger at 99.96$ The 0.02 would translate to a -2% stop loss. Before this, stoploss is used for the trailing stoploss. Trailing stop loss only once the trade has reached a certain offset \u00b6 It is also possible to use a static stoploss until the offset is reached, and then trail the trade to take profits once the market turns. If \"trailing_only_offset_is_reached\": true then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured stoploss . This option can be used with or without trailing_stop_positive , but uses trailing_stop_positive_offset as offset. python trailing_stop_positive_offset = 0.011 trailing_only_offset_is_reached = True Configuration (offset is buy-price + 3%): python stoploss = -0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 trailing_only_offset_is_reached = True For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ stoploss will remain at 90$ unless asset increases to or above the configured offset assuming the asset now increases to 103$ (where we have the offset configured) the stop loss will now be -2% of 103$ = 100.94$ now the asset drops in value to 101$, the stop loss will still be 100.94$ and would trigger at 100.94$ Tip Make sure to have this value ( trailing_stop_positive_offset ) lower than minimal ROI, otherwise minimal ROI will apply first and sell the trade. Changing stoploss on open trades \u00b6 A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the /reload_config command (alternatively, completely stopping and restarting the bot also works). The new stoploss value will be applied to open trades (and corresponding log-messages will be generated). Limitations \u00b6 Stoploss values cannot be changed if trailing_stop is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).","title":"Stoploss"},{"location":"stoploss/#stop-loss","text":"The stoploss configuration parameter is loss as ratio that should trigger a sale. For example, value -0.10 will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional. Stoploss calculations do include fees, so a stoploss of -10% is placed exactly 10% below the entry point. Most of the strategy files already include the optimal stoploss value. Info All stoploss properties mentioned in this file can be set in the Strategy, or in the configuration. Configuration values will override the strategy values.","title":"Stop Loss"},{"location":"stoploss/#stop-loss-on-exchangefreqtrade","text":"Those stoploss modes can be on exchange or off exchange . These modes can be configured with these values: python 'emergencysell': 'market', 'stoploss_on_exchange': False 'stoploss_on_exchange_interval': 60, 'stoploss_on_exchange_limit_ratio': 0.99 Note Stoploss on exchange is only supported for Binance (stop-loss-limit), Huobi (stop-limit), Kraken (stop-loss-market, stop-loss-limit), FTX (stop limit and stop-market) Gateio (stop-limit), and Kucoin (stop-limit and stop-market) as of now. Do not set too low/tight stoploss value if using stop loss on exchange! If set to low/tight then you have greater risk of missing fill on the order and stoploss will not work.","title":"Stop Loss On-Exchange/Freqtrade"},{"location":"stoploss/#stoploss_on_exchange-and-stoploss_on_exchange_limit_ratio","text":"Enable or Disable stop loss on exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order fills. This will protect you against sudden crashes in market, as the order execution happens purely within the exchange, and has no potential network overhead. If stoploss_on_exchange uses limit orders, the exchange needs 2 prices, the stoploss_price and the Limit price. stoploss defines the stop-price where the limit order is placed - and limit should be slightly below this. If an exchange supports both limit and market stoploss orders, then the value of stoploss will be used to determine the stoploss type. Calculation example: we bought the asset at 100$. Stop-price is 95$, then limit would be 95 * 0.99 = 94.05$ - so the limit order fill can happen between 95$ and 94.05$. For example, assuming the stoploss is on exchange, and trailing stoploss is enabled, and the market is going up, then the bot automatically cancels the previous stoploss order and puts a new one with a stop value higher than the previous stoploss order. Note If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order.","title":"stoploss_on_exchange and stoploss_on_exchange_limit_ratio"},{"location":"stoploss/#stoploss_on_exchange_interval","text":"In case of stoploss on exchange there is another parameter called stoploss_on_exchange_interval . This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. The bot cannot do these every 5 seconds (at each iteration), otherwise it would get banned by the exchange. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute). This same logic will reapply a stoploss order on the exchange should you cancel it accidentally.","title":"stoploss_on_exchange_interval"},{"location":"stoploss/#forcesell","text":"forcesell is an optional value, which defaults to the same value as sell and is used when sending a /forcesell command from Telegram or from the Rest API.","title":"forcesell"},{"location":"stoploss/#forcebuy","text":"forcebuy is an optional value, which defaults to the same value as buy and is used when sending a /forcebuy command from Telegram or from the Rest API.","title":"forcebuy"},{"location":"stoploss/#emergencysell","text":"emergencysell is an optional value, which defaults to market and is used when creating stop loss on exchange orders fails. The below is the default which is used if not changed in strategy or configuration file. Example from strategy file: python order_types = { 'buy': 'limit', 'sell': 'limit', 'emergencysell': 'market', 'stoploss': 'market', 'stoploss_on_exchange': True, 'stoploss_on_exchange_interval': 60, 'stoploss_on_exchange_limit_ratio': 0.99 }","title":"emergencysell"},{"location":"stoploss/#stop-loss-types","text":"At this stage the bot contains the following stoploss support modes: Static stop loss. Trailing stop loss. Trailing stop loss, custom positive loss. Trailing stop loss only once the trade has reached a certain offset. Custom stoploss function","title":"Stop Loss Types"},{"location":"stoploss/#static-stop-loss","text":"This is very simple, you define a stop loss of x (as a ratio of price, i.e. x * 100% of price). This will try to sell the asset once the loss exceeds the defined loss. Example of stop loss: python stoploss = -0.10 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$","title":"Static Stop Loss"},{"location":"stoploss/#trailing-stop-loss","text":"The initial value for this is stoploss , just as you would define your static Stop loss. To enable trailing stoploss: python stoploss = -0.10 trailing_stop = True This will now activate an algorithm, which automatically moves the stop loss up every time the price of your asset increases. For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -10% of 102$ = 91.8$ now the asset drops in value to 101$, the stop loss will still be 91.8$ and would trigger at 91.8$. In summary: The stoploss will be adjusted to be always be -10% of the highest observed price.","title":"Trailing Stop Loss"},{"location":"stoploss/#trailing-stop-loss-custom-positive-loss","text":"It is also possible to have a default stop loss, when you are in the red with your buy (buy - fee), but once you hit positive result the system will utilize a new stop loss, which can have a different value. For example, your default stop loss is -10%, but once you have more than 0% profit (example 0.1%) a different trailing stoploss will be used. Note If you want the stoploss to only be changed when you break even of making a profit (what most users want) please refer to next section with offset enabled . Both values require trailing_stop to be set to true and trailing_stop_positive with a value. python stoploss = -0.10 trailing_stop = True trailing_stop_positive = 0.02 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -2% of 102$ = 99.96$ (99.96$ stop loss will be locked in and will follow asset price increments with -2%) now the asset drops in value to 101$, the stop loss will still be 99.96$ and would trigger at 99.96$ The 0.02 would translate to a -2% stop loss. Before this, stoploss is used for the trailing stoploss.","title":"Trailing stop loss, custom positive loss"},{"location":"stoploss/#trailing-stop-loss-only-once-the-trade-has-reached-a-certain-offset","text":"It is also possible to use a static stoploss until the offset is reached, and then trail the trade to take profits once the market turns. If \"trailing_only_offset_is_reached\": true then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured stoploss . This option can be used with or without trailing_stop_positive , but uses trailing_stop_positive_offset as offset. python trailing_stop_positive_offset = 0.011 trailing_only_offset_is_reached = True Configuration (offset is buy-price + 3%): python stoploss = -0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 trailing_only_offset_is_reached = True For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ stoploss will remain at 90$ unless asset increases to or above the configured offset assuming the asset now increases to 103$ (where we have the offset configured) the stop loss will now be -2% of 103$ = 100.94$ now the asset drops in value to 101$, the stop loss will still be 100.94$ and would trigger at 100.94$ Tip Make sure to have this value ( trailing_stop_positive_offset ) lower than minimal ROI, otherwise minimal ROI will apply first and sell the trade.","title":"Trailing stop loss only once the trade has reached a certain offset"},{"location":"stoploss/#changing-stoploss-on-open-trades","text":"A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the /reload_config command (alternatively, completely stopping and restarting the bot also works). The new stoploss value will be applied to open trades (and corresponding log-messages will be generated).","title":"Changing stoploss on open trades"},{"location":"stoploss/#limitations","text":"Stoploss values cannot be changed if trailing_stop is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).","title":"Limitations"},{"location":"strategy-advanced/","text":"Advanced Strategies \u00b6 This page explains some advanced concepts available for strategies. If you're just getting started, please be familiar with the methods described in the Strategy Customization documentation and with the Freqtrade basics first. Freqtrade basics describes in which sequence each method described below is called, which can be helpful to understand which method to use for your custom needs. Note All callback methods described below should only be implemented in a strategy if they are actually used. Tip You can get a strategy template containing all below methods by running freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced Storing information \u00b6 Storing information can be accomplished by creating a new dictionary within the strategy class. The name of the variable can be chosen at will, but should be prefixed with cust_ to avoid naming collisions with predefined strategy variables. ```python class AwesomeStrategy(IStrategy): # Create custom dictionary custom_info = {} def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # Check if the entry already exists if not metadata[\"pair\"] in self.custom_info: # Create empty entry for this pair self.custom_info[metadata[\"pair\"]] = {} if \"crosstime\" in self.custom_info[metadata[\"pair\"]]: self.custom_info[metadata[\"pair\"]][\"crosstime\"] += 1 else: self.custom_info[metadata[\"pair\"]][\"crosstime\"] = 1 ``` Warning The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash. Note If the data is pair-specific, make sure to use pair as one of the keys in the dictionary. Dataframe access \u00b6 You may access dataframe in various strategy functions by querying it from dataprovider. ``` python from freqtrade.exchange import timeframe_to_prev_date class AwesomeStrategy(IStrategy): def confirm_trade_exit(self, pair: str, trade: 'Trade', order_type: str, amount: float, rate: float, time_in_force: str, sell_reason: str, current_time: 'datetime', **kwargs) -> bool: # Obtain pair dataframe. dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) # Obtain last available candle. Do not use current_time to look up latest candle, because # current_time points to current incomplete candle whose data is not available. last_candle = dataframe.iloc[-1].squeeze() # <...> # In dry/live runs trade open date will not match candle open date therefore it must be # rounded. trade_date = timeframe_to_prev_date(self.timeframe, trade.open_date_utc) # Look up trade candle. trade_candle = dataframe.loc[dataframe['date'] == trade_date] # trade_candle may be empty for trades that just opened as it is still incomplete. if not trade_candle.empty: trade_candle = trade_candle.squeeze() # <...> ``` Using .iloc[-1] You can use .iloc[-1] here because get_analyzed_dataframe() only returns candles that backtesting is allowed to see. This will not work in populate_* methods, so make sure to not use .iloc[] in that area. Also, this will only work starting with version 2021.5. Buy Tag \u00b6 When your strategy has multiple buy signals, you can name the signal that triggered. Then you can access you buy signal on custom_sell ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (dataframe['rsi'] < 35) & (dataframe['volume'] > 0) ), ['buy', 'buy_tag']] = (1, 'buy_signal_rsi') return dataframe def custom_sell(self, pair: str, trade: Trade, current_time: datetime, current_rate: float, current_profit: float, **kwargs): dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() if trade.buy_tag == 'buy_signal_rsi' and last_candle['rsi'] > 80: return 'sell_signal_rsi' return None ``` Note buy_tag is limited to 100 characters, remaining data will be truncated. Exit tag \u00b6 Similar to Buy Tagging , you can also specify a sell tag. ``` python def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (dataframe['rsi'] > 70) & (dataframe['volume'] > 0) ), ['sell', 'exit_tag']] = (1, 'exit_rsi') return dataframe ``` The provided exit-tag is then used as sell-reason - and shown as such in backtest results. Note sell_reason is limited to 100 characters, remaining data will be truncated. Strategy version \u00b6 You can implement custom strategy versioning by using the \"version\" method, and returning the version you would like this strategy to have. python def version(self) -> str: \"\"\" Returns version of the strategy. \"\"\" return \"1.1\" Note You should make sure to implement proper version control (like a git repository) alongside this, as freqtrade will not keep historic versions of your strategy, so it's up to the user to be able to eventually roll back to a prior version of the strategy. Derived strategies \u00b6 The strategies can be derived from other strategies. This avoids duplication of your custom strategy code. You can use this technique to override small parts of your main strategy, leaving the rest untouched: ``` python title=\"user_data/strategies/myawesomestrategy.py\" class MyAwesomeStrategy(IStrategy): ... stoploss = 0.13 trailing_stop = False # All other attributes and methods are here as they # should be in any custom strategy... ... ``` python title=\"user_data/strategies/MyAwesomeStrategy2.py\" from myawesomestrategy import MyAwesomeStrategy class MyAwesomeStrategy2(MyAwesomeStrategy): # Override something stoploss = 0.08 trailing_stop = True Both attributes and methods may be overridden, altering behavior of the original strategy in a way you need. While keeping the subclass in the same file is technically possible, it can lead to some problems with hyperopt parameter files, we therefore recommend to use separate strategy files, and import the parent strategy as shown above. Embedding Strategies \u00b6 Freqtrade provides you with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file. Encoding a string as BASE64 \u00b6 This is a quick example, how to generate the BASE64 string in python ```python from base64 import urlsafe_b64encode with open(file, 'r') as f: content = f.read() content = urlsafe_b64encode(content.encode('utf-8')) ``` The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following json \"strategy\": \"NameOfStrategy:BASE64String\" Please ensure that 'NameOfStrategy' is identical to the strategy name! Performance warning \u00b6 When executing a strategy, one can sometimes be greeted by the following in the logs PerformanceWarning: DataFrame is highly fragmented. This is a warning from pandas and as the warning continues to say: use pd.concat(axis=1) . This can have slight performance implications, which are usually only visible during hyperopt (when optimizing an indicator). For example: python for val in self.buy_ema_short.range: dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val) should be rewritten to ```python frames = [dataframe] for val in self.buy_ema_short.range: frames.append(DataFrame({ f'ema_short_{val}': ta.EMA(dataframe, timeperiod=val) })) Append columns to existing dataframe \u00b6 merged_frame = pd.concat(frames, axis=1) ```","title":"Advanced Strategy"},{"location":"strategy-advanced/#advanced-strategies","text":"This page explains some advanced concepts available for strategies. If you're just getting started, please be familiar with the methods described in the Strategy Customization documentation and with the Freqtrade basics first. Freqtrade basics describes in which sequence each method described below is called, which can be helpful to understand which method to use for your custom needs. Note All callback methods described below should only be implemented in a strategy if they are actually used. Tip You can get a strategy template containing all below methods by running freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced","title":"Advanced Strategies"},{"location":"strategy-advanced/#storing-information","text":"Storing information can be accomplished by creating a new dictionary within the strategy class. The name of the variable can be chosen at will, but should be prefixed with cust_ to avoid naming collisions with predefined strategy variables. ```python class AwesomeStrategy(IStrategy): # Create custom dictionary custom_info = {} def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # Check if the entry already exists if not metadata[\"pair\"] in self.custom_info: # Create empty entry for this pair self.custom_info[metadata[\"pair\"]] = {} if \"crosstime\" in self.custom_info[metadata[\"pair\"]]: self.custom_info[metadata[\"pair\"]][\"crosstime\"] += 1 else: self.custom_info[metadata[\"pair\"]][\"crosstime\"] = 1 ``` Warning The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash. Note If the data is pair-specific, make sure to use pair as one of the keys in the dictionary.","title":"Storing information"},{"location":"strategy-advanced/#dataframe-access","text":"You may access dataframe in various strategy functions by querying it from dataprovider. ``` python from freqtrade.exchange import timeframe_to_prev_date class AwesomeStrategy(IStrategy): def confirm_trade_exit(self, pair: str, trade: 'Trade', order_type: str, amount: float, rate: float, time_in_force: str, sell_reason: str, current_time: 'datetime', **kwargs) -> bool: # Obtain pair dataframe. dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) # Obtain last available candle. Do not use current_time to look up latest candle, because # current_time points to current incomplete candle whose data is not available. last_candle = dataframe.iloc[-1].squeeze() # <...> # In dry/live runs trade open date will not match candle open date therefore it must be # rounded. trade_date = timeframe_to_prev_date(self.timeframe, trade.open_date_utc) # Look up trade candle. trade_candle = dataframe.loc[dataframe['date'] == trade_date] # trade_candle may be empty for trades that just opened as it is still incomplete. if not trade_candle.empty: trade_candle = trade_candle.squeeze() # <...> ``` Using .iloc[-1] You can use .iloc[-1] here because get_analyzed_dataframe() only returns candles that backtesting is allowed to see. This will not work in populate_* methods, so make sure to not use .iloc[] in that area. Also, this will only work starting with version 2021.5.","title":"Dataframe access"},{"location":"strategy-advanced/#buy-tag","text":"When your strategy has multiple buy signals, you can name the signal that triggered. Then you can access you buy signal on custom_sell ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (dataframe['rsi'] < 35) & (dataframe['volume'] > 0) ), ['buy', 'buy_tag']] = (1, 'buy_signal_rsi') return dataframe def custom_sell(self, pair: str, trade: Trade, current_time: datetime, current_rate: float, current_profit: float, **kwargs): dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() if trade.buy_tag == 'buy_signal_rsi' and last_candle['rsi'] > 80: return 'sell_signal_rsi' return None ``` Note buy_tag is limited to 100 characters, remaining data will be truncated.","title":"Buy Tag"},{"location":"strategy-advanced/#exit-tag","text":"Similar to Buy Tagging , you can also specify a sell tag. ``` python def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (dataframe['rsi'] > 70) & (dataframe['volume'] > 0) ), ['sell', 'exit_tag']] = (1, 'exit_rsi') return dataframe ``` The provided exit-tag is then used as sell-reason - and shown as such in backtest results. Note sell_reason is limited to 100 characters, remaining data will be truncated.","title":"Exit tag"},{"location":"strategy-advanced/#strategy-version","text":"You can implement custom strategy versioning by using the \"version\" method, and returning the version you would like this strategy to have. python def version(self) -> str: \"\"\" Returns version of the strategy. \"\"\" return \"1.1\" Note You should make sure to implement proper version control (like a git repository) alongside this, as freqtrade will not keep historic versions of your strategy, so it's up to the user to be able to eventually roll back to a prior version of the strategy.","title":"Strategy version"},{"location":"strategy-advanced/#derived-strategies","text":"The strategies can be derived from other strategies. This avoids duplication of your custom strategy code. You can use this technique to override small parts of your main strategy, leaving the rest untouched: ``` python title=\"user_data/strategies/myawesomestrategy.py\" class MyAwesomeStrategy(IStrategy): ... stoploss = 0.13 trailing_stop = False # All other attributes and methods are here as they # should be in any custom strategy... ... ``` python title=\"user_data/strategies/MyAwesomeStrategy2.py\" from myawesomestrategy import MyAwesomeStrategy class MyAwesomeStrategy2(MyAwesomeStrategy): # Override something stoploss = 0.08 trailing_stop = True Both attributes and methods may be overridden, altering behavior of the original strategy in a way you need. While keeping the subclass in the same file is technically possible, it can lead to some problems with hyperopt parameter files, we therefore recommend to use separate strategy files, and import the parent strategy as shown above.","title":"Derived strategies"},{"location":"strategy-advanced/#embedding-strategies","text":"Freqtrade provides you with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file.","title":"Embedding Strategies"},{"location":"strategy-advanced/#encoding-a-string-as-base64","text":"This is a quick example, how to generate the BASE64 string in python ```python from base64 import urlsafe_b64encode with open(file, 'r') as f: content = f.read() content = urlsafe_b64encode(content.encode('utf-8')) ``` The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following json \"strategy\": \"NameOfStrategy:BASE64String\" Please ensure that 'NameOfStrategy' is identical to the strategy name!","title":"Encoding a string as BASE64"},{"location":"strategy-advanced/#performance-warning","text":"When executing a strategy, one can sometimes be greeted by the following in the logs PerformanceWarning: DataFrame is highly fragmented. This is a warning from pandas and as the warning continues to say: use pd.concat(axis=1) . This can have slight performance implications, which are usually only visible during hyperopt (when optimizing an indicator). For example: python for val in self.buy_ema_short.range: dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val) should be rewritten to ```python frames = [dataframe] for val in self.buy_ema_short.range: frames.append(DataFrame({ f'ema_short_{val}': ta.EMA(dataframe, timeperiod=val) }))","title":"Performance warning"},{"location":"strategy-advanced/#append-columns-to-existing-dataframe","text":"merged_frame = pd.concat(frames, axis=1) ```","title":"Append columns to existing dataframe"},{"location":"strategy-callbacks/","text":"Strategy Callbacks \u00b6 While the main strategy functions ( populate_indicators() , populate_buy_trend() , populate_sell_trend() ) should be used in a vectorized way, and are only called once during backtesting , callbacks are called \"whenever needed\". As such, you should avoid doing heavy calculations in callbacks to avoid delays during operations. Depending on the callback used, they may be called when entering / exiting a trade, or throughout the duration of a trade. Currently available callbacks: bot_loop_start() custom_stake_amount() custom_sell() custom_stoploss() custom_entry_price() and custom_exit_price() check_buy_timeout() and `check_sell_timeout() confirm_trade_entry() confirm_trade_exit() adjust_trade_position() Callback calling sequence You can find the callback calling sequence in bot-basics Bot loop start \u00b6 A simple callback which is called once at the start of every bot throttling iteration (roughly every 5 seconds, unless configured differently). This can be used to perform calculations which are pair independent (apply to all pairs), loading of external data, etc. ``` python import requests class AwesomeStrategy(IStrategy): # ... populate_* methods def bot_loop_start(self, **kwargs) -> None: \"\"\" Called at the start of the bot iteration (one loop). Might be used to perform pair-independent tasks (e.g. gather some remote resource for comparison) :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self.config['runmode'].value in ('live', 'dry_run'): # Assign this to the class by using self.* # can then be used by populate_* methods self.remote_data = requests.get('https://some_remote_source.example.com') ``` Custom Stake size \u00b6 Called before entering a trade, makes it possible to manage your position size when placing a new trade. ```python class AwesomeStrategy(IStrategy): def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float, proposed_stake: float, min_stake: float, max_stake: float, entry_tag: Optional[str], **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) current_candle = dataframe.iloc[-1].squeeze() if current_candle['fastk_rsi_1h'] > current_candle['fastd_rsi_1h']: if self.config['stake_amount'] == 'unlimited': # Use entire available wallet during favorable conditions when in compounding mode. return max_stake else: # Compound profits during favorable conditions instead of using a static stake. return self.wallets.get_total_stake_amount() / self.config['max_open_trades'] # Use default stake amount. return proposed_stake ``` Freqtrade will fall back to the proposed_stake value should your code raise an exception. The exception itself will be logged. Tip You do not have to ensure that min_stake <= returned_value <= max_stake . Trades will succeed as the returned value will be clamped to supported range and this action will be logged. Tip Returning 0 or None will prevent trades from being placed. Custom sell signal \u00b6 Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. Allows to define custom sell signals, indicating that specified position should be sold. This is very useful when we need to customize sell conditions for each individual trade, or if you need trade data to make an exit decision. For example you could implement a 1:2 risk-reward ROI with custom_sell() . Using custom_sell() signals in place of stoploss though is not recommended . It is a inferior method to using custom_stoploss() in this regard - which also allows you to keep the stoploss on exchange. Note Returning a (none-empty) string or True from this method is equal to setting sell signal on a candle at specified time. This method is not called when sell signal is set already, or if sell signals are disabled ( use_sell_signal=False or sell_profit_only=True while profit is below sell_profit_offset ). string max length is 64 characters. Exceeding this limit will cause the message to be truncated to 64 characters. An example of how we can use different indicators depending on the current profit and also sell trades that were open longer than one day: ``` python class AwesomeStrategy(IStrategy): def custom_sell(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float, current_profit: float, **kwargs): dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() # Above 20% profit, sell when rsi < 80 if current_profit > 0.2: if last_candle['rsi'] < 80: return 'rsi_below_80' # Between 2% and 10%, sell if EMA-long above EMA-short if 0.02 < current_profit < 0.1: if last_candle['emalong'] > last_candle['emashort']: return 'ema_long_below_80' # Sell any positions at a loss if they are held for more than one day. if current_profit < 0.0 and (current_time - trade.open_date_utc).days >= 1: return 'unclog' ``` See Dataframe access for more information about dataframe use in strategy callbacks. Custom stoploss \u00b6 Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. The usage of the custom stoploss method must be enabled by setting use_custom_stoploss=True on the strategy object. The stoploss price can only ever move upwards - if the stoploss value returned from custom_stoploss would result in a lower stoploss price than was previously set, it will be ignored. The traditional stoploss value serves as an absolute lower level and will be instated as the initial stoploss (before this method is called for the first time for a trade). The method must return a stoploss value (float / number) as a percentage of the current price. E.g. If the current_rate is 200 USD, then returning 0.02 will set the stoploss price 2% lower, at 196 USD. The absolute value of the return value is used (the sign is ignored), so returning 0.05 or -0.05 have the same result, a stoploss 5% below the current price. To simulate a regular trailing stoploss of 4% (trailing 4% behind the maximum reached price) you would use the following very simple method: ``` python additional imports required \u00b6 from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: \"\"\" Custom stoploss logic, returning the new distance relative to current_rate (as ratio). e.g. returning -0.05 would create a stoploss 5% below current_rate. The custom stoploss can never be below self.stoploss, which serves as a hard maximum loss. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns the initial stoploss value Only called when use_custom_stoploss is set to True. :param pair: Pair that's currently analyzed :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in ask_strategy. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New stoploss value, relative to the current rate \"\"\" return -0.04 ``` Stoploss on exchange works similar to trailing_stop , and the stoploss on exchange is updated as configured in stoploss_on_exchange_interval ( More details about stoploss on exchange ). Use of dates All time-based calculations should be done based on current_time - using datetime.now() or datetime.utcnow() is discouraged, as this will break backtesting support. Trailing stoploss It's recommended to disable trailing_stop when using custom stoploss values. Both can work in tandem, but you might encounter the trailing stop to move the price higher while your custom function would not want this, causing conflicting behavior. Custom stoploss examples \u00b6 The next section will show some examples on what's possible with the custom stoploss function. Of course, many more things are possible, and all examples can be combined at will. Time based trailing stop \u00b6 Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss. ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # Make sure you have the longest interval first - these conditions are evaluated from top to bottom. if current_time - timedelta(minutes=120) > trade.open_date_utc: return -0.05 elif current_time - timedelta(minutes=60) > trade.open_date_utc: return -0.10 return 1 ``` Different stoploss per pair \u00b6 Use a different stoploss depending on the pair. In this example, we'll trail the highest price with 10% trailing stoploss for ETH/BTC and XRP/BTC , with 5% trailing stoploss for LTC/BTC and with 15% for all other pairs. ``` python from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: if pair in ('ETH/BTC', 'XRP/BTC'): return -0.10 elif pair in ('LTC/BTC'): return -0.05 return -0.15 ``` Trailing stoploss with positive offset \u00b6 Use the initial stoploss until the profit is above 4%, then use a trailing stoploss of 50% of the current profit with a minimum of 2.5% and a maximum of 5%. Please note that the stoploss can only increase, values lower than the current stoploss are ignored. ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: if current_profit < 0.04: return -1 # return a value bigger than the initial stoploss to keep using the initial stoploss # After reaching the desired offset, allow the stoploss to trail by half the profit desired_stoploss = current_profit / 2 # Use a minimum of 2.5% and a maximum of 5% return max(min(desired_stoploss, 0.05), 0.025) ``` Stepped stoploss \u00b6 Instead of continuously trailing behind the current price, this example sets fixed stoploss price levels based on the current profit. Use the regular stoploss until 20% profit is reached Once profit is > 20% - set stoploss to 7% above open price. Once profit is > 25% - set stoploss to 15% above open price. Once profit is > 40% - set stoploss to 25% above open price. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import stoploss_from_open class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # evaluate highest to lowest, so that highest possible stop is used if current_profit > 0.40: return stoploss_from_open(0.25, current_profit) elif current_profit > 0.25: return stoploss_from_open(0.15, current_profit) elif current_profit > 0.20: return stoploss_from_open(0.07, current_profit) # return maximum stoploss value, keeping current stoploss price unchanged return 1 ``` Custom stoploss using an indicator from dataframe example \u00b6 Absolute stoploss value may be derived from indicators stored in dataframe. Example uses parabolic SAR below the price as stoploss. ``` python class AwesomeStrategy(IStrategy): def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # <...> dataframe['sar'] = ta.SAR(dataframe) use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() # Use parabolic sar as absolute stoploss price stoploss_price = last_candle['sar'] # Convert absolute price to percentage relative to current_rate if stoploss_price < current_rate: return (stoploss_price / current_rate) - 1 # return maximum stoploss value, keeping current stoploss price unchanged return 1 ``` See Dataframe access for more information about dataframe use in strategy callbacks. Common helpers for stoploss calculations \u00b6 Stoploss relative to open price \u00b6 Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss relative to the open price, we need to use current_profit to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_open() can be used to convert from an open price relative stop, to a current price relative stop which can be returned from custom_stoploss() . Stoploss percentage from absolute price \u00b6 Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss at specified absolute price level, we need to use stop_rate to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_absolute() can be used to convert from an absolute price, to a current price relative stop which can be returned from custom_stoploss() . Custom order price rules \u00b6 By default, freqtrade use the orderbook to automatically set an order price( Relevant documentation ), you also have the option to create custom order prices based on your strategy. You can use this feature by creating a custom_entry_price() function in your strategy file to customize entry prices and custom_exit_price() for exits. Each of these methods are called right before placing an order on the exchange. Note If your custom pricing function return None or an invalid value, price will fall back to proposed_rate , which is based on the regular pricing configuration. Custom order entry and exit price example \u00b6 ``` python from datetime import datetime, timedelta, timezone from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods def custom_entry_price(self, pair: str, current_time: datetime, proposed_rate: float, entry_tag: Optional[str], **kwargs) -> float: dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) new_entryprice = dataframe['bollinger_10_lowerband'].iat[-1] return new_entryprice def custom_exit_price(self, pair: str, trade: Trade, current_time: datetime, proposed_rate: float, current_profit: float, **kwargs) -> float: dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) new_exitprice = dataframe['bollinger_10_upperband'].iat[-1] return new_exitprice ``` Warning Modifying entry and exit prices will only work for limit orders. Depending on the price chosen, this can result in a lot of unfilled orders. By default the maximum allowed distance between the current price and the custom price is 2%, this value can be changed in config with the custom_price_max_distance_ratio parameter. Example : If the new_entryprice is 97, the proposed_rate is 100 and the custom_price_max_distance_ratio is set to 2%, The retained valid custom entry price will be 98, which is 2% below the current (proposed) rate. Backtesting Custom prices are supported in backtesting (starting with 2021.12), and orders will fill if the price falls within the candle's low/high range. Orders that don't fill immediately are subject to regular timeout handling, which happens once per (detail) candle. custom_exit_price() is only called for sells of type Sell_signal and Custom sell. All other sell-types will use regular backtesting prices. Custom order timeout rules \u00b6 Simple, time-based order-timeouts can be configured either via strategy or in the configuration in the unfilledtimeout section. However, freqtrade also offers a custom callback for both order types, which allows you to decide based on custom criteria if an order did time out or not. Note Backtesting fills orders if their price falls within the candle's low/high range. The below callbacks will be called once per (detail) candle for orders that don't fill immediately (which use custom pricing). Custom order timeout example \u00b6 Called for every open order until that order is either filled or cancelled. check_buy_timeout() is called for trade entries, while check_sell_timeout() is called for trade exit orders. A simple example, which applies different unfilled-timeouts depending on the price of the asset can be seen below. It applies a tight timeout for higher priced assets, while allowing more time to fill on cheap coins. The function must return either True (cancel order) or False (keep order alive). ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'buy': 60 * 25, 'sell': 60 * 25 } def check_buy_timeout(self, pair: str, trade: 'Trade', order: dict, current_time: datetime, **kwargs) -> bool: if trade.open_rate > 100 and trade.open_date_utc < current_time - timedelta(minutes=5): return True elif trade.open_rate > 10 and trade.open_date_utc < current_time - timedelta(minutes=3): return True elif trade.open_rate < 1 and trade.open_date_utc < current_time - timedelta(hours=24): return True return False def check_sell_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: if trade.open_rate > 100 and trade.open_date_utc < current_time - timedelta(minutes=5): return True elif trade.open_rate > 10 and trade.open_date_utc < current_time - timedelta(minutes=3): return True elif trade.open_rate < 1 and trade.open_date_utc < current_time - timedelta(hours=24): return True return False ``` Note For the above example, unfilledtimeout must be set to something bigger than 24h, otherwise that type of timeout will apply first. Custom order timeout example (using additional data) \u00b6 ``` python from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'buy': 60 * 25, 'sell': 60 * 25 } def check_buy_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: ob = self.dp.orderbook(pair, 1) current_price = ob['bids'][0][0] # Cancel buy order if price is more than 2% above the order. if current_price > order['price'] * 1.02: return True return False def check_sell_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: ob = self.dp.orderbook(pair, 1) current_price = ob['asks'][0][0] # Cancel sell order if price is more than 2% below the order. if current_price < order['price'] * 0.98: return True return False ``` Bot order confirmation \u00b6 Confirm trade entry / exits. This are the last methods that will be called before an order is placed. Trade entry (buy order) confirmation \u00b6 confirm_trade_entry() can be used to abort a trade entry at the latest second (maybe because the price is not what we expect). ``` python class AwesomeStrategy(IStrategy): # ... populate_* methods def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float, time_in_force: str, current_time: datetime, entry_tag: Optional[str], **kwargs) -> bool: \"\"\" Called right before placing a buy order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be bought. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in target (quote) currency that's going to be traded. :param rate: Rate that's going to be used when using limit orders :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the buy-order is placed on the exchange. False aborts the process \"\"\" return True ``` Trade exit (sell order) confirmation \u00b6 confirm_trade_exit() can be used to abort a trade exit (sell) at the latest second (maybe because the price is not what we expect). ``` python from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods def confirm_trade_exit(self, pair: str, trade: Trade, order_type: str, amount: float, rate: float, time_in_force: str, sell_reason: str, current_time: datetime, **kwargs) -> bool: \"\"\" Called right before placing a regular sell order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be sold. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in quote currency. :param rate: Rate that's going to be used when using limit orders :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param sell_reason: Sell reason. Can be any of ['roi', 'stop_loss', 'stoploss_on_exchange', 'trailing_stop_loss', 'sell_signal', 'force_sell', 'emergency_sell'] :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the sell-order is placed on the exchange. False aborts the process \"\"\" if sell_reason == 'force_sell' and trade.calc_profit_ratio(rate) < 0: # Reject force-sells with negative profit # This is just a sample, please adjust to your needs # (this does not necessarily make sense, assuming you know when you're force-selling) return False return True ``` Adjust trade position \u00b6 The position_adjustment_enable strategy property enables the usage of adjust_trade_position() callback in the strategy. For performance reasons, it's disabled by default and freqtrade will show a warning message on startup if enabled. adjust_trade_position() can be used to perform additional orders, for example to manage risk with DCA (Dollar Cost Averaging). max_entry_position_adjustment property is used to limit the number of additional buys per trade (on top of the first buy) that the bot can execute. By default, the value is -1 which means the bot have no limit on number of adjustment buys. The strategy is expected to return a stake_amount (in stake currency) between min_stake and max_stake if and when an additional buy order should be made (position is increased). If there are not enough funds in the wallet (the return value is above max_stake ) then the signal will be ignored. Additional orders also result in additional fees and those orders don't count towards max_open_trades . This callback is not called when there is an open order (either buy or sell) waiting for execution, or when you have reached the maximum amount of extra buys that you have set on max_entry_position_adjustment . adjust_trade_position() is called very frequently for the duration of a trade, so you must keep your implementation as performant as possible. About stake size Using fixed stake size means it will be the amount used for the first order, just like without position adjustment. If you wish to buy additional orders with DCA, then make sure to leave enough funds in the wallet for that. Using 'unlimited' stake amount with DCA orders requires you to also implement the custom_stake_amount() callback to avoid allocating all funds to the initial order. Warning Stoploss is still calculated from the initial opening price, not averaged price. /stopbuy While /stopbuy command stops the bot from entering new trades, the position adjustment feature will continue buying new orders on existing trades. Backtesting During backtesting this callback is called for each candle in timeframe or timeframe_detail , so performance will be affected. ``` python from freqtrade.persistence import Trade class DigDeeperStrategy(IStrategy): position_adjustment_enable = True # Attempts to handle large drops with DCA. High stoploss is required. stoploss = -0.30 # ... populate_* methods # Example specific variables max_entry_position_adjustment = 3 # This number is explained a bit further down max_dca_multiplier = 5.5 # This is called when placing the initial order (opening trade) def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float, proposed_stake: float, min_stake: float, max_stake: float, entry_tag: Optional[str], **kwargs) -> float: # We need to leave most of the funds for possible further DCA orders # This also applies to fixed stakes return proposed_stake / self.max_dca_multiplier def adjust_trade_position(self, trade: Trade, current_time: datetime, current_rate: float, current_profit: float, min_stake: float, max_stake: float, **kwargs): \"\"\" Custom trade adjustment logic, returning the stake amount that a trade should be increased. This means extra buy orders with additional fees. :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Current buy rate. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param min_stake: Minimal stake size allowed by exchange. :param max_stake: Balance available for trading. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: Stake amount to adjust your trade \"\"\" if current_profit > -0.05: return None # Obtain pair dataframe (just to show how to access it) dataframe, _ = self.dp.get_analyzed_dataframe(trade.pair, self.timeframe) # Only buy when not actively falling price. last_candle = dataframe.iloc[-1].squeeze() previous_candle = dataframe.iloc[-2].squeeze() if last_candle['close'] < previous_candle['close']: return None filled_buys = trade.select_filled_orders('buy') count_of_buys = trade.nr_of_successful_buys # Allow up to 3 additional increasingly larger buys (4 in total) # Initial buy is 1x # If that falls to -5% profit, we buy 1.25x more, average profit should increase to roughly -2.2% # If that falls down to -5% again, we buy 1.5x more # If that falls once again down to -5%, we buy 1.75x more # Total stake for this trade would be 1 + 1.25 + 1.5 + 1.75 = 5.5x of the initial allowed stake. # That is why max_dca_multiplier is 5.5 # Hope you have a deep wallet! try: # This returns first order stake size stake_amount = filled_buys[0].cost # This then calculates current safety order size stake_amount = stake_amount * (1 + (count_of_buys * 0.25)) return stake_amount except Exception as exception: return None return None ```","title":"Strategy Callbacks"},{"location":"strategy-callbacks/#strategy-callbacks","text":"While the main strategy functions ( populate_indicators() , populate_buy_trend() , populate_sell_trend() ) should be used in a vectorized way, and are only called once during backtesting , callbacks are called \"whenever needed\". As such, you should avoid doing heavy calculations in callbacks to avoid delays during operations. Depending on the callback used, they may be called when entering / exiting a trade, or throughout the duration of a trade. Currently available callbacks: bot_loop_start() custom_stake_amount() custom_sell() custom_stoploss() custom_entry_price() and custom_exit_price() check_buy_timeout() and `check_sell_timeout() confirm_trade_entry() confirm_trade_exit() adjust_trade_position() Callback calling sequence You can find the callback calling sequence in bot-basics","title":"Strategy Callbacks"},{"location":"strategy-callbacks/#bot-loop-start","text":"A simple callback which is called once at the start of every bot throttling iteration (roughly every 5 seconds, unless configured differently). This can be used to perform calculations which are pair independent (apply to all pairs), loading of external data, etc. ``` python import requests class AwesomeStrategy(IStrategy): # ... populate_* methods def bot_loop_start(self, **kwargs) -> None: \"\"\" Called at the start of the bot iteration (one loop). Might be used to perform pair-independent tasks (e.g. gather some remote resource for comparison) :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self.config['runmode'].value in ('live', 'dry_run'): # Assign this to the class by using self.* # can then be used by populate_* methods self.remote_data = requests.get('https://some_remote_source.example.com') ```","title":"Bot loop start"},{"location":"strategy-callbacks/#custom-stake-size","text":"Called before entering a trade, makes it possible to manage your position size when placing a new trade. ```python class AwesomeStrategy(IStrategy): def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float, proposed_stake: float, min_stake: float, max_stake: float, entry_tag: Optional[str], **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) current_candle = dataframe.iloc[-1].squeeze() if current_candle['fastk_rsi_1h'] > current_candle['fastd_rsi_1h']: if self.config['stake_amount'] == 'unlimited': # Use entire available wallet during favorable conditions when in compounding mode. return max_stake else: # Compound profits during favorable conditions instead of using a static stake. return self.wallets.get_total_stake_amount() / self.config['max_open_trades'] # Use default stake amount. return proposed_stake ``` Freqtrade will fall back to the proposed_stake value should your code raise an exception. The exception itself will be logged. Tip You do not have to ensure that min_stake <= returned_value <= max_stake . Trades will succeed as the returned value will be clamped to supported range and this action will be logged. Tip Returning 0 or None will prevent trades from being placed.","title":"Custom Stake size"},{"location":"strategy-callbacks/#custom-sell-signal","text":"Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. Allows to define custom sell signals, indicating that specified position should be sold. This is very useful when we need to customize sell conditions for each individual trade, or if you need trade data to make an exit decision. For example you could implement a 1:2 risk-reward ROI with custom_sell() . Using custom_sell() signals in place of stoploss though is not recommended . It is a inferior method to using custom_stoploss() in this regard - which also allows you to keep the stoploss on exchange. Note Returning a (none-empty) string or True from this method is equal to setting sell signal on a candle at specified time. This method is not called when sell signal is set already, or if sell signals are disabled ( use_sell_signal=False or sell_profit_only=True while profit is below sell_profit_offset ). string max length is 64 characters. Exceeding this limit will cause the message to be truncated to 64 characters. An example of how we can use different indicators depending on the current profit and also sell trades that were open longer than one day: ``` python class AwesomeStrategy(IStrategy): def custom_sell(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float, current_profit: float, **kwargs): dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() # Above 20% profit, sell when rsi < 80 if current_profit > 0.2: if last_candle['rsi'] < 80: return 'rsi_below_80' # Between 2% and 10%, sell if EMA-long above EMA-short if 0.02 < current_profit < 0.1: if last_candle['emalong'] > last_candle['emashort']: return 'ema_long_below_80' # Sell any positions at a loss if they are held for more than one day. if current_profit < 0.0 and (current_time - trade.open_date_utc).days >= 1: return 'unclog' ``` See Dataframe access for more information about dataframe use in strategy callbacks.","title":"Custom sell signal"},{"location":"strategy-callbacks/#custom-stoploss","text":"Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. The usage of the custom stoploss method must be enabled by setting use_custom_stoploss=True on the strategy object. The stoploss price can only ever move upwards - if the stoploss value returned from custom_stoploss would result in a lower stoploss price than was previously set, it will be ignored. The traditional stoploss value serves as an absolute lower level and will be instated as the initial stoploss (before this method is called for the first time for a trade). The method must return a stoploss value (float / number) as a percentage of the current price. E.g. If the current_rate is 200 USD, then returning 0.02 will set the stoploss price 2% lower, at 196 USD. The absolute value of the return value is used (the sign is ignored), so returning 0.05 or -0.05 have the same result, a stoploss 5% below the current price. To simulate a regular trailing stoploss of 4% (trailing 4% behind the maximum reached price) you would use the following very simple method: ``` python","title":"Custom stoploss"},{"location":"strategy-callbacks/#additional-imports-required","text":"from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: \"\"\" Custom stoploss logic, returning the new distance relative to current_rate (as ratio). e.g. returning -0.05 would create a stoploss 5% below current_rate. The custom stoploss can never be below self.stoploss, which serves as a hard maximum loss. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns the initial stoploss value Only called when use_custom_stoploss is set to True. :param pair: Pair that's currently analyzed :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in ask_strategy. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New stoploss value, relative to the current rate \"\"\" return -0.04 ``` Stoploss on exchange works similar to trailing_stop , and the stoploss on exchange is updated as configured in stoploss_on_exchange_interval ( More details about stoploss on exchange ). Use of dates All time-based calculations should be done based on current_time - using datetime.now() or datetime.utcnow() is discouraged, as this will break backtesting support. Trailing stoploss It's recommended to disable trailing_stop when using custom stoploss values. Both can work in tandem, but you might encounter the trailing stop to move the price higher while your custom function would not want this, causing conflicting behavior.","title":"additional imports required"},{"location":"strategy-callbacks/#custom-stoploss-examples","text":"The next section will show some examples on what's possible with the custom stoploss function. Of course, many more things are possible, and all examples can be combined at will.","title":"Custom stoploss examples"},{"location":"strategy-callbacks/#time-based-trailing-stop","text":"Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss. ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # Make sure you have the longest interval first - these conditions are evaluated from top to bottom. if current_time - timedelta(minutes=120) > trade.open_date_utc: return -0.05 elif current_time - timedelta(minutes=60) > trade.open_date_utc: return -0.10 return 1 ```","title":"Time based trailing stop"},{"location":"strategy-callbacks/#different-stoploss-per-pair","text":"Use a different stoploss depending on the pair. In this example, we'll trail the highest price with 10% trailing stoploss for ETH/BTC and XRP/BTC , with 5% trailing stoploss for LTC/BTC and with 15% for all other pairs. ``` python from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: if pair in ('ETH/BTC', 'XRP/BTC'): return -0.10 elif pair in ('LTC/BTC'): return -0.05 return -0.15 ```","title":"Different stoploss per pair"},{"location":"strategy-callbacks/#trailing-stoploss-with-positive-offset","text":"Use the initial stoploss until the profit is above 4%, then use a trailing stoploss of 50% of the current profit with a minimum of 2.5% and a maximum of 5%. Please note that the stoploss can only increase, values lower than the current stoploss are ignored. ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: if current_profit < 0.04: return -1 # return a value bigger than the initial stoploss to keep using the initial stoploss # After reaching the desired offset, allow the stoploss to trail by half the profit desired_stoploss = current_profit / 2 # Use a minimum of 2.5% and a maximum of 5% return max(min(desired_stoploss, 0.05), 0.025) ```","title":"Trailing stoploss with positive offset"},{"location":"strategy-callbacks/#stepped-stoploss","text":"Instead of continuously trailing behind the current price, this example sets fixed stoploss price levels based on the current profit. Use the regular stoploss until 20% profit is reached Once profit is > 20% - set stoploss to 7% above open price. Once profit is > 25% - set stoploss to 15% above open price. Once profit is > 40% - set stoploss to 25% above open price. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import stoploss_from_open class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # evaluate highest to lowest, so that highest possible stop is used if current_profit > 0.40: return stoploss_from_open(0.25, current_profit) elif current_profit > 0.25: return stoploss_from_open(0.15, current_profit) elif current_profit > 0.20: return stoploss_from_open(0.07, current_profit) # return maximum stoploss value, keeping current stoploss price unchanged return 1 ```","title":"Stepped stoploss"},{"location":"strategy-callbacks/#custom-stoploss-using-an-indicator-from-dataframe-example","text":"Absolute stoploss value may be derived from indicators stored in dataframe. Example uses parabolic SAR below the price as stoploss. ``` python class AwesomeStrategy(IStrategy): def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # <...> dataframe['sar'] = ta.SAR(dataframe) use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) last_candle = dataframe.iloc[-1].squeeze() # Use parabolic sar as absolute stoploss price stoploss_price = last_candle['sar'] # Convert absolute price to percentage relative to current_rate if stoploss_price < current_rate: return (stoploss_price / current_rate) - 1 # return maximum stoploss value, keeping current stoploss price unchanged return 1 ``` See Dataframe access for more information about dataframe use in strategy callbacks.","title":"Custom stoploss using an indicator from dataframe example"},{"location":"strategy-callbacks/#common-helpers-for-stoploss-calculations","text":"","title":"Common helpers for stoploss calculations"},{"location":"strategy-callbacks/#stoploss-relative-to-open-price","text":"Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss relative to the open price, we need to use current_profit to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_open() can be used to convert from an open price relative stop, to a current price relative stop which can be returned from custom_stoploss() .","title":"Stoploss relative to open price"},{"location":"strategy-callbacks/#stoploss-percentage-from-absolute-price","text":"Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss at specified absolute price level, we need to use stop_rate to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_absolute() can be used to convert from an absolute price, to a current price relative stop which can be returned from custom_stoploss() .","title":"Stoploss percentage from absolute price"},{"location":"strategy-callbacks/#custom-order-price-rules","text":"By default, freqtrade use the orderbook to automatically set an order price( Relevant documentation ), you also have the option to create custom order prices based on your strategy. You can use this feature by creating a custom_entry_price() function in your strategy file to customize entry prices and custom_exit_price() for exits. Each of these methods are called right before placing an order on the exchange. Note If your custom pricing function return None or an invalid value, price will fall back to proposed_rate , which is based on the regular pricing configuration.","title":"Custom order price rules"},{"location":"strategy-callbacks/#custom-order-entry-and-exit-price-example","text":"``` python from datetime import datetime, timedelta, timezone from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods def custom_entry_price(self, pair: str, current_time: datetime, proposed_rate: float, entry_tag: Optional[str], **kwargs) -> float: dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) new_entryprice = dataframe['bollinger_10_lowerband'].iat[-1] return new_entryprice def custom_exit_price(self, pair: str, trade: Trade, current_time: datetime, proposed_rate: float, current_profit: float, **kwargs) -> float: dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe) new_exitprice = dataframe['bollinger_10_upperband'].iat[-1] return new_exitprice ``` Warning Modifying entry and exit prices will only work for limit orders. Depending on the price chosen, this can result in a lot of unfilled orders. By default the maximum allowed distance between the current price and the custom price is 2%, this value can be changed in config with the custom_price_max_distance_ratio parameter. Example : If the new_entryprice is 97, the proposed_rate is 100 and the custom_price_max_distance_ratio is set to 2%, The retained valid custom entry price will be 98, which is 2% below the current (proposed) rate. Backtesting Custom prices are supported in backtesting (starting with 2021.12), and orders will fill if the price falls within the candle's low/high range. Orders that don't fill immediately are subject to regular timeout handling, which happens once per (detail) candle. custom_exit_price() is only called for sells of type Sell_signal and Custom sell. All other sell-types will use regular backtesting prices.","title":"Custom order entry and exit price example"},{"location":"strategy-callbacks/#custom-order-timeout-rules","text":"Simple, time-based order-timeouts can be configured either via strategy or in the configuration in the unfilledtimeout section. However, freqtrade also offers a custom callback for both order types, which allows you to decide based on custom criteria if an order did time out or not. Note Backtesting fills orders if their price falls within the candle's low/high range. The below callbacks will be called once per (detail) candle for orders that don't fill immediately (which use custom pricing).","title":"Custom order timeout rules"},{"location":"strategy-callbacks/#custom-order-timeout-example","text":"Called for every open order until that order is either filled or cancelled. check_buy_timeout() is called for trade entries, while check_sell_timeout() is called for trade exit orders. A simple example, which applies different unfilled-timeouts depending on the price of the asset can be seen below. It applies a tight timeout for higher priced assets, while allowing more time to fill on cheap coins. The function must return either True (cancel order) or False (keep order alive). ``` python from datetime import datetime, timedelta from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'buy': 60 * 25, 'sell': 60 * 25 } def check_buy_timeout(self, pair: str, trade: 'Trade', order: dict, current_time: datetime, **kwargs) -> bool: if trade.open_rate > 100 and trade.open_date_utc < current_time - timedelta(minutes=5): return True elif trade.open_rate > 10 and trade.open_date_utc < current_time - timedelta(minutes=3): return True elif trade.open_rate < 1 and trade.open_date_utc < current_time - timedelta(hours=24): return True return False def check_sell_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: if trade.open_rate > 100 and trade.open_date_utc < current_time - timedelta(minutes=5): return True elif trade.open_rate > 10 and trade.open_date_utc < current_time - timedelta(minutes=3): return True elif trade.open_rate < 1 and trade.open_date_utc < current_time - timedelta(hours=24): return True return False ``` Note For the above example, unfilledtimeout must be set to something bigger than 24h, otherwise that type of timeout will apply first.","title":"Custom order timeout example"},{"location":"strategy-callbacks/#custom-order-timeout-example-using-additional-data","text":"``` python from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'buy': 60 * 25, 'sell': 60 * 25 } def check_buy_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: ob = self.dp.orderbook(pair, 1) current_price = ob['bids'][0][0] # Cancel buy order if price is more than 2% above the order. if current_price > order['price'] * 1.02: return True return False def check_sell_timeout(self, pair: str, trade: Trade, order: dict, current_time: datetime, **kwargs) -> bool: ob = self.dp.orderbook(pair, 1) current_price = ob['asks'][0][0] # Cancel sell order if price is more than 2% below the order. if current_price < order['price'] * 0.98: return True return False ```","title":"Custom order timeout example (using additional data)"},{"location":"strategy-callbacks/#bot-order-confirmation","text":"Confirm trade entry / exits. This are the last methods that will be called before an order is placed.","title":"Bot order confirmation"},{"location":"strategy-callbacks/#trade-entry-buy-order-confirmation","text":"confirm_trade_entry() can be used to abort a trade entry at the latest second (maybe because the price is not what we expect). ``` python class AwesomeStrategy(IStrategy): # ... populate_* methods def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float, time_in_force: str, current_time: datetime, entry_tag: Optional[str], **kwargs) -> bool: \"\"\" Called right before placing a buy order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be bought. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in target (quote) currency that's going to be traded. :param rate: Rate that's going to be used when using limit orders :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the buy-order is placed on the exchange. False aborts the process \"\"\" return True ```","title":"Trade entry (buy order) confirmation"},{"location":"strategy-callbacks/#trade-exit-sell-order-confirmation","text":"confirm_trade_exit() can be used to abort a trade exit (sell) at the latest second (maybe because the price is not what we expect). ``` python from freqtrade.persistence import Trade class AwesomeStrategy(IStrategy): # ... populate_* methods def confirm_trade_exit(self, pair: str, trade: Trade, order_type: str, amount: float, rate: float, time_in_force: str, sell_reason: str, current_time: datetime, **kwargs) -> bool: \"\"\" Called right before placing a regular sell order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be sold. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in quote currency. :param rate: Rate that's going to be used when using limit orders :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param sell_reason: Sell reason. Can be any of ['roi', 'stop_loss', 'stoploss_on_exchange', 'trailing_stop_loss', 'sell_signal', 'force_sell', 'emergency_sell'] :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the sell-order is placed on the exchange. False aborts the process \"\"\" if sell_reason == 'force_sell' and trade.calc_profit_ratio(rate) < 0: # Reject force-sells with negative profit # This is just a sample, please adjust to your needs # (this does not necessarily make sense, assuming you know when you're force-selling) return False return True ```","title":"Trade exit (sell order) confirmation"},{"location":"strategy-callbacks/#adjust-trade-position","text":"The position_adjustment_enable strategy property enables the usage of adjust_trade_position() callback in the strategy. For performance reasons, it's disabled by default and freqtrade will show a warning message on startup if enabled. adjust_trade_position() can be used to perform additional orders, for example to manage risk with DCA (Dollar Cost Averaging). max_entry_position_adjustment property is used to limit the number of additional buys per trade (on top of the first buy) that the bot can execute. By default, the value is -1 which means the bot have no limit on number of adjustment buys. The strategy is expected to return a stake_amount (in stake currency) between min_stake and max_stake if and when an additional buy order should be made (position is increased). If there are not enough funds in the wallet (the return value is above max_stake ) then the signal will be ignored. Additional orders also result in additional fees and those orders don't count towards max_open_trades . This callback is not called when there is an open order (either buy or sell) waiting for execution, or when you have reached the maximum amount of extra buys that you have set on max_entry_position_adjustment . adjust_trade_position() is called very frequently for the duration of a trade, so you must keep your implementation as performant as possible. About stake size Using fixed stake size means it will be the amount used for the first order, just like without position adjustment. If you wish to buy additional orders with DCA, then make sure to leave enough funds in the wallet for that. Using 'unlimited' stake amount with DCA orders requires you to also implement the custom_stake_amount() callback to avoid allocating all funds to the initial order. Warning Stoploss is still calculated from the initial opening price, not averaged price. /stopbuy While /stopbuy command stops the bot from entering new trades, the position adjustment feature will continue buying new orders on existing trades. Backtesting During backtesting this callback is called for each candle in timeframe or timeframe_detail , so performance will be affected. ``` python from freqtrade.persistence import Trade class DigDeeperStrategy(IStrategy): position_adjustment_enable = True # Attempts to handle large drops with DCA. High stoploss is required. stoploss = -0.30 # ... populate_* methods # Example specific variables max_entry_position_adjustment = 3 # This number is explained a bit further down max_dca_multiplier = 5.5 # This is called when placing the initial order (opening trade) def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float, proposed_stake: float, min_stake: float, max_stake: float, entry_tag: Optional[str], **kwargs) -> float: # We need to leave most of the funds for possible further DCA orders # This also applies to fixed stakes return proposed_stake / self.max_dca_multiplier def adjust_trade_position(self, trade: Trade, current_time: datetime, current_rate: float, current_profit: float, min_stake: float, max_stake: float, **kwargs): \"\"\" Custom trade adjustment logic, returning the stake amount that a trade should be increased. This means extra buy orders with additional fees. :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Current buy rate. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param min_stake: Minimal stake size allowed by exchange. :param max_stake: Balance available for trading. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: Stake amount to adjust your trade \"\"\" if current_profit > -0.05: return None # Obtain pair dataframe (just to show how to access it) dataframe, _ = self.dp.get_analyzed_dataframe(trade.pair, self.timeframe) # Only buy when not actively falling price. last_candle = dataframe.iloc[-1].squeeze() previous_candle = dataframe.iloc[-2].squeeze() if last_candle['close'] < previous_candle['close']: return None filled_buys = trade.select_filled_orders('buy') count_of_buys = trade.nr_of_successful_buys # Allow up to 3 additional increasingly larger buys (4 in total) # Initial buy is 1x # If that falls to -5% profit, we buy 1.25x more, average profit should increase to roughly -2.2% # If that falls down to -5% again, we buy 1.5x more # If that falls once again down to -5%, we buy 1.75x more # Total stake for this trade would be 1 + 1.25 + 1.5 + 1.75 = 5.5x of the initial allowed stake. # That is why max_dca_multiplier is 5.5 # Hope you have a deep wallet! try: # This returns first order stake size stake_amount = filled_buys[0].cost # This then calculates current safety order size stake_amount = stake_amount * (1 + (count_of_buys * 0.25)) return stake_amount except Exception as exception: return None return None ```","title":"Adjust trade position"},{"location":"strategy-customization/","text":"Strategy Customization \u00b6 This page explains how to customize your strategies, add new indicators and set up trading rules. Please familiarize yourself with Freqtrade basics first, which provides overall info on how the bot operates. Develop your own strategy \u00b6 The bot includes a default strategy file. Also, several other strategies are available in the strategy repository . You will however most likely have your own idea for a strategy. This document intends to help you convert your strategy idea into your own strategy. To get started, use freqtrade new-strategy --strategy AwesomeStrategy (you can obviously use your own naming for your strategy). This will create a new strategy file from a template, which will be located under user_data/strategies/AwesomeStrategy.py . Note This is just a template file, which will most likely not be profitable out of the box. Different template levels freqtrade new-strategy has an additional parameter, --template , which controls the amount of pre-build information you get in the created strategy. Use --template minimal to get an empty strategy without any indicator examples, or --template advanced to get a template with most callbacks defined. Anatomy of a strategy \u00b6 A strategy file contains all the information needed to build a good strategy: Indicators Buy strategy rules Sell strategy rules Minimal ROI recommended Stoploss strongly recommended The bot also include a sample strategy called SampleStrategy you can update: user_data/strategies/sample_strategy.py . You can test it with the parameter: --strategy SampleStrategy Additionally, there is an attribute called INTERFACE_VERSION , which defines the version of the strategy interface the bot should use. The current version is 2 - which is also the default when it's not set explicitly in the strategy. Future versions will require this to be set. bash freqtrade trade --strategy AwesomeStrategy For the following section we will use the user_data/strategies/sample_strategy.py file as reference. Strategies and Backtesting To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time range is passed to the populate_*() methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing ( df.iloc[-1] ), but instead use df.shift() to get to the previous candle. Warning: Using future data Since backtesting passes the full time range to the populate_*() methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Some common patterns for this are listed in the Common Mistakes section of this document. Dataframe \u00b6 Freqtrade uses pandas to store/provide the candlestick (OHLCV) data. Pandas is a great library developed for processing large amounts of data. Each row in a dataframe corresponds to one candle on a chart, with the latest candle always being the last in the dataframe (sorted by date). ``` output dataframe.head() date open high low close volume 0 2021-11-09 23:25:00+00:00 67279.67 67321.84 67255.01 67300.97 44.62253 1 2021-11-09 23:30:00+00:00 67300.97 67301.34 67183.03 67187.01 61.38076 2 2021-11-09 23:35:00+00:00 67187.02 67187.02 67031.93 67123.81 113.42728 3 2021-11-09 23:40:00+00:00 67123.80 67222.40 67080.33 67160.48 78.96008 4 2021-11-09 23:45:00+00:00 67160.48 67160.48 66901.26 66943.37 111.39292 ``` Pandas provides fast ways to calculate metrics. To benefit from this speed, it's advised to not use loops, but use vectorized methods instead. Vectorized operations perform calculations across the whole range of data and are therefore, compared to looping through each row, a lot faster when calculating indicators. As a dataframe is a table, simple python comparisons like the following will not work python if dataframe['rsi'] > 30: dataframe['buy'] = 1 The above section will fail with The truth value of a Series is ambiguous. [...] . This must instead be written in a pandas-compatible way, so the operation is performed across the whole dataframe. python dataframe.loc[ (dataframe['rsi'] > 30) , 'buy'] = 1 With this section, you have a new column in your dataframe, which has 1 assigned whenever RSI is above 30. Customize Indicators \u00b6 Buy and sell strategies need indicators. You can add more indicators by extending the list contained in the method populate_indicators() from your strategy file. You should only add the indicators used in either populate_buy_trend() , populate_sell_trend() , or to populate another indicator, otherwise performance may suffer. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. Sample: ```python def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Adds several different TA indicators to the given DataFrame Performance Note: For the best performance be frugal on the number of indicators you are using. Let uncomment only the indicator you are using in your strategies or your hyperopt configuration, otherwise you will waste your memory and CPU usage. :param dataframe: Dataframe with data from the exchange :param metadata: Additional information, like the currently traded pair :return: a Dataframe with all mandatory indicators for the strategies \"\"\" dataframe['sar'] = ta.SAR(dataframe) dataframe['adx'] = ta.ADX(dataframe) stoch = ta.STOCHF(dataframe) dataframe['fastd'] = stoch['fastd'] dataframe['fastk'] = stoch['fastk'] dataframe['blower'] = ta.BBANDS(dataframe, nbdevup=2, nbdevdn=2)['lowerband'] dataframe['sma'] = ta.SMA(dataframe, timeperiod=40) dataframe['tema'] = ta.TEMA(dataframe, timeperiod=9) dataframe['mfi'] = ta.MFI(dataframe) dataframe['rsi'] = ta.RSI(dataframe) dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5) dataframe['ema10'] = ta.EMA(dataframe, timeperiod=10) dataframe['ema50'] = ta.EMA(dataframe, timeperiod=50) dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100) dataframe['ao'] = awesome_oscillator(dataframe) macd = ta.MACD(dataframe) dataframe['macd'] = macd['macd'] dataframe['macdsignal'] = macd['macdsignal'] dataframe['macdhist'] = macd['macdhist'] hilbert = ta.HT_SINE(dataframe) dataframe['htsine'] = hilbert['sine'] dataframe['htleadsine'] = hilbert['leadsine'] dataframe['plus_dm'] = ta.PLUS_DM(dataframe) dataframe['plus_di'] = ta.PLUS_DI(dataframe) dataframe['minus_dm'] = ta.MINUS_DM(dataframe) dataframe['minus_di'] = ta.MINUS_DI(dataframe) return dataframe ``` Want more indicator examples? Look into the user_data/strategies/sample_strategy.py . Then uncomment indicators you need. Indicator libraries \u00b6 Out of the box, freqtrade installs the following technical libraries: ta-lib pandas-ta technical Additional technical libraries can be installed as necessary, or custom indicators may be written / invented by the strategy author. Strategy startup period \u00b6 Most indicators have an instable startup period, in which they are either not available (NaN), or the calculation is incorrect. This can lead to inconsistencies, since Freqtrade does not know how long this instable period should be. To account for this, the strategy can be assigned the startup_candle_count attribute. This should be set to the maximum number of candles that the strategy requires to calculate stable indicators. In this example strategy, this should be set to 100 ( startup_candle_count = 100 ), since the longest needed history is 100 candles. python dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100) By letting the bot know how much history is needed, backtest trades can start at the specified timerange during backtesting and hyperopt. Using x calls to get OHLCV If you receive a warning like WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy - you should consider if you really need this much historic data for your signals. Having this will cause Freqtrade to make multiple calls for the same pair, which will obviously be slower than one network request. As a consequence, Freqtrade will take longer to refresh candles - and should therefore be avoided if possible. This is capped to 5 total calls to avoid overloading the exchange, or make freqtrade too slow. Warning startup_candle_count should be below ohlcv_candle_limit * 5 (which is 500 * 5 for most exchanges) - since only this amount of candles will be available during Dry-Run/Live Trade operations. Example \u00b6 Let's try to backtest 1 month (January 2019) of 5m candles using an example strategy with EMA100, as above. bash freqtrade backtesting --timerange 20190101-20190201 --timeframe 5m Assuming startup_candle_count is set to 100, backtesting knows it needs 100 candles to generate valid buy signals. It will load data from 20190101 - (100 * 5m) - which is ~2018-12-31 15:30:00. If this data is available, indicators will be calculated with this extended timerange. The instable startup period (up to 2019-01-01 00:00:00) will then be removed before starting backtesting. Note If data for the startup period is not available, then the timerange will be adjusted to account for this startup period - so Backtesting would start at 2019-01-01 08:30:00. Buy signal rules \u00b6 Edit the method populate_buy_trend() in your strategy file to update your buy strategy. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"buy\" , which needs to contain 1 for buys, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Based on TA indicators, populates the buy signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 30)) & # Signal: RSI crosses above 30 (dataframe['tema'] <= dataframe['bb_middleband']) & # Guard (dataframe['tema'] > dataframe['tema'].shift(1)) & # Guard (dataframe['volume'] > 0) # Make sure Volume is not 0 ), 'buy'] = 1 return dataframe ``` Note Buying requires sellers to buy from - therefore volume needs to be > 0 ( dataframe['volume'] > 0 ) to make sure that the bot does not buy/sell in no-activity periods. Sell signal rules \u00b6 Edit the method populate_sell_trend() into your strategy file to update your sell strategy. Please note that the sell-signal is only used if use_sell_signal is set to true in the configuration. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"sell\" , which needs to contain 1 for sells, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : python def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Based on TA indicators, populates the sell signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 70)) & # Signal: RSI crosses above 70 (dataframe['tema'] > dataframe['bb_middleband']) & # Guard (dataframe['tema'] < dataframe['tema'].shift(1)) & # Guard (dataframe['volume'] > 0) # Make sure Volume is not 0 ), 'sell'] = 1 return dataframe Minimal ROI \u00b6 This dict defines the minimal Return On Investment (ROI) a trade should reach before selling, independent from the sell signal. It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage. python minimal_roi = { \"40\": 0.0, \"30\": 0.01, \"20\": 0.02, \"0\": 0.04 } The above configuration would therefore mean: Sell whenever 4% profit was reached Sell when 2% profit was reached (in effect after 20 minutes) Sell when 1% profit was reached (in effect after 30 minutes) Sell when trade is non-loosing (in effect after 40 minutes) The calculation does include fees. To disable ROI completely, set it to an insanely high number: python minimal_roi = { \"0\": 100 } While technically not completely disabled, this would sell once the trade reaches 10000% Profit. To use times based on candle duration (timeframe), the following snippet can be handy. This will allow you to change the timeframe for the strategy, and ROI times will still be set as candles (e.g. after 3 candles ...) ``` python from freqtrade.exchange import timeframe_to_minutes class AwesomeStrategy(IStrategy): timeframe = \"1d\" timeframe_mins = timeframe_to_minutes(timeframe) minimal_roi = { \"0\": 0.05, # 5% for the first 3 candles str(timeframe_mins * 3)): 0.02, # 2% after 3 candles str(timeframe_mins * 6)): 0.01, # 1% After 6 candles } ``` Stoploss \u00b6 Setting a stoploss is highly recommended to protect your capital from strong moves against you. Sample of setting a 10% stoploss: python stoploss = -0.10 For the full documentation on stoploss features, look at the dedicated stoploss page . Timeframe \u00b6 This is the set of candles the bot should download and use for the analysis. Common values are \"1m\" , \"5m\" , \"15m\" , \"1h\" , however all values supported by your exchange should work. Please note that the same buy/sell signals may work well with one timeframe, but not with the others. This setting is accessible within the strategy methods as the self.timeframe attribute. Metadata dict \u00b6 The metadata-dict (available for populate_buy_trend , populate_sell_trend , populate_indicators ) contains additional information. Currently this is pair , which can be accessed using metadata['pair'] - and will return a pair in the format XRP/BTC . The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the Storing information section. Strategy file loading \u00b6 By default, freqtrade will attempt to load strategies from all .py files within user_data/strategies . Assuming your strategy is called AwesomeStrategy , stored in the file user_data/strategies/AwesomeStrategy.py , then you can start freqtrade with freqtrade trade --strategy AwesomeStrategy . Note that we're using the class-name, not the file name. You can use freqtrade list-strategies to see a list of all strategies Freqtrade is able to load (all strategies in the correct folder). It will also include a \"status\" field, highlighting potential problems. Customize strategy directory You can use a different directory by using --strategy-path user_data/otherPath . This parameter is available to all commands that require a strategy. Informative Pairs \u00b6 Get data for non-tradeable pairs \u00b6 Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. OHLCV data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via DataProvider just as other pairs (see below). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting. The pairs need to be specified as tuples in the format (\"pair\", \"timeframe\") , with pair as the first and timeframe as the second argument. Sample: python def informative_pairs(self): return [(\"ETH/USDT\", \"5m\"), (\"BTC/TUSD\", \"15m\"), ] A full sample can be found in the DataProvider section . Warning As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All timeframes and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer timeframes whenever possible to avoid hammering the exchange with too many requests and risk being blocked. Informative pairs decorator ( @informative() ) \u00b6 In most common case it is possible to easily define informative pairs by using a decorator. All decorated populate_indicators_* methods run in isolation, not having access to data from other informative pairs, in the end all informative dataframes are merged and passed to main populate_indicators() method. When hyperopting, use of hyperoptable parameter .value attribute is not supported. Please use .range attribute. See optimizing an indicator parameter for more information. Full documentation ``` python def informative(timeframe: str, asset: str = '', fmt: Optional[Union[str, Callable[[KwArg(str)], str]]] = None, ffill: bool = True) -> Callable[[PopulateIndicators], PopulateIndicators]: \"\"\" A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to define informative indicators. Example usage: @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe. :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use current pair. :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not specified, defaults to: * {base}_{quote}_{column}_{timeframe} if asset is specified. * {column}_{timeframe} if asset is not specified. Format string supports these format variables: * {asset} - full name of the asset, for example 'BTC/USDT'. * {base} - base currency in lower case, for example 'eth'. * {BASE} - same as {base}, except in upper case. * {quote} - quote currency in lower case, for example 'usdt'. * {QUOTE} - same as {quote}, except in upper case. * {column} - name of dataframe column. * {timeframe} - timeframe of informative dataframe. :param ffill: ffill dataframe after merging informative pair. \"\"\" ``` Fast and easy way to define informative pairs Most of the time we do not need power and flexibility offered by merge_informative_pair() , therefore we can use a decorator to quickly define informative pairs. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, informative class AwesomeStrategy(IStrategy): # This method is not required. # def informative_pairs(self): ... # Define informative upper timeframe for each pair. Decorators can be stacked on same # method. Available in populate_indicators as 'rsi_30m' and 'rsi_1h'. @informative('30m') @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/STAKE informative pair. Available in populate_indicators and other methods as # 'btc_rsi_1h'. Current stake currency should be specified as {stake} format variable # instead of hardcoding actual stake currency. Available in populate_indicators and other # methods as 'btc_usdt_rsi_1h' (when stake currency is USDT). @informative('1h', 'BTC/{stake}') def populate_indicators_btc_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/ETH informative pair. You must specify quote currency if it is different from # stake currency. Available in populate_indicators and other methods as 'eth_btc_rsi_1h'. @informative('1h', 'ETH/BTC') def populate_indicators_eth_btc_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/STAKE informative pair. A custom formatter may be specified for formatting # column names. A callable `fmt(**kwargs) -> str` may be specified, to implement custom # formatting. Available in populate_indicators and other methods as 'rsi_upper'. @informative('1h', 'BTC/{stake}', '{column}') def populate_indicators_btc_1h_2(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi_upper'] = ta.RSI(dataframe, timeperiod=14) return dataframe def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # Strategy timeframe indicators for current pair. dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) # Informative pairs are available in this method. dataframe['rsi_less'] = dataframe['rsi'] < dataframe['rsi_1h'] return dataframe ``` Note Do not use @informative decorator if you need to use data of one informative pair when generating another informative pair. Instead, define informative pairs manually as described in the DataProvider section . Note Use string formatting when accessing informative dataframes of other pairs. This will allow easily changing stake currency in config without having to adjust strategy code. ``` python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: stake = self.config['stake_currency'] dataframe.loc[ ( (dataframe[f'btc_{stake}_rsi_1h'] < 35) & (dataframe['volume'] > 0) ), ['buy', 'buy_tag']] = (1, 'buy_signal_rsi') return dataframe ``` Alternatively column renaming may be used to remove stake currency from column names: @informative('1h', 'BTC/{stake}', fmt='{base}_{column}_{timeframe}') . Duplicate method names Methods tagged with @informative() decorator must always have unique names! Re-using same name (for example when copy-pasting already defined informative method) will overwrite previously defined method and not produce any errors due to limitations of Python programming language. In such cases you will find that indicators created in earlier-defined methods are not available in the dataframe. Carefully review method names and make sure they are unique! Additional data (DataProvider) \u00b6 The strategy provides access to the DataProvider . This allows you to get additional data to use in your strategy. All methods return None in case of failure (do not raise an exception). Please always check the mode of operation to select the correct method to get data (samples see below). Hyperopt Dataprovider is available during hyperopt, however it can only be used in populate_indicators() within a strategy. It is not available in populate_buy() and populate_sell() methods, nor in populate_indicators() , if this method located in the hyperopt file. Possible options for DataProvider \u00b6 available_pairs - Property with tuples listing cached pairs with their timeframe (pair, timeframe). current_whitelist() - Returns a current list of whitelisted pairs. Useful for accessing dynamic whitelists (i.e. VolumePairlist) get_pair_dataframe(pair, timeframe) - This is a universal method, which returns either historical data (for backtesting) or cached live data (for the Dry-Run and Live-Run modes). get_analyzed_dataframe(pair, timeframe) - Returns the analyzed dataframe (after calling populate_indicators() , populate_buy() , populate_sell() ) and the time of the latest analysis. historic_ohlcv(pair, timeframe) - Returns historical data stored on disk. market(pair) - Returns market data for the pair: fees, limits, precisions, activity flag, etc. See ccxt documentation for more details on the Market data structure. ohlcv(pair, timeframe) - Currently cached candle (OHLCV) data for the pair, returns DataFrame or empty DataFrame. orderbook(pair, maximum) - Returns latest orderbook data for the pair, a dict with bids/asks with a total of maximum entries. ticker(pair) - Returns current ticker data for the pair. See ccxt documentation for more details on the Ticker data structure. runmode - Property containing the current runmode. Example Usages \u00b6 available_pairs \u00b6 python if self.dp: for pair, timeframe in self.dp.available_pairs: print(f\"available {pair}, {timeframe}\") current_whitelist() \u00b6 Imagine you've developed a strategy that trades the 5m timeframe using signals generated from a 1d timeframe on the top 10 volume pairs by volume. The strategy might look something like this: Scan through the top 10 pairs by volume using the VolumePairList every 5 minutes and use a 14 day RSI to buy and sell. Due to the limited available data, it's very difficult to resample 5m candles into daily candles for use in a 14 day RSI. Most exchanges limit us to just 500 candles which effectively gives us around 1.74 daily candles. We need 14 days at least! Since we can't resample the data we will have to use an informative pair; and since the whitelist will be dynamic we don't know which pair(s) to use. This is where calling self.dp.current_whitelist() comes in handy. ```python def informative_pairs(self): # get access to all pairs available in whitelist. pairs = self.dp.current_whitelist() # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [(pair, '1d') for pair in pairs] return informative_pairs ``` get_pair_dataframe(pair, timeframe) \u00b6 ``` python fetch live / historical candle (OHLCV) data for the first informative pair \u00b6 if self.dp: inf_pair, inf_timeframe = self.informative_pairs()[0] informative = self.dp.get_pair_dataframe(pair=inf_pair, timeframe=inf_timeframe) ``` Warning about backtesting Be careful when using dataprovider in backtesting. historic_ohlcv() (and get_pair_dataframe() for the backtesting runmode) provides the full time-range in one go, so please be aware of it and make sure to not \"look into the future\" to avoid surprises when running in dry/live mode. get_analyzed_dataframe(pair, timeframe) \u00b6 This method is used by freqtrade internally to determine the last signal. It can also be used in specific callbacks to get the signal that caused the action (see Advanced Strategy Documentation for more details on available callbacks). ``` python fetch current dataframe \u00b6 if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=metadata['pair'], timeframe=self.timeframe) ``` No data available Returns an empty dataframe if the requested pair was not cached. This should not happen when using whitelisted pairs. orderbook(pair, maximum) \u00b6 python if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): ob = self.dp.orderbook(metadata['pair'], 1) dataframe['best_bid'] = ob['bids'][0][0] dataframe['best_ask'] = ob['asks'][0][0] The orderbook structure is aligned with the order structure from ccxt , so the result will look as follows: js { 'bids': [ [ price, amount ], // [ float, float ] [ price, amount ], ... ], 'asks': [ [ price, amount ], [ price, amount ], //... ], //... } Therefore, using ob['bids'][0][0] as demonstrated above will result in using the best bid price. ob['bids'][0][1] would look at the amount at this orderbook position. Warning about backtesting The order book is not part of the historic data which means backtesting and hyperopt will not work correctly if this method is used, as the method will return uptodate values. ticker(pair) \u00b6 python if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): ticker = self.dp.ticker(metadata['pair']) dataframe['last_price'] = ticker['last'] dataframe['volume24h'] = ticker['quoteVolume'] dataframe['vwap'] = ticker['vwap'] Warning Although the ticker data structure is a part of the ccxt Unified Interface, the values returned by this method can vary for different exchanges. For instance, many exchanges do not return vwap values, the FTX exchange does not always fills in the last field (so it can be None), etc. So you need to carefully verify the ticker data returned from the exchange and add appropriate error handling / defaults. Warning about backtesting This method will always return up-to-date values - so usage during backtesting / hyperopt will lead to wrong results. Complete Data-provider sample \u00b6 ```python from freqtrade.strategy import IStrategy, merge_informative_pair from pandas import DataFrame class SampleStrategy(IStrategy): # strategy init stuff... timeframe = '5m' # more strategy init stuff.. def informative_pairs(self): # get access to all pairs available in whitelist. pairs = self.dp.current_whitelist() # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [(pair, '1d') for pair in pairs] # Optionally Add additional \"static\" pairs informative_pairs += [(\"ETH/USDT\", \"5m\"), (\"BTC/TUSD\", \"15m\"), ] return informative_pairs def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: if not self.dp: # Don't do anything if DataProvider is not available. return dataframe inf_tf = '1d' # Get the informative pair informative = self.dp.get_pair_dataframe(pair=metadata['pair'], timeframe=inf_tf) # Get the 14 day rsi informative['rsi'] = ta.RSI(informative, timeperiod=14) # Use the helper function merge_informative_pair to safely merge the pair # Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair # use ffill to have the 1d value available in every row throughout the day. # Without this, comparisons between columns of the original and the informative pair would only work once per day. # Full documentation of this method, see below dataframe = merge_informative_pair(dataframe, informative, self.timeframe, inf_tf, ffill=True) # Calculate rsi of the original dataframe (5m timeframe) dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) # Do other stuff # ... return dataframe def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 30)) & # Signal: RSI crosses above 30 (dataframe['rsi_1d'] < 30) & # Ensure daily RSI is < 30 (dataframe['volume'] > 0) # Ensure this candle had volume (important for backtesting) ), 'buy'] = 1 ``` Helper functions \u00b6 merge_informative_pair() \u00b6 This method helps you merge an informative pair to a regular dataframe without lookahead bias. It's there to help you merge the dataframe in a safe and consistent way. Options: Rename the columns for you to create unique columns Merge the dataframe without lookahead bias Forward-fill (optional) All columns of the informative dataframe will be available on the returning dataframe in a renamed fashion: Column renaming Assuming inf_tf = '1d' the resulting columns will be: python 'date', 'open', 'high', 'low', 'close', 'rsi' # from the original dataframe 'date_1d', 'open_1d', 'high_1d', 'low_1d', 'close_1d', 'rsi_1d' # from the informative dataframe Column renaming - 1h Assuming inf_tf = '1h' the resulting columns will be: python 'date', 'open', 'high', 'low', 'close', 'rsi' # from the original dataframe 'date_1h', 'open_1h', 'high_1h', 'low_1h', 'close_1h', 'rsi_1h' # from the informative dataframe Custom implementation A custom implementation for this is possible, and can be done as follows: ``` python Shift date by 1 candle \u00b6 This is necessary since the data is always the \"open date\" \u00b6 and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00 \u00b6 minutes = timeframe_to_minutes(inf_tf) Only do this if the timeframes are different: \u00b6 informative['date_merge'] = informative[\"date\"] + pd.to_timedelta(minutes, 'm') Rename columns to be unique \u00b6 informative.columns = [f\"{col}_{inf_tf}\" for col in informative.columns] Assuming inf_tf = '1d' - then the columns will now be: \u00b6 date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d \u00b6 Combine the 2 dataframes \u00b6 all indicators on the informative sample MUST be calculated before this point \u00b6 dataframe = pd.merge(dataframe, informative, left_on='date', right_on=f'date_merge_{inf_tf}', how='left') FFill to have the 1d value available in every row throughout the day. \u00b6 Without this, comparisons would only work once per day. \u00b6 dataframe = dataframe.ffill() ``` Informative timeframe < timeframe Using informative timeframes smaller than the dataframe timeframe is not recommended with this method, as it will not use any of the additional information this would provide. To use the more detailed information properly, more advanced methods should be applied (which are out of scope for freqtrade documentation, as it'll depend on the respective need). stoploss_from_open() \u00b6 Stoploss values returned from custom_stoploss must specify a percentage relative to current_rate , but sometimes you may want to specify a stoploss relative to the open price instead. stoploss_from_open() is a helper function to calculate a stoploss value that can be returned from custom_stoploss which will be equivalent to the desired percentage above the open price. Returning a stoploss relative to the open price from the custom stoploss function Say the open price was $100, and current_price is $121 ( current_profit will be 0.21 ). If we want a stop price at 7% above the open price we can call stoploss_from_open(0.07, current_profit) which will return 0.1157024793 . 11.57% below $121 is $107, which is the same as 7% above $100. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, stoploss_from_open class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10: return stoploss_from_open(0.07, current_profit) return 1 ``` Full examples can be found in the Custom stoploss section of the Documentation. Note Providing invalid input to stoploss_from_open() may produce \"CustomStoploss function did not return valid stoploss\" warnings. This may happen if current_profit parameter is below specified open_relative_stop . Such situations may arise when closing trade is blocked by confirm_trade_exit() method. Warnings can be solved by never blocking stop loss sells by checking sell_reason in confirm_trade_exit() , or by using return stoploss_from_open(...) or 1 idiom, which will request to not change stop loss when current_profit < open_relative_stop . stoploss_from_absolute() \u00b6 In some situations it may be confusing to deal with stops relative to current rate. Instead, you may define a stoploss level using an absolute price. Returning a stoploss using absolute price from the custom stoploss function If we want to trail a stop price at 2xATR below current proce we can call stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate) . ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, stoploss_from_absolute class AwesomeStrategy(IStrategy): use_custom_stoploss = True def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['atr'] = ta.ATR(dataframe, timeperiod=14) return dataframe def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) candle = dataframe.iloc[-1].squeeze() return stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate) ``` Additional data (Wallets) \u00b6 The strategy provides access to the Wallets object. This contains the current balances on the exchange. Note Wallets is not available during backtesting / hyperopt. Please always check if Wallets is available to avoid failures during backtesting. python if self.wallets: free_eth = self.wallets.get_free('ETH') used_eth = self.wallets.get_used('ETH') total_eth = self.wallets.get_total('ETH') Possible options for Wallets \u00b6 get_free(asset) - currently available balance to trade get_used(asset) - currently tied up balance (open orders) get_total(asset) - total available balance - sum of the 2 above Additional data (Trades) \u00b6 A history of Trades can be retrieved in the strategy by querying the database. At the top of the file, import Trade. python from freqtrade.persistence import Trade The following example queries for the current pair and trades from today, however other filters can easily be added. python if self.config['runmode'].value in ('live', 'dry_run'): trades = Trade.get_trades([Trade.pair == metadata['pair'], Trade.open_date > datetime.utcnow() - timedelta(days=1), Trade.is_open.is_(False), ]).order_by(Trade.close_date).all() # Summarize profit for this pair. curdayprofit = sum(trade.close_profit for trade in trades) Get amount of stake_currency currently invested in Trades: python if self.config['runmode'].value in ('live', 'dry_run'): total_stakes = Trade.total_open_trades_stakes() Retrieve performance per pair. Returns a List of dicts per pair. python if self.config['runmode'].value in ('live', 'dry_run'): performance = Trade.get_overall_performance() Sample return value: ETH/BTC had 5 trades, with a total profit of 1.5% (ratio of 0.015). json {'pair': \"ETH/BTC\", 'profit': 0.015, 'count': 5} Warning Trade history is not available during backtesting or hyperopt. Prevent trades from happening for a specific pair \u00b6 Freqtrade locks pairs automatically for the current candle (until that candle is over) when a pair is sold, preventing an immediate re-buy of that pair. Locked pairs will show the message Pair <pair> is currently locked. . Locking pairs from within the strategy \u00b6 Sometimes it may be desired to lock a pair after certain events happen (e.g. multiple losing trades in a row). Freqtrade has an easy method to do this from within the strategy, by calling self.lock_pair(pair, until, [reason]) . until must be a datetime object in the future, after which trading will be re-enabled for that pair, while reason is an optional string detailing why the pair was locked. Locks can also be lifted manually, by calling self.unlock_pair(pair) or self.unlock_reason(<reason>) - providing reason the pair was locked with. self.unlock_reason(<reason>) will unlock all pairs currently locked with the provided reason. To verify if a pair is currently locked, use self.is_pair_locked(pair) . Note Locked pairs will always be rounded up to the next candle. So assuming a 5m timeframe, a lock with until set to 10:18 will lock the pair until the candle from 10:15-10:20 will be finished. Warning Manually locking pairs is not available during backtesting, only locks via Protections are allowed. Pair locking example \u00b6 ``` python from freqtrade.persistence import Trade from datetime import timedelta, datetime, timezone Put the above lines a the top of the strategy file, next to all the other imports \u00b6 -------- \u00b6 Within populate indicators (or populate_buy): \u00b6 if self.config['runmode'].value in ('live', 'dry_run'): # fetch closed trades for the last 2 days trades = Trade.get_trades([Trade.pair == metadata['pair'], Trade.open_date > datetime.utcnow() - timedelta(days=2), Trade.is_open.is_(False), ]).all() # Analyze the conditions you'd like to lock the pair .... will probably be different for every strategy sumprofit = sum(trade.close_profit for trade in trades) if sumprofit < 0: # Lock pair for 12 hours self.lock_pair(metadata['pair'], until=datetime.now(timezone.utc) + timedelta(hours=12)) ``` Print created dataframe \u00b6 To inspect the created dataframe, you can issue a print-statement in either populate_buy_trend() or populate_sell_trend() . You may also want to print the pair so it's clear what data is currently shown. ``` python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( #>> whatever condition<<< ), 'buy'] = 1 # Print the Analyzed pair print(f\"result for {metadata['pair']}\") # Inspect the last 5 rows print(dataframe.tail()) return dataframe ``` Printing more than a few rows is also possible (simply use print(dataframe) instead of print(dataframe.tail()) ), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds). Common mistakes when developing strategies \u00b6 Peeking into the future while backtesting \u00b6 Backtesting analyzes the whole time-range at once for performance reasons. Because of this, strategy authors need to make sure that strategies do not look-ahead into the future. This is a common pain-point, which can cause huge differences between backtesting and dry/live run methods, since they all use data which is not available during dry/live runs, so these strategies will perform well during backtesting, but will fail / perform badly in real conditions. The following lists some common patterns which should be avoided to prevent frustration: don't use shift(-1) . This uses data from the future, which is not available. don't use .iloc[-1] or any other absolute position in the dataframe, this will be different between dry-run and backtesting. don't use dataframe['volume'].mean() . This uses the full DataFrame for backtesting, including data from the future. Use dataframe['volume'].rolling(<window>).mean() instead don't use .resample('1h') . This uses the left border of the interval, so moves data from an hour to the start of the hour. Use .resample('1h', label='right') instead. Colliding signals \u00b6 When buy and sell signals collide (both 'buy' and 'sell' are 1), freqtrade will do nothing and ignore the entry (buy) signal. This will avoid trades that buy, and sell immediately. Obviously, this can potentially lead to missed entries. Further strategy ideas \u00b6 To get additional Ideas for strategies, head over to the strategy repository . Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo. Next step \u00b6 Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting .","title":"Strategy Customization"},{"location":"strategy-customization/#strategy-customization","text":"This page explains how to customize your strategies, add new indicators and set up trading rules. Please familiarize yourself with Freqtrade basics first, which provides overall info on how the bot operates.","title":"Strategy Customization"},{"location":"strategy-customization/#develop-your-own-strategy","text":"The bot includes a default strategy file. Also, several other strategies are available in the strategy repository . You will however most likely have your own idea for a strategy. This document intends to help you convert your strategy idea into your own strategy. To get started, use freqtrade new-strategy --strategy AwesomeStrategy (you can obviously use your own naming for your strategy). This will create a new strategy file from a template, which will be located under user_data/strategies/AwesomeStrategy.py . Note This is just a template file, which will most likely not be profitable out of the box. Different template levels freqtrade new-strategy has an additional parameter, --template , which controls the amount of pre-build information you get in the created strategy. Use --template minimal to get an empty strategy without any indicator examples, or --template advanced to get a template with most callbacks defined.","title":"Develop your own strategy"},{"location":"strategy-customization/#anatomy-of-a-strategy","text":"A strategy file contains all the information needed to build a good strategy: Indicators Buy strategy rules Sell strategy rules Minimal ROI recommended Stoploss strongly recommended The bot also include a sample strategy called SampleStrategy you can update: user_data/strategies/sample_strategy.py . You can test it with the parameter: --strategy SampleStrategy Additionally, there is an attribute called INTERFACE_VERSION , which defines the version of the strategy interface the bot should use. The current version is 2 - which is also the default when it's not set explicitly in the strategy. Future versions will require this to be set. bash freqtrade trade --strategy AwesomeStrategy For the following section we will use the user_data/strategies/sample_strategy.py file as reference. Strategies and Backtesting To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time range is passed to the populate_*() methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing ( df.iloc[-1] ), but instead use df.shift() to get to the previous candle. Warning: Using future data Since backtesting passes the full time range to the populate_*() methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Some common patterns for this are listed in the Common Mistakes section of this document.","title":"Anatomy of a strategy"},{"location":"strategy-customization/#dataframe","text":"Freqtrade uses pandas to store/provide the candlestick (OHLCV) data. Pandas is a great library developed for processing large amounts of data. Each row in a dataframe corresponds to one candle on a chart, with the latest candle always being the last in the dataframe (sorted by date). ``` output dataframe.head() date open high low close volume 0 2021-11-09 23:25:00+00:00 67279.67 67321.84 67255.01 67300.97 44.62253 1 2021-11-09 23:30:00+00:00 67300.97 67301.34 67183.03 67187.01 61.38076 2 2021-11-09 23:35:00+00:00 67187.02 67187.02 67031.93 67123.81 113.42728 3 2021-11-09 23:40:00+00:00 67123.80 67222.40 67080.33 67160.48 78.96008 4 2021-11-09 23:45:00+00:00 67160.48 67160.48 66901.26 66943.37 111.39292 ``` Pandas provides fast ways to calculate metrics. To benefit from this speed, it's advised to not use loops, but use vectorized methods instead. Vectorized operations perform calculations across the whole range of data and are therefore, compared to looping through each row, a lot faster when calculating indicators. As a dataframe is a table, simple python comparisons like the following will not work python if dataframe['rsi'] > 30: dataframe['buy'] = 1 The above section will fail with The truth value of a Series is ambiguous. [...] . This must instead be written in a pandas-compatible way, so the operation is performed across the whole dataframe. python dataframe.loc[ (dataframe['rsi'] > 30) , 'buy'] = 1 With this section, you have a new column in your dataframe, which has 1 assigned whenever RSI is above 30.","title":"Dataframe"},{"location":"strategy-customization/#customize-indicators","text":"Buy and sell strategies need indicators. You can add more indicators by extending the list contained in the method populate_indicators() from your strategy file. You should only add the indicators used in either populate_buy_trend() , populate_sell_trend() , or to populate another indicator, otherwise performance may suffer. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. Sample: ```python def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Adds several different TA indicators to the given DataFrame Performance Note: For the best performance be frugal on the number of indicators you are using. Let uncomment only the indicator you are using in your strategies or your hyperopt configuration, otherwise you will waste your memory and CPU usage. :param dataframe: Dataframe with data from the exchange :param metadata: Additional information, like the currently traded pair :return: a Dataframe with all mandatory indicators for the strategies \"\"\" dataframe['sar'] = ta.SAR(dataframe) dataframe['adx'] = ta.ADX(dataframe) stoch = ta.STOCHF(dataframe) dataframe['fastd'] = stoch['fastd'] dataframe['fastk'] = stoch['fastk'] dataframe['blower'] = ta.BBANDS(dataframe, nbdevup=2, nbdevdn=2)['lowerband'] dataframe['sma'] = ta.SMA(dataframe, timeperiod=40) dataframe['tema'] = ta.TEMA(dataframe, timeperiod=9) dataframe['mfi'] = ta.MFI(dataframe) dataframe['rsi'] = ta.RSI(dataframe) dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5) dataframe['ema10'] = ta.EMA(dataframe, timeperiod=10) dataframe['ema50'] = ta.EMA(dataframe, timeperiod=50) dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100) dataframe['ao'] = awesome_oscillator(dataframe) macd = ta.MACD(dataframe) dataframe['macd'] = macd['macd'] dataframe['macdsignal'] = macd['macdsignal'] dataframe['macdhist'] = macd['macdhist'] hilbert = ta.HT_SINE(dataframe) dataframe['htsine'] = hilbert['sine'] dataframe['htleadsine'] = hilbert['leadsine'] dataframe['plus_dm'] = ta.PLUS_DM(dataframe) dataframe['plus_di'] = ta.PLUS_DI(dataframe) dataframe['minus_dm'] = ta.MINUS_DM(dataframe) dataframe['minus_di'] = ta.MINUS_DI(dataframe) return dataframe ``` Want more indicator examples? Look into the user_data/strategies/sample_strategy.py . Then uncomment indicators you need.","title":"Customize Indicators"},{"location":"strategy-customization/#indicator-libraries","text":"Out of the box, freqtrade installs the following technical libraries: ta-lib pandas-ta technical Additional technical libraries can be installed as necessary, or custom indicators may be written / invented by the strategy author.","title":"Indicator libraries"},{"location":"strategy-customization/#strategy-startup-period","text":"Most indicators have an instable startup period, in which they are either not available (NaN), or the calculation is incorrect. This can lead to inconsistencies, since Freqtrade does not know how long this instable period should be. To account for this, the strategy can be assigned the startup_candle_count attribute. This should be set to the maximum number of candles that the strategy requires to calculate stable indicators. In this example strategy, this should be set to 100 ( startup_candle_count = 100 ), since the longest needed history is 100 candles. python dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100) By letting the bot know how much history is needed, backtest trades can start at the specified timerange during backtesting and hyperopt. Using x calls to get OHLCV If you receive a warning like WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy - you should consider if you really need this much historic data for your signals. Having this will cause Freqtrade to make multiple calls for the same pair, which will obviously be slower than one network request. As a consequence, Freqtrade will take longer to refresh candles - and should therefore be avoided if possible. This is capped to 5 total calls to avoid overloading the exchange, or make freqtrade too slow. Warning startup_candle_count should be below ohlcv_candle_limit * 5 (which is 500 * 5 for most exchanges) - since only this amount of candles will be available during Dry-Run/Live Trade operations.","title":"Strategy startup period"},{"location":"strategy-customization/#example","text":"Let's try to backtest 1 month (January 2019) of 5m candles using an example strategy with EMA100, as above. bash freqtrade backtesting --timerange 20190101-20190201 --timeframe 5m Assuming startup_candle_count is set to 100, backtesting knows it needs 100 candles to generate valid buy signals. It will load data from 20190101 - (100 * 5m) - which is ~2018-12-31 15:30:00. If this data is available, indicators will be calculated with this extended timerange. The instable startup period (up to 2019-01-01 00:00:00) will then be removed before starting backtesting. Note If data for the startup period is not available, then the timerange will be adjusted to account for this startup period - so Backtesting would start at 2019-01-01 08:30:00.","title":"Example"},{"location":"strategy-customization/#buy-signal-rules","text":"Edit the method populate_buy_trend() in your strategy file to update your buy strategy. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"buy\" , which needs to contain 1 for buys, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : ```python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Based on TA indicators, populates the buy signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 30)) & # Signal: RSI crosses above 30 (dataframe['tema'] <= dataframe['bb_middleband']) & # Guard (dataframe['tema'] > dataframe['tema'].shift(1)) & # Guard (dataframe['volume'] > 0) # Make sure Volume is not 0 ), 'buy'] = 1 return dataframe ``` Note Buying requires sellers to buy from - therefore volume needs to be > 0 ( dataframe['volume'] > 0 ) to make sure that the bot does not buy/sell in no-activity periods.","title":"Buy signal rules"},{"location":"strategy-customization/#sell-signal-rules","text":"Edit the method populate_sell_trend() into your strategy file to update your sell strategy. Please note that the sell-signal is only used if use_sell_signal is set to true in the configuration. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"sell\" , which needs to contain 1 for sells, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : python def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: \"\"\" Based on TA indicators, populates the sell signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 70)) & # Signal: RSI crosses above 70 (dataframe['tema'] > dataframe['bb_middleband']) & # Guard (dataframe['tema'] < dataframe['tema'].shift(1)) & # Guard (dataframe['volume'] > 0) # Make sure Volume is not 0 ), 'sell'] = 1 return dataframe","title":"Sell signal rules"},{"location":"strategy-customization/#minimal-roi","text":"This dict defines the minimal Return On Investment (ROI) a trade should reach before selling, independent from the sell signal. It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage. python minimal_roi = { \"40\": 0.0, \"30\": 0.01, \"20\": 0.02, \"0\": 0.04 } The above configuration would therefore mean: Sell whenever 4% profit was reached Sell when 2% profit was reached (in effect after 20 minutes) Sell when 1% profit was reached (in effect after 30 minutes) Sell when trade is non-loosing (in effect after 40 minutes) The calculation does include fees. To disable ROI completely, set it to an insanely high number: python minimal_roi = { \"0\": 100 } While technically not completely disabled, this would sell once the trade reaches 10000% Profit. To use times based on candle duration (timeframe), the following snippet can be handy. This will allow you to change the timeframe for the strategy, and ROI times will still be set as candles (e.g. after 3 candles ...) ``` python from freqtrade.exchange import timeframe_to_minutes class AwesomeStrategy(IStrategy): timeframe = \"1d\" timeframe_mins = timeframe_to_minutes(timeframe) minimal_roi = { \"0\": 0.05, # 5% for the first 3 candles str(timeframe_mins * 3)): 0.02, # 2% after 3 candles str(timeframe_mins * 6)): 0.01, # 1% After 6 candles } ```","title":"Minimal ROI"},{"location":"strategy-customization/#stoploss","text":"Setting a stoploss is highly recommended to protect your capital from strong moves against you. Sample of setting a 10% stoploss: python stoploss = -0.10 For the full documentation on stoploss features, look at the dedicated stoploss page .","title":"Stoploss"},{"location":"strategy-customization/#timeframe","text":"This is the set of candles the bot should download and use for the analysis. Common values are \"1m\" , \"5m\" , \"15m\" , \"1h\" , however all values supported by your exchange should work. Please note that the same buy/sell signals may work well with one timeframe, but not with the others. This setting is accessible within the strategy methods as the self.timeframe attribute.","title":"Timeframe"},{"location":"strategy-customization/#metadata-dict","text":"The metadata-dict (available for populate_buy_trend , populate_sell_trend , populate_indicators ) contains additional information. Currently this is pair , which can be accessed using metadata['pair'] - and will return a pair in the format XRP/BTC . The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the Storing information section.","title":"Metadata dict"},{"location":"strategy-customization/#strategy-file-loading","text":"By default, freqtrade will attempt to load strategies from all .py files within user_data/strategies . Assuming your strategy is called AwesomeStrategy , stored in the file user_data/strategies/AwesomeStrategy.py , then you can start freqtrade with freqtrade trade --strategy AwesomeStrategy . Note that we're using the class-name, not the file name. You can use freqtrade list-strategies to see a list of all strategies Freqtrade is able to load (all strategies in the correct folder). It will also include a \"status\" field, highlighting potential problems. Customize strategy directory You can use a different directory by using --strategy-path user_data/otherPath . This parameter is available to all commands that require a strategy.","title":"Strategy file loading"},{"location":"strategy-customization/#informative-pairs","text":"","title":"Informative Pairs"},{"location":"strategy-customization/#get-data-for-non-tradeable-pairs","text":"Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. OHLCV data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via DataProvider just as other pairs (see below). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting. The pairs need to be specified as tuples in the format (\"pair\", \"timeframe\") , with pair as the first and timeframe as the second argument. Sample: python def informative_pairs(self): return [(\"ETH/USDT\", \"5m\"), (\"BTC/TUSD\", \"15m\"), ] A full sample can be found in the DataProvider section . Warning As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All timeframes and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer timeframes whenever possible to avoid hammering the exchange with too many requests and risk being blocked.","title":"Get data for non-tradeable pairs"},{"location":"strategy-customization/#informative-pairs-decorator-informative","text":"In most common case it is possible to easily define informative pairs by using a decorator. All decorated populate_indicators_* methods run in isolation, not having access to data from other informative pairs, in the end all informative dataframes are merged and passed to main populate_indicators() method. When hyperopting, use of hyperoptable parameter .value attribute is not supported. Please use .range attribute. See optimizing an indicator parameter for more information. Full documentation ``` python def informative(timeframe: str, asset: str = '', fmt: Optional[Union[str, Callable[[KwArg(str)], str]]] = None, ffill: bool = True) -> Callable[[PopulateIndicators], PopulateIndicators]: \"\"\" A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to define informative indicators. Example usage: @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe. :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use current pair. :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not specified, defaults to: * {base}_{quote}_{column}_{timeframe} if asset is specified. * {column}_{timeframe} if asset is not specified. Format string supports these format variables: * {asset} - full name of the asset, for example 'BTC/USDT'. * {base} - base currency in lower case, for example 'eth'. * {BASE} - same as {base}, except in upper case. * {quote} - quote currency in lower case, for example 'usdt'. * {QUOTE} - same as {quote}, except in upper case. * {column} - name of dataframe column. * {timeframe} - timeframe of informative dataframe. :param ffill: ffill dataframe after merging informative pair. \"\"\" ``` Fast and easy way to define informative pairs Most of the time we do not need power and flexibility offered by merge_informative_pair() , therefore we can use a decorator to quickly define informative pairs. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, informative class AwesomeStrategy(IStrategy): # This method is not required. # def informative_pairs(self): ... # Define informative upper timeframe for each pair. Decorators can be stacked on same # method. Available in populate_indicators as 'rsi_30m' and 'rsi_1h'. @informative('30m') @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/STAKE informative pair. Available in populate_indicators and other methods as # 'btc_rsi_1h'. Current stake currency should be specified as {stake} format variable # instead of hardcoding actual stake currency. Available in populate_indicators and other # methods as 'btc_usdt_rsi_1h' (when stake currency is USDT). @informative('1h', 'BTC/{stake}') def populate_indicators_btc_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/ETH informative pair. You must specify quote currency if it is different from # stake currency. Available in populate_indicators and other methods as 'eth_btc_rsi_1h'. @informative('1h', 'ETH/BTC') def populate_indicators_eth_btc_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe # Define BTC/STAKE informative pair. A custom formatter may be specified for formatting # column names. A callable `fmt(**kwargs) -> str` may be specified, to implement custom # formatting. Available in populate_indicators and other methods as 'rsi_upper'. @informative('1h', 'BTC/{stake}', '{column}') def populate_indicators_btc_1h_2(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi_upper'] = ta.RSI(dataframe, timeperiod=14) return dataframe def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: # Strategy timeframe indicators for current pair. dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) # Informative pairs are available in this method. dataframe['rsi_less'] = dataframe['rsi'] < dataframe['rsi_1h'] return dataframe ``` Note Do not use @informative decorator if you need to use data of one informative pair when generating another informative pair. Instead, define informative pairs manually as described in the DataProvider section . Note Use string formatting when accessing informative dataframes of other pairs. This will allow easily changing stake currency in config without having to adjust strategy code. ``` python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: stake = self.config['stake_currency'] dataframe.loc[ ( (dataframe[f'btc_{stake}_rsi_1h'] < 35) & (dataframe['volume'] > 0) ), ['buy', 'buy_tag']] = (1, 'buy_signal_rsi') return dataframe ``` Alternatively column renaming may be used to remove stake currency from column names: @informative('1h', 'BTC/{stake}', fmt='{base}_{column}_{timeframe}') . Duplicate method names Methods tagged with @informative() decorator must always have unique names! Re-using same name (for example when copy-pasting already defined informative method) will overwrite previously defined method and not produce any errors due to limitations of Python programming language. In such cases you will find that indicators created in earlier-defined methods are not available in the dataframe. Carefully review method names and make sure they are unique!","title":"Informative pairs decorator (@informative())"},{"location":"strategy-customization/#additional-data-dataprovider","text":"The strategy provides access to the DataProvider . This allows you to get additional data to use in your strategy. All methods return None in case of failure (do not raise an exception). Please always check the mode of operation to select the correct method to get data (samples see below). Hyperopt Dataprovider is available during hyperopt, however it can only be used in populate_indicators() within a strategy. It is not available in populate_buy() and populate_sell() methods, nor in populate_indicators() , if this method located in the hyperopt file.","title":"Additional data (DataProvider)"},{"location":"strategy-customization/#possible-options-for-dataprovider","text":"available_pairs - Property with tuples listing cached pairs with their timeframe (pair, timeframe). current_whitelist() - Returns a current list of whitelisted pairs. Useful for accessing dynamic whitelists (i.e. VolumePairlist) get_pair_dataframe(pair, timeframe) - This is a universal method, which returns either historical data (for backtesting) or cached live data (for the Dry-Run and Live-Run modes). get_analyzed_dataframe(pair, timeframe) - Returns the analyzed dataframe (after calling populate_indicators() , populate_buy() , populate_sell() ) and the time of the latest analysis. historic_ohlcv(pair, timeframe) - Returns historical data stored on disk. market(pair) - Returns market data for the pair: fees, limits, precisions, activity flag, etc. See ccxt documentation for more details on the Market data structure. ohlcv(pair, timeframe) - Currently cached candle (OHLCV) data for the pair, returns DataFrame or empty DataFrame. orderbook(pair, maximum) - Returns latest orderbook data for the pair, a dict with bids/asks with a total of maximum entries. ticker(pair) - Returns current ticker data for the pair. See ccxt documentation for more details on the Ticker data structure. runmode - Property containing the current runmode.","title":"Possible options for DataProvider"},{"location":"strategy-customization/#example-usages","text":"","title":"Example Usages"},{"location":"strategy-customization/#available_pairs","text":"python if self.dp: for pair, timeframe in self.dp.available_pairs: print(f\"available {pair}, {timeframe}\")","title":"available_pairs"},{"location":"strategy-customization/#current_whitelist","text":"Imagine you've developed a strategy that trades the 5m timeframe using signals generated from a 1d timeframe on the top 10 volume pairs by volume. The strategy might look something like this: Scan through the top 10 pairs by volume using the VolumePairList every 5 minutes and use a 14 day RSI to buy and sell. Due to the limited available data, it's very difficult to resample 5m candles into daily candles for use in a 14 day RSI. Most exchanges limit us to just 500 candles which effectively gives us around 1.74 daily candles. We need 14 days at least! Since we can't resample the data we will have to use an informative pair; and since the whitelist will be dynamic we don't know which pair(s) to use. This is where calling self.dp.current_whitelist() comes in handy. ```python def informative_pairs(self): # get access to all pairs available in whitelist. pairs = self.dp.current_whitelist() # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [(pair, '1d') for pair in pairs] return informative_pairs ```","title":"current_whitelist()"},{"location":"strategy-customization/#get_pair_dataframepair-timeframe","text":"``` python","title":"get_pair_dataframe(pair, timeframe)"},{"location":"strategy-customization/#fetch-live-historical-candle-ohlcv-data-for-the-first-informative-pair","text":"if self.dp: inf_pair, inf_timeframe = self.informative_pairs()[0] informative = self.dp.get_pair_dataframe(pair=inf_pair, timeframe=inf_timeframe) ``` Warning about backtesting Be careful when using dataprovider in backtesting. historic_ohlcv() (and get_pair_dataframe() for the backtesting runmode) provides the full time-range in one go, so please be aware of it and make sure to not \"look into the future\" to avoid surprises when running in dry/live mode.","title":"fetch live / historical candle (OHLCV) data for the first informative pair"},{"location":"strategy-customization/#get_analyzed_dataframepair-timeframe","text":"This method is used by freqtrade internally to determine the last signal. It can also be used in specific callbacks to get the signal that caused the action (see Advanced Strategy Documentation for more details on available callbacks). ``` python","title":"get_analyzed_dataframe(pair, timeframe)"},{"location":"strategy-customization/#fetch-current-dataframe","text":"if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=metadata['pair'], timeframe=self.timeframe) ``` No data available Returns an empty dataframe if the requested pair was not cached. This should not happen when using whitelisted pairs.","title":"fetch current dataframe"},{"location":"strategy-customization/#orderbookpair-maximum","text":"python if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): ob = self.dp.orderbook(metadata['pair'], 1) dataframe['best_bid'] = ob['bids'][0][0] dataframe['best_ask'] = ob['asks'][0][0] The orderbook structure is aligned with the order structure from ccxt , so the result will look as follows: js { 'bids': [ [ price, amount ], // [ float, float ] [ price, amount ], ... ], 'asks': [ [ price, amount ], [ price, amount ], //... ], //... } Therefore, using ob['bids'][0][0] as demonstrated above will result in using the best bid price. ob['bids'][0][1] would look at the amount at this orderbook position. Warning about backtesting The order book is not part of the historic data which means backtesting and hyperopt will not work correctly if this method is used, as the method will return uptodate values.","title":"orderbook(pair, maximum)"},{"location":"strategy-customization/#tickerpair","text":"python if self.dp: if self.dp.runmode.value in ('live', 'dry_run'): ticker = self.dp.ticker(metadata['pair']) dataframe['last_price'] = ticker['last'] dataframe['volume24h'] = ticker['quoteVolume'] dataframe['vwap'] = ticker['vwap'] Warning Although the ticker data structure is a part of the ccxt Unified Interface, the values returned by this method can vary for different exchanges. For instance, many exchanges do not return vwap values, the FTX exchange does not always fills in the last field (so it can be None), etc. So you need to carefully verify the ticker data returned from the exchange and add appropriate error handling / defaults. Warning about backtesting This method will always return up-to-date values - so usage during backtesting / hyperopt will lead to wrong results.","title":"ticker(pair)"},{"location":"strategy-customization/#complete-data-provider-sample","text":"```python from freqtrade.strategy import IStrategy, merge_informative_pair from pandas import DataFrame class SampleStrategy(IStrategy): # strategy init stuff... timeframe = '5m' # more strategy init stuff.. def informative_pairs(self): # get access to all pairs available in whitelist. pairs = self.dp.current_whitelist() # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [(pair, '1d') for pair in pairs] # Optionally Add additional \"static\" pairs informative_pairs += [(\"ETH/USDT\", \"5m\"), (\"BTC/TUSD\", \"15m\"), ] return informative_pairs def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame: if not self.dp: # Don't do anything if DataProvider is not available. return dataframe inf_tf = '1d' # Get the informative pair informative = self.dp.get_pair_dataframe(pair=metadata['pair'], timeframe=inf_tf) # Get the 14 day rsi informative['rsi'] = ta.RSI(informative, timeperiod=14) # Use the helper function merge_informative_pair to safely merge the pair # Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair # use ffill to have the 1d value available in every row throughout the day. # Without this, comparisons between columns of the original and the informative pair would only work once per day. # Full documentation of this method, see below dataframe = merge_informative_pair(dataframe, informative, self.timeframe, inf_tf, ffill=True) # Calculate rsi of the original dataframe (5m timeframe) dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) # Do other stuff # ... return dataframe def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( (qtpylib.crossed_above(dataframe['rsi'], 30)) & # Signal: RSI crosses above 30 (dataframe['rsi_1d'] < 30) & # Ensure daily RSI is < 30 (dataframe['volume'] > 0) # Ensure this candle had volume (important for backtesting) ), 'buy'] = 1 ```","title":"Complete Data-provider sample"},{"location":"strategy-customization/#helper-functions","text":"","title":"Helper functions"},{"location":"strategy-customization/#merge_informative_pair","text":"This method helps you merge an informative pair to a regular dataframe without lookahead bias. It's there to help you merge the dataframe in a safe and consistent way. Options: Rename the columns for you to create unique columns Merge the dataframe without lookahead bias Forward-fill (optional) All columns of the informative dataframe will be available on the returning dataframe in a renamed fashion: Column renaming Assuming inf_tf = '1d' the resulting columns will be: python 'date', 'open', 'high', 'low', 'close', 'rsi' # from the original dataframe 'date_1d', 'open_1d', 'high_1d', 'low_1d', 'close_1d', 'rsi_1d' # from the informative dataframe Column renaming - 1h Assuming inf_tf = '1h' the resulting columns will be: python 'date', 'open', 'high', 'low', 'close', 'rsi' # from the original dataframe 'date_1h', 'open_1h', 'high_1h', 'low_1h', 'close_1h', 'rsi_1h' # from the informative dataframe Custom implementation A custom implementation for this is possible, and can be done as follows: ``` python","title":"merge_informative_pair()"},{"location":"strategy-customization/#shift-date-by-1-candle","text":"","title":"Shift date by 1 candle"},{"location":"strategy-customization/#this-is-necessary-since-the-data-is-always-the-open-date","text":"","title":"This is necessary since the data is always the \"open date\""},{"location":"strategy-customization/#and-a-15m-candle-starting-at-1215-should-not-know-the-close-of-the-1h-candle-from-1200-to-1300","text":"minutes = timeframe_to_minutes(inf_tf)","title":"and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00"},{"location":"strategy-customization/#only-do-this-if-the-timeframes-are-different","text":"informative['date_merge'] = informative[\"date\"] + pd.to_timedelta(minutes, 'm')","title":"Only do this if the timeframes are different:"},{"location":"strategy-customization/#rename-columns-to-be-unique","text":"informative.columns = [f\"{col}_{inf_tf}\" for col in informative.columns]","title":"Rename columns to be unique"},{"location":"strategy-customization/#assuming-inf_tf-1d-then-the-columns-will-now-be","text":"","title":"Assuming inf_tf = '1d' - then the columns will now be:"},{"location":"strategy-customization/#date_1d-open_1d-high_1d-low_1d-close_1d-rsi_1d","text":"","title":"date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d"},{"location":"strategy-customization/#combine-the-2-dataframes","text":"","title":"Combine the 2 dataframes"},{"location":"strategy-customization/#all-indicators-on-the-informative-sample-must-be-calculated-before-this-point","text":"dataframe = pd.merge(dataframe, informative, left_on='date', right_on=f'date_merge_{inf_tf}', how='left')","title":"all indicators on the informative sample MUST be calculated before this point"},{"location":"strategy-customization/#ffill-to-have-the-1d-value-available-in-every-row-throughout-the-day","text":"","title":"FFill to have the 1d value available in every row throughout the day."},{"location":"strategy-customization/#without-this-comparisons-would-only-work-once-per-day","text":"dataframe = dataframe.ffill() ``` Informative timeframe < timeframe Using informative timeframes smaller than the dataframe timeframe is not recommended with this method, as it will not use any of the additional information this would provide. To use the more detailed information properly, more advanced methods should be applied (which are out of scope for freqtrade documentation, as it'll depend on the respective need).","title":"Without this, comparisons would only work once per day."},{"location":"strategy-customization/#stoploss_from_open","text":"Stoploss values returned from custom_stoploss must specify a percentage relative to current_rate , but sometimes you may want to specify a stoploss relative to the open price instead. stoploss_from_open() is a helper function to calculate a stoploss value that can be returned from custom_stoploss which will be equivalent to the desired percentage above the open price. Returning a stoploss relative to the open price from the custom stoploss function Say the open price was $100, and current_price is $121 ( current_profit will be 0.21 ). If we want a stop price at 7% above the open price we can call stoploss_from_open(0.07, current_profit) which will return 0.1157024793 . 11.57% below $121 is $107, which is the same as 7% above $100. ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, stoploss_from_open class AwesomeStrategy(IStrategy): # ... populate_* methods use_custom_stoploss = True def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10: return stoploss_from_open(0.07, current_profit) return 1 ``` Full examples can be found in the Custom stoploss section of the Documentation. Note Providing invalid input to stoploss_from_open() may produce \"CustomStoploss function did not return valid stoploss\" warnings. This may happen if current_profit parameter is below specified open_relative_stop . Such situations may arise when closing trade is blocked by confirm_trade_exit() method. Warnings can be solved by never blocking stop loss sells by checking sell_reason in confirm_trade_exit() , or by using return stoploss_from_open(...) or 1 idiom, which will request to not change stop loss when current_profit < open_relative_stop .","title":"stoploss_from_open()"},{"location":"strategy-customization/#stoploss_from_absolute","text":"In some situations it may be confusing to deal with stops relative to current rate. Instead, you may define a stoploss level using an absolute price. Returning a stoploss using absolute price from the custom stoploss function If we want to trail a stop price at 2xATR below current proce we can call stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate) . ``` python from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy, stoploss_from_absolute class AwesomeStrategy(IStrategy): use_custom_stoploss = True def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['atr'] = ta.ATR(dataframe, timeperiod=14) return dataframe def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime, current_rate: float, current_profit: float, **kwargs) -> float: dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe) candle = dataframe.iloc[-1].squeeze() return stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate) ```","title":"stoploss_from_absolute()"},{"location":"strategy-customization/#additional-data-wallets","text":"The strategy provides access to the Wallets object. This contains the current balances on the exchange. Note Wallets is not available during backtesting / hyperopt. Please always check if Wallets is available to avoid failures during backtesting. python if self.wallets: free_eth = self.wallets.get_free('ETH') used_eth = self.wallets.get_used('ETH') total_eth = self.wallets.get_total('ETH')","title":"Additional data (Wallets)"},{"location":"strategy-customization/#possible-options-for-wallets","text":"get_free(asset) - currently available balance to trade get_used(asset) - currently tied up balance (open orders) get_total(asset) - total available balance - sum of the 2 above","title":"Possible options for Wallets"},{"location":"strategy-customization/#additional-data-trades","text":"A history of Trades can be retrieved in the strategy by querying the database. At the top of the file, import Trade. python from freqtrade.persistence import Trade The following example queries for the current pair and trades from today, however other filters can easily be added. python if self.config['runmode'].value in ('live', 'dry_run'): trades = Trade.get_trades([Trade.pair == metadata['pair'], Trade.open_date > datetime.utcnow() - timedelta(days=1), Trade.is_open.is_(False), ]).order_by(Trade.close_date).all() # Summarize profit for this pair. curdayprofit = sum(trade.close_profit for trade in trades) Get amount of stake_currency currently invested in Trades: python if self.config['runmode'].value in ('live', 'dry_run'): total_stakes = Trade.total_open_trades_stakes() Retrieve performance per pair. Returns a List of dicts per pair. python if self.config['runmode'].value in ('live', 'dry_run'): performance = Trade.get_overall_performance() Sample return value: ETH/BTC had 5 trades, with a total profit of 1.5% (ratio of 0.015). json {'pair': \"ETH/BTC\", 'profit': 0.015, 'count': 5} Warning Trade history is not available during backtesting or hyperopt.","title":"Additional data (Trades)"},{"location":"strategy-customization/#prevent-trades-from-happening-for-a-specific-pair","text":"Freqtrade locks pairs automatically for the current candle (until that candle is over) when a pair is sold, preventing an immediate re-buy of that pair. Locked pairs will show the message Pair <pair> is currently locked. .","title":"Prevent trades from happening for a specific pair"},{"location":"strategy-customization/#locking-pairs-from-within-the-strategy","text":"Sometimes it may be desired to lock a pair after certain events happen (e.g. multiple losing trades in a row). Freqtrade has an easy method to do this from within the strategy, by calling self.lock_pair(pair, until, [reason]) . until must be a datetime object in the future, after which trading will be re-enabled for that pair, while reason is an optional string detailing why the pair was locked. Locks can also be lifted manually, by calling self.unlock_pair(pair) or self.unlock_reason(<reason>) - providing reason the pair was locked with. self.unlock_reason(<reason>) will unlock all pairs currently locked with the provided reason. To verify if a pair is currently locked, use self.is_pair_locked(pair) . Note Locked pairs will always be rounded up to the next candle. So assuming a 5m timeframe, a lock with until set to 10:18 will lock the pair until the candle from 10:15-10:20 will be finished. Warning Manually locking pairs is not available during backtesting, only locks via Protections are allowed.","title":"Locking pairs from within the strategy"},{"location":"strategy-customization/#pair-locking-example","text":"``` python from freqtrade.persistence import Trade from datetime import timedelta, datetime, timezone","title":"Pair locking example"},{"location":"strategy-customization/#put-the-above-lines-a-the-top-of-the-strategy-file-next-to-all-the-other-imports","text":"","title":"Put the above lines a the top of the strategy file, next to all the other imports"},{"location":"strategy-customization/#-","text":"","title":"--------"},{"location":"strategy-customization/#within-populate-indicators-or-populate_buy","text":"if self.config['runmode'].value in ('live', 'dry_run'): # fetch closed trades for the last 2 days trades = Trade.get_trades([Trade.pair == metadata['pair'], Trade.open_date > datetime.utcnow() - timedelta(days=2), Trade.is_open.is_(False), ]).all() # Analyze the conditions you'd like to lock the pair .... will probably be different for every strategy sumprofit = sum(trade.close_profit for trade in trades) if sumprofit < 0: # Lock pair for 12 hours self.lock_pair(metadata['pair'], until=datetime.now(timezone.utc) + timedelta(hours=12)) ```","title":"Within populate indicators (or populate_buy):"},{"location":"strategy-customization/#print-created-dataframe","text":"To inspect the created dataframe, you can issue a print-statement in either populate_buy_trend() or populate_sell_trend() . You may also want to print the pair so it's clear what data is currently shown. ``` python def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe.loc[ ( #>> whatever condition<<< ), 'buy'] = 1 # Print the Analyzed pair print(f\"result for {metadata['pair']}\") # Inspect the last 5 rows print(dataframe.tail()) return dataframe ``` Printing more than a few rows is also possible (simply use print(dataframe) instead of print(dataframe.tail()) ), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds).","title":"Print created dataframe"},{"location":"strategy-customization/#common-mistakes-when-developing-strategies","text":"","title":"Common mistakes when developing strategies"},{"location":"strategy-customization/#peeking-into-the-future-while-backtesting","text":"Backtesting analyzes the whole time-range at once for performance reasons. Because of this, strategy authors need to make sure that strategies do not look-ahead into the future. This is a common pain-point, which can cause huge differences between backtesting and dry/live run methods, since they all use data which is not available during dry/live runs, so these strategies will perform well during backtesting, but will fail / perform badly in real conditions. The following lists some common patterns which should be avoided to prevent frustration: don't use shift(-1) . This uses data from the future, which is not available. don't use .iloc[-1] or any other absolute position in the dataframe, this will be different between dry-run and backtesting. don't use dataframe['volume'].mean() . This uses the full DataFrame for backtesting, including data from the future. Use dataframe['volume'].rolling(<window>).mean() instead don't use .resample('1h') . This uses the left border of the interval, so moves data from an hour to the start of the hour. Use .resample('1h', label='right') instead.","title":"Peeking into the future while backtesting"},{"location":"strategy-customization/#colliding-signals","text":"When buy and sell signals collide (both 'buy' and 'sell' are 1), freqtrade will do nothing and ignore the entry (buy) signal. This will avoid trades that buy, and sell immediately. Obviously, this can potentially lead to missed entries.","title":"Colliding signals"},{"location":"strategy-customization/#further-strategy-ideas","text":"To get additional Ideas for strategies, head over to the strategy repository . Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo.","title":"Further strategy ideas"},{"location":"strategy-customization/#next-step","text":"Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting .","title":"Next step"},{"location":"strategy_analysis_example/","text":"Strategy analysis example \u00b6 Debugging a strategy can be time-consuming. Freqtrade offers helper functions to visualize raw data. The following assumes you work with SampleStrategy, data for 5m timeframe from Binance and have downloaded them into the data directory in the default location. Setup \u00b6 ```python from pathlib import Path from freqtrade.configuration import Configuration Customize these according to your needs. \u00b6 Initialize empty configuration object \u00b6 config = Configuration.from_files([]) Optionally, use existing configuration file \u00b6 config = Configuration.from_files([\"config.json\"]) \u00b6 Define some constants \u00b6 config[\"timeframe\"] = \"5m\" Name of the strategy class \u00b6 config[\"strategy\"] = \"SampleStrategy\" Location of the data \u00b6 data_location = Path(config['user_data_dir'], 'data', 'binance') Pair to analyze - Only use one pair here \u00b6 pair = \"BTC/USDT\" ``` ```python Load data using values set above \u00b6 from freqtrade.data.history import load_pair_history candles = load_pair_history(datadir=data_location, timeframe=config[\"timeframe\"], pair=pair, data_format = \"hdf5\", ) Confirm success \u00b6 print(\"Loaded \" + str(len(candles)) + f\" rows of data for {pair} from {data_location}\") candles.head() ``` Load and run strategy \u00b6 Rerun each time the strategy file is changed ```python Load strategy using values set above \u00b6 from freqtrade.resolvers import StrategyResolver from freqtrade.data.dataprovider import DataProvider strategy = StrategyResolver.load_strategy(config) strategy.dp = DataProvider(config, None, None) Generate buy/sell signals using strategy \u00b6 df = strategy.analyze_ticker(candles, {'pair': pair}) df.tail() ``` Display the trade details \u00b6 Note that using data.head() would also work, however most indicators have some \"startup\" data at the top of the dataframe. Some possible problems * Columns with NaN values at the end of the dataframe * Columns used in crossed*() functions with completely different units Comparison with full backtest * having 200 buy signals as output for one pair from analyze_ticker() does not necessarily mean that 200 trades will be made during backtesting. * Assuming you use only one condition such as, df['rsi'] < 30 as buy condition, this will generate multiple \"buy\" signals for each pair in sequence (until rsi returns > 29). The bot will only buy on the first of these signals (and also only if a trade-slot (\"max_open_trades\") is still available), or on one of the middle signals, as soon as a \"slot\" becomes available. ```python Report results \u00b6 print(f\"Generated {df['buy'].sum()} buy signals\") data = df.set_index('date', drop=False) data.tail() ``` Load existing objects into a Jupyter notebook \u00b6 The following cells assume that you have already generated data using the cli. They will allow you to drill deeper into your results, and perform analysis which otherwise would make the output very difficult to digest due to information overload. Load backtest results to pandas dataframe \u00b6 Analyze a trades dataframe (also used below for plotting) ```python from freqtrade.data.btanalysis import load_backtest_data, load_backtest_stats if backtest_dir points to a directory, it'll automatically load the last backtest file. \u00b6 backtest_dir = config[\"user_data_dir\"] / \"backtest_results\" backtest_dir can also point to a specific file \u00b6 backtest_dir = config[\"user_data_dir\"] / \"backtest_results/backtest-result-2020-07-01_20-04-22.json\" \u00b6 ``` ```python You can get the full backtest statistics by using the following command. \u00b6 This contains all information used to generate the backtest result. \u00b6 stats = load_backtest_stats(backtest_dir) strategy = 'SampleStrategy' All statistics are available per strategy, so if --strategy-list was used during backtest, this will be reflected here as well. \u00b6 Example usages: \u00b6 print(stats['strategy'][strategy]['results_per_pair']) Get pairlist used for this backtest \u00b6 print(stats['strategy'][strategy]['pairlist']) Get market change (average change of all pairs from start to end of the backtest period) \u00b6 print(stats['strategy'][strategy]['market_change']) Maximum drawdown () \u00b6 print(stats['strategy'][strategy]['max_drawdown']) Maximum drawdown start and end \u00b6 print(stats['strategy'][strategy]['drawdown_start']) print(stats['strategy'][strategy]['drawdown_end']) Get strategy comparison (only relevant if multiple strategies were compared) \u00b6 print(stats['strategy_comparison']) ``` ```python Load backtested trades as dataframe \u00b6 trades = load_backtest_data(backtest_dir) Show value-counts per pair \u00b6 trades.groupby(\"pair\")[\"sell_reason\"].value_counts() ``` Plotting daily profit / equity line \u00b6 ```python Plotting equity line (starting with 0 on day 1 and adding daily profit for each backtested day) \u00b6 from freqtrade.configuration import Configuration from freqtrade.data.btanalysis import load_backtest_data, load_backtest_stats import plotly.express as px import pandas as pd strategy = 'SampleStrategy' \u00b6 config = Configuration.from_files([\"user_data/config.json\"]) \u00b6 backtest_dir = config[\"user_data_dir\"] / \"backtest_results\" \u00b6 stats = load_backtest_stats(backtest_dir) strategy_stats = stats['strategy'][strategy] dates = [] profits = [] for date_profit in strategy_stats['daily_profit']: dates.append(date_profit[0]) profits.append(date_profit[1]) equity = 0 equity_daily = [] for daily_profit in profits: equity_daily.append(equity) equity += float(daily_profit) df = pd.DataFrame({'dates': dates,'equity_daily': equity_daily}) fig = px.line(df, x=\"dates\", y=\"equity_daily\") fig.show() ``` Load live trading results into a pandas dataframe \u00b6 In case you did already some trading and want to analyze your performance ```python from freqtrade.data.btanalysis import load_trades_from_db Fetch trades from database \u00b6 trades = load_trades_from_db(\"sqlite:///tradesv3.sqlite\") Display results \u00b6 trades.groupby(\"pair\")[\"sell_reason\"].value_counts() ``` Analyze the loaded trades for trade parallelism \u00b6 This can be useful to find the best max_open_trades parameter, when used with backtesting in conjunction with --disable-max-market-positions . analyze_trade_parallelism() returns a timeseries dataframe with an \"open_trades\" column, specifying the number of open trades for each candle. ```python from freqtrade.data.btanalysis import analyze_trade_parallelism Analyze the above \u00b6 parallel_trades = analyze_trade_parallelism(trades, '5m') parallel_trades.plot() ``` Plot results \u00b6 Freqtrade offers interactive plotting capabilities based on plotly. ```python from freqtrade.plot.plotting import generate_candlestick_graph Limit graph period to keep plotly quick and reactive \u00b6 Filter trades to one pair \u00b6 trades_red = trades.loc[trades['pair'] == pair] data_red = data['2019-06-01':'2019-06-10'] Generate candlestick graph \u00b6 graph = generate_candlestick_graph(pair=pair, data=data_red, trades=trades_red, indicators1=['sma20', 'ema50', 'ema55'], indicators2=['rsi', 'macd', 'macdsignal', 'macdhist'] ) ``` ```python Show graph inline \u00b6 graph.show() \u00b6 Render graph in a seperate window \u00b6 graph.show(renderer=\"browser\") ``` Plot average profit per trade as distribution graph \u00b6 ```python import plotly.figure_factory as ff hist_data = [trades.profit_ratio] group_labels = ['profit_ratio'] # name of the dataset fig = ff.create_distplot(hist_data, group_labels,bin_size=0.01) fig.show() ``` Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Strategy analysis"},{"location":"strategy_analysis_example/#strategy-analysis-example","text":"Debugging a strategy can be time-consuming. Freqtrade offers helper functions to visualize raw data. The following assumes you work with SampleStrategy, data for 5m timeframe from Binance and have downloaded them into the data directory in the default location.","title":"Strategy analysis example"},{"location":"strategy_analysis_example/#setup","text":"```python from pathlib import Path from freqtrade.configuration import Configuration","title":"Setup"},{"location":"strategy_analysis_example/#customize-these-according-to-your-needs","text":"","title":"Customize these according to your needs."},{"location":"strategy_analysis_example/#initialize-empty-configuration-object","text":"config = Configuration.from_files([])","title":"Initialize empty configuration object"},{"location":"strategy_analysis_example/#optionally-use-existing-configuration-file","text":"","title":"Optionally, use existing configuration file"},{"location":"strategy_analysis_example/#config-configurationfrom_filesconfigjson","text":"","title":"config = Configuration.from_files([\"config.json\"])"},{"location":"strategy_analysis_example/#define-some-constants","text":"config[\"timeframe\"] = \"5m\"","title":"Define some constants"},{"location":"strategy_analysis_example/#name-of-the-strategy-class","text":"config[\"strategy\"] = \"SampleStrategy\"","title":"Name of the strategy class"},{"location":"strategy_analysis_example/#location-of-the-data","text":"data_location = Path(config['user_data_dir'], 'data', 'binance')","title":"Location of the data"},{"location":"strategy_analysis_example/#pair-to-analyze-only-use-one-pair-here","text":"pair = \"BTC/USDT\" ``` ```python","title":"Pair to analyze - Only use one pair here"},{"location":"strategy_analysis_example/#load-data-using-values-set-above","text":"from freqtrade.data.history import load_pair_history candles = load_pair_history(datadir=data_location, timeframe=config[\"timeframe\"], pair=pair, data_format = \"hdf5\", )","title":"Load data using values set above"},{"location":"strategy_analysis_example/#confirm-success","text":"print(\"Loaded \" + str(len(candles)) + f\" rows of data for {pair} from {data_location}\") candles.head() ```","title":"Confirm success"},{"location":"strategy_analysis_example/#load-and-run-strategy","text":"Rerun each time the strategy file is changed ```python","title":"Load and run strategy"},{"location":"strategy_analysis_example/#load-strategy-using-values-set-above","text":"from freqtrade.resolvers import StrategyResolver from freqtrade.data.dataprovider import DataProvider strategy = StrategyResolver.load_strategy(config) strategy.dp = DataProvider(config, None, None)","title":"Load strategy using values set above"},{"location":"strategy_analysis_example/#generate-buysell-signals-using-strategy","text":"df = strategy.analyze_ticker(candles, {'pair': pair}) df.tail() ```","title":"Generate buy/sell signals using strategy"},{"location":"strategy_analysis_example/#display-the-trade-details","text":"Note that using data.head() would also work, however most indicators have some \"startup\" data at the top of the dataframe. Some possible problems * Columns with NaN values at the end of the dataframe * Columns used in crossed*() functions with completely different units Comparison with full backtest * having 200 buy signals as output for one pair from analyze_ticker() does not necessarily mean that 200 trades will be made during backtesting. * Assuming you use only one condition such as, df['rsi'] < 30 as buy condition, this will generate multiple \"buy\" signals for each pair in sequence (until rsi returns > 29). The bot will only buy on the first of these signals (and also only if a trade-slot (\"max_open_trades\") is still available), or on one of the middle signals, as soon as a \"slot\" becomes available. ```python","title":"Display the trade details"},{"location":"strategy_analysis_example/#report-results","text":"print(f\"Generated {df['buy'].sum()} buy signals\") data = df.set_index('date', drop=False) data.tail() ```","title":"Report results"},{"location":"strategy_analysis_example/#load-existing-objects-into-a-jupyter-notebook","text":"The following cells assume that you have already generated data using the cli. They will allow you to drill deeper into your results, and perform analysis which otherwise would make the output very difficult to digest due to information overload.","title":"Load existing objects into a Jupyter notebook"},{"location":"strategy_analysis_example/#load-backtest-results-to-pandas-dataframe","text":"Analyze a trades dataframe (also used below for plotting) ```python from freqtrade.data.btanalysis import load_backtest_data, load_backtest_stats","title":"Load backtest results to pandas dataframe"},{"location":"strategy_analysis_example/#if-backtest_dir-points-to-a-directory-itll-automatically-load-the-last-backtest-file","text":"backtest_dir = config[\"user_data_dir\"] / \"backtest_results\"","title":"if backtest_dir points to a directory, it'll automatically load the last backtest file."},{"location":"strategy_analysis_example/#backtest_dir-can-also-point-to-a-specific-file","text":"","title":"backtest_dir can also point to a specific file"},{"location":"strategy_analysis_example/#backtest_dir-configuser_data_dir-backtest_resultsbacktest-result-2020-07-01_20-04-22json","text":"``` ```python","title":"backtest_dir = config[\"user_data_dir\"] / \"backtest_results/backtest-result-2020-07-01_20-04-22.json\""},{"location":"strategy_analysis_example/#you-can-get-the-full-backtest-statistics-by-using-the-following-command","text":"","title":"You can get the full backtest statistics by using the following command."},{"location":"strategy_analysis_example/#this-contains-all-information-used-to-generate-the-backtest-result","text":"stats = load_backtest_stats(backtest_dir) strategy = 'SampleStrategy'","title":"This contains all information used to generate the backtest result."},{"location":"strategy_analysis_example/#all-statistics-are-available-per-strategy-so-if-strategy-list-was-used-during-backtest-this-will-be-reflected-here-as-well","text":"","title":"All statistics are available per strategy, so if --strategy-list was used during backtest, this will be reflected here as well."},{"location":"strategy_analysis_example/#example-usages","text":"print(stats['strategy'][strategy]['results_per_pair'])","title":"Example usages:"},{"location":"strategy_analysis_example/#get-pairlist-used-for-this-backtest","text":"print(stats['strategy'][strategy]['pairlist'])","title":"Get pairlist used for this backtest"},{"location":"strategy_analysis_example/#get-market-change-average-change-of-all-pairs-from-start-to-end-of-the-backtest-period","text":"print(stats['strategy'][strategy]['market_change'])","title":"Get market change (average change of all pairs from start to end of the backtest period)"},{"location":"strategy_analysis_example/#maximum-drawdown","text":"print(stats['strategy'][strategy]['max_drawdown'])","title":"Maximum drawdown ()"},{"location":"strategy_analysis_example/#maximum-drawdown-start-and-end","text":"print(stats['strategy'][strategy]['drawdown_start']) print(stats['strategy'][strategy]['drawdown_end'])","title":"Maximum drawdown start and end"},{"location":"strategy_analysis_example/#get-strategy-comparison-only-relevant-if-multiple-strategies-were-compared","text":"print(stats['strategy_comparison']) ``` ```python","title":"Get strategy comparison (only relevant if multiple strategies were compared)"},{"location":"strategy_analysis_example/#load-backtested-trades-as-dataframe","text":"trades = load_backtest_data(backtest_dir)","title":"Load backtested trades as dataframe"},{"location":"strategy_analysis_example/#show-value-counts-per-pair","text":"trades.groupby(\"pair\")[\"sell_reason\"].value_counts() ```","title":"Show value-counts per pair"},{"location":"strategy_analysis_example/#plotting-daily-profit-equity-line","text":"```python","title":"Plotting daily profit / equity line"},{"location":"strategy_analysis_example/#plotting-equity-line-starting-with-0-on-day-1-and-adding-daily-profit-for-each-backtested-day","text":"from freqtrade.configuration import Configuration from freqtrade.data.btanalysis import load_backtest_data, load_backtest_stats import plotly.express as px import pandas as pd","title":"Plotting equity line (starting with 0 on day 1 and adding daily profit for each backtested day)"},{"location":"strategy_analysis_example/#strategy-samplestrategy","text":"","title":"strategy = 'SampleStrategy'"},{"location":"strategy_analysis_example/#config-configurationfrom_filesuser_dataconfigjson","text":"","title":"config = Configuration.from_files([\"user_data/config.json\"])"},{"location":"strategy_analysis_example/#backtest_dir-configuser_data_dir-backtest_results","text":"stats = load_backtest_stats(backtest_dir) strategy_stats = stats['strategy'][strategy] dates = [] profits = [] for date_profit in strategy_stats['daily_profit']: dates.append(date_profit[0]) profits.append(date_profit[1]) equity = 0 equity_daily = [] for daily_profit in profits: equity_daily.append(equity) equity += float(daily_profit) df = pd.DataFrame({'dates': dates,'equity_daily': equity_daily}) fig = px.line(df, x=\"dates\", y=\"equity_daily\") fig.show() ```","title":"backtest_dir = config[\"user_data_dir\"] / \"backtest_results\""},{"location":"strategy_analysis_example/#load-live-trading-results-into-a-pandas-dataframe","text":"In case you did already some trading and want to analyze your performance ```python from freqtrade.data.btanalysis import load_trades_from_db","title":"Load live trading results into a pandas dataframe"},{"location":"strategy_analysis_example/#fetch-trades-from-database","text":"trades = load_trades_from_db(\"sqlite:///tradesv3.sqlite\")","title":"Fetch trades from database"},{"location":"strategy_analysis_example/#display-results","text":"trades.groupby(\"pair\")[\"sell_reason\"].value_counts() ```","title":"Display results"},{"location":"strategy_analysis_example/#analyze-the-loaded-trades-for-trade-parallelism","text":"This can be useful to find the best max_open_trades parameter, when used with backtesting in conjunction with --disable-max-market-positions . analyze_trade_parallelism() returns a timeseries dataframe with an \"open_trades\" column, specifying the number of open trades for each candle. ```python from freqtrade.data.btanalysis import analyze_trade_parallelism","title":"Analyze the loaded trades for trade parallelism"},{"location":"strategy_analysis_example/#analyze-the-above","text":"parallel_trades = analyze_trade_parallelism(trades, '5m') parallel_trades.plot() ```","title":"Analyze the above"},{"location":"strategy_analysis_example/#plot-results","text":"Freqtrade offers interactive plotting capabilities based on plotly. ```python from freqtrade.plot.plotting import generate_candlestick_graph","title":"Plot results"},{"location":"strategy_analysis_example/#limit-graph-period-to-keep-plotly-quick-and-reactive","text":"","title":"Limit graph period to keep plotly quick and reactive"},{"location":"strategy_analysis_example/#filter-trades-to-one-pair","text":"trades_red = trades.loc[trades['pair'] == pair] data_red = data['2019-06-01':'2019-06-10']","title":"Filter trades to one pair"},{"location":"strategy_analysis_example/#generate-candlestick-graph","text":"graph = generate_candlestick_graph(pair=pair, data=data_red, trades=trades_red, indicators1=['sma20', 'ema50', 'ema55'], indicators2=['rsi', 'macd', 'macdsignal', 'macdhist'] ) ``` ```python","title":"Generate candlestick graph"},{"location":"strategy_analysis_example/#show-graph-inline","text":"","title":"Show graph inline"},{"location":"strategy_analysis_example/#graphshow","text":"","title":"graph.show()"},{"location":"strategy_analysis_example/#render-graph-in-a-seperate-window","text":"graph.show(renderer=\"browser\") ```","title":"Render graph in a seperate window"},{"location":"strategy_analysis_example/#plot-average-profit-per-trade-as-distribution-graph","text":"```python import plotly.figure_factory as ff hist_data = [trades.profit_ratio] group_labels = ['profit_ratio'] # name of the dataset fig = ff.create_distplot(hist_data, group_labels,bin_size=0.01) fig.show() ``` Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Plot average profit per trade as distribution graph"},{"location":"telegram-usage/","text":"Telegram usage \u00b6 Setup your Telegram bot \u00b6 Below we explain how to create your Telegram Bot, and how to get your Telegram user id. 1. Create your Telegram bot \u00b6 Start a chat with the Telegram BotFather Send the message /newbot . BotFather response: Alright, a new bot. How are we going to call it? Please choose a name for your bot. Choose the public name of your bot (e.x. Freqtrade bot ) BotFather response: Good. Now let's choose a username for your bot. It must end in bot . Like this, for example: TetrisBot or tetris_bot. Choose the name id of your bot and send it to the BotFather (e.g. \" My_own_freqtrade_bot \") BotFather response: Done! Congratulations on your new bot. You will find it at t.me/yourbots_name_bot . You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this. Use this token to access the HTTP API: 22222222:APITOKEN For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key) Copy the API Token ( 22222222:APITOKEN in the above example) and keep use it for the config parameter token . Don't forget to start the conversation with your bot, by clicking /START button 2. Telegram user_id \u00b6 Get your user id \u00b6 Talk to the userinfobot Get your \"Id\", you will use it for the config parameter chat_id . Use Group id \u00b6 You can use bots in telegram groups by just adding them to the group. You can find the group id by first adding a RawDataBot to your group. The Group id is shown as id in the \"chat\" section, which the RawDataBot will send to you: json \"chat\":{ \"id\":-1001332619709 } For the Freqtrade configuration, you can then use the the full value (including - if it's there) as string: json \"chat_id\": \"-1001332619709\" Using telegram groups When using telegram groups, you're giving every member of the telegram group access to your freqtrade bot and to all commands possible via telegram. Please make sure that you can trust everyone in the telegram group to avoid unpleasent surprises. Control telegram noise \u00b6 Freqtrade provides means to control the verbosity of your telegram bot. Each setting has the following possible values: on - Messages will be sent, and user will be notified. silent - Message will be sent, Notification will be without sound / vibration. off - Skip sending a message-type all together. Example configuration showing the different settings: json \"telegram\": { \"enabled\": true, \"token\": \"your_telegram_token\", \"chat_id\": \"your_telegram_chat_id\", \"notification_settings\": { \"status\": \"silent\", \"warning\": \"on\", \"startup\": \"off\", \"buy\": \"silent\", \"sell\": { \"roi\": \"silent\", \"emergency_sell\": \"on\", \"force_sell\": \"on\", \"sell_signal\": \"silent\", \"trailing_stop_loss\": \"on\", \"stop_loss\": \"on\", \"stoploss_on_exchange\": \"on\", \"custom_sell\": \"silent\" }, \"buy_cancel\": \"silent\", \"sell_cancel\": \"on\", \"buy_fill\": \"off\", \"sell_fill\": \"off\", \"protection_trigger\": \"off\", \"protection_trigger_global\": \"on\" }, \"reload\": true, \"balance_dust_level\": 0.01 }, buy notifications are sent when the order is placed, while buy_fill notifications are sent when the order is filled on the exchange. sell notifications are sent when the order is placed, while sell_fill notifications are sent when the order is filled on the exchange. *_fill notifications are off by default and must be explicitly enabled. protection_trigger notifications are sent when a protection triggers and protection_trigger_global notifications trigger when global protections are triggered. balance_dust_level will define what the /balance command takes as \"dust\" - Currencies with a balance below this will be shown. reload allows you to disable reload-buttons on selected messages. Create a custom keyboard (command shortcut buttons) \u00b6 Telegram allows us to create a custom keyboard with buttons for commands. The default custom keyboard looks like this. python [ [\"/daily\", \"/profit\", \"/balance\"], # row 1, 3 commands [\"/status\", \"/status table\", \"/performance\"], # row 2, 3 commands [\"/count\", \"/start\", \"/stop\", \"/help\"] # row 3, 4 commands ] Usage \u00b6 You can create your own keyboard in config.json : json \"telegram\": { \"enabled\": true, \"token\": \"your_telegram_token\", \"chat_id\": \"your_telegram_chat_id\", \"keyboard\": [ [\"/daily\", \"/stats\", \"/balance\", \"/profit\"], [\"/status table\", \"/performance\"], [\"/reload_config\", \"/count\", \"/logs\"] ] }, Supported Commands Only the following commands are allowed. Command arguments are not supported! /start , /stop , /status , /status table , /trades , /profit , /performance , /daily , /stats , /count , /locks , /balance , /stopbuy , /reload_config , /show_config , /logs , /whitelist , /blacklist , /edge , /help , /version Telegram commands \u00b6 Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with /help . Command Description /start Starts the trader /stop Stops the trader /stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. /reload_config Reloads the configuration file /show_config Shows part of the current configuration with relevant settings to operation /logs [limit] Show last log messages. /status Lists all open trades /status <trade_id> Lists one or more specific trade. Separate multiple with a blank space. /status table List all open trades in a table format. Pending buy orders are marked with an asterisk ( ) Pending sell orders are marked with a double asterisk ( *) /trades [limit] List all recently closed trades in a table format. /delete <trade_id> Delete a specific trade from the Database. Tries to close open orders. Requires manual handling of this trade on the exchange. /count Displays number of trades used and available /locks Show currently locked pairs. /unlock <pair or lock_id> Remove the lock for this pair (or for this lock id). /profit [<n>] Display a summary of your profit/loss from close trades and some stats about your performance, over the last n days (all trades by default) /forcesell <trade_id> Instantly sells the given trade (Ignoring minimum_roi ). /forcesell all Instantly sells all open trades (Ignoring minimum_roi ). /forcebuy <pair> [rate] Instantly buys the given pair. Rate is optional and only applies to limit orders. ( forcebuy_enable must be set to True) /performance Show performance of each finished trade grouped by pair /balance Show account balance per currency /daily <n> Shows profit or loss per day, over the last n days (n defaults to 7) /weekly <n> Shows profit or loss per week, over the last n weeks (n defaults to 8) /monthly <n> Shows profit or loss per month, over the last n months (n defaults to 6) /stats Shows Wins / losses by Sell reason as well as Avg. holding durations for buys and sells /whitelist Show the current whitelist /blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. /edge Show validated pairs by Edge if it is enabled. /help Show help message /version Show version Telegram commands in action \u00b6 Below, example of Telegram message you will receive for each command. /start \u00b6 Status: running /stop \u00b6 Stopping trader ... Status: stopped /stopbuy \u00b6 status: Setting max_open_trades to 0. Run /reload_config to reset. Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...). After this, give the bot time to close off open trades (can be checked via /status table ). Once all positions are sold, run /stop to completely stop the bot. /reload_config resets \"max_open_trades\" to the value set in the configuration and resets this command. Warning The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset. /status \u00b6 For each open trade, the bot will send you the following message. Trade ID: 123 (since 1 days ago) Current Pair: CVC/BTC Open Since: 1 days ago Amount: 26.64180098 Open Rate: 0.00007489 Current Rate: 0.00007489 Current Profit: 12.95% Stoploss: 0.00007389 (-0.02%) /status table \u00b6 Return the status of all open trades in a table format. ``` ID Pair Since Profit 67 SC/BTC 1 d 13.33% 123 CVC/BTC 1 h 12.95% ``` /count \u00b6 Return the number of trades used and available. ``` current max 2 10 ``` /profit \u00b6 Return a summary of your profit/loss and performance. ROI: Close trades \u2219 0.00485701 BTC (2.2%) (15.2 \u03a3%) \u2219 62.968 USD ROI: All trades \u2219 0.00255280 BTC (1.5%) (6.43 \u03a3%) \u2219 33.095 EUR Total Trade Count: 138 First Trade opened: 3 days ago Latest Trade opened: 2 minutes ago Avg. Duration: 2:33:45 Best Performing: PAY/BTC: 50.23% The relative profit of 1.2% is the average profit per trade. The relative profit of 15.2 \u03a3% is be based on the starting capital - so in this case, the starting capital was 0.00485701 * 1.152 = 0.00738 BTC . Starting capital is either taken from the available_capital setting, or calculated by using current wallet size - profits. /forcesell \u00b6 BITTREX: Selling BTC/LTC with limit 0.01650000 (profit: ~-4.07%, -0.00008168) /forcebuy [rate] \u00b6 BITTREX: Buying ETH/BTC with limit 0.03400000 ( 1.000000 ETH , 225.290 USD ) Omitting the pair will open a query asking for the pair to buy (based on the current whitelist). Trades crated through /forcebuy will have the buy-tag of forceentry . Note that for this to work, forcebuy_enable needs to be set to true. More details /performance \u00b6 Return the performance of each crypto-currency the bot has sold. Performance: 1. RCN/BTC 0.003 BTC (57.77%) (1) 2. PAY/BTC 0.0012 BTC (56.91%) (1) 3. VIB/BTC 0.0011 BTC (47.07%) (1) 4. SALT/BTC 0.0010 BTC (30.24%) (1) 5. STORJ/BTC 0.0009 BTC (27.24%) (1) ... /balance \u00b6 Return the balance of all crypto-currency your have on the exchange. Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0 Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0 /daily \u00b6 Per default /daily will return the 7 last days. The example below if for /daily 3 : Daily Profit over the last 3 days: ``` Day Profit BTC Profit USD 2018-01-03 0.00224175 BTC 29,142 USD 2018-01-02 0.00033131 BTC 4,307 USD 2018-01-01 0.00269130 BTC 34.986 USD ``` /weekly \u00b6 Per default /weekly will return the 8 last weeks, including the current week. Each week starts from Monday. The example below if for /weekly 3 : Weekly Profit over the last 3 weeks (starting from Monday): ``` Monday Profit BTC Profit USD 2018-01-03 0.00224175 BTC 29,142 USD 2017-12-27 0.00033131 BTC 4,307 USD 2017-12-20 0.00269130 BTC 34.986 USD ``` /monthly \u00b6 Per default /monthly will return the 6 last months, including the current month. The example below if for /monthly 3 : Monthly Profit over the last 3 months: ``` Month Profit BTC Profit USD 2018-01 0.00224175 BTC 29,142 USD 2017-12 0.00033131 BTC 4,307 USD 2017-11 0.00269130 BTC 34.986 USD ``` /whitelist \u00b6 Shows the current whitelist Using whitelist StaticPairList with 22 pairs IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC /blacklist [pair] \u00b6 Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, separated by a space. Use /reload_config to reset the blacklist. Using blacklist StaticPairList with 2 pairs DODGE/BTC , HOT/BTC . /edge \u00b6 Shows pairs validated by Edge along with their corresponding win-rate, expectancy and stoploss values. Edge only validated following pairs: ``` Pair Winrate Expectancy Stoploss DOCK/ETH 0.522727 0.881821 -0.03 PHX/ETH 0.677419 0.560488 -0.03 HOT/ETH 0.733333 0.490492 -0.03 HC/ETH 0.588235 0.280988 -0.02 ARDR/ETH 0.366667 0.143059 -0.01 ``` /version \u00b6 Version: 0.14.3","title":"Telegram"},{"location":"telegram-usage/#telegram-usage","text":"","title":"Telegram usage"},{"location":"telegram-usage/#setup-your-telegram-bot","text":"Below we explain how to create your Telegram Bot, and how to get your Telegram user id.","title":"Setup your Telegram bot"},{"location":"telegram-usage/#1-create-your-telegram-bot","text":"Start a chat with the Telegram BotFather Send the message /newbot . BotFather response: Alright, a new bot. How are we going to call it? Please choose a name for your bot. Choose the public name of your bot (e.x. Freqtrade bot ) BotFather response: Good. Now let's choose a username for your bot. It must end in bot . Like this, for example: TetrisBot or tetris_bot. Choose the name id of your bot and send it to the BotFather (e.g. \" My_own_freqtrade_bot \") BotFather response: Done! Congratulations on your new bot. You will find it at t.me/yourbots_name_bot . You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this. Use this token to access the HTTP API: 22222222:APITOKEN For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key) Copy the API Token ( 22222222:APITOKEN in the above example) and keep use it for the config parameter token . Don't forget to start the conversation with your bot, by clicking /START button","title":"1. Create your Telegram bot"},{"location":"telegram-usage/#2-telegram-user_id","text":"","title":"2. Telegram user_id"},{"location":"telegram-usage/#get-your-user-id","text":"Talk to the userinfobot Get your \"Id\", you will use it for the config parameter chat_id .","title":"Get your user id"},{"location":"telegram-usage/#use-group-id","text":"You can use bots in telegram groups by just adding them to the group. You can find the group id by first adding a RawDataBot to your group. The Group id is shown as id in the \"chat\" section, which the RawDataBot will send to you: json \"chat\":{ \"id\":-1001332619709 } For the Freqtrade configuration, you can then use the the full value (including - if it's there) as string: json \"chat_id\": \"-1001332619709\" Using telegram groups When using telegram groups, you're giving every member of the telegram group access to your freqtrade bot and to all commands possible via telegram. Please make sure that you can trust everyone in the telegram group to avoid unpleasent surprises.","title":"Use Group id"},{"location":"telegram-usage/#control-telegram-noise","text":"Freqtrade provides means to control the verbosity of your telegram bot. Each setting has the following possible values: on - Messages will be sent, and user will be notified. silent - Message will be sent, Notification will be without sound / vibration. off - Skip sending a message-type all together. Example configuration showing the different settings: json \"telegram\": { \"enabled\": true, \"token\": \"your_telegram_token\", \"chat_id\": \"your_telegram_chat_id\", \"notification_settings\": { \"status\": \"silent\", \"warning\": \"on\", \"startup\": \"off\", \"buy\": \"silent\", \"sell\": { \"roi\": \"silent\", \"emergency_sell\": \"on\", \"force_sell\": \"on\", \"sell_signal\": \"silent\", \"trailing_stop_loss\": \"on\", \"stop_loss\": \"on\", \"stoploss_on_exchange\": \"on\", \"custom_sell\": \"silent\" }, \"buy_cancel\": \"silent\", \"sell_cancel\": \"on\", \"buy_fill\": \"off\", \"sell_fill\": \"off\", \"protection_trigger\": \"off\", \"protection_trigger_global\": \"on\" }, \"reload\": true, \"balance_dust_level\": 0.01 }, buy notifications are sent when the order is placed, while buy_fill notifications are sent when the order is filled on the exchange. sell notifications are sent when the order is placed, while sell_fill notifications are sent when the order is filled on the exchange. *_fill notifications are off by default and must be explicitly enabled. protection_trigger notifications are sent when a protection triggers and protection_trigger_global notifications trigger when global protections are triggered. balance_dust_level will define what the /balance command takes as \"dust\" - Currencies with a balance below this will be shown. reload allows you to disable reload-buttons on selected messages.","title":"Control telegram noise"},{"location":"telegram-usage/#create-a-custom-keyboard-command-shortcut-buttons","text":"Telegram allows us to create a custom keyboard with buttons for commands. The default custom keyboard looks like this. python [ [\"/daily\", \"/profit\", \"/balance\"], # row 1, 3 commands [\"/status\", \"/status table\", \"/performance\"], # row 2, 3 commands [\"/count\", \"/start\", \"/stop\", \"/help\"] # row 3, 4 commands ]","title":"Create a custom keyboard (command shortcut buttons)"},{"location":"telegram-usage/#usage","text":"You can create your own keyboard in config.json : json \"telegram\": { \"enabled\": true, \"token\": \"your_telegram_token\", \"chat_id\": \"your_telegram_chat_id\", \"keyboard\": [ [\"/daily\", \"/stats\", \"/balance\", \"/profit\"], [\"/status table\", \"/performance\"], [\"/reload_config\", \"/count\", \"/logs\"] ] }, Supported Commands Only the following commands are allowed. Command arguments are not supported! /start , /stop , /status , /status table , /trades , /profit , /performance , /daily , /stats , /count , /locks , /balance , /stopbuy , /reload_config , /show_config , /logs , /whitelist , /blacklist , /edge , /help , /version","title":"Usage"},{"location":"telegram-usage/#telegram-commands","text":"Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with /help . Command Description /start Starts the trader /stop Stops the trader /stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. /reload_config Reloads the configuration file /show_config Shows part of the current configuration with relevant settings to operation /logs [limit] Show last log messages. /status Lists all open trades /status <trade_id> Lists one or more specific trade. Separate multiple with a blank space. /status table List all open trades in a table format. Pending buy orders are marked with an asterisk ( ) Pending sell orders are marked with a double asterisk ( *) /trades [limit] List all recently closed trades in a table format. /delete <trade_id> Delete a specific trade from the Database. Tries to close open orders. Requires manual handling of this trade on the exchange. /count Displays number of trades used and available /locks Show currently locked pairs. /unlock <pair or lock_id> Remove the lock for this pair (or for this lock id). /profit [<n>] Display a summary of your profit/loss from close trades and some stats about your performance, over the last n days (all trades by default) /forcesell <trade_id> Instantly sells the given trade (Ignoring minimum_roi ). /forcesell all Instantly sells all open trades (Ignoring minimum_roi ). /forcebuy <pair> [rate] Instantly buys the given pair. Rate is optional and only applies to limit orders. ( forcebuy_enable must be set to True) /performance Show performance of each finished trade grouped by pair /balance Show account balance per currency /daily <n> Shows profit or loss per day, over the last n days (n defaults to 7) /weekly <n> Shows profit or loss per week, over the last n weeks (n defaults to 8) /monthly <n> Shows profit or loss per month, over the last n months (n defaults to 6) /stats Shows Wins / losses by Sell reason as well as Avg. holding durations for buys and sells /whitelist Show the current whitelist /blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. /edge Show validated pairs by Edge if it is enabled. /help Show help message /version Show version","title":"Telegram commands"},{"location":"telegram-usage/#telegram-commands-in-action","text":"Below, example of Telegram message you will receive for each command.","title":"Telegram commands in action"},{"location":"telegram-usage/#start","text":"Status: running","title":"/start"},{"location":"telegram-usage/#stop","text":"Stopping trader ... Status: stopped","title":"/stop"},{"location":"telegram-usage/#stopbuy","text":"status: Setting max_open_trades to 0. Run /reload_config to reset. Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...). After this, give the bot time to close off open trades (can be checked via /status table ). Once all positions are sold, run /stop to completely stop the bot. /reload_config resets \"max_open_trades\" to the value set in the configuration and resets this command. Warning The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset.","title":"/stopbuy"},{"location":"telegram-usage/#status","text":"For each open trade, the bot will send you the following message. Trade ID: 123 (since 1 days ago) Current Pair: CVC/BTC Open Since: 1 days ago Amount: 26.64180098 Open Rate: 0.00007489 Current Rate: 0.00007489 Current Profit: 12.95% Stoploss: 0.00007389 (-0.02%)","title":"/status"},{"location":"telegram-usage/#status-table","text":"Return the status of all open trades in a table format. ``` ID Pair Since Profit 67 SC/BTC 1 d 13.33% 123 CVC/BTC 1 h 12.95% ```","title":"/status table"},{"location":"telegram-usage/#count","text":"Return the number of trades used and available. ``` current max 2 10 ```","title":"/count"},{"location":"telegram-usage/#profit","text":"Return a summary of your profit/loss and performance. ROI: Close trades \u2219 0.00485701 BTC (2.2%) (15.2 \u03a3%) \u2219 62.968 USD ROI: All trades \u2219 0.00255280 BTC (1.5%) (6.43 \u03a3%) \u2219 33.095 EUR Total Trade Count: 138 First Trade opened: 3 days ago Latest Trade opened: 2 minutes ago Avg. Duration: 2:33:45 Best Performing: PAY/BTC: 50.23% The relative profit of 1.2% is the average profit per trade. The relative profit of 15.2 \u03a3% is be based on the starting capital - so in this case, the starting capital was 0.00485701 * 1.152 = 0.00738 BTC . Starting capital is either taken from the available_capital setting, or calculated by using current wallet size - profits.","title":"/profit"},{"location":"telegram-usage/#forcesell","text":"BITTREX: Selling BTC/LTC with limit 0.01650000 (profit: ~-4.07%, -0.00008168)","title":"/forcesell "},{"location":"telegram-usage/#forcebuy-rate","text":"BITTREX: Buying ETH/BTC with limit 0.03400000 ( 1.000000 ETH , 225.290 USD ) Omitting the pair will open a query asking for the pair to buy (based on the current whitelist). Trades crated through /forcebuy will have the buy-tag of forceentry . Note that for this to work, forcebuy_enable needs to be set to true. More details","title":"/forcebuy  [rate]"},{"location":"telegram-usage/#performance","text":"Return the performance of each crypto-currency the bot has sold. Performance: 1. RCN/BTC 0.003 BTC (57.77%) (1) 2. PAY/BTC 0.0012 BTC (56.91%) (1) 3. VIB/BTC 0.0011 BTC (47.07%) (1) 4. SALT/BTC 0.0010 BTC (30.24%) (1) 5. STORJ/BTC 0.0009 BTC (27.24%) (1) ...","title":"/performance"},{"location":"telegram-usage/#balance","text":"Return the balance of all crypto-currency your have on the exchange. Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0 Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0","title":"/balance"},{"location":"telegram-usage/#daily","text":"Per default /daily will return the 7 last days. The example below if for /daily 3 : Daily Profit over the last 3 days: ``` Day Profit BTC Profit USD 2018-01-03 0.00224175 BTC 29,142 USD 2018-01-02 0.00033131 BTC 4,307 USD 2018-01-01 0.00269130 BTC 34.986 USD ```","title":"/daily "},{"location":"telegram-usage/#weekly","text":"Per default /weekly will return the 8 last weeks, including the current week. Each week starts from Monday. The example below if for /weekly 3 : Weekly Profit over the last 3 weeks (starting from Monday): ``` Monday Profit BTC Profit USD 2018-01-03 0.00224175 BTC 29,142 USD 2017-12-27 0.00033131 BTC 4,307 USD 2017-12-20 0.00269130 BTC 34.986 USD ```","title":"/weekly "},{"location":"telegram-usage/#monthly","text":"Per default /monthly will return the 6 last months, including the current month. The example below if for /monthly 3 : Monthly Profit over the last 3 months: ``` Month Profit BTC Profit USD 2018-01 0.00224175 BTC 29,142 USD 2017-12 0.00033131 BTC 4,307 USD 2017-11 0.00269130 BTC 34.986 USD ```","title":"/monthly "},{"location":"telegram-usage/#whitelist","text":"Shows the current whitelist Using whitelist StaticPairList with 22 pairs IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC","title":"/whitelist"},{"location":"telegram-usage/#blacklist-pair","text":"Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, separated by a space. Use /reload_config to reset the blacklist. Using blacklist StaticPairList with 2 pairs DODGE/BTC , HOT/BTC .","title":"/blacklist [pair]"},{"location":"telegram-usage/#edge","text":"Shows pairs validated by Edge along with their corresponding win-rate, expectancy and stoploss values. Edge only validated following pairs: ``` Pair Winrate Expectancy Stoploss DOCK/ETH 0.522727 0.881821 -0.03 PHX/ETH 0.677419 0.560488 -0.03 HOT/ETH 0.733333 0.490492 -0.03 HC/ETH 0.588235 0.280988 -0.02 ARDR/ETH 0.366667 0.143059 -0.01 ```","title":"/edge"},{"location":"telegram-usage/#version","text":"Version: 0.14.3","title":"/version"},{"location":"updating/","text":"How to update \u00b6 To update your freqtrade installation, please use one of the below methods, corresponding to your installation method. docker-compose \u00b6 Legacy installations using the master image We're switching from master to stable for the release Images - please adjust your docker-file and replace freqtradeorg/freqtrade:master with freqtradeorg/freqtrade:stable bash docker-compose pull docker-compose up -d Installation via setup script \u00b6 bash ./setup.sh --update Note Make sure to run this command with your virtual environment disabled! Plain native installation \u00b6 Please ensure that you're also updating dependencies - otherwise things might break without you noticing. bash git pull pip install -U -r requirements.txt","title":"Updating Freqtrade"},{"location":"updating/#how-to-update","text":"To update your freqtrade installation, please use one of the below methods, corresponding to your installation method.","title":"How to update"},{"location":"updating/#docker-compose","text":"Legacy installations using the master image We're switching from master to stable for the release Images - please adjust your docker-file and replace freqtradeorg/freqtrade:master with freqtradeorg/freqtrade:stable bash docker-compose pull docker-compose up -d","title":"docker-compose"},{"location":"updating/#installation-via-setup-script","text":"bash ./setup.sh --update Note Make sure to run this command with your virtual environment disabled!","title":"Installation via setup script"},{"location":"updating/#plain-native-installation","text":"Please ensure that you're also updating dependencies - otherwise things might break without you noticing. bash git pull pip install -U -r requirements.txt","title":"Plain native installation"},{"location":"utils/","text":"Utility Subcommands \u00b6 Besides the Live-Trade and Dry-Run run modes, the backtesting , edge and hyperopt optimization subcommands, and the download-data subcommand which prepares historical data, the bot contains a number of utility subcommands. They are described in this section. Create userdir \u00b6 Creates the directory structure to hold your files for freqtrade. Will also create strategy and hyperopt examples for you to get started. Can be used multiple times - using --reset will reset the sample strategy and hyperopt files to their default state. ``` usage: freqtrade create-userdir [-h] [--userdir PATH] [--reset] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. --reset Reset sample files to their original state. ``` Warning Using --reset may result in loss of data, since this will overwrite all sample files without asking again. \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 hyperopts \u2502 \u251c\u2500\u2500 sample_hyperopt_loss.py \u251c\u2500\u2500 notebooks \u2502 \u2514\u2500\u2500 strategy_analysis_example.ipynb \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies \u2514\u2500\u2500 sample_strategy.py Create new config \u00b6 Creates a new configuration file, asking some questions which are important selections for a configuration. ``` usage: freqtrade new-config [-h] [-c PATH] optional arguments: -h, --help show this help message and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. ``` Warning Only vital questions are asked. Freqtrade offers a lot more configuration possibilities, which are listed in the Configuration documentation Create config examples \u00b6 ``` $ freqtrade new-config --config config_binance.json ? Do you want to enable Dry-run (simulated trades)? Yes ? Please insert your stake currency: BTC ? Please insert your stake amount: 0.05 ? Please insert max_open_trades (Integer or -1 for unlimited open trades): 3 ? Please insert your desired timeframe (e.g. 5m): 5m ? Please insert your display Currency (for reporting): USD ? Select exchange binance ? Do you want to enable Telegram? No ``` Create new strategy \u00b6 Creates a new strategy from a template similar to SampleStrategy. The file will be named inline with your class name, and will not overwrite existing files. Results will be located in user_data/strategies/<strategyclassname>.py . ``` output usage: freqtrade new-strategy [-h] [--userdir PATH] [-s NAME] [--template {full,minimal,advanced}] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --template {full,minimal,advanced} Use a template which is either minimal , full (containing multiple sample indicators) or advanced . Default: full . ``` Sample usage of new-strategy \u00b6 bash freqtrade new-strategy --strategy AwesomeStrategy With custom user directory bash freqtrade new-strategy --userdir ~/.freqtrade/ --strategy AwesomeStrategy Using the advanced template (populates all optional functions and methods) bash freqtrade new-strategy --strategy AwesomeStrategy --template advanced List Strategies \u00b6 Use the list-strategies subcommand to see all strategies in one particular directory. This subcommand is useful for finding problems in your environment with loading strategies: modules with strategies that contain errors and failed to load are printed in red (LOAD FAILED), while strategies with duplicate names are printed in yellow (DUPLICATE NAME). ``` usage: freqtrade list-strategies [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--strategy-path PATH] [-1] [--no-color] optional arguments: -h, --help show this help message and exit --strategy-path PATH Specify additional strategy lookup path. -1, --one-column Print output in one column. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Warning Using these commands will try to load all python files from a directory. This can be a security risk if untrusted files reside in this directory, since all module-level code is executed. Example: Search default strategies directories (within the default userdir). bash freqtrade list-strategies Example: Search strategies directory within the userdir. bash freqtrade list-strategies --userdir ~/.freqtrade/ Example: Search dedicated strategy path. bash freqtrade list-strategies --strategy-path ~/.freqtrade/strategies/ List Exchanges \u00b6 Use the list-exchanges subcommand to see the exchanges available for the bot. ``` usage: freqtrade list-exchanges [-h] [-1] [-a] optional arguments: -h, --help show this help message and exit -1, --one-column Print output in one column. -a, --all Print all exchanges known to the ccxt library. ``` Example: see exchanges available for the bot: ``` $ freqtrade list-exchanges Exchanges available for Freqtrade: Exchange name Valid reason aax True ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bitbank True missing opt: fetchTickers bitcoincom True bitfinex True bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitpanda True bittrex True bitvavo True bitz True missing opt: fetchMyTrades btcalpha True missing opt: fetchTicker, fetchTickers btcmarkets True missing opt: fetchTickers buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coinex True crex24 True deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers ftx True gateio True gemini True gopax True hbtc True hitbtc True huobijp True huobipro True idex True kraken True kucoin True lbank True missing opt: fetchMyTrades mercado True missing opt: fetchTickers ndax True missing opt: fetchTickers novadax True okcoin True okex True probit True qtrade True stex True timex True upbit True missing opt: fetchMyTrades vcc True zb True missing opt: fetchMyTrades ``` missing opt exchanges Values with \"missing opt:\" might need special configuration (e.g. using orderbook if fetchTickers is missing) - but should in theory work (although we cannot guarantee they will). Example: see all exchanges supported by the ccxt library (including 'bad' ones, i.e. those that are known to not work with Freqtrade): ``` $ freqtrade list-exchanges -a All exchanges supported by the ccxt library: Exchange name Valid reason aax True aofex False missing: fetchOrder ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bit2c False missing: fetchOrder, fetchOHLCV bitbank True missing opt: fetchTickers bitbay False missing: fetchOrder bitcoincom True bitfinex True bitfinex2 False missing: fetchOrder bitflyer False missing: fetchOrder, fetchOHLCV bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitmex False Various reasons. bitpanda True bitso False missing: fetchOHLCV bitstamp True missing opt: fetchTickers bitstamp1 False missing: fetchOrder, fetchOHLCV bittrex True bitvavo True bitz True missing opt: fetchMyTrades bl3p False missing: fetchOrder, fetchOHLCV bleutrade False missing: fetchOrder braziliex False missing: fetchOHLCV btcalpha True missing opt: fetchTicker, fetchTickers btcbox False missing: fetchOHLCV btcmarkets True missing opt: fetchTickers btctradeua False missing: fetchOrder, fetchOHLCV btcturk False missing: fetchOrder buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades chilebit False missing: fetchOrder, fetchOHLCV coinbase False missing: fetchOrder, cancelOrder, createOrder, fetchOHLCV coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coincheck False missing: fetchOrder, fetchOHLCV coinegg False missing: fetchOHLCV coinex True coinfalcon False missing: fetchOHLCV coinfloor False missing: fetchOrder, fetchOHLCV coingi False missing: fetchOrder, fetchOHLCV coinmarketcap False missing: fetchOrder, cancelOrder, createOrder, fetchBalance, fetchOHLCV coinmate False missing: fetchOHLCV coinone False missing: fetchOHLCV coinspot False missing: fetchOrder, cancelOrder, fetchOHLCV crex24 True currencycom False missing: fetchOrder delta False missing: fetchOrder deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True exmo False missing: fetchOrder exx False missing: fetchOHLCV fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers flowbtc False missing: fetchOrder, fetchOHLCV foxbit False missing: fetchOrder, fetchOHLCV ftx True gateio True gemini True gopax True hbtc True hitbtc True hollaex False missing: fetchOrder huobijp True huobipro True idex True independentreserve False missing: fetchOHLCV indodax False missing: fetchOHLCV itbit False missing: fetchOHLCV kraken True kucoin True kuna False missing: fetchOHLCV lakebtc False missing: fetchOrder, fetchOHLCV latoken False missing: fetchOrder, fetchOHLCV lbank True missing opt: fetchMyTrades liquid False missing: fetchOHLCV luno False missing: fetchOHLCV lykke False missing: fetchOHLCV mercado True missing opt: fetchTickers mixcoins False missing: fetchOrder, fetchOHLCV ndax True missing opt: fetchTickers novadax True oceanex False missing: fetchOHLCV okcoin True okex True paymium False missing: fetchOrder, fetchOHLCV phemex False Does not provide history. poloniex False missing: fetchOrder probit True qtrade True rightbtc False missing: fetchOrder ripio False missing: fetchOHLCV southxchange False missing: fetchOrder, fetchOHLCV stex True surbitcoin False missing: fetchOrder, fetchOHLCV therock False missing: fetchOHLCV tidebit False missing: fetchOrder tidex False missing: fetchOHLCV timex True upbit True missing opt: fetchMyTrades vbtc False missing: fetchOrder, fetchOHLCV vcc True wavesexchange False missing: fetchOrder whitebit False missing: fetchOrder, cancelOrder, createOrder, fetchBalance xbtce False missing: fetchOrder, fetchOHLCV xena False missing: fetchOrder yobit False missing: fetchOHLCV zaif False missing: fetchOrder, fetchOHLCV zb True missing opt: fetchMyTrades ``` List Timeframes \u00b6 Use the list-timeframes subcommand to see the list of timeframes available for the exchange. ``` usage: freqtrade list-timeframes [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [-1] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. -1, --one-column Print output in one column. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example: see the timeframes for the 'binance' exchange, set in the configuration file: $ freqtrade list-timeframes -c config_binance.json ... Timeframes available for the exchange `binance`: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M Example: enumerate exchanges available for Freqtrade and print timeframes supported by each of them: $ for i in `freqtrade list-exchanges -1`; do freqtrade list-timeframes --exchange $i; done List pairs/list markets \u00b6 The list-pairs and list-markets subcommands allow to see the pairs/markets available on exchange. Pairs are markets with the '/' character between the base currency part and the quote currency part in the market symbol. For example, in the 'ETH/BTC' pair 'ETH' is the base currency, while 'BTC' is the quote currency. For pairs traded by Freqtrade the pair quote currency is defined by the value of the stake_currency configuration setting. You can print info about any pair/market with these subcommands - and you can filter output by quote-currency using --quote BTC , or by base-currency using --base ETH options correspondingly. These subcommands have same usage and same set of available options: ``` usage: freqtrade list-markets [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] usage: freqtrade list-pairs [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --print-list Print list of pairs or market symbols. By default data is printed in the tabular format. --print-json Print list of pairs or market symbols in JSON format. -1, --one-column Print output in one column. --print-csv Print exchange pair or market data in the csv format. --base BASE_CURRENCY [BASE_CURRENCY ...] Specify base currency(-ies). Space-separated list. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -a, --all Print all pairs or market symbols. By default only active ones are shown. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` By default, only active pairs/markets are shown. Active pairs/markets are those that can currently be traded on the exchange. The see the list of all pairs/markets (not only the active ones), use the -a / -all option. Pairs/markets are sorted by its symbol string in the printed output. Examples \u00b6 Print the list of active pairs with quote currency USD on exchange, specified in the default configuration file (i.e. pairs on the \"Bittrex\" exchange) in JSON format: $ freqtrade list-pairs --quote USD --print-json Print the list of all pairs on the exchange, specified in the config_binance.json configuration file (i.e. on the \"Binance\" exchange) with base currencies BTC or ETH and quote currencies USDT or USD, as the human-readable list with summary: $ freqtrade list-pairs -c config_binance.json --all --base BTC ETH --quote USDT USD --print-list Print all markets on exchange \"Kraken\", in the tabular format: $ freqtrade list-markets --exchange kraken --all Test pairlist \u00b6 Use the test-pairlist subcommand to test the configuration of dynamic pairlists . Requires a configuration with specified pairlists attribute. Can be used to generate static pairlists to be used during backtesting / hyperopt. ``` usage: freqtrade test-pairlist [-h] [-v] [-c PATH] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-1] [--print-json] [--exchange EXCHANGE] optional arguments: -h, --help show this help message and exit -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -1, --one-column Print output in one column. --print-json Print list of pairs or market symbols in JSON format. --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. ``` Examples \u00b6 Show whitelist when using a dynamic pairlist . freqtrade test-pairlist --config config.json --quote USDT BTC Webserver mode \u00b6 Experimental Webserver mode is an experimental mode to increase backesting and strategy development productivity. There may still be bugs - so if you happen to stumble across these, please report them as github issues, thanks. Run freqtrade in webserver mode. Freqtrade will start the webserver and allow FreqUI to start and control backtesting processes. This has the advantage that data will not be reloaded between backtesting runs (as long as timeframe and timerange remain identical). FreqUI will also show the backtesting results. ``` usage: freqtrade webserver [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] optional arguments: -h, --help show this help message and exit Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Show previous Backtest results \u00b6 Allows you to show previous backtest results. Adding --show-pair-list outputs a sorted pair list you can easily copy/paste into your configuration (omitting bad pairs). Strategy overfitting Only using winning pairs can lead to an overfitted strategy, which will not work well on future data. Make sure to extensively test your strategy in dry-run before risking real money. ``` usage: freqtrade backtesting-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--show-pair-list] optional arguments: -h, --help show this help message and exit --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --show-pair-list Show backtesting pairlist sorted by profit. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` List Hyperopt results \u00b6 You can list the hyperoptimization epochs the Hyperopt module evaluated previously with the hyperopt-list sub-command. ``` usage: freqtrade hyperopt-list [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [--min-trades INT] [--max-trades INT] [--min-avg-time FLOAT] [--max-avg-time FLOAT] [--min-avg-profit FLOAT] [--max-avg-profit FLOAT] [--min-total-profit FLOAT] [--max-total-profit FLOAT] [--min-objective FLOAT] [--max-objective FLOAT] [--no-color] [--print-json] [--no-details] [--hyperopt-filename PATH] [--export-csv FILE] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. --min-trades INT Select epochs with more than INT trades. --max-trades INT Select epochs with less than INT trades. --min-avg-time FLOAT Select epochs above average time. --max-avg-time FLOAT Select epochs below average time. --min-avg-profit FLOAT Select epochs above average profit. --max-avg-profit FLOAT Select epochs below average profit. --min-total-profit FLOAT Select epochs above total profit. --max-total-profit FLOAT Select epochs below total profit. --min-objective FLOAT Select epochs above objective. --max-objective FLOAT Select epochs below objective. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. --no-details Do not print best epoch details. --hyperopt-filename FILENAME Hyperopt result filename.Example: --hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle --export-csv FILE Export to CSV-File. This will disable table print. Example: --export-csv hyperopt.csv Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Note hyperopt-list will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!). Examples \u00b6 List all results, print details of the best result at the end: freqtrade hyperopt-list List only epochs with positive profit. Do not print the details of the best epoch, so that the list can be iterated in a script: freqtrade hyperopt-list --profitable --no-details Show details of Hyperopt results \u00b6 You can show the details of any hyperoptimization epoch previously evaluated by the Hyperopt module with the hyperopt-show subcommand. ``` usage: freqtrade hyperopt-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [-n INT] [--print-json] [--hyperopt-filename FILENAME] [--no-header] [--disable-param-export] [--breakdown {day,week,month} [{day,week,month} ...]] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. -n INT, --index INT Specify the index of the epoch to print details for. --print-json Print output in JSON format. --hyperopt-filename FILENAME Hyperopt result filename.Example: --hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle --no-header Do not print epoch details header. --disable-param-export Disable automatic hyperopt parameter export. --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Note hyperopt-show will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!). Examples \u00b6 Print details for the epoch 168 (the number of the epoch is shown by the hyperopt-list subcommand or by Hyperopt itself during hyperoptimization run): freqtrade hyperopt-show -n 168 Prints JSON data with details for the last best epoch (i.e., the best of all epochs): freqtrade hyperopt-show --best -n -1 --print-json --no-header Show trades \u00b6 Print selected (or all) trades from database to screen. ``` usage: freqtrade show-trades [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--db-url PATH] [--trade-ids TRADE_IDS [TRADE_IDS ...]] [--print-json] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-ids TRADE_IDS [TRADE_IDS ...] Specify the list of trade ids. --print-json Print output in JSON format. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Examples \u00b6 Print trades with id 2 and 3 as json bash freqtrade show-trades --db-url sqlite:///tradesv3.sqlite --trade-ids 2 3 --print-json","title":"Utility Sub-commands"},{"location":"utils/#utility-subcommands","text":"Besides the Live-Trade and Dry-Run run modes, the backtesting , edge and hyperopt optimization subcommands, and the download-data subcommand which prepares historical data, the bot contains a number of utility subcommands. They are described in this section.","title":"Utility Subcommands"},{"location":"utils/#create-userdir","text":"Creates the directory structure to hold your files for freqtrade. Will also create strategy and hyperopt examples for you to get started. Can be used multiple times - using --reset will reset the sample strategy and hyperopt files to their default state. ``` usage: freqtrade create-userdir [-h] [--userdir PATH] [--reset] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. --reset Reset sample files to their original state. ``` Warning Using --reset may result in loss of data, since this will overwrite all sample files without asking again. \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 hyperopts \u2502 \u251c\u2500\u2500 sample_hyperopt_loss.py \u251c\u2500\u2500 notebooks \u2502 \u2514\u2500\u2500 strategy_analysis_example.ipynb \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies \u2514\u2500\u2500 sample_strategy.py","title":"Create userdir"},{"location":"utils/#create-new-config","text":"Creates a new configuration file, asking some questions which are important selections for a configuration. ``` usage: freqtrade new-config [-h] [-c PATH] optional arguments: -h, --help show this help message and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. ``` Warning Only vital questions are asked. Freqtrade offers a lot more configuration possibilities, which are listed in the Configuration documentation","title":"Create new config"},{"location":"utils/#create-config-examples","text":"``` $ freqtrade new-config --config config_binance.json ? Do you want to enable Dry-run (simulated trades)? Yes ? Please insert your stake currency: BTC ? Please insert your stake amount: 0.05 ? Please insert max_open_trades (Integer or -1 for unlimited open trades): 3 ? Please insert your desired timeframe (e.g. 5m): 5m ? Please insert your display Currency (for reporting): USD ? Select exchange binance ? Do you want to enable Telegram? No ```","title":"Create config examples"},{"location":"utils/#create-new-strategy","text":"Creates a new strategy from a template similar to SampleStrategy. The file will be named inline with your class name, and will not overwrite existing files. Results will be located in user_data/strategies/<strategyclassname>.py . ``` output usage: freqtrade new-strategy [-h] [--userdir PATH] [-s NAME] [--template {full,minimal,advanced}] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --template {full,minimal,advanced} Use a template which is either minimal , full (containing multiple sample indicators) or advanced . Default: full . ```","title":"Create new strategy"},{"location":"utils/#sample-usage-of-new-strategy","text":"bash freqtrade new-strategy --strategy AwesomeStrategy With custom user directory bash freqtrade new-strategy --userdir ~/.freqtrade/ --strategy AwesomeStrategy Using the advanced template (populates all optional functions and methods) bash freqtrade new-strategy --strategy AwesomeStrategy --template advanced","title":"Sample usage of new-strategy"},{"location":"utils/#list-strategies","text":"Use the list-strategies subcommand to see all strategies in one particular directory. This subcommand is useful for finding problems in your environment with loading strategies: modules with strategies that contain errors and failed to load are printed in red (LOAD FAILED), while strategies with duplicate names are printed in yellow (DUPLICATE NAME). ``` usage: freqtrade list-strategies [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--strategy-path PATH] [-1] [--no-color] optional arguments: -h, --help show this help message and exit --strategy-path PATH Specify additional strategy lookup path. -1, --one-column Print output in one column. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Warning Using these commands will try to load all python files from a directory. This can be a security risk if untrusted files reside in this directory, since all module-level code is executed. Example: Search default strategies directories (within the default userdir). bash freqtrade list-strategies Example: Search strategies directory within the userdir. bash freqtrade list-strategies --userdir ~/.freqtrade/ Example: Search dedicated strategy path. bash freqtrade list-strategies --strategy-path ~/.freqtrade/strategies/","title":"List Strategies"},{"location":"utils/#list-exchanges","text":"Use the list-exchanges subcommand to see the exchanges available for the bot. ``` usage: freqtrade list-exchanges [-h] [-1] [-a] optional arguments: -h, --help show this help message and exit -1, --one-column Print output in one column. -a, --all Print all exchanges known to the ccxt library. ``` Example: see exchanges available for the bot: ``` $ freqtrade list-exchanges Exchanges available for Freqtrade: Exchange name Valid reason aax True ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bitbank True missing opt: fetchTickers bitcoincom True bitfinex True bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitpanda True bittrex True bitvavo True bitz True missing opt: fetchMyTrades btcalpha True missing opt: fetchTicker, fetchTickers btcmarkets True missing opt: fetchTickers buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coinex True crex24 True deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers ftx True gateio True gemini True gopax True hbtc True hitbtc True huobijp True huobipro True idex True kraken True kucoin True lbank True missing opt: fetchMyTrades mercado True missing opt: fetchTickers ndax True missing opt: fetchTickers novadax True okcoin True okex True probit True qtrade True stex True timex True upbit True missing opt: fetchMyTrades vcc True zb True missing opt: fetchMyTrades ``` missing opt exchanges Values with \"missing opt:\" might need special configuration (e.g. using orderbook if fetchTickers is missing) - but should in theory work (although we cannot guarantee they will). Example: see all exchanges supported by the ccxt library (including 'bad' ones, i.e. those that are known to not work with Freqtrade): ``` $ freqtrade list-exchanges -a All exchanges supported by the ccxt library: Exchange name Valid reason aax True aofex False missing: fetchOrder ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bit2c False missing: fetchOrder, fetchOHLCV bitbank True missing opt: fetchTickers bitbay False missing: fetchOrder bitcoincom True bitfinex True bitfinex2 False missing: fetchOrder bitflyer False missing: fetchOrder, fetchOHLCV bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitmex False Various reasons. bitpanda True bitso False missing: fetchOHLCV bitstamp True missing opt: fetchTickers bitstamp1 False missing: fetchOrder, fetchOHLCV bittrex True bitvavo True bitz True missing opt: fetchMyTrades bl3p False missing: fetchOrder, fetchOHLCV bleutrade False missing: fetchOrder braziliex False missing: fetchOHLCV btcalpha True missing opt: fetchTicker, fetchTickers btcbox False missing: fetchOHLCV btcmarkets True missing opt: fetchTickers btctradeua False missing: fetchOrder, fetchOHLCV btcturk False missing: fetchOrder buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades chilebit False missing: fetchOrder, fetchOHLCV coinbase False missing: fetchOrder, cancelOrder, createOrder, fetchOHLCV coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coincheck False missing: fetchOrder, fetchOHLCV coinegg False missing: fetchOHLCV coinex True coinfalcon False missing: fetchOHLCV coinfloor False missing: fetchOrder, fetchOHLCV coingi False missing: fetchOrder, fetchOHLCV coinmarketcap False missing: fetchOrder, cancelOrder, createOrder, fetchBalance, fetchOHLCV coinmate False missing: fetchOHLCV coinone False missing: fetchOHLCV coinspot False missing: fetchOrder, cancelOrder, fetchOHLCV crex24 True currencycom False missing: fetchOrder delta False missing: fetchOrder deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True exmo False missing: fetchOrder exx False missing: fetchOHLCV fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers flowbtc False missing: fetchOrder, fetchOHLCV foxbit False missing: fetchOrder, fetchOHLCV ftx True gateio True gemini True gopax True hbtc True hitbtc True hollaex False missing: fetchOrder huobijp True huobipro True idex True independentreserve False missing: fetchOHLCV indodax False missing: fetchOHLCV itbit False missing: fetchOHLCV kraken True kucoin True kuna False missing: fetchOHLCV lakebtc False missing: fetchOrder, fetchOHLCV latoken False missing: fetchOrder, fetchOHLCV lbank True missing opt: fetchMyTrades liquid False missing: fetchOHLCV luno False missing: fetchOHLCV lykke False missing: fetchOHLCV mercado True missing opt: fetchTickers mixcoins False missing: fetchOrder, fetchOHLCV ndax True missing opt: fetchTickers novadax True oceanex False missing: fetchOHLCV okcoin True okex True paymium False missing: fetchOrder, fetchOHLCV phemex False Does not provide history. poloniex False missing: fetchOrder probit True qtrade True rightbtc False missing: fetchOrder ripio False missing: fetchOHLCV southxchange False missing: fetchOrder, fetchOHLCV stex True surbitcoin False missing: fetchOrder, fetchOHLCV therock False missing: fetchOHLCV tidebit False missing: fetchOrder tidex False missing: fetchOHLCV timex True upbit True missing opt: fetchMyTrades vbtc False missing: fetchOrder, fetchOHLCV vcc True wavesexchange False missing: fetchOrder whitebit False missing: fetchOrder, cancelOrder, createOrder, fetchBalance xbtce False missing: fetchOrder, fetchOHLCV xena False missing: fetchOrder yobit False missing: fetchOHLCV zaif False missing: fetchOrder, fetchOHLCV zb True missing opt: fetchMyTrades ```","title":"List Exchanges"},{"location":"utils/#list-timeframes","text":"Use the list-timeframes subcommand to see the list of timeframes available for the exchange. ``` usage: freqtrade list-timeframes [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [-1] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. -1, --one-column Print output in one column. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Example: see the timeframes for the 'binance' exchange, set in the configuration file: $ freqtrade list-timeframes -c config_binance.json ... Timeframes available for the exchange `binance`: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M Example: enumerate exchanges available for Freqtrade and print timeframes supported by each of them: $ for i in `freqtrade list-exchanges -1`; do freqtrade list-timeframes --exchange $i; done","title":"List Timeframes"},{"location":"utils/#list-pairslist-markets","text":"The list-pairs and list-markets subcommands allow to see the pairs/markets available on exchange. Pairs are markets with the '/' character between the base currency part and the quote currency part in the market symbol. For example, in the 'ETH/BTC' pair 'ETH' is the base currency, while 'BTC' is the quote currency. For pairs traded by Freqtrade the pair quote currency is defined by the value of the stake_currency configuration setting. You can print info about any pair/market with these subcommands - and you can filter output by quote-currency using --quote BTC , or by base-currency using --base ETH options correspondingly. These subcommands have same usage and same set of available options: ``` usage: freqtrade list-markets [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] usage: freqtrade list-pairs [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. --print-list Print list of pairs or market symbols. By default data is printed in the tabular format. --print-json Print list of pairs or market symbols in JSON format. -1, --one-column Print output in one column. --print-csv Print exchange pair or market data in the csv format. --base BASE_CURRENCY [BASE_CURRENCY ...] Specify base currency(-ies). Space-separated list. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -a, --all Print all pairs or market symbols. By default only active ones are shown. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: config.json ). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` By default, only active pairs/markets are shown. Active pairs/markets are those that can currently be traded on the exchange. The see the list of all pairs/markets (not only the active ones), use the -a / -all option. Pairs/markets are sorted by its symbol string in the printed output.","title":"List pairs/list markets"},{"location":"utils/#examples","text":"Print the list of active pairs with quote currency USD on exchange, specified in the default configuration file (i.e. pairs on the \"Bittrex\" exchange) in JSON format: $ freqtrade list-pairs --quote USD --print-json Print the list of all pairs on the exchange, specified in the config_binance.json configuration file (i.e. on the \"Binance\" exchange) with base currencies BTC or ETH and quote currencies USDT or USD, as the human-readable list with summary: $ freqtrade list-pairs -c config_binance.json --all --base BTC ETH --quote USDT USD --print-list Print all markets on exchange \"Kraken\", in the tabular format: $ freqtrade list-markets --exchange kraken --all","title":"Examples"},{"location":"utils/#test-pairlist","text":"Use the test-pairlist subcommand to test the configuration of dynamic pairlists . Requires a configuration with specified pairlists attribute. Can be used to generate static pairlists to be used during backtesting / hyperopt. ``` usage: freqtrade test-pairlist [-h] [-v] [-c PATH] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-1] [--print-json] [--exchange EXCHANGE] optional arguments: -h, --help show this help message and exit -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -1, --one-column Print output in one column. --print-json Print list of pairs or market symbols in JSON format. --exchange EXCHANGE Exchange name (default: bittrex ). Only valid if no config is provided. ```","title":"Test pairlist"},{"location":"utils/#examples_1","text":"Show whitelist when using a dynamic pairlist . freqtrade test-pairlist --config config.json --quote USDT BTC","title":"Examples"},{"location":"utils/#webserver-mode","text":"Experimental Webserver mode is an experimental mode to increase backesting and strategy development productivity. There may still be bugs - so if you happen to stumble across these, please report them as github issues, thanks. Run freqtrade in webserver mode. Freqtrade will start the webserver and allow FreqUI to start and control backtesting processes. This has the advantage that data will not be reloaded between backtesting runs (as long as timeframe and timerange remain identical). FreqUI will also show the backtesting results. ``` usage: freqtrade webserver [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] optional arguments: -h, --help show this help message and exit Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Webserver mode"},{"location":"utils/#show-previous-backtest-results","text":"Allows you to show previous backtest results. Adding --show-pair-list outputs a sorted pair list you can easily copy/paste into your configuration (omitting bad pairs). Strategy overfitting Only using winning pairs can lead to an overfitted strategy, which will not work well on future data. Make sure to extensively test your strategy in dry-run before risking real money. ``` usage: freqtrade backtesting-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--show-pair-list] optional arguments: -h, --help show this help message and exit --export-filename PATH Save backtest results to the file with this filename. Requires --export to be set as well. Example: --export-filename=user_data/backtest_results/backtest _today.json --show-pair-list Show backtesting pairlist sorted by profit. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Show previous Backtest results"},{"location":"utils/#list-hyperopt-results","text":"You can list the hyperoptimization epochs the Hyperopt module evaluated previously with the hyperopt-list sub-command. ``` usage: freqtrade hyperopt-list [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [--min-trades INT] [--max-trades INT] [--min-avg-time FLOAT] [--max-avg-time FLOAT] [--min-avg-profit FLOAT] [--max-avg-profit FLOAT] [--min-total-profit FLOAT] [--max-total-profit FLOAT] [--min-objective FLOAT] [--max-objective FLOAT] [--no-color] [--print-json] [--no-details] [--hyperopt-filename PATH] [--export-csv FILE] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. --min-trades INT Select epochs with more than INT trades. --max-trades INT Select epochs with less than INT trades. --min-avg-time FLOAT Select epochs above average time. --max-avg-time FLOAT Select epochs below average time. --min-avg-profit FLOAT Select epochs above average profit. --max-avg-profit FLOAT Select epochs below average profit. --min-total-profit FLOAT Select epochs above total profit. --max-total-profit FLOAT Select epochs below total profit. --min-objective FLOAT Select epochs above objective. --max-objective FLOAT Select epochs below objective. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. --no-details Do not print best epoch details. --hyperopt-filename FILENAME Hyperopt result filename.Example: --hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle --export-csv FILE Export to CSV-File. This will disable table print. Example: --export-csv hyperopt.csv Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Note hyperopt-list will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!).","title":"List Hyperopt results"},{"location":"utils/#examples_2","text":"List all results, print details of the best result at the end: freqtrade hyperopt-list List only epochs with positive profit. Do not print the details of the best epoch, so that the list can be iterated in a script: freqtrade hyperopt-list --profitable --no-details","title":"Examples"},{"location":"utils/#show-details-of-hyperopt-results","text":"You can show the details of any hyperoptimization epoch previously evaluated by the Hyperopt module with the hyperopt-show subcommand. ``` usage: freqtrade hyperopt-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [-n INT] [--print-json] [--hyperopt-filename FILENAME] [--no-header] [--disable-param-export] [--breakdown {day,week,month} [{day,week,month} ...]] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. -n INT, --index INT Specify the index of the epoch to print details for. --print-json Print output in JSON format. --hyperopt-filename FILENAME Hyperopt result filename.Example: --hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle --no-header Do not print epoch details header. --disable-param-export Disable automatic hyperopt parameter export. --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ``` Note hyperopt-show will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!).","title":"Show details of Hyperopt results"},{"location":"utils/#examples_3","text":"Print details for the epoch 168 (the number of the epoch is shown by the hyperopt-list subcommand or by Hyperopt itself during hyperoptimization run): freqtrade hyperopt-show -n 168 Prints JSON data with details for the last best epoch (i.e., the best of all epochs): freqtrade hyperopt-show --best -n -1 --print-json --no-header","title":"Examples"},{"location":"utils/#show-trades","text":"Print selected (or all) trades from database to screen. ``` usage: freqtrade show-trades [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--db-url PATH] [--trade-ids TRADE_IDS [TRADE_IDS ...]] [--print-json] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: sqlite:///tradesv3.sqlite for Live Run mode, sqlite:///tradesv3.dryrun.sqlite for Dry Run). --trade-ids TRADE_IDS [TRADE_IDS ...] Specify the list of trade ids. --print-json Print output in JSON format. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: userdir/config.json or config.json whichever exists). Multiple --config options may be used. Can be set to - to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. ```","title":"Show trades"},{"location":"utils/#examples_4","text":"Print trades with id 2 and 3 as json bash freqtrade show-trades --db-url sqlite:///tradesv3.sqlite --trade-ids 2 3 --print-json","title":"Examples"},{"location":"webhook-config/","text":"Webhook usage \u00b6 Configuration \u00b6 Enable webhooks by adding a webhook-section to your configuration file, and setting webhook.enabled to true . Sample configuration (tested using IFTTT). json \"webhook\": { \"enabled\": true, \"url\": \"https://maker.ifttt.com/trigger/<YOUREVENT>/with/key/<YOURKEY>/\", \"webhookbuy\": { \"value1\": \"Buying {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"{stake_amount:8f} {stake_currency}\" }, \"webhookbuycancel\": { \"value1\": \"Cancelling Open Buy Order for {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"{stake_amount:8f} {stake_currency}\" }, \"webhookbuyfill\": { \"value1\": \"Buy Order for {pair} filled\", \"value2\": \"at {open_rate:8f}\", \"value3\": \"\" }, \"webhooksell\": { \"value1\": \"Selling {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhooksellcancel\": { \"value1\": \"Cancelling Open Sell Order for {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhooksellfill\": { \"value1\": \"Sell Order for {pair} filled\", \"value2\": \"at {close_rate:8f}.\", \"value3\": \"\" }, \"webhookstatus\": { \"value1\": \"Status: {status}\", \"value2\": \"\", \"value3\": \"\" } }, The url in webhook.url should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert your event and key to the url. You can set the POST body format to Form-Encoded (default), JSON-Encoded, or raw data. Use \"format\": \"form\" , \"format\": \"json\" , or \"format\": \"raw\" respectively. Example configuration for Mattermost Cloud integration: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURSUBDOMAIN>.cloud.mattermost.com/hooks/<YOURHOOK>\", \"format\": \"json\", \"webhookstatus\": { \"text\": \"Status: {status}\" } }, The result would be a POST request with e.g. {\"text\":\"Status: running\"} body and Content-Type: application/json header which results Status: running message in the Mattermost channel. When using the Form-Encoded or JSON-Encoded configuration you can configure any number of payload values, and both the key and value will be ouput in the POST request. However, when using the raw data format you can only configure one value and it must be named \"data\" . In this instance the data key will not be output in the POST request, only the value. For example: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURHOOKURL>\", \"format\": \"raw\", \"webhookstatus\": { \"data\": \"Status: {status}\" } }, The result would be a POST request with e.g. Status: running body and Content-Type: text/plain header. Optional parameters are available to enable automatic retries for webhook messages. The webhook.retries parameter can be set for the maximum number of retries the webhook request should attempt if it is unsuccessful (i.e. HTTP response status is not 200). By default this is set to 0 which is disabled. An additional webhook.retry_delay parameter can be set to specify the time in seconds between retry attempts. By default this is set to 0.1 (i.e. 100ms). Note that increasing the number of retries or retry delay may slow down the trader if there are connectivity issues with the webhook. Example configuration for retries: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURHOOKURL>\", \"retries\": 3, \"retry_delay\": 0.2, \"webhookstatus\": { \"status\": \"Status: {status}\" } }, Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called. Webhookbuy \u00b6 The fields in webhook.webhookbuy are filled when the bot executes a buy. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair limit # Deprecated - should no longer be used. open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag Webhookbuycancel \u00b6 The fields in webhook.webhookbuycancel are filled when the bot cancels a buy order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair limit amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag Webhookbuyfill \u00b6 The fields in webhook.webhookbuyfill are filled when the bot filled a buy order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag Webhooksell \u00b6 The fields in webhook.webhooksell are filled when the bot sells a trade. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain limit amount open_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date Webhooksellfill \u00b6 The fields in webhook.webhooksellfill are filled when the bot fills a sell order (closes a Trae). Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain close_rate amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date Webhooksellcancel \u00b6 The fields in webhook.webhooksellcancel are filled when the bot cancels a sell order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain limit amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date Webhookstatus \u00b6 The fields in webhook.webhookstatus are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format. The only possible value here is {status} .","title":"Web Hook"},{"location":"webhook-config/#webhook-usage","text":"","title":"Webhook usage"},{"location":"webhook-config/#configuration","text":"Enable webhooks by adding a webhook-section to your configuration file, and setting webhook.enabled to true . Sample configuration (tested using IFTTT). json \"webhook\": { \"enabled\": true, \"url\": \"https://maker.ifttt.com/trigger/<YOUREVENT>/with/key/<YOURKEY>/\", \"webhookbuy\": { \"value1\": \"Buying {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"{stake_amount:8f} {stake_currency}\" }, \"webhookbuycancel\": { \"value1\": \"Cancelling Open Buy Order for {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"{stake_amount:8f} {stake_currency}\" }, \"webhookbuyfill\": { \"value1\": \"Buy Order for {pair} filled\", \"value2\": \"at {open_rate:8f}\", \"value3\": \"\" }, \"webhooksell\": { \"value1\": \"Selling {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhooksellcancel\": { \"value1\": \"Cancelling Open Sell Order for {pair}\", \"value2\": \"limit {limit:8f}\", \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhooksellfill\": { \"value1\": \"Sell Order for {pair} filled\", \"value2\": \"at {close_rate:8f}.\", \"value3\": \"\" }, \"webhookstatus\": { \"value1\": \"Status: {status}\", \"value2\": \"\", \"value3\": \"\" } }, The url in webhook.url should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert your event and key to the url. You can set the POST body format to Form-Encoded (default), JSON-Encoded, or raw data. Use \"format\": \"form\" , \"format\": \"json\" , or \"format\": \"raw\" respectively. Example configuration for Mattermost Cloud integration: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURSUBDOMAIN>.cloud.mattermost.com/hooks/<YOURHOOK>\", \"format\": \"json\", \"webhookstatus\": { \"text\": \"Status: {status}\" } }, The result would be a POST request with e.g. {\"text\":\"Status: running\"} body and Content-Type: application/json header which results Status: running message in the Mattermost channel. When using the Form-Encoded or JSON-Encoded configuration you can configure any number of payload values, and both the key and value will be ouput in the POST request. However, when using the raw data format you can only configure one value and it must be named \"data\" . In this instance the data key will not be output in the POST request, only the value. For example: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURHOOKURL>\", \"format\": \"raw\", \"webhookstatus\": { \"data\": \"Status: {status}\" } }, The result would be a POST request with e.g. Status: running body and Content-Type: text/plain header. Optional parameters are available to enable automatic retries for webhook messages. The webhook.retries parameter can be set for the maximum number of retries the webhook request should attempt if it is unsuccessful (i.e. HTTP response status is not 200). By default this is set to 0 which is disabled. An additional webhook.retry_delay parameter can be set to specify the time in seconds between retry attempts. By default this is set to 0.1 (i.e. 100ms). Note that increasing the number of retries or retry delay may slow down the trader if there are connectivity issues with the webhook. Example configuration for retries: json \"webhook\": { \"enabled\": true, \"url\": \"https://<YOURHOOKURL>\", \"retries\": 3, \"retry_delay\": 0.2, \"webhookstatus\": { \"status\": \"Status: {status}\" } }, Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called.","title":"Configuration"},{"location":"webhook-config/#webhookbuy","text":"The fields in webhook.webhookbuy are filled when the bot executes a buy. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair limit # Deprecated - should no longer be used. open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag","title":"Webhookbuy"},{"location":"webhook-config/#webhookbuycancel","text":"The fields in webhook.webhookbuycancel are filled when the bot cancels a buy order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair limit amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag","title":"Webhookbuycancel"},{"location":"webhook-config/#webhookbuyfill","text":"The fields in webhook.webhookbuyfill are filled when the bot filled a buy order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate buy_tag","title":"Webhookbuyfill"},{"location":"webhook-config/#webhooksell","text":"The fields in webhook.webhooksell are filled when the bot sells a trade. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain limit amount open_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date","title":"Webhooksell"},{"location":"webhook-config/#webhooksellfill","text":"The fields in webhook.webhooksellfill are filled when the bot fills a sell order (closes a Trae). Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain close_rate amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date","title":"Webhooksellfill"},{"location":"webhook-config/#webhooksellcancel","text":"The fields in webhook.webhooksellcancel are filled when the bot cancels a sell order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair gain limit amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency sell_reason order_type open_date close_date","title":"Webhooksellcancel"},{"location":"webhook-config/#webhookstatus","text":"The fields in webhook.webhookstatus are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format. The only possible value here is {status} .","title":"Webhookstatus"},{"location":"windows_installation/","text":"Windows installation \u00b6 We strongly recommend that Windows users use Docker as this will work much easier and smoother (also more secure). If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. Otherwise, try the instructions below. Install freqtrade manually \u00b6 Note Make sure to use 64bit Windows and 64bit Python to avoid problems with backtesting or hyperopt due to the memory constraints 32bit applications have under Windows. Hint Using the Anaconda Distribution under Windows can greatly help with installation problems. Check out the Anaconda installation section in this document for more information. 1. Clone the git repository \u00b6 bash git clone https://github.com/freqtrade/freqtrade.git 2. Install ta-lib \u00b6 Install ta-lib according to the ta-lib documentation . As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), there is also a repository of unofficial pre-compiled windows Wheels here , which need to be downloaded and installed using pip install TA_Lib-0.4.24-cp38-cp38-win_amd64.whl (make sure to use the version matching your python version). Freqtrade provides these dependencies for the latest 3 Python versions (3.8, 3.9 and 3.10) and for 64bit Windows. Other versions must be downloaded from the above link. ``` powershell cd \\path\\freqtrade python -m venv .env .env\\Scripts\\activate.ps1 optionally install ta-lib from wheel \u00b6 Eventually adjust the below filename to match the downloaded wheel \u00b6 pip install build_helpers/TA_Lib-0.4.19-cp38-cp38-win_amd64.whl pip install -r requirements.txt pip install -e . freqtrade ``` Use Powershell The above installation script assumes you're using powershell on a 64bit windows. Commands for the legacy CMD windows console may differ. Thanks Owdr for the commands. Source: Issue #222 Error during installation on Windows \u00b6 bash error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools Unfortunately, many packages requiring compilation don't provide a pre-built wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use. You can download the Visual C++ build tools from here and install \"Desktop development with C++\" in it's default configuration. Unfortunately, this is a heavy download / dependency so you might want to consider WSL2 or docker compose first.","title":"Windows"},{"location":"windows_installation/#windows-installation","text":"We strongly recommend that Windows users use Docker as this will work much easier and smoother (also more secure). If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. Otherwise, try the instructions below.","title":"Windows installation"},{"location":"windows_installation/#install-freqtrade-manually","text":"Note Make sure to use 64bit Windows and 64bit Python to avoid problems with backtesting or hyperopt due to the memory constraints 32bit applications have under Windows. Hint Using the Anaconda Distribution under Windows can greatly help with installation problems. Check out the Anaconda installation section in this document for more information.","title":"Install freqtrade manually"},{"location":"windows_installation/#1-clone-the-git-repository","text":"bash git clone https://github.com/freqtrade/freqtrade.git","title":"1. Clone the git repository"},{"location":"windows_installation/#2-install-ta-lib","text":"Install ta-lib according to the ta-lib documentation . As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), there is also a repository of unofficial pre-compiled windows Wheels here , which need to be downloaded and installed using pip install TA_Lib-0.4.24-cp38-cp38-win_amd64.whl (make sure to use the version matching your python version). Freqtrade provides these dependencies for the latest 3 Python versions (3.8, 3.9 and 3.10) and for 64bit Windows. Other versions must be downloaded from the above link. ``` powershell cd \\path\\freqtrade python -m venv .env .env\\Scripts\\activate.ps1","title":"2. Install ta-lib"},{"location":"windows_installation/#optionally-install-ta-lib-from-wheel","text":"","title":"optionally install ta-lib from wheel"},{"location":"windows_installation/#eventually-adjust-the-below-filename-to-match-the-downloaded-wheel","text":"pip install build_helpers/TA_Lib-0.4.19-cp38-cp38-win_amd64.whl pip install -r requirements.txt pip install -e . freqtrade ``` Use Powershell The above installation script assumes you're using powershell on a 64bit windows. Commands for the legacy CMD windows console may differ. Thanks Owdr for the commands. Source: Issue #222","title":"Eventually adjust the below filename to match the downloaded wheel"},{"location":"windows_installation/#error-during-installation-on-windows","text":"bash error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools Unfortunately, many packages requiring compilation don't provide a pre-built wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use. You can download the Visual C++ build tools from here and install \"Desktop development with C++\" in it's default configuration. Unfortunately, this is a heavy download / dependency so you might want to consider WSL2 or docker compose first.","title":"Error during installation on Windows"},{"location":"includes/pairlists/","text":"Pairlists and Pairlist Handlers \u00b6 Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist. Pair blacklist \u00b6 The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!) Available Pairlist Handlers \u00b6 StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly. Static Pair List \u00b6 By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . json \"pairlists\": [ {\"method\": \"StaticPairList\"} ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist. Volume Pair List \u00b6 VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange. VolumePairList Advanced mode \u00b6 VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 3600, \"lookback_timeframe\": \"1h\", \"lookback_period\": 72 } ], Note VolumePairList does not support backtesting mode. AgeFilter \u00b6 Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed . OffsetFilter \u00b6 Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist: json \"pairlists\": [ // ... { \"method\": \"OffsetFilter\", \"offset\": 10 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger then the total length of the incoming pairlist will result in an empty pairlist. PerformanceFilter \u00b6 Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. json \"pairlists\": [ // ... { \"method\": \"PerformanceFilter\", \"minutes\": 1440, // rolling 24h \"min_profit\": 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode. PrecisionFilter \u00b6 Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies. PriceFilter \u00b6 The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding. ShuffleFilter \u00b6 Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set. SpreadFilter \u00b6 Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out. RangeStabilityFilter \u00b6 Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. json \"pairlists\": [ { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"max_rate_of_change\": 0.99, \"refresh_period\": 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time. VolatilityFilter \u00b6 Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. json \"pairlists\": [ { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 } ] Full example of Pairlist Handlers \u00b6 The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. json \"exchange\": { \"pair_whitelist\": [], \"pair_blacklist\": [\"BNB/BTC\"] }, \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\" }, {\"method\": \"AgeFilter\", \"min_days_listed\": 10}, {\"method\": \"PrecisionFilter\"}, {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01}, {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005}, { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"refresh_period\": 1440 }, { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 }, {\"method\": \"ShuffleFilter\", \"seed\": 42} ],","title":"Pairlists"},{"location":"includes/pairlists/#pairlists-and-pairlist-handlers","text":"Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist.","title":"Pairlists and Pairlist Handlers"},{"location":"includes/pairlists/#pair-blacklist","text":"The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!)","title":"Pair blacklist"},{"location":"includes/pairlists/#available-pairlist-handlers","text":"StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly.","title":"Available Pairlist Handlers"},{"location":"includes/pairlists/#static-pair-list","text":"By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . json \"pairlists\": [ {\"method\": \"StaticPairList\"} ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist.","title":"Static Pair List"},{"location":"includes/pairlists/#volume-pair-list","text":"VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange.","title":"Volume Pair List"},{"location":"includes/pairlists/#volumepairlist-advanced-mode","text":"VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 86400, \"lookback_days\": 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: json \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\", \"min_value\": 0, \"refresh_period\": 3600, \"lookback_timeframe\": \"1h\", \"lookback_period\": 72 } ], Note VolumePairList does not support backtesting mode.","title":"VolumePairList Advanced mode"},{"location":"includes/pairlists/#agefilter","text":"Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed .","title":"AgeFilter"},{"location":"includes/pairlists/#offsetfilter","text":"Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist: json \"pairlists\": [ // ... { \"method\": \"OffsetFilter\", \"offset\": 10 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger then the total length of the incoming pairlist will result in an empty pairlist.","title":"OffsetFilter"},{"location":"includes/pairlists/#performancefilter","text":"Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. json \"pairlists\": [ // ... { \"method\": \"PerformanceFilter\", \"minutes\": 1440, // rolling 24h \"min_profit\": 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode.","title":"PerformanceFilter"},{"location":"includes/pairlists/#precisionfilter","text":"Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies.","title":"PrecisionFilter"},{"location":"includes/pairlists/#pricefilter","text":"The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.","title":"PriceFilter"},{"location":"includes/pairlists/#shufflefilter","text":"Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set.","title":"ShuffleFilter"},{"location":"includes/pairlists/#spreadfilter","text":"Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out.","title":"SpreadFilter"},{"location":"includes/pairlists/#rangestabilityfilter","text":"Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. json \"pairlists\": [ { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"max_rate_of_change\": 0.99, \"refresh_period\": 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.","title":"RangeStabilityFilter"},{"location":"includes/pairlists/#volatilityfilter","text":"Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. json \"pairlists\": [ { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 } ]","title":"VolatilityFilter"},{"location":"includes/pairlists/#full-example-of-pairlist-handlers","text":"The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. json \"exchange\": { \"pair_whitelist\": [], \"pair_blacklist\": [\"BNB/BTC\"] }, \"pairlists\": [ { \"method\": \"VolumePairList\", \"number_assets\": 20, \"sort_key\": \"quoteVolume\" }, {\"method\": \"AgeFilter\", \"min_days_listed\": 10}, {\"method\": \"PrecisionFilter\"}, {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01}, {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005}, { \"method\": \"RangeStabilityFilter\", \"lookback_days\": 10, \"min_rate_of_change\": 0.01, \"refresh_period\": 1440 }, { \"method\": \"VolatilityFilter\", \"lookback_days\": 10, \"min_volatility\": 0.05, \"max_volatility\": 0.50, \"refresh_period\": 86400 }, {\"method\": \"ShuffleFilter\", \"seed\": 42} ],","title":"Full example of Pairlist Handlers"},{"location":"includes/pricing/","text":"Prices used for orders \u00b6 Prices for regular orders can be controlled via the parameter structures bid_strategy for buying and ask_strategy for selling. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders. Buy price \u00b6 Check depth of market \u00b6 When check depth of market is enabled ( bid_strategy.check_depth_of_market.enabled=True ), the buy signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the bid_strategy.check_depth_of_market.bids_to_ask_delta parameter. The buy order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side). Buy price side \u00b6 The configuration setting bid_strategy.price_side defines the side of the spread the bot looks for when buying. The following displays an orderbook. explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If bid_strategy.price_side is set to \"bid\" , then the bot will use 99 as buying price. In line with that, if bid_strategy.price_side is set to \"ask\" , then the bot will use 101 as buying price. Using ask price often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"ask\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price). Buy price with Orderbook enabled \u00b6 When buying with the orderbook enabled ( bid_strategy.use_order_book=True ), Freqtrade fetches the bid_strategy.order_book_top entries from the orderbook and uses the entry specified as bid_strategy.order_book_top on the configured side ( bid_strategy.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Buy price without Orderbook enabled \u00b6 The following section uses side as the configured bid_strategy.price_side (defaults to \"bid\" ). When not using orderbook ( bid_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on bid_strategy.ask_last_balance .. The bid_strategy.ask_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price. Sell price \u00b6 Sell price side \u00b6 The configuration setting ask_strategy.price_side defines the side of the spread the bot looks for when selling. The following displays an orderbook: explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If ask_strategy.price_side is set to \"ask\" , then the bot will use 101 as selling price. In line with that, if ask_strategy.price_side is set to \"bid\" , then the bot will use 99 as selling price. Sell price with Orderbook enabled \u00b6 When selling with the orderbook enabled ( ask_strategy.use_order_book=True ), Freqtrade fetches the ask_strategy.order_book_top entries in the orderbook and uses the entry specified as ask_strategy.order_book_top from the configured side ( ask_strategy.price_side ) as selling price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Sell price without Orderbook enabled \u00b6 The following section uses side as the configured ask_strategy.price_side (defaults to \"ask\" ). When not using orderbook ( ask_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on ask_strategy.bid_last_balance . The ask_strategy.bid_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price. Market order pricing \u00b6 When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both buy and sell are using market orders, a configuration similar to the following might be used jsonc \"order_types\": { \"buy\": \"market\", \"sell\": \"market\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Pricing"},{"location":"includes/pricing/#prices-used-for-orders","text":"Prices for regular orders can be controlled via the parameter structures bid_strategy for buying and ask_strategy for selling. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders.","title":"Prices used for orders"},{"location":"includes/pricing/#buy-price","text":"","title":"Buy price"},{"location":"includes/pricing/#check-depth-of-market","text":"When check depth of market is enabled ( bid_strategy.check_depth_of_market.enabled=True ), the buy signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the bid_strategy.check_depth_of_market.bids_to_ask_delta parameter. The buy order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).","title":"Check depth of market"},{"location":"includes/pricing/#buy-price-side","text":"The configuration setting bid_strategy.price_side defines the side of the spread the bot looks for when buying. The following displays an orderbook. explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If bid_strategy.price_side is set to \"bid\" , then the bot will use 99 as buying price. In line with that, if bid_strategy.price_side is set to \"ask\" , then the bot will use 101 as buying price. Using ask price often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"ask\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).","title":"Buy price side"},{"location":"includes/pricing/#buy-price-with-orderbook-enabled","text":"When buying with the orderbook enabled ( bid_strategy.use_order_book=True ), Freqtrade fetches the bid_strategy.order_book_top entries from the orderbook and uses the entry specified as bid_strategy.order_book_top on the configured side ( bid_strategy.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Buy price with Orderbook enabled"},{"location":"includes/pricing/#buy-price-without-orderbook-enabled","text":"The following section uses side as the configured bid_strategy.price_side (defaults to \"bid\" ). When not using orderbook ( bid_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on bid_strategy.ask_last_balance .. The bid_strategy.ask_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price.","title":"Buy price without Orderbook enabled"},{"location":"includes/pricing/#sell-price","text":"","title":"Sell price"},{"location":"includes/pricing/#sell-price-side","text":"The configuration setting ask_strategy.price_side defines the side of the spread the bot looks for when selling. The following displays an orderbook: explanation ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If ask_strategy.price_side is set to \"ask\" , then the bot will use 101 as selling price. In line with that, if ask_strategy.price_side is set to \"bid\" , then the bot will use 99 as selling price.","title":"Sell price side"},{"location":"includes/pricing/#sell-price-with-orderbook-enabled","text":"When selling with the orderbook enabled ( ask_strategy.use_order_book=True ), Freqtrade fetches the ask_strategy.order_book_top entries in the orderbook and uses the entry specified as ask_strategy.order_book_top from the configured side ( ask_strategy.price_side ) as selling price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Sell price with Orderbook enabled"},{"location":"includes/pricing/#sell-price-without-orderbook-enabled","text":"The following section uses side as the configured ask_strategy.price_side (defaults to \"ask\" ). When not using orderbook ( ask_strategy.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on ask_strategy.bid_last_balance . The ask_strategy.bid_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price.","title":"Sell price without Orderbook enabled"},{"location":"includes/pricing/#market-order-pricing","text":"When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both buy and sell are using market orders, a configuration similar to the following might be used jsonc \"order_types\": { \"buy\": \"market\", \"sell\": \"market\" // ... }, \"bid_strategy\": { \"price_side\": \"ask\", // ... }, \"ask_strategy\":{ \"price_side\": \"bid\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Market order pricing"},{"location":"includes/protections/","text":"Protections \u00b6 Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property . Available Protections \u00b6 StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade. Common settings to all Protections \u00b6 Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition. Stoploss Guard \u00b6 StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. python @property def protections(self): return [ { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 4, \"only_per_pair\": False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy. MaxDrawdown \u00b6 MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. python @property def protections(self): return [ { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 12, \"max_allowed_drawdown\": 0.2 }, ] Low Profit Pairs \u00b6 LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. python @property def protections(self): return [ { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration\": 60, \"required_profit\": 0.02 } ] Cooldown Period \u00b6 CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". python @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade. Full example of Protections \u00b6 All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. ``` python from freqtrade.strategy import IStrategy class AwesomeStrategy(IStrategy) timeframe = '1h' @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 5 }, { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 4, \"max_allowed_drawdown\": 0.2 }, { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"only_per_pair\": False }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration_candles\": 60, \"required_profit\": 0.02 }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"required_profit\": 0.01 } ] # ... ```","title":"Protections"},{"location":"includes/protections/#protections","text":"Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property .","title":"Protections"},{"location":"includes/protections/#available-protections","text":"StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade.","title":"Available Protections"},{"location":"includes/protections/#common-settings-to-all-protections","text":"Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.","title":"Common settings to all Protections"},{"location":"includes/protections/#stoploss-guard","text":"StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. python @property def protections(self): return [ { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 4, \"only_per_pair\": False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy.","title":"Stoploss Guard"},{"location":"includes/protections/#maxdrawdown","text":"MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. python @property def protections(self): return [ { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 12, \"max_allowed_drawdown\": 0.2 }, ]","title":"MaxDrawdown"},{"location":"includes/protections/#low-profit-pairs","text":"LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. python @property def protections(self): return [ { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration\": 60, \"required_profit\": 0.02 } ]","title":"Low Profit Pairs"},{"location":"includes/protections/#cooldown-period","text":"CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". python @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade.","title":"Cooldown Period"},{"location":"includes/protections/#full-example-of-protections","text":"All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. ``` python from freqtrade.strategy import IStrategy class AwesomeStrategy(IStrategy) timeframe = '1h' @property def protections(self): return [ { \"method\": \"CooldownPeriod\", \"stop_duration_candles\": 5 }, { \"method\": \"MaxDrawdown\", \"lookback_period_candles\": 48, \"trade_limit\": 20, \"stop_duration_candles\": 4, \"max_allowed_drawdown\": 0.2 }, { \"method\": \"StoplossGuard\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"only_per_pair\": False }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 6, \"trade_limit\": 2, \"stop_duration_candles\": 60, \"required_profit\": 0.02 }, { \"method\": \"LowProfitPairs\", \"lookback_period_candles\": 24, \"trade_limit\": 4, \"stop_duration_candles\": 2, \"required_profit\": 0.01 } ] # ... ```","title":"Full example of Protections"}]}