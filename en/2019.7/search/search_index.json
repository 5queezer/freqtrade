{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Freqtrade","text":"<p>Star</p> <p>Fork</p> <p>Download</p> <p>Follow @freqtrade</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Freqtrade is a cryptocurrency trading bot written in Python.</p> <p>DISCLAIMER</p> <p>This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</p> <p>Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect.</p> <p>We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Based on Python 3.6+: For botting on any operating system \u2014 Windows, macOS and Linux.</li> <li>Persistence: Persistence is achieved through sqlite database.</li> <li>Dry-run mode: Run the bot without playing money.</li> <li>Backtesting: Run a simulation of your buy/sell strategy with historical data.</li> <li>Strategy Optimization by machine learning: Use machine learning to optimize your buy/sell strategy parameters with real exchange data.</li> <li>Edge position sizing: Calculate your win rate, risk reward ratio, the best stoploss and adjust your position size before taking a position for each specific market.</li> <li>Whitelist crypto-currencies: Select which crypto-currency you want to trade or use dynamic whitelists based on market (pair) trade volume.</li> <li>Blacklist crypto-currencies: Select which crypto-currency you want to avoid.</li> <li>Manageable via Telegram or REST APi: Manage the bot with Telegram or via the builtin REST API.</li> <li>Display profit/loss in fiat: Display your profit/loss in any of 33 fiat currencies supported.</li> <li>Daily summary of profit/loss: Receive the daily summary of your profit/loss.</li> <li>Performance status report: Receive the performance status of your current trades.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#up-to-date-clock","title":"Up to date clock","text":"<p>The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.</p>"},{"location":"#hardware-requirements","title":"Hardware requirements","text":"<p>To run this bot we recommend you a cloud instance with a minimum of:</p> <ul> <li>2GB RAM</li> <li>1GB disk space</li> <li>2vCPU</li> </ul>"},{"location":"#software-requirements","title":"Software requirements","text":"<ul> <li>Python 3.6.x</li> <li>pip (pip3)</li> <li>git</li> <li>TA-Lib</li> <li>virtualenv (Recommended)</li> <li>Docker (Recommended)</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Help / Slack For any questions not covered by the documentation or for further information about the bot, we encourage you to join our Slack channel.</p> <p>Click here to join Slack channel.</p>"},{"location":"#ready-to-try","title":"Ready to try?","text":"<p>Begin by reading our installation guide here.</p>"},{"location":"backtesting/","title":"Backtesting","text":"<p>This page explains how to validate your strategy performance by using Backtesting.</p>"},{"location":"backtesting/#test-your-strategy-with-backtesting","title":"Test your strategy with Backtesting","text":"<p>Now you have good Buy and Sell strategies, you want to test it against real data. This is what we call backtesting.</p> <p>Backtesting will use the crypto-currencies (pair) from your config file and load static tickers located in /freqtrade/tests/testdata. If the 5 min and 1 min ticker for the crypto-currencies to test is not already in the <code>testdata</code> directory, backtesting will download them automatically. Testdata files will not be updated until you specify it.</p> <p>The result of backtesting will confirm you if your bot has better odds of making a profit than a loss.</p> <p>The backtesting is very easy with freqtrade.</p>"},{"location":"backtesting/#run-a-backtesting-against-the-currencies-listed-in-your-config-file","title":"Run a backtesting against the currencies listed in your config file","text":""},{"location":"backtesting/#with-5-min-tickers-per-default","title":"With 5 min tickers (Per default)","text":"<pre><code>freqtrade backtesting\n</code></pre>"},{"location":"backtesting/#with-1-min-tickers","title":"With 1 min tickers","text":"<pre><code>freqtrade backtesting --ticker-interval 1m\n</code></pre>"},{"location":"backtesting/#update-cached-pairs-with-the-latest-data","title":"Update cached pairs with the latest data","text":"<pre><code>freqtrade backtesting --refresh-pairs-cached\n</code></pre>"},{"location":"backtesting/#with-live-data-do-not-alter-your-testdata-files","title":"With live data (do not alter your testdata files)","text":"<pre><code>freqtrade backtesting --live\n</code></pre>"},{"location":"backtesting/#using-a-different-on-disk-ticker-data-source","title":"Using a different on-disk ticker-data source","text":"<pre><code>freqtrade backtesting --datadir freqtrade/tests/testdata-20180101\n</code></pre>"},{"location":"backtesting/#with-a-custom-strategy-file","title":"With a (custom) strategy file","text":"<pre><code>freqtrade -s TestStrategy backtesting\n</code></pre> <p>Where <code>-s TestStrategy</code> refers to the class name within the strategy file <code>test_strategy.py</code> found in the <code>freqtrade/user_data/strategies</code> directory</p>"},{"location":"backtesting/#exporting-trades-to-file","title":"Exporting trades to file","text":"<pre><code>freqtrade backtesting --export trades\n</code></pre> <p>The exported trades can be used for further analysis, or can be used by the plotting script <code>plot_dataframe.py</code> in the scripts directory.</p>"},{"location":"backtesting/#exporting-trades-to-file-specifying-a-custom-filename","title":"Exporting trades to file specifying a custom filename","text":"<pre><code>freqtrade backtesting --export trades --export-filename=backtest_teststrategy.json\n</code></pre>"},{"location":"backtesting/#running-backtest-with-smaller-testset","title":"Running backtest with smaller testset","text":"<p>Use the <code>--timerange</code> argument to change how much of the testset you want to use. The last N ticks/timeframes will be used.</p> <p>Example:</p> <pre><code>freqtrade backtesting --timerange=-200\n</code></pre>"},{"location":"backtesting/#advanced-use-of-timerange","title":"Advanced use of timerange","text":"<p>Doing <code>--timerange=-200</code> will get the last 200 timeframes from your inputdata. You can also specify specific dates, or a range span indexed by start and stop.</p> <p>The full timerange specification:</p> <ul> <li>Use last 123 tickframes of data: <code>--timerange=-123</code></li> <li>Use first 123 tickframes of data: <code>--timerange=123-</code></li> <li>Use tickframes from line 123 through 456: <code>--timerange=123-456</code></li> <li>Use tickframes till 2018/01/31: <code>--timerange=-20180131</code></li> <li>Use tickframes since 2018/01/31: <code>--timerange=20180131-</code></li> <li>Use tickframes since 2018/01/31 till 2018/03/01 : <code>--timerange=20180131-20180301</code></li> <li>Use tickframes between POSIX timestamps 1527595200 1527618600:                                                 <code>--timerange=1527595200-1527618600</code></li> </ul>"},{"location":"backtesting/#downloading-new-set-of-ticker-data","title":"Downloading new set of ticker data","text":"<p>To download new set of backtesting ticker data, you can use a download script.</p> <p>If you are using Binance for example:</p> <ul> <li>create a directory <code>user_data/data/binance</code> and copy <code>pairs.json</code> in that directory.</li> <li>update the <code>pairs.json</code> to contain the currency pairs you are interested in.</li> </ul> <pre><code>mkdir -p user_data/data/binance\ncp freqtrade/tests/testdata/pairs.json user_data/data/binance\n</code></pre> <p>Then run:</p> <pre><code>python scripts/download_backtest_data.py --exchange binance\n</code></pre> <p>This will download ticker data for all the currency pairs you defined in <code>pairs.json</code>.</p> <ul> <li>To use a different directory than the exchange specific default, use <code>--datadir user_data/data/some_directory</code>.</li> <li>To change the exchange used to download the tickers, use <code>--exchange</code>. Default is <code>bittrex</code>.</li> <li>To use <code>pairs.json</code> from some other directory, use <code>--pairs-file some_other_dir/pairs.json</code>.</li> <li>To download ticker data for only 10 days, use <code>--days 10</code>.</li> <li>Use <code>--timeframes</code> to specify which tickers to download. Default is <code>--timeframes 1m 5m</code> which will download 1-minute and 5-minute tickers.</li> <li>To use exchange, timeframe and list of pairs as defined in your configuration file, use the <code>-c/--config</code> option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine <code>-c/--config</code> with other options.</li> </ul> <p>For help about backtesting usage, please refer to Backtesting commands.</p>"},{"location":"backtesting/#understand-the-backtesting-result","title":"Understand the backtesting result","text":"<p>The most important in the backtesting is to understand the result.</p> <p>A backtesting result will look like that:</p> <pre><code>========================================================= BACKTESTING REPORT ========================================================\n| pair     |   buy count |   avg profit % |   cum profit % |   tot profit BTC |   tot profit % | avg duration   |   profit |   loss |\n|:---------|------------:|---------------:|---------------:|-----------------:|---------------:|:---------------|---------:|-------:|\n| ADA/BTC  |          35 |          -0.11 |          -3.88 |      -0.00019428 |          -1.94 | 4:35:00        |       14 |     21 |\n| ARK/BTC  |          11 |          -0.41 |          -4.52 |      -0.00022647 |          -2.26 | 2:03:00        |        3 |      8 |\n| BTS/BTC  |          32 |           0.31 |           9.78 |       0.00048938 |           4.89 | 5:05:00        |       18 |     14 |\n| DASH/BTC |          13 |          -0.08 |          -1.07 |      -0.00005343 |          -0.53 | 4:39:00        |        6 |      7 |\n| ENG/BTC  |          18 |           1.36 |          24.54 |       0.00122807 |          12.27 | 2:50:00        |        8 |     10 |\n| EOS/BTC  |          36 |           0.08 |           3.06 |       0.00015304 |           1.53 | 3:34:00        |       16 |     20 |\n| ETC/BTC  |          26 |           0.37 |           9.51 |       0.00047576 |           4.75 | 6:14:00        |       11 |     15 |\n| ETH/BTC  |          33 |           0.30 |           9.96 |       0.00049856 |           4.98 | 7:31:00        |       16 |     17 |\n| IOTA/BTC |          32 |           0.03 |           1.09 |       0.00005444 |           0.54 | 3:12:00        |       14 |     18 |\n| LSK/BTC  |          15 |           1.75 |          26.26 |       0.00131413 |          13.13 | 2:58:00        |        6 |      9 |\n| LTC/BTC  |          32 |          -0.04 |          -1.38 |      -0.00006886 |          -0.69 | 4:49:00        |       11 |     21 |\n| NANO/BTC |          17 |           1.26 |          21.39 |       0.00107058 |          10.70 | 1:55:00        |       10 |      7 |\n| NEO/BTC  |          23 |           0.82 |          18.97 |       0.00094936 |           9.48 | 2:59:00        |       10 |     13 |\n| REQ/BTC  |           9 |           1.17 |          10.54 |       0.00052734 |           5.27 | 3:47:00        |        4 |      5 |\n| XLM/BTC  |          16 |           1.22 |          19.54 |       0.00097800 |           9.77 | 3:15:00        |        7 |      9 |\n| XMR/BTC  |          23 |          -0.18 |          -4.13 |      -0.00020696 |          -2.07 | 5:30:00        |       12 |     11 |\n| XRP/BTC  |          35 |           0.66 |          22.96 |       0.00114897 |          11.48 | 3:49:00        |       12 |     23 |\n| ZEC/BTC  |          22 |          -0.46 |         -10.18 |      -0.00050971 |          -5.09 | 2:22:00        |        7 |     15 |\n| TOTAL    |         429 |           0.36 |         152.41 |       0.00762792 |          76.20 | 4:12:00        |      186 |    243 |\n========================================================= SELL REASON STATS =========================================================\n| Sell Reason        |   Count |\n|:-------------------|--------:|\n| trailing_stop_loss |     205 |\n| stop_loss          |     166 |\n| sell_signal        |      56 |\n| force_sell         |       2 |\n====================================================== LEFT OPEN TRADES REPORT ======================================================\n| pair     |   buy count |   avg profit % |   cum profit % |   tot profit BTC |   tot profit % | avg duration   |   profit |   loss |\n|:---------|------------:|---------------:|---------------:|-----------------:|---------------:|:---------------|---------:|-------:|\n| ADA/BTC  |           1 |           0.89 |           0.89 |       0.00004434 |           0.44 | 6:00:00        |        1 |      0 |\n| LTC/BTC  |           1 |           0.68 |           0.68 |       0.00003421 |           0.34 | 2:00:00        |        1 |      0 |\n| TOTAL    |           2 |           0.78 |           1.57 |       0.00007855 |           0.78 | 4:00:00        |        2 |      0 |\n</code></pre> <p>The 1<sup>st</sup> table will contain all trades the bot made.</p> <p>The 2<sup>nd</sup> table will contain a recap of sell reasons.</p> <p>The 3<sup>rd</sup> table will contain all trades the bot had to <code>forcesell</code> at the end of the backtest period to present a full picture. These trades are also included in the first table, but are extracted separately for clarity.</p> <p>The last line will give you the overall performance of your strategy, here:</p> <pre><code>| TOTAL    |         429 |           0.36 |         152.41 |       0.00762792 |          76.20 | 4:12:00        |      186 |    243 |\n</code></pre> <p>We understand the bot has made <code>429</code> trades for an average duration of <code>4:12:00</code>, with a performance of <code>76.20%</code> (profit), that means it has earned a total of <code>0.00762792 BTC</code> starting with a capital of 0.01 BTC.</p> <p>The column <code>avg profit %</code> shows the average profit for all trades made while the column <code>cum profit %</code> sums all the profits/losses.  The column <code>tot profit %</code> shows instead the total profit % in relation to allocated capital  (<code>max_open_trades * stake_amount</code>). In the above results we have <code>max_open_trades=2 stake_amount=0.005</code> in config  so <code>(76.20/100) * (0.005 * 2) =~ 0.00762792 BTC</code>.</p> <p>As you will see your strategy performance will be influenced by your buy strategy, your sell strategy, and also by the <code>minimal_roi</code> and <code>stop_loss</code> you have set.</p> <p>As for an example if your minimal_roi is only <code>\"0\":  0.01</code>. You cannot expect the bot to make more profit than 1% (because it will sell every time a trade will reach 1%).</p> <pre><code>\"minimal_roi\": {\n    \"0\":  0.01\n},\n</code></pre> <p>On the other hand, if you set a too high <code>minimal_roi</code> like <code>\"0\":  0.55</code> (55%), there is a lot of chance that the bot will never reach this profit. Hence, keep in mind that your performance is a mix of your strategies, your configuration, and the crypto-currency you have set up.</p>"},{"location":"backtesting/#further-backtest-result-analysis","title":"Further backtest-result analysis","text":"<p>To further analyze your backtest results, you can export the trades. You can then load the trades to perform further analysis as shown in our data analysis backtesting section.</p>"},{"location":"backtesting/#backtesting-multiple-strategies","title":"Backtesting multiple strategies","text":"<p>To backtest multiple strategies, a list of Strategies can be provided.</p> <p>This is limited to 1 ticker-interval per run, however, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this should give a nice runtime boost.</p> <p>All listed Strategies need to be in the same directory.</p> <pre><code>freqtrade backtesting --timerange 20180401-20180410 --ticker-interval 5m --strategy-list Strategy001 Strategy002 --export trades\n</code></pre> <p>This will save the results to <code>user_data/backtest_data/backtest-result-&lt;strategy&gt;.json</code>, injecting the strategy-name into the target filename. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up.</p> <pre><code>=========================================================== Strategy Summary ===========================================================\n| Strategy    |   buy count |   avg profit % |   cum profit % |   tot profit BTC |   tot profit % | avg duration   |   profit |   loss |\n|:------------|------------:|---------------:|---------------:|-----------------:|---------------:|:---------------|---------:|-------:|\n| Strategy1   |         429 |           0.36 |         152.41 |       0.00762792 |          76.20 | 4:12:00        |      186 |    243 |\n| Strategy2   |        1487 |          -0.13 |        -197.58 |      -0.00988917 |         -98.79 | 4:43:00        |      662 |    825 |\n</code></pre>"},{"location":"backtesting/#next-step","title":"Next step","text":"<p>Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt</p>"},{"location":"bot-usage/","title":"Start the bot","text":"<p>This page explains the different parameters of the bot and how to run it.</p> <p>!Note:     If you've used <code>setup.sh</code>, don't forget to activate your virtual environment (<code>source .env/bin/activate</code>) before running freqtrade commands.</p>"},{"location":"bot-usage/#bot-commands","title":"Bot commands","text":"<pre><code>usage: freqtrade [-h] [-v] [--logfile FILE] [--version] [-c PATH] [-d PATH]\n                 [-s NAME] [--strategy-path PATH] [--db-url PATH]\n                 [--sd-notify]\n                 {backtesting,edge,hyperopt} ...\n\nFree, open source crypto trading bot\n\npositional arguments:\n  {backtesting,edge,hyperopt}\n    backtesting         Backtesting module.\n    edge                Edge module.\n    hyperopt            Hyperopt module.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default: None). Multiple\n                        --config options may be used. Can be set to '-' to\n                        read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to backtest data.\n  -s NAME, --strategy NAME\n                        Specify strategy class name (default:\n                        DefaultStrategy).\n  --strategy-path PATH  Specify additional strategy lookup path.\n  --db-url PATH         Override trades database URL, this is useful if\n                        dry_run is enabled or in custom deployments (default:\n                        None).\n  --sd-notify           Notify systemd service manager.\n</code></pre>"},{"location":"bot-usage/#how-to-use-a-different-configuration-file","title":"How to use a different configuration file?","text":"<p>The bot allows you to select which configuration file you want to use. Per default, the bot will load the file <code>./config.json</code></p> <pre><code>freqtrade -c path/far/far/away/config.json\n</code></pre>"},{"location":"bot-usage/#how-to-use-multiple-configuration-files","title":"How to use multiple configuration files?","text":"<p>The bot allows you to use multiple configuration files by specifying multiple <code>-c/--config</code> configuration options in the command line. Configuration parameters defined in the last configuration file override parameters with the same name defined in the previous configuration file specified in the command line.</p> <p>For example, you can make a separate configuration file with your key and secrete for the Exchange you use for trading, specify default configuration file with empty key and secrete values while running in the Dry Mode (which does not actually require them):</p> <pre><code>freqtrade -c ./config.json\n</code></pre> <p>and specify both configuration files when running in the normal Live Trade Mode:</p> <pre><code>freqtrade -c ./config.json -c path/to/secrets/keys.config.json\n</code></pre> <p>This could help you hide your private Exchange key and Exchange secrete on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet.</p> <p>See more details on this technique with examples in the documentation page on configuration.</p>"},{"location":"bot-usage/#how-to-use-strategy","title":"How to use --strategy?","text":"<p>This parameter will allow you to load your custom strategy class. Per default without <code>--strategy</code> or <code>-s</code> the bot will load the <code>DefaultStrategy</code> included with the bot (<code>freqtrade/strategy/default_strategy.py</code>).</p> <p>The bot will search your strategy file within <code>user_data/strategies</code> and <code>freqtrade/strategy</code>.</p> <p>To load a strategy, simply pass the class name (e.g.: <code>CustomStrategy</code>) in this parameter.</p> <p>Example: In <code>user_data/strategies</code> you have a file <code>my_awesome_strategy.py</code> which has a strategy class called <code>AwesomeStrategy</code> to load it:</p> <pre><code>freqtrade --strategy AwesomeStrategy\n</code></pre> <p>If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code).</p> <p>Learn more about strategy file in Strategy Customization.</p>"},{"location":"bot-usage/#how-to-use-strategy-path","title":"How to use --strategy-path?","text":"<p>This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!): <pre><code>freqtrade --strategy AwesomeStrategy --strategy-path /some/directory\n</code></pre></p>"},{"location":"bot-usage/#how-to-install-a-strategy","title":"How to install a strategy?","text":"<p>This is very simple. Copy paste your strategy file into the directory <code>user_data/strategies</code> or use <code>--strategy-path</code>. And voila, the bot is ready to use it.</p>"},{"location":"bot-usage/#how-to-use-db-url","title":"How to use --db-url?","text":"<p>When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using <code>--db-url</code>. This can also be used to specify a custom database in production mode. Example command:</p> <pre><code>freqtrade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite\n</code></pre>"},{"location":"bot-usage/#backtesting-commands","title":"Backtesting commands","text":"<p>Backtesting also uses the config specified via <code>-c/--config</code>.</p> <pre><code>usage: freqtrade backtesting [-h] [-i TICKER_INTERVAL] [--timerange TIMERANGE]\n                           [--max_open_trades MAX_OPEN_TRADES]\n                           [--stake_amount STAKE_AMOUNT] [-r] [--eps] [--dmmp]\n                           [-l]\n                           [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]]\n                           [--export EXPORT] [--export-filename PATH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TICKER_INTERVAL, --ticker-interval TICKER_INTERVAL\n                        Specify ticker interval (1m, 5m, 30m, 1h, 1d).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --max_open_trades MAX_OPEN_TRADES\n                        Specify max_open_trades to use.\n  --stake_amount STAKE_AMOUNT\n                        Specify stake_amount.\n  -r, --refresh-pairs-cached\n                        Refresh the pairs files in tests/testdata with the\n                        latest data from the exchange. Use it if you want to\n                        run your optimization commands with up-to-date data.\n  --eps, --enable-position-stacking\n                        Allow buying the same pair multiple times (position\n                        stacking).\n  --dmmp, --disable-max-market-positions\n                        Disable applying `max_open_trades` during backtest\n                        (same as setting `max_open_trades` to a very high\n                        number).\n  -l, --live            Use live data.\n  --strategy-list STRATEGY_LIST [STRATEGY_LIST ...]\n                        Provide a commaseparated list of strategies to\n                        backtest Please note that ticker-interval needs to be\n                        set either in config or via command line. When using\n                        this together with --export trades, the strategy-name\n                        is injected into the filename (so backtest-data.json\n                        becomes backtest-data-DefaultStrategy.json\n  --export EXPORT       Export backtest results, argument are: trades. Example\n                        --export=trades\n  --export-filename PATH\n                        Save backtest results to this filename requires\n                        --export to be set as well Example --export-\n                        filename=user_data/backtest_data/backtest_today.json\n                        (default: user_data/backtest_data/backtest-\n                        result.json)\n</code></pre>"},{"location":"bot-usage/#how-to-use-refresh-pairs-cached-parameter","title":"How to use --refresh-pairs-cached parameter?","text":"<p>The first time your run Backtesting, it will take the pairs you have set in your config file and download data from the Exchange.</p> <p>If for any reason you want to update your data set, you use <code>--refresh-pairs-cached</code> to force Backtesting to update the data it has.</p> <p>Note</p> <p>Use it only if you want to update your data set. You will not be able to come back to the previous version.</p> <p>To test your strategy with latest data, we recommend continuing using the parameter <code>-l</code> or <code>--live</code>.</p>"},{"location":"bot-usage/#hyperopt-commands","title":"Hyperopt commands","text":"<p>To optimize your strategy, you can use hyperopt parameter hyperoptimization to find optimal parameter values for your stategy.</p> <pre><code>usage: freqtrade hyperopt [-h] [-i TICKER_INTERVAL] [--timerange TIMERANGE]\n                          [--max_open_trades INT]\n                          [--stake_amount STAKE_AMOUNT] [-r]\n                          [--customhyperopt NAME] [--hyperopt-path PATH]\n                          [--eps] [-e INT]\n                          [-s {all,buy,sell,roi,stoploss} [{all,buy,sell,roi,stoploss} ...]]\n                          [--dmmp] [--print-all] [-j JOBS]\n                          [--random-state INT] [--min-trades INT] [--continue]\n                          [--hyperopt-loss NAME]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TICKER_INTERVAL, --ticker-interval TICKER_INTERVAL\n                        Specify ticker interval (`1m`, `5m`, `30m`, `1h`,\n                        `1d`).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --max_open_trades INT\n                        Specify max_open_trades to use.\n  --stake_amount STAKE_AMOUNT\n                        Specify stake_amount.\n  -r, --refresh-pairs-cached\n                        Refresh the pairs files in tests/testdata with the\n                        latest data from the exchange. Use it if you want to\n                        run your optimization commands with up-to-date data.\n  --customhyperopt NAME\n                        Specify hyperopt class name (default:\n                        `DefaultHyperOpts`).\n  --hyperopt-path PATH  Specify additional lookup path for Hyperopts and\n                        Hyperopt Loss functions.\n  --eps, --enable-position-stacking\n                        Allow buying the same pair multiple times (position\n                        stacking).\n  -e INT, --epochs INT  Specify number of epochs (default: 100).\n  -s {all,buy,sell,roi,stoploss} [{all,buy,sell,roi,stoploss} ...], --spaces {all,buy,sell,roi,stoploss} [{all,buy,sell,roi,stoploss} ...]\n                        Specify which parameters to hyperopt. Space-separated\n                        list. Default: `all`.\n  --dmmp, --disable-max-market-positions\n                        Disable applying `max_open_trades` during backtest\n                        (same as setting `max_open_trades` to a very high\n                        number).\n  --print-all           Print all results, not only the best ones.\n  -j JOBS, --job-workers JOBS\n                        The number of concurrently running jobs for\n                        hyperoptimization (hyperopt worker processes). If -1\n                        (default), all CPUs are used, for -2, all CPUs but one\n                        are used, etc. If 1 is given, no parallel computing\n                        code is used at all.\n  --random-state INT    Set random state to some positive integer for\n                        reproducible hyperopt results.\n  --min-trades INT      Set minimal desired number of trades for evaluations\n                        in the hyperopt optimization path (default: 1).\n  --continue            Continue hyperopt from previous runs. By default,\n                        temporary files will be removed and hyperopt will\n                        start from scratch.\n  --hyperopt-loss       NAME\n                        Specify the class name of the hyperopt loss function\n                        class (IHyperOptLoss). Different functions can\n                        generate completely different results, since the\n                        target for optimization is different. (default:\n                        `DefaultHyperOptLoss`).\n</code></pre>"},{"location":"bot-usage/#edge-commands","title":"Edge commands","text":"<p>To know your trade expectacny and winrate against historical data, you can use Edge.</p> <pre><code>usage: freqtrade edge [-h] [-i TICKER_INTERVAL] [--timerange TIMERANGE]\n                    [--max_open_trades MAX_OPEN_TRADES]\n                    [--stake_amount STAKE_AMOUNT] [-r]\n                    [--stoplosses STOPLOSS_RANGE]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TICKER_INTERVAL, --ticker-interval TICKER_INTERVAL\n                        Specify ticker interval (1m, 5m, 30m, 1h, 1d).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --max_open_trades MAX_OPEN_TRADES\n                        Specify max_open_trades to use.\n  --stake_amount STAKE_AMOUNT\n                        Specify stake_amount.\n  -r, --refresh-pairs-cached\n                        Refresh the pairs files in tests/testdata with the\n                        latest data from the exchange. Use it if you want to\n                        run your optimization commands with up-to-date data.\n  --stoplosses STOPLOSS_RANGE\n                        Defines a range of stoploss against which edge will\n                        assess the strategy the format is \"min,max,step\"\n                        (without any space).example:\n                        --stoplosses=-0.01,-0.1,-0.001\n</code></pre> <p>To understand edge and how to read the results, please read the edge documentation.</p>"},{"location":"bot-usage/#next-step","title":"Next step","text":"<p>The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization.</p>"},{"location":"configuration/","title":"Configure the bot","text":"<p>This page explains how to configure your <code>config.json</code> file.</p>"},{"location":"configuration/#setup-configjson","title":"Setup config.json","text":"<p>We recommend to copy and use the <code>config.json.example</code> as a template for your bot configuration.</p> <p>The table below will list all configuration parameters.</p> <p>Mandatory Parameters are marked as Required.</p> Command Default Description <code>max_open_trades</code> 3 Required. Number of trades open your bot will have. If -1 then it is ignored (i.e. potentially unlimited open trades) <code>stake_currency</code> BTC Required. Crypto-currency used for trading. Strategy Override. <code>stake_amount</code> 0.05 Required. Amount of crypto-currency your bot will use for each trade. Per default, the bot will use (0.05 BTC x 3) = 0.15 BTC in total will be always engaged. Set it to <code>\"unlimited\"</code> to allow the bot to use all available balance. Strategy Override. <code>amount_reserve_percent</code> 0.05 Reserve some amount in min pair stake amount. Default is 5%. The bot will reserve <code>amount_reserve_percent</code> + stop-loss value when calculating min pair stake amount in order to avoid possible trade refusals. <code>ticker_interval</code> [1m, 5m, 15m, 30m, 1h, 1d, ...] The ticker interval to use (1min, 5 min, 15 min, 30 min, 1 hour or 1 day). Default is 5 minutes. Strategy Override. <code>fiat_display_currency</code> USD Required. Fiat currency used to show your profits. More information below. <code>dry_run</code> true Required. Define if the bot must be in Dry-run or production mode. <code>dry_run_wallet</code> 999.9 Overrides the default amount of 999.9 stake currency units in the wallet used by the bot running in the Dry Run mode if you need it for any reason. <code>process_only_new_candles</code> false If set to true indicators are processed only once a new candle arrives. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override. <code>minimal_roi</code> See below Set the threshold in percent the bot will use to sell a trade. More information below. Strategy Override. <code>stoploss</code> -0.10 Value of the stoploss in percent used by the bot. More information below. More details in the stoploss documentation. Strategy Override. <code>trailing_stop</code> false Enables trailing stop-loss (based on <code>stoploss</code> in either configuration or strategy file). More details in the stoploss documentation. Strategy Override. <code>trailing_stop_positive</code> 0 Changes stop-loss once profit has been reached. More details in the stoploss documentation. Strategy Override. <code>trailing_stop_positive_offset</code> 0 Offset on when to apply <code>trailing_stop_positive</code>. Percentage value which should be positive. More details in the stoploss documentation. Strategy Override. <code>trailing_only_offset_is_reached</code> false Only apply trailing stoploss when the offset is reached. stoploss documentation. Strategy Override. <code>unfilledtimeout.buy</code> 10 Required. How long (in minutes) the bot will wait for an unfilled buy order to complete, after which the order will be cancelled. <code>unfilledtimeout.sell</code> 10 Required. How long (in minutes) the bot will wait for an unfilled sell order to complete, after which the order will be cancelled. <code>bid_strategy.ask_last_balance</code> 0.0 Required. Set the bidding price. More information below. <code>bid_strategy.use_order_book</code> false Allows buying of pair using the rates in Order Book Bids. <code>bid_strategy.order_book_top</code> 0 Bot will use the top N rate in Order Book Bids. Ie. a value of 2 will allow the bot to pick the 2<sup>nd</sup> bid rate in Order Book Bids. <code>bid_strategy. check_depth_of_market.enabled</code> false Does not buy if the % difference of buy orders and sell orders is met in Order Book. <code>bid_strategy. check_depth_of_market.bids_to_ask_delta</code> 0 The % difference of buy orders and sell orders found in Order Book. A value lesser than 1 means sell orders is greater, while value greater than 1 means buy orders is higher. <code>ask_strategy.use_order_book</code> false Allows selling of open traded pair using the rates in Order Book Asks. <code>ask_strategy.order_book_min</code> 0 Bot will scan from the top min to max Order Book Asks searching for a profitable rate. <code>ask_strategy.order_book_max</code> 0 Bot will scan from the top min to max Order Book Asks searching for a profitable rate. <code>order_types</code> None Configure order-types depending on the action (<code>\"buy\"</code>, <code>\"sell\"</code>, <code>\"stoploss\"</code>, <code>\"stoploss_on_exchange\"</code>). More information below. Strategy Override. <code>order_time_in_force</code> None Configure time in force for buy and sell orders. More information below. Strategy Override. <code>exchange.name</code> Required. Name of the exchange class to use. List below. <code>exchange.sandbox</code> false Use the 'sandbox' version of the exchange, where the exchange provides a sandbox for risk-free integration. See here in more details. <code>exchange.key</code> '' API key to use for the exchange. Only required when you are in production mode. <code>exchange.secret</code> '' API secret to use for the exchange. Only required when you are in production mode. <code>exchange.pair_whitelist</code> [] List of pairs to use by the bot for trading and to check for potential trades during backtesting. Can be overriden by dynamic pairlists (see below). <code>exchange.pair_blacklist</code> [] List of pairs the bot must absolutely avoid for trading and backtesting. Can be overriden by dynamic pairlists (see below). <code>exchange.ccxt_config</code> None Additional CCXT parameters passed to the regular ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation <code>exchange.ccxt_async_config</code> None Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange  and are documented in the ccxt documentation <code>exchange.markets_refresh_interval</code> 60 The interval in minutes in which markets are reloaded. <code>edge</code> false Please refer to edge configuration document for detailed explanation. <code>experimental.use_sell_signal</code> false Use your sell strategy in addition of the <code>minimal_roi</code>. Strategy Override. <code>experimental.sell_profit_only</code> false Waits until you have made a positive profit before taking a sell decision. Strategy Override. <code>experimental.ignore_roi_if_buy_signal</code> false Does not sell if the buy-signal is still active. Takes preference over <code>minimal_roi</code> and <code>use_sell_signal</code>. Strategy Override. <code>pairlist.method</code> StaticPairList Use static or dynamic volume-based pairlist. More information below. <code>pairlist.config</code> None Additional configuration for dynamic pairlists. More information below. <code>telegram.enabled</code> true Required. Enable or not the usage of Telegram. <code>telegram.token</code> token Your Telegram bot token. Only required if <code>telegram.enabled</code> is <code>true</code>. <code>telegram.chat_id</code> chat_id Your personal Telegram account id. Only required if <code>telegram.enabled</code> is <code>true</code>. <code>webhook.enabled</code> false Enable usage of Webhook notifications <code>webhook.url</code> false URL for the webhook. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details. <code>webhook.webhookbuy</code> false Payload to send on buy. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentationV for more details. <code>webhook.webhooksell</code> false Payload to send on sell. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentationV for more details. <code>webhook.webhookstatus</code> false Payload to send on status calls. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentationV for more details. <code>db_url</code> <code>sqlite:///tradesv3.sqlite</code> Declares database URL to use. NOTE: This defaults to <code>sqlite://</code> if <code>dry_run</code> is <code>True</code>. <code>initial_state</code> running Defines the initial application state. More information below. <code>forcebuy_enable</code> false Enables the RPC Commands to force a buy. More information below. <code>strategy</code> DefaultStrategy Defines Strategy class to use. <code>strategy_path</code> null Adds an additional strategy lookup path (must be a directory). <code>internals.process_throttle_secs</code> 5 Required. Set the process throttle. Value in second. <code>internals.sd_notify</code> false Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details. <code>logfile</code> Specify Logfile. Uses a rolling strategy of 10 files, with 1Mb per file."},{"location":"configuration/#parameters-in-the-strategy","title":"Parameters in the strategy","text":"<p>The following parameters can be set in either configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy.</p> <ul> <li><code>stake_currency</code></li> <li><code>stake_amount</code></li> <li><code>ticker_interval</code></li> <li><code>minimal_roi</code></li> <li><code>stoploss</code></li> <li><code>trailing_stop</code></li> <li><code>trailing_stop_positive</code></li> <li><code>trailing_stop_positive_offset</code></li> <li><code>process_only_new_candles</code></li> <li><code>order_types</code></li> <li><code>order_time_in_force</code></li> <li><code>use_sell_signal</code> (experimental)</li> <li><code>sell_profit_only</code> (experimental)</li> <li><code>ignore_roi_if_buy_signal</code> (experimental)</li> </ul>"},{"location":"configuration/#understand-stake_amount","title":"Understand stake_amount","text":"<p>The <code>stake_amount</code> configuration parameter is an amount of crypto-currency your bot will use for each trade. The minimal value is 0.0005. If there is not enough crypto-currency in the account an exception is generated. To allow the bot to trade all the available <code>stake_currency</code> in your account set</p> <pre><code>\"stake_amount\" : \"unlimited\",\n</code></pre> <p>In this case a trade amount is calclulated as:</p> <pre><code>currency_balanse / (max_open_trades - current_open_trades)\n</code></pre>"},{"location":"configuration/#understand-minimal_roi","title":"Understand minimal_roi","text":"<p>The <code>minimal_roi</code> configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI in percent. See the example below:</p> <pre><code>\"minimal_roi\": {\n    \"40\": 0.0,    # Sell after 40 minutes if the profit is not negative\n    \"30\": 0.01,   # Sell after 30 minutes if there is at least 1% profit\n    \"20\": 0.02,   # Sell after 20 minutes if there is at least 2% profit\n    \"0\":  0.04    # Sell immediately if there is at least 4% profit\n},\n</code></pre> <p>Most of the strategy files already include the optimal <code>minimal_roi</code> value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the <code>minimal_roi</code> value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% <code>{\"0\": 10}</code> is used, and minimal roi is disabled unless your trade generates 1000% profit.</p>"},{"location":"configuration/#understand-stoploss","title":"Understand stoploss","text":"<p>Go to the stoploss documentation for more details.</p>"},{"location":"configuration/#understand-trailing-stoploss","title":"Understand trailing stoploss","text":"<p>Go to the trailing stoploss Documentation for details on trailing stoploss.</p>"},{"location":"configuration/#understand-initial_state","title":"Understand initial_state","text":"<p>The <code>initial_state</code> configuration parameter is an optional field that defines the initial application state. Possible values are <code>running</code> or <code>stopped</code>. (default=<code>running</code>) If the value is <code>stopped</code> the bot has to be started with <code>/start</code> first.</p>"},{"location":"configuration/#understand-forcebuy_enable","title":"Understand forcebuy_enable","text":"<p>The <code>forcebuy_enable</code> configuration parameter enables the usage of forcebuy commands via Telegram. This is disabled for security reasons by default, and will show a warning message on startup if enabled. For example, you can send <code>/forcebuy ETH/BTC</code> Telegram command when this feature if enabled to the bot, who then buys the pair and holds it until a regular sell-signal (ROI, stoploss, /forcesell) appears.</p> <p>This can be dangerous with some strategies, so use with care.</p> <p>See the telegram documentation for details on usage.</p>"},{"location":"configuration/#understand-process_throttle_secs","title":"Understand process_throttle_secs","text":"<p>The <code>process_throttle_secs</code> configuration parameter is an optional field that defines in seconds how long the bot should wait before asking the strategy if we should buy or a sell an asset. After each wait period, the strategy is asked again for every opened trade wether or not we should sell, and for all the remaining pairs (either the dynamic list of pairs or the static list of pairs) if we should buy.</p>"},{"location":"configuration/#understand-ask_last_balance","title":"Understand ask_last_balance","text":"<p>The <code>ask_last_balance</code> configuration parameter sets the bidding price. Value <code>0.0</code> will use <code>ask</code> price, <code>1.0</code> will use the <code>last</code> price and values between those interpolate between ask and last price. Using <code>ask</code> price will guarantee quick success in bid, but bot will also end up paying more then would probably have been necessary.</p>"},{"location":"configuration/#understand-order_types","title":"Understand order_types","text":"<p>The <code>order_types</code> configuration parameter contains a dict mapping order-types to market-types as well as stoploss on or off exchange type and stoploss on exchange update interval in seconds. This allows to buy using limit orders, sell using limit-orders, and create stoploss orders using market. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled. In case stoploss on exchange and <code>trailing_stop</code> are both set, then the bot will use <code>stoploss_on_exchange_interval</code> to check it periodically and update it if necessary (e.x. in case of trailing stoploss). This can be set in the configuration file or in the strategy. Values set in the configuration file  overwrites values set in the strategy.</p> <p>If this is configured, all 4 values (<code>buy</code>, <code>sell</code>, <code>stoploss</code> and <code>stoploss_on_exchange</code>) need to be present, otherwise the bot will warn about it and fail to start. The below is the default which is used if this is not configured in either strategy or configuration file.</p> <p>Syntax for Strategy:</p> <pre><code>order_types = {\n    \"buy\": \"limit\",\n    \"sell\": \"limit\",\n    \"stoploss\": \"market\",\n    \"stoploss_on_exchange\": False,\n    \"stoploss_on_exchange_interval\": 60\n}\n</code></pre> <p>Configuration:</p> <pre><code>\"order_types\": {\n    \"buy\": \"limit\",\n    \"sell\": \"limit\",\n    \"stoploss\": \"market\",\n    \"stoploss_on_exchange\": false,\n    \"stoploss_on_exchange_interval\": 60\n}\n</code></pre> <p>Note</p> <p>Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: <code>\"Exchange &lt;yourexchange&gt;  does not support market orders.\"</code></p> <p>Note</p> <p>Stoploss on exchange interval is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please read the stoploss documentation.</p> <p>Note</p> <p>In case of stoploss on exchange if the stoploss is cancelled manually then the bot would recreate one.</p>"},{"location":"configuration/#understand-order_time_in_force","title":"Understand order_time_in_force","text":"<p>The <code>order_time_in_force</code> configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are:</p> <p>GTC (Good Till Canceled):</p> <p>This is most of the time the default time in force. It means the order will remain on exchange till it is canceled by user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled.</p> <p>FOK (Full Or Kill):</p> <p>It means if the order is not executed immediately AND fully then it is canceled by the exchange.</p> <p>IOC (Immediate Or Canceled):</p> <p>It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange.</p> <p>The <code>order_time_in_force</code> parameter contains a dict with buy and sell time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy.</p> <p>The possible values are: <code>gtc</code> (default), <code>fok</code> or <code>ioc</code>.</p> <pre><code>\"order_time_in_force\": {\n    \"buy\": \"gtc\",\n    \"sell\": \"gtc\"\n},\n</code></pre> <p>Warning</p> <p>This is an ongoing work. For now it is supported only for binance and only for buy orders. Please don't change the default value unless you know what you are doing.</p>"},{"location":"configuration/#exchange-configuration","title":"Exchange configuration","text":"<p>Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage. However, the bot was tested with only Bittrex and Binance.</p> <p>The bot was tested with the following exchanges:</p> <ul> <li>Bittrex: \"bittrex\"</li> <li>Binance: \"binance\"</li> </ul> <p>Feel free to test other exchanges and submit your PR to improve the bot.</p>"},{"location":"configuration/#sample-exchange-configuration","title":"Sample exchange configuration","text":"<p>A exchange configuration for \"binance\" would look as follows:</p> <pre><code>\"exchange\": {\n    \"name\": \"binance\",\n    \"key\": \"your_exchange_key\",\n    \"secret\": \"your_exchange_secret\",\n    \"ccxt_config\": {\"enableRateLimit\": true},\n    \"ccxt_async_config\": {\n        \"enableRateLimit\": true,\n        \"rateLimit\": 200\n    },\n</code></pre> <p>This configuration enables binance, as well as rate limiting to avoid bans from the exchange. <code>\"rateLimit\": 200</code> defines a wait-event of 0.2s between each call. This can also be completely disabled by setting <code>\"enableRateLimit\"</code> to false.</p> <p>Note</p> <p>Optimal settings for rate limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that <code>\"enableRateLimit\"</code> is enabled and increase the <code>\"rateLimit\"</code> parameter step by step.</p>"},{"location":"configuration/#advanced-freqtrade-exchange-configuration","title":"Advanced FreqTrade Exchange configuration","text":"<p>Advanced options can be configured using the <code>_ft_has_params</code> setting, which will override Defaults and exchange-specific behaviours.</p> <p>Available options are listed in the exchange-class as <code>_ft_has_default</code>.</p> <p>For example, to test the order type <code>FOK</code> with Kraken, and modify candle_limit to 200 (so you only get 200 candles per call):</p> <pre><code>\"exchange\": {\n    \"name\": \"kraken\",\n    \"_ft_has_params\": {\n        \"order_time_in_force\": [\"gtc\", \"fok\"],\n        \"ohlcv_candle_limit\": 200\n        }\n</code></pre> <p>Warning</p> <p>Please make sure to fully understand the impacts of these settings before modifying them.</p>"},{"location":"configuration/#what-values-can-be-used-for-fiat_display_currency","title":"What values can be used for fiat_display_currency?","text":"<p>The <code>fiat_display_currency</code> configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports.</p> <p>The valid values are:</p> <pre><code>\"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\", \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"ZAR\", \"USD\"\n</code></pre> <p>In addition to fiat currencies, a range of cryto currencies are supported.</p> <p>The valid values are:</p> <pre><code>\"BTC\", \"ETH\", \"XRP\", \"LTC\", \"BCH\", \"USDT\"\n</code></pre>"},{"location":"configuration/#switch-to-dry-run-mode","title":"Switch to Dry-run mode","text":"<p>We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode the bot does not engage your money. It only runs a live simulation without creating trades on the exchange.</p> <ol> <li>Edit your <code>config.json</code> configuration file.</li> <li>Switch <code>dry-run</code> to <code>true</code> and specify <code>db_url</code> for a persistence database.</li> </ol> <pre><code>\"dry_run\": true,\n\"db_url\": \"sqlite:///tradesv3.dryrun.sqlite\",\n</code></pre> <ol> <li>Remove your Exchange API key and secrete (change them by empty values or fake credentials):</li> </ol> <pre><code>\"exchange\": {\n        \"name\": \"bittrex\",\n        \"key\": \"key\",\n        \"secret\": \"secret\",\n        ...\n}\n</code></pre> <p>Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode.</p>"},{"location":"configuration/#dynamic-pairlists","title":"Dynamic Pairlists","text":"<p>Dynamic pairlists select pairs for you based on the logic configured. The bot runs against all pairs (with that stake) on the exchange, and a number of assets (<code>number_assets</code>) is selected based on the selected criteria.</p> <p>By default, the <code>StaticPairList</code> method is used. The Pairlist method is configured as <code>pair_whitelist</code> parameter under the <code>exchange</code> section of the configuration.</p> <p>Available Pairlist methods:</p> <ul> <li><code>StaticPairList</code></li> <li>It uses configuration from <code>exchange.pair_whitelist</code> and <code>exchange.pair_blacklist</code>.</li> <li><code>VolumePairList</code></li> <li>It selects <code>number_assets</code> top pairs based on <code>sort_key</code>, which can be one of <code>askVolume</code>, <code>bidVolume</code> and <code>quoteVolume</code>, defaults to <code>quoteVolume</code>.</li> <li>There is a possibility to filter low-value coins that would not allow setting a stop loss (set <code>precision_filter</code> parameter to <code>true</code> for this).</li> </ul> <p>Example:</p> <pre><code>\"pairlist\": {\n        \"method\": \"VolumePairList\",\n        \"config\": {\n            \"number_assets\": 20,\n            \"sort_key\": \"quoteVolume\",\n            \"precision_filter\": false\n        }\n    },\n</code></pre>"},{"location":"configuration/#switch-to-production-mode","title":"Switch to production mode","text":"<p>In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode.</p>"},{"location":"configuration/#to-switch-your-bot-in-production-mode","title":"To switch your bot in production mode","text":"<p>Edit your <code>config.json</code>  file.</p> <p>Switch dry-run to false and don't forget to adapt your database URL if set:</p> <pre><code>\"dry_run\": false,\n</code></pre> <p>Insert your Exchange API key (change them by fake api keys):</p> <pre><code>\"exchange\": {\n        \"name\": \"bittrex\",\n        \"key\": \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\",\n        \"secret\": \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\",\n        ...\n}\n</code></pre> <p>Note</p> <p>If you have an exchange API key yet, see our tutorial.</p>"},{"location":"configuration/#using-proxy-with-freqtrade","title":"Using proxy with FreqTrade","text":"<p>To use a proxy with freqtrade, add the kwarg <code>\"aiohttp_trust_env\"=true</code> to the <code>\"ccxt_async_kwargs\"</code> dict in the exchange section of the configuration.</p> <p>An example for this can be found in <code>config_full.json.example</code></p> <pre><code>\"ccxt_async_config\": {\n    \"aiohttp_trust_env\": true\n}\n</code></pre> <p>Then, export your proxy settings using the variables <code>\"HTTP_PROXY\"</code> and <code>\"HTTPS_PROXY\"</code> set to the appropriate values</p> <pre><code>export HTTP_PROXY=\"http://addr:port\"\nexport HTTPS_PROXY=\"http://addr:port\"\nfreqtrade\n</code></pre>"},{"location":"configuration/#embedding-strategies","title":"Embedding Strategies","text":"<p>FreqTrade provides you with with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file.</p>"},{"location":"configuration/#encoding-a-string-as-base64","title":"Encoding a string as BASE64","text":"<p>This is a quick example, how to generate the BASE64 string in python</p> <pre><code>from base64 import urlsafe_b64encode\n\nwith open(file, 'r') as f:\n    content = f.read()\ncontent = urlsafe_b64encode(content.encode('utf-8'))\n</code></pre> <p>The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following</p> <pre><code>\"strategy\": \"NameOfStrategy:BASE64String\"\n</code></pre> <p>Please ensure that 'NameOfStrategy' is identical to the strategy name!</p>"},{"location":"configuration/#next-step","title":"Next step","text":"<p>Now you have configured your config.json, the next step is to start your bot.</p>"},{"location":"data-analysis/","title":"Analyzing bot data","text":"<p>After performing backtests, or after running the bot for some time, it will be interesting to analyze the results your bot generated.</p> <p>A good way for this is using Jupyter (notebook or lab) - which provides an interactive environment to analyze the data.</p> <p>The following helpers will help you loading the data into Pandas DataFrames, and may also give you some starting points in analyzing the results.</p>"},{"location":"data-analysis/#backtesting","title":"Backtesting","text":"<p>To analyze your backtest results, you can export the trades. You can then load the trades to perform further analysis.</p> <p>Freqtrade provides the <code>load_backtest_data()</code> helper function to easily load the backtest results, which takes the path to the the backtest-results file as parameter.</p> <pre><code>from freqtrade.data.btanalysis import load_backtest_data\ndf = load_backtest_data(\"user_data/backtest-result.json\")\n\n# Show value-counts per pair\ndf.groupby(\"pair\")[\"sell_reason\"].value_counts()\n</code></pre> <p>This will allow you to drill deeper into your backtest results, and perform analysis which otherwise would make the regular backtest-output very difficult to digest due to information overload.</p> <p>If you have some ideas for interesting / helpful backtest data analysis ideas, please submit a Pull Request so the community can benefit from it.</p>"},{"location":"data-analysis/#live-data","title":"Live data","text":"<p>To analyze the trades your bot generated, you can load them to a DataFrame as follows:</p> <pre><code>from freqtrade.data.btanalysis import load_trades_from_db\n\ndf = load_trades_from_db(\"sqlite:///tradesv3.sqlite\")\n\ndf.groupby(\"pair\")[\"sell_reason\"].value_counts()\n</code></pre> <p>Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.</p>"},{"location":"deprecated/","title":"Deprecated features","text":"<p>This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration.</p>"},{"location":"deprecated/#the-live-command-line-option","title":"the <code>--live</code> command line option","text":"<p><code>--live</code> in the context of backtesting allows to download the latest tick data for backtesting. Since this only downloads one set of data (by default 500 candles) - this is not really suitable for extendet backtesting, and has therefore been deprecated.</p> <p>This command was deprecated in <code>2019.6-dev</code> and will be removed after the next release.</p>"},{"location":"deprecated/#removed-features","title":"Removed features","text":""},{"location":"deprecated/#the-dynamic-whitelist-command-line-option","title":"The --dynamic-whitelist command line option","text":"<p>This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7 (master branch).</p>"},{"location":"developer/","title":"Development Help","text":"<p>This page is intended for developers of FreqTrade, people who want to contribute to the FreqTrade codebase or documentation, or people who want to understand the source code of the application they're running.</p> <p>All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel in slack where you can ask questions.</p>"},{"location":"developer/#documentation","title":"Documentation","text":"<p>Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR.</p> <p>Special fields for the documentation (like Note boxes, ...) can be found here.</p>"},{"location":"developer/#developer-setup","title":"Developer setup","text":"<p>To configure a development environment, use best use the <code>setup.sh</code> script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (if your system is not supported by the setup.sh script), follow the manual installation process and run <code>pip3 install -r requirements-dev.txt</code>.</p> <p>This will install all required tools for development, including <code>pytest</code>, <code>flake8</code>, <code>mypy</code>, and <code>coveralls</code>.</p>"},{"location":"developer/#modules","title":"Modules","text":""},{"location":"developer/#dynamic-pairlist","title":"Dynamic Pairlist","text":"<p>You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream.</p> <p>Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist provider.</p> <p>First of all, have a look at the VolumePairList provider, and best copy this file with a name of your new Pairlist Provider.</p> <p>This is a simple provider, which however serves as a good example on how to start developing.</p> <p>Next, modify the classname of the provider (ideally align this with the Filename).</p> <p>The base-class provides the an instance of the bot (<code>self._freqtrade</code>), as well as the configuration (<code>self._config</code>), and initiates both <code>_blacklist</code> and <code>_whitelist</code>.</p> <pre><code>        self._freqtrade = freqtrade\n        self._config = config\n        self._whitelist = self._config['exchange']['pair_whitelist']\n        self._blacklist = self._config['exchange'].get('pair_blacklist', [])\n</code></pre> <p>Now, let's step through the methods which require actions:</p>"},{"location":"developer/#configuration","title":"configuration","text":"<p>Configuration for PairListProvider is done in the bot configuration file in the element <code>\"pairlist\"</code>. This Pairlist-object may contain a <code>\"config\"</code> dict with additional configurations for the configured pairlist. By convention, <code>\"number_assets\"</code> is used to specify the maximum number of pairs to keep in the whitelist. Please follow this to ensure a consistent user experience.</p> <p>Additional elements can be configured as needed. <code>VolumePairList</code> uses <code>\"sort_key\"</code> to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successfull and dynamic.</p>"},{"location":"developer/#short_desc","title":"short_desc","text":"<p>Returns a description used for Telegram messages. This should contain the name of the Provider, as well as a short description containing the number of assets. Please follow the format <code>\"PairlistName - top/bottom X pairs\"</code>.</p>"},{"location":"developer/#refresh_pairlist","title":"refresh_pairlist","text":"<p>Override this method and run all calculations needed in this method. This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations.</p> <p>Assign the resulting whiteslist to <code>self._whitelist</code> and <code>self._blacklist</code> respectively. These will then be used to run the bot in this iteration. Pairs with open trades will be added to the whitelist to have the sell-methods run correctly.</p> <p>Please also run <code>self._validate_whitelist(pairs)</code> and to check and remove pairs with inactive markets. This function is available in the Parent class (<code>StaticPairList</code>) and should ideally not be overwritten.</p>"},{"location":"developer/#sample","title":"sample","text":"<pre><code>    def refresh_pairlist(self) -&gt; None:\n        # Generate dynamic whitelist\n        pairs = self._gen_pair_whitelist(self._config['stake_currency'], self._sort_key)\n        # Validate whitelist to only have active market pairs\n        self._whitelist = self._validate_whitelist(pairs)[:self._number_pairs]\n</code></pre>"},{"location":"developer/#_gen_pair_whitelist","title":"_gen_pair_whitelist","text":"<p>This is a simple method used by <code>VolumePairList</code> - however serves as a good example. It implements caching (<code>@cached(TTLCache(maxsize=1, ttl=1800))</code>) as well as a configuration option to allow different (but similar) strategies to work with the same PairListProvider.</p>"},{"location":"developer/#implement-a-new-exchange-wip","title":"Implement a new Exchange (WIP)","text":"<p>Note</p> <p>This section is a Work in Progress and is not a complete guide on how to test a new exchange with FreqTrade.</p> <p>Most exchanges supported by CCXT should work out of the box.</p>"},{"location":"developer/#stoploss-on-exchange","title":"Stoploss On Exchange","text":"<p>Check if the new exchange supports Stoploss on Exchange orders through their API.</p> <p>Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselfs. Best look at <code>binance.py</code> for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects.</p>"},{"location":"developer/#incomplete-candles","title":"Incomplete candles","text":"<p>While fetching OHLCV data, we're may end up getting incomplete candles (Depending on the exchange). To demonstrate this, we'll use daily candles (<code>\"1d\"</code>) to keep things simple. We query the api (<code>ct.fetch_ohlcv()</code>) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete.</p> <p>To check how the new exchange behaves, you can use the following snippet:</p> <pre><code>import ccxt\nfrom datetime import datetime\nfrom freqtrade.data.converter import parse_ticker_dataframe\nct = ccxt.binance()\ntimeframe = \"1d\"\npair = \"XLM/BTC\"  # Make sure to use a pair that exists on that exchange!\nraw = ct.fetch_ohlcv(pair, timeframe=timeframe)\n\n# convert to dataframe\ndf1 = parse_ticker_dataframe(raw, timeframe, pair=pair, drop_incomplete=False)\n\nprint(df1[\"date\"].tail(1))\nprint(datetime.utcnow())\n</code></pre> <pre><code>19   2019-06-08 00:00:00+00:00\n2019-06-09 12:30:27.873327\n</code></pre> <p>The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting <code>\"ohlcv_partial_candle\"</code> from the exchange-class untouched / True). Otherwise, set <code>\"ohlcv_partial_candle\"</code> to <code>False</code> to not drop Candles (shown in the example above).</p>"},{"location":"developer/#creating-a-release","title":"Creating a release","text":"<p>This part of the documentation is aimed at maintainers, and shows how to create a release.</p>"},{"location":"developer/#create-release-branch","title":"Create release branch","text":"<pre><code># make sure you're in develop branch\ngit checkout develop\n\n# create new branch\ngit checkout -b new_release\n</code></pre> <ul> <li>Edit <code>freqtrade/__init__.py</code> and add the version matching the current date (for example <code>2019.7</code> for July 2019). Minor versions can be <code>2019.7-1</code> should we need to do a second release that month.</li> <li>Commit this part</li> <li>push that branch to the remote and create a PR against the master branch</li> </ul>"},{"location":"developer/#create-changelog-from-git-commits","title":"Create changelog from git commits","text":"<p>Note</p> <p>Make sure that both master and develop are up-todate!.</p> <pre><code># Needs to be done before merging / pulling that branch.\ngit log --oneline --no-decorate --no-merges master..develop\n</code></pre>"},{"location":"developer/#create-github-release-tag","title":"Create github release / tag","text":"<ul> <li>Use the button \"Draft a new release\" in the Github UI (subsection releases)</li> <li>Use the version-number specified as tag. </li> <li>Use \"master\" as reference (this step comes after the above PR is merged).</li> <li>Use the above changelog as release comment (as codeblock)</li> </ul>"},{"location":"developer/#after-release","title":"After-release","text":"<ul> <li>Update version in develop by postfixing that with <code>-dev</code> (<code>2019.6 -&gt; 2019.6-dev</code>).</li> <li>Create a PR against develop to update that branch.</li> </ul>"},{"location":"docker/","title":"Using FreqTrade with Docker","text":""},{"location":"docker/#install-docker","title":"Install Docker","text":"<p>Start by downloading and installing Docker CE for your platform:</p> <ul> <li>Mac</li> <li>Windows</li> <li>Linux</li> </ul> <p>Once you have Docker installed, simply prepare the config file (e.g. <code>config.json</code>) and run the image for <code>freqtrade</code> as explained below.</p>"},{"location":"docker/#download-the-official-freqtrade-docker-image","title":"Download the official FreqTrade docker image","text":"<p>Pull the image from docker hub.</p> <p>Branches / tags available can be checked out on Dockerhub.</p> <pre><code>docker pull freqtradeorg/freqtrade:develop\n# Optionally tag the repository so the run-commands remain shorter\ndocker tag freqtradeorg/freqtrade:develop freqtrade\n</code></pre> <p>To update the image, simply run the above commands again and restart your running container.</p> <p>Should you require additional libraries, please build the image yourself.</p>"},{"location":"docker/#prepare-the-configuration-files","title":"Prepare the configuration files","text":"<p>Even though you will use docker, you'll still need some files from the github repository.</p>"},{"location":"docker/#clone-the-git-repository","title":"Clone the git repository","text":"<p>Linux/Mac/Windows with WSL</p> <pre><code>git clone https://github.com/freqtrade/freqtrade.git\n</code></pre> <p>Windows with docker</p> <pre><code>git clone --config core.autocrlf=input https://github.com/freqtrade/freqtrade.git\n</code></pre>"},{"location":"docker/#copy-configjsonexample-to-configjson","title":"Copy <code>config.json.example</code> to <code>config.json</code>","text":"<pre><code>cd freqtrade\ncp -n config.json.example config.json\n</code></pre> <p>To understand the configuration options, please refer to the Bot Configuration page.</p>"},{"location":"docker/#create-your-database-file","title":"Create your database file","text":"<p>Production</p> <pre><code>touch tradesv3.sqlite\n````\n\nDry-Run\n\n```bash\ntouch tradesv3.dryrun.sqlite\n</code></pre> <p>Note</p> <p>Make sure to use the path to this file when starting the bot in docker.</p>"},{"location":"docker/#build-your-own-docker-image","title":"Build your own Docker image","text":"<p>Best start by pulling the official docker image from dockerhub as explained here to speed up building.</p> <p>To add additional libraries to your docker image, best check out Dockerfile.technical which adds the technical module to the image.</p> <pre><code>docker build -t freqtrade -f Dockerfile.technical .\n</code></pre> <p>If you are developing using Docker, use <code>Dockerfile.develop</code> to build a dev Docker image, which will also set up develop dependencies:</p> <pre><code>docker build -f Dockerfile.develop -t freqtrade-dev .\n</code></pre> <p>Note</p> <p>For security reasons, your configuration file will not be included in the image, you will need to bind mount it. It is also advised to bind mount an SQLite database file (see the \"5. Run a restartable docker image\" section) to keep it between  updates.</p>"},{"location":"docker/#verify-the-docker-image","title":"Verify the Docker image","text":"<p>After the build process you can verify that the image was created with:</p> <pre><code>docker images\n</code></pre> <p>The output should contain the freqtrade image.</p>"},{"location":"docker/#run-the-docker-image","title":"Run the Docker image","text":"<p>You can run a one-off container that is immediately deleted upon exiting with the following command (<code>config.json</code> must be in the current working directory):</p> <pre><code>docker run --rm -v `pwd`/config.json:/freqtrade/config.json -it freqtrade\n</code></pre> <p>Warning</p> <p>In this example, the database will be created inside the docker instance and will be lost when you will refresh your image.</p>"},{"location":"docker/#adjust-timezone","title":"Adjust timezone","text":"<p>By default, the container will use UTC timezone. Should you find this irritating please add the following to your docker commands:</p>"},{"location":"docker/#linux","title":"Linux","text":"<pre><code>-v /etc/timezone:/etc/timezone:ro\n\n# Complete command:\ndocker run --rm -v /etc/timezone:/etc/timezone:ro -v `pwd`/config.json:/freqtrade/config.json -it freqtrade\n</code></pre>"},{"location":"docker/#macos","title":"MacOS","text":"<p>There is known issue in OSX Docker versions after 17.09.1, whereby <code>/etc/localtime</code> cannot be shared causing Docker to not start. A work-around for this is to start with the following cmd.</p> <pre><code>docker run --rm -e TZ=`ls -la /etc/localtime | cut -d/ -f8-9` -v `pwd`/config.json:/freqtrade/config.json -it freqtrade\n</code></pre> <p>More information on this docker issue and work-around can be read here.</p>"},{"location":"docker/#run-a-restartable-docker-image","title":"Run a restartable docker image","text":"<p>To run a restartable instance in the background (feel free to place your configuration and database files wherever it feels comfortable on your filesystem).</p>"},{"location":"docker/#move-your-config-file-and-database","title":"Move your config file and database","text":"<p>The following will assume that you place your configuration / database files to <code>~/.freqtrade</code>, which is a hidden directory in your home directory. Feel free to use a different directory and replace the directory in the upcomming commands.</p> <pre><code>mkdir ~/.freqtrade\nmv config.json ~/.freqtrade\nmv tradesv3.sqlite ~/.freqtrade\n</code></pre>"},{"location":"docker/#run-the-docker-image_1","title":"Run the docker image","text":"<pre><code>docker run -d \\\n  --name freqtrade \\\n  -v ~/.freqtrade/config.json:/freqtrade/config.json \\\n  -v ~/.freqtrade/user_data/:/freqtrade/user_data \\\n  -v ~/.freqtrade/tradesv3.sqlite:/freqtrade/tradesv3.sqlite \\\n  freqtrade --db-url sqlite:///tradesv3.sqlite --strategy MyAwesomeStrategy\n</code></pre> <p>Note</p> <p>db-url defaults to <code>sqlite:///tradesv3.sqlite</code> but it defaults to <code>sqlite://</code> if <code>dry_run=True</code> is being used. To override this behaviour use a custom db-url value: i.e.: <code>--db-url sqlite:///tradesv3.dryrun.sqlite</code></p> <p>Note</p> <p>All available bot command line parameters can be added to the end of the <code>docker run</code> command.</p>"},{"location":"docker/#monitor-your-docker-instance","title":"Monitor your Docker instance","text":"<p>You can use the following commands to monitor and manage your container:</p> <pre><code>docker logs freqtrade\ndocker logs -f freqtrade\ndocker restart freqtrade\ndocker stop freqtrade\ndocker start freqtrade\n</code></pre> <p>For more information on how to operate Docker, please refer to the official Docker documentation.</p> <p>Note</p> <p>You do not need to rebuild the image for configuration changes, it will suffice to edit <code>config.json</code> and restart the container.</p>"},{"location":"docker/#backtest-with-docker","title":"Backtest with docker","text":"<p>The following assumes that the download/setup of the docker image have been completed successfully. Also, backtest-data should be available at <code>~/.freqtrade/user_data/</code>.</p> <pre><code>docker run -d \\\n  --name freqtrade \\\n  -v /etc/localtime:/etc/localtime:ro \\\n  -v ~/.freqtrade/config.json:/freqtrade/config.json \\\n  -v ~/.freqtrade/tradesv3.sqlite:/freqtrade/tradesv3.sqlite \\\n  -v ~/.freqtrade/user_data/:/freqtrade/user_data/ \\\n  freqtrade --strategy AwsomelyProfitableStrategy backtesting\n</code></pre> <p>Head over to the Backtesting Documentation for more details.</p> <p>Note</p> <p>Additional bot command line parameters can be appended after the image name (<code>freqtrade</code> in the above example).</p>"},{"location":"edge/","title":"Edge positioning","text":"<p>This page explains how to use Edge Positioning module in your bot in order to enter into a trade only if the trade has a reasonable win rate and risk reward ratio, and consequently adjust your position size and stoploss.</p> <p>Warning</p> <p>Edge positioning is not compatible with dynamic (volume-based) whitelist.</p> <p>Note</p> <p>Edge does not consider anything else than buy/sell/stoploss signals. So trailing stoploss, ROI, and everything else are ignored in its calculation.</p>"},{"location":"edge/#introduction","title":"Introduction","text":"<p>Trading is all about probability. No one can claim that he has a strategy working all the time. You have to assume that sometimes you lose.</p> <p>But it doesn't mean there is no rule, it only means rules should work \"most of the time\". Let's play a game: we toss a coin, heads: I give you 10, tails: you give me 10. Is it an interesting game? No, it's quite boring, isn't it?</p> <p>But let's say the probability that we have heads is 80% (because our coin has the displaced distribution of mass or other defect), and the probability that we have tails is 20%. Now it is becoming interesting...</p> <p>That means 10$ X 80% versus 10$ X 20%. 8$ versus 2. That means over time you will win 8 risking only 2$ on each toss of coin.</p> <p>Let's complicate it more: you win 80% of the time but only 2, I win 20% of the time but 8. The calculation is: 80% X 2$ versus 20% X 8. It is becoming boring again because overtime you win 1.6 (80% X 2 (80% X 2 (80% X 2 (80% X 2) and me 1.6 (20% X 8) too.</p> <p>The question is: How do you calculate that? How do you know if you wanna play?</p> <p>The answer comes to two factors: - Win Rate - Risk Reward Ratio</p>"},{"location":"edge/#win-rate","title":"Win Rate","text":"<p>Win Rate (W) is is the mean over some amount of trades (N) what is the percentage of winning trades to total number of trades (note that we don't consider how much you gained but only if you won or not).</p> <pre><code>W = (Number of winning trades) / (Total number of trades) = (Number of winning trades) / N\n</code></pre> <p>Complementary Loss Rate (L) is defined as</p> <pre><code>L = (Number of losing trades) / (Total number of trades) = (Number of losing trades) / N\n</code></pre> <p>or, which is the same, as</p> <pre><code>L = 1 \u2013 W\n</code></pre>"},{"location":"edge/#risk-reward-ratio","title":"Risk Reward Ratio","text":"<p>Risk Reward Ratio (R) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose:</p> <pre><code>R = Profit / Loss\n</code></pre> <p>Over time, on many trades, you can calculate your risk reward by dividing your average profit on winning trades by your average loss on losing trades:</p> <pre><code>Average profit = (Sum of profits) / (Number of winning trades)\n\nAverage loss = (Sum of losses) / (Number of losing trades)\n\nR = (Average profit) / (Average loss)\n</code></pre>"},{"location":"edge/#expectancy","title":"Expectancy","text":"<p>At this point we can combine W and R to create an expectancy ratio. This is a simple process of multiplying the risk reward ratio by the percentage of winning trades and subtracting the percentage of losing trades, which is calculated as follows:</p> <pre><code>Expectancy Ratio = (Risk Reward Ratio X Win Rate) \u2013 Loss Rate = (R X W) \u2013 L\n</code></pre> <p>So lets say your Win rate is 28% and your Risk Reward Ratio is 5:</p> <pre><code>Expectancy = (5 X 0.28) \u2013 0.72 = 0.68\n</code></pre> <p>Superficially, this means that on average you expect this strategy\u2019s trades to return .68 times the size of your loses. This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ.</p> <p>It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future.</p> <p>You can also use this value to evaluate the effectiveness of modifications to this system.</p> <p>NOTICE: It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology, but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades.</p>"},{"location":"edge/#how-does-it-work","title":"How does it work?","text":"<p>If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example:</p> Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 <p>The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at 3% leads to the maximum expectancy according to historical data.</p> <p>Edge module then forces stoploss value it evaluated to your strategy dynamically.</p>"},{"location":"edge/#position-size","title":"Position size","text":"<p>Edge also dictates the stake amount for each trade to the bot according to the following factors:</p> <ul> <li>Allowed capital at risk</li> <li>Stoploss</li> </ul> <p>Allowed capital at risk is calculated as follows:</p> <pre><code>Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade)\n</code></pre> <p>Stoploss is calculated as described above against historical data.</p> <p>Your position size then will be:</p> <pre><code>Position size = (Allowed capital at risk) / Stoploss\n</code></pre> <p>Example:</p> <p>Let's say the stake currency is ETH and you have 10 ETH on the exchange, your capital available percentage is 50% and you would allow 1% of risk for each trade. thus your available capital for trading is 10 x 0.5 = 5 ETH and allowed capital at risk would be 5 x 0.01 = 0.05 ETH.</p> <p>Let's assume Edge has calculated that for XLM/ETH market your stoploss should be at 2%. So your position size will be 0.05 / 0.02 = 2.5 ETH.</p> <p>Bot takes a position of 2.5 ETH on XLM/ETH (call it trade 1). Up next, you receive another buy signal while trade 1 is still open. This time on BTC/ETH market. Edge calculated stoploss for this market at 4%. So your position size would be 0.05 / 0.04 = 1.25 ETH (call it trade 2).</p> <p>Note that available capital for trading didn\u2019t change for trade 2 even if you had already trade 1. The available capital doesn\u2019t mean the free amount on your wallet.</p> <p>Now you have two trades open. The bot receives yet another buy signal for another market: ADA/ETH. This time the stoploss is calculated at 1%. So your position size is 0.05 / 0.01 = 5 ETH. But there are already 3.75 ETH blocked in two previous trades. So the position size for this third trade would be 5 \u2013 3.75 = 1.25 ETH.</p> <p>Available capital doesn\u2019t change before a position is sold. Let\u2019s assume that trade 1 receives a sell signal and it is sold with a profit of 1 ETH. Your total capital on exchange would be 11 ETH and the available capital for trading becomes 5.5 ETH.</p> <p>So the Bot receives another buy signal for trade 4 with a stoploss at 2% then your position size would be 0.055 / 0.02 = 2.75 ETH.</p>"},{"location":"edge/#configurations","title":"Configurations","text":"<p>Edge module has following configuration options:</p>"},{"location":"edge/#enabled","title":"enabled","text":"<p>If true, then Edge will run periodically.</p> <p>(defaults to false)</p>"},{"location":"edge/#process_throttle_secs","title":"process_throttle_secs","text":"<p>How often should Edge run in seconds?</p> <p>(defaults to 3600 so one hour)</p>"},{"location":"edge/#calculate_since_number_of_days","title":"calculate_since_number_of_days","text":"<p>Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy Note that it downloads historical data so increasing this number would lead to slowing down the bot.</p> <p>(defaults to 7)</p>"},{"location":"edge/#capital_available_percentage","title":"capital_available_percentage","text":"<p>This is the percentage of the total capital on exchange in stake currency.</p> <p>As an example if you have 10 ETH available in your wallet on the exchange and this value is 0.5 (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers it as available capital.</p> <p>(defaults to 0.5)</p>"},{"location":"edge/#allowed_risk","title":"allowed_risk","text":"<p>Percentage of allowed risk per trade.</p> <p>(defaults to 0.01 so 1%)</p>"},{"location":"edge/#stoploss_range_min","title":"stoploss_range_min","text":"<p>Minimum stoploss.</p> <p>(defaults to -0.01)</p>"},{"location":"edge/#stoploss_range_max","title":"stoploss_range_max","text":"<p>Maximum stoploss.</p> <p>(defaults to -0.10)</p>"},{"location":"edge/#stoploss_range_step","title":"stoploss_range_step","text":"<p>As an example if this is set to -0.01 then Edge will test the strategy for [-0.01, -0,02, -0,03 ..., -0.09, -0.10] ranges. Note than having a smaller step means having a bigger range which could lead to slow calculation.</p> <p>If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10.</p> <p>(defaults to -0.01)</p>"},{"location":"edge/#minimum_winrate","title":"minimum_winrate","text":"<p>It filters out pairs which don't have at least minimum_winrate.</p> <p>This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio.</p> <p>(defaults to 0.60)</p>"},{"location":"edge/#minimum_expectancy","title":"minimum_expectancy","text":"<p>It filters out pairs which have the expectancy lower than this number.</p> <p>Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return.</p> <p>(defaults to 0.20)</p>"},{"location":"edge/#min_trade_number","title":"min_trade_number","text":"<p>When calculating W, R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable.</p> <p>Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something.</p> <p>(defaults to 10, it is highly recommended not to decrease this number)</p>"},{"location":"edge/#max_trade_duration_minute","title":"max_trade_duration_minute","text":"<p>Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign.</p> <p>NOTICE: While configuring this value, you should take into consideration your ticker interval. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.).</p> <p>(defaults to 1 day, i.e. to 60 * 24 = 1440 minutes)</p>"},{"location":"edge/#remove_pumps","title":"remove_pumps","text":"<p>Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off.</p> <p>(defaults to false)</p>"},{"location":"edge/#running-edge-independently","title":"Running Edge independently","text":"<p>You can run Edge independently in order to see in details the result. Here is an example:</p> <pre><code>freqtrade edge\n</code></pre> <p>An example of its output:</p> pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59"},{"location":"edge/#update-cached-pairs-with-the-latest-data","title":"Update cached pairs with the latest data","text":"<pre><code>freqtrade edge --refresh-pairs-cached\n</code></pre>"},{"location":"edge/#precising-stoploss-range","title":"Precising stoploss range","text":"<pre><code>freqtrade edge --stoplosses=-0.01,-0.1,-0.001 #min,max,step\n</code></pre>"},{"location":"edge/#advanced-use-of-timerange","title":"Advanced use of timerange","text":"<pre><code>freqtrade edge --timerange=20181110-20181113\n</code></pre> <p>Doing <code>--timerange=-200</code> will get the last 200 timeframes from your inputdata. You can also specify specific dates, or a range span indexed by start and stop.</p> <p>The full timerange specification:</p> <ul> <li>Use last 123 tickframes of data: <code>--timerange=-123</code></li> <li>Use first 123 tickframes of data: <code>--timerange=123-</code></li> <li>Use tickframes from line 123 through 456: <code>--timerange=123-456</code></li> <li>Use tickframes till 2018/01/31: <code>--timerange=-20180131</code></li> <li>Use tickframes since 2018/01/31: <code>--timerange=20180131-</code></li> <li>Use tickframes since 2018/01/31 till 2018/03/01 : <code>--timerange=20180131-20180301</code></li> <li>Use tickframes between POSIX timestamps 1527595200 1527618600: <code>--timerange=1527595200-1527618600</code></li> </ul>"},{"location":"faq/","title":"Freqtrade FAQ","text":""},{"location":"faq/#freqtrade-common-issues","title":"Freqtrade common issues","text":""},{"location":"faq/#the-bot-does-not-start","title":"The bot does not start","text":"<p>Running the bot with <code>freqtrade --config config.json</code> does show the output <code>freqtrade: command not found</code>.</p> <p>This could have the following reasons:</p> <ul> <li>The virtual environment is not active</li> <li>run <code>source .env/bin/activate</code> to activate the virtual environment</li> <li>The installation did not work correctly.</li> <li>Please check the Installation documentation.</li> </ul>"},{"location":"faq/#i-have-waited-5-minutes-why-hasnt-the-bot-made-any-trades-yet","title":"I have waited 5 minutes, why hasn't the bot made any trades yet?!","text":"<p>Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find good entry position for a trade. Be patient!</p>"},{"location":"faq/#i-have-made-12-trades-already-why-is-my-total-profit-negative","title":"I have made 12 trades already, why is my total profit negative?!","text":"<p>I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that our current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades.</p>"},{"location":"faq/#id-like-to-change-the-stake-amount-can-i-just-stop-the-bot-with-stop-and-then-change-the-configjson-and-run-it-again","title":"I\u2019d like to change the stake amount. Can I just stop the bot with /stop and then change the config.json and run it again?","text":"<p>Not quite. Trades are persisted to a database but the configuration is currently only read when the bot is killed and restarted. <code>/stop</code> more like pauses. You can stop your bot, adjust settings and start it again.</p>"},{"location":"faq/#i-want-to-improve-the-bot-with-a-new-strategy","title":"I want to improve the bot with a new strategy","text":"<p>That's great. We have a nice backtesting and hyperoptimizing setup. See the tutorial here|Testing-new-strategies-with-Hyperopt.</p>"},{"location":"faq/#is-there-a-setting-to-only-sell-the-coins-being-held-and-not-perform-anymore-buys","title":"Is there a setting to only SELL the coins being held and not perform anymore BUYS?","text":"<p>You can use the <code>/forcesell all</code> command from Telegram.</p>"},{"location":"faq/#hyperopt-module","title":"Hyperopt module","text":""},{"location":"faq/#how-many-epoch-do-i-need-to-get-a-good-hyperopt-result","title":"How many epoch do I need to get a good Hyperopt result?","text":"<p>Per default Hyperopts without <code>-e</code> or <code>--epochs</code> parameter will only run 100 epochs, means 100 evals of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10.000 or more. But it will take an eternity to compute.</p> <p>We recommend you to run it at least 10.000 epochs:</p> <pre><code>freqtrade hyperopt -e 10000\n</code></pre> <p>or if you want intermediate result to see</p> <pre><code>for i in {1..100}; do freqtrade hyperopt -e 100; done\n</code></pre>"},{"location":"faq/#why-it-is-so-long-to-run-hyperopt","title":"Why it is so long to run hyperopt?","text":"<p>Finding a great Hyperopt results takes time.</p> <p>If you wonder why it takes a while to find great hyperopt results</p> <p>This answer was written during the under the release 0.15.1, when we had:</p> <ul> <li>8 triggers</li> <li>9 guards: let's say we evaluate even 10 values from each</li> <li>1 stoploss calculation: let's say we want 10 values from that too to be evaluated</li> </ul> <p>The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evals. Did you run 100 000 evals? Congrats, you've done roughly 1 / 100 000 th of the search space.</p>"},{"location":"faq/#edge-module","title":"Edge module","text":""},{"location":"faq/#edge-implements-interesting-approach-for-controlling-position-size-is-there-any-theory-behind-it","title":"Edge implements interesting approach for controlling position size, is there any theory behind it?","text":"<p>The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members.</p> <p>You can find further info on expectancy, winrate, risk management and position size in the following sources:</p> <ul> <li>https://www.tradeciety.com/ultimate-math-guide-for-traders/</li> <li>http://www.vantharp.com/tharp-concepts/expectancy.asp</li> <li>https://samuraitradingacademy.com/trading-expectancy/</li> <li>https://www.learningmarkets.com/determining-expectancy-in-your-trading/</li> <li>http://www.lonestocktrader.com/make-money-trading-positive-expectancy/</li> <li>https://www.babypips.com/trading/trade-expectancy-matter</li> </ul>"},{"location":"hyperopt/","title":"Hyperopt","text":"<p>This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses several algorithms included in the <code>scikit-optimize</code> package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time.</p> <p>Bug</p> <p>Hyperopt will crash when used with only 1 CPU Core as found out in Issue #1133</p>"},{"location":"hyperopt/#prepare-hyperopting","title":"Prepare Hyperopting","text":"<p>Before we start digging into Hyperopt, we recommend you to take a look at an example hyperopt file located into user_data/hyperopts/</p> <p>Configuring hyperopt is similar to writing your own strategy, and many tasks will be similar and a lot of code can be copied across from the strategy.</p>"},{"location":"hyperopt/#checklist-on-all-tasks-possibilities-in-hyperopt","title":"Checklist on all tasks / possibilities in hyperopt","text":"<p>Depending on the space you want to optimize, only some of the below are required.</p> <ul> <li>fill <code>populate_indicators</code> - probably a copy from your strategy</li> <li>fill <code>buy_strategy_generator</code> - for buy signal optimization</li> <li>fill <code>indicator_space</code> - for buy signal optimzation</li> <li>fill <code>sell_strategy_generator</code> - for sell signal optimization</li> <li>fill <code>sell_indicator_space</code> - for sell signal optimzation</li> <li>fill <code>roi_space</code> - for ROI optimization</li> <li>fill <code>generate_roi_table</code> - for ROI optimization (if you need more than 3 entries)</li> <li>fill <code>stoploss_space</code> - stoploss optimization</li> <li>Optional but recommended</li> <li>copy <code>populate_buy_trend</code> from your strategy - otherwise default-strategy will be used</li> <li>copy <code>populate_sell_trend</code> from your strategy - otherwise default-strategy will be used</li> </ul>"},{"location":"hyperopt/#1-install-a-custom-hyperopt-file","title":"1. Install a Custom Hyperopt File","text":"<p>Put your hyperopt file into the directory <code>user_data/hyperopts</code>.</p> <p>Let assume you want a hyperopt file <code>awesome_hyperopt.py</code>: Copy the file <code>user_data/hyperopts/sample_hyperopt.py</code> into <code>user_data/hyperopts/awesome_hyperopt.py</code></p>"},{"location":"hyperopt/#2-configure-your-guards-and-triggers","title":"2. Configure your Guards and Triggers","text":"<p>There are two places you need to change in your hyperopt file to add a new buy hyperopt for testing:</p> <ul> <li>Inside <code>indicator_space()</code> - the parameters hyperopt shall be optimizing.</li> <li>Inside <code>populate_buy_trend()</code> - applying the parameters.</li> </ul> <p>There you have two different types of indicators: 1. <code>guards</code> and 2. <code>triggers</code>.</p> <ol> <li>Guards are conditions like \"never buy if ADX &lt; 10\", or never buy if current price is over EMA10.</li> <li>Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower bollinger band\".</li> </ol> <p>Hyperoptimization will, for each eval round, pick one trigger and possibly multiple guards. The constructed strategy will be something like \"buy exactly when close price touches lower bollinger band, BUT only if ADX &gt; 10\".</p> <p>If you have updated the buy strategy, ie. changed the contents of <code>populate_buy_trend()</code> method you have to update the <code>guards</code> and <code>triggers</code> hyperopts must use.</p>"},{"location":"hyperopt/#sell-optimization","title":"Sell optimization","text":"<p>Similar to the buy-signal above, sell-signals can also be optimized. Place the corresponding settings into the following methods</p> <ul> <li>Inside <code>sell_indicator_space()</code> - the parameters hyperopt shall be optimizing.</li> <li>Inside <code>populate_sell_trend()</code> - applying the parameters.</li> </ul> <p>The configuration and rules are the same than for buy signals. To avoid naming collisions in the search-space, please prefix all sell-spaces with <code>sell-</code>.</p>"},{"location":"hyperopt/#using-ticker-interval-as-part-of-the-strategy","title":"Using ticker-interval as part of the Strategy","text":"<p>The Strategy exposes the ticker-interval as <code>self.ticker_interval</code>. The same value is available as class-attribute <code>HyperoptName.ticker_interval</code>. In the case of the linked sample-value this would be <code>SampleHyperOpts.ticker_interval</code>.</p>"},{"location":"hyperopt/#solving-a-mystery","title":"Solving a Mystery","text":"<p>Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your buys. And you also wonder should you use RSI or ADX to help with those buy decisions. If you decide to use RSI or ADX, which values should I use for them? So let's use hyperparameter optimization to solve this mystery.</p> <p>We will start by defining a search space:</p> <pre><code>    def indicator_space() -&gt; List[Dimension]:\n        \"\"\"\n        Define your Hyperopt space for searching strategy parameters\n        \"\"\"\n        return [\n            Integer(20, 40, name='adx-value'),\n            Integer(20, 40, name='rsi-value'),\n            Categorical([True, False], name='adx-enabled'),\n            Categorical([True, False], name='rsi-enabled'),\n            Categorical(['bb_lower', 'macd_cross_signal'], name='trigger')\n        ]\n</code></pre> <p>Above definition says: I have five parameters I want you to randomly combine to find the best combination. Two of them are integer values (<code>adx-value</code> and <code>rsi-value</code>) and I want you test in the range of values 20 to 40. Then we have three category variables. First two are either <code>True</code> or <code>False</code>. We use these to either enable or disable the ADX and RSI guards. The last one we call <code>trigger</code> and use it to decide which buy trigger we want to use.</p> <p>So let's write the buy strategy using these values:</p> <pre><code>        def populate_buy_trend(dataframe: DataFrame) -&gt; DataFrame:\n            conditions = []\n            # GUARDS AND TRENDS\n            if 'adx-enabled' in params and params['adx-enabled']:\n                conditions.append(dataframe['adx'] &gt; params['adx-value'])\n            if 'rsi-enabled' in params and params['rsi-enabled']:\n                conditions.append(dataframe['rsi'] &lt; params['rsi-value'])\n\n            # TRIGGERS\n            if 'trigger' in params:\n                if params['trigger'] == 'bb_lower':\n                    conditions.append(dataframe['close'] &lt; dataframe['bb_lowerband'])\n                if params['trigger'] == 'macd_cross_signal':\n                    conditions.append(qtpylib.crossed_above(\n                        dataframe['macd'], dataframe['macdsignal']\n                    ))\n\n            if conditions:\n                dataframe.loc[\n                    reduce(lambda x, y: x &amp; y, conditions),\n                    'buy'] = 1\n\n            return dataframe\n\n        return populate_buy_trend\n</code></pre> <p>Hyperopting will now call this <code>populate_buy_trend</code> as many times you ask it (<code>epochs</code>) with different value combinations. It will then use the given historical data and make buys based on the buy signals generated with the above function and based on the results it will end with telling you which paramter combination produced the best profits.</p> <p>The search for best parameters starts with a few random combinations and then uses a regressor algorithm (currently ExtraTreesRegressor) to quickly find a parameter combination that minimizes the value of the loss function.</p> <p>The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the <code>populate_indicators()</code> method in <code>hyperopt.py</code>.</p>"},{"location":"hyperopt/#loss-functions","title":"Loss-functions","text":"<p>Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results.</p> <p>By default, FreqTrade uses a loss function, which has been with freqtrade since the beginning and optimizes mostly for short trade duration and avoiding losses.</p> <p>A different loss function can be specified by using the <code>--hyperopt-loss &lt;Class-name&gt;</code> argument. This class should be in its own file within the <code>user_data/hyperopts/</code> directory.</p> <p>Currently, the following loss functions are builtin: <code>DefaultHyperOptLoss</code> (default legacy Freqtrade hyperoptimization loss function), <code>SharpeHyperOptLoss</code> (optimizes Sharpe Ratio calculated on the trade returns) and <code>OnlyProfitHyperOptLoss</code> (which takes only amount of profit into consideration).</p>"},{"location":"hyperopt/#creating-and-using-a-custom-loss-function","title":"Creating and using a custom loss function","text":"<p>To use a custom loss function class, make sure that the function <code>hyperopt_loss_function</code> is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter <code>--hyperopt-loss SuperDuperHyperOptLoss</code> to your hyperopt call so this fuction is being used.</p> <p>A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found user_data/hyperopts/</p> <pre><code>from freqtrade.optimize.hyperopt import IHyperOptLoss\n\nTARGET_TRADES = 600\nEXPECTED_MAX_PROFIT = 3.0\nMAX_ACCEPTED_TRADE_DURATION = 300\n\nclass SuperDuperHyperOptLoss(IHyperOptLoss):\n    \"\"\"\n    Defines the default loss function for hyperopt\n    \"\"\"\n\n    @staticmethod\n    def hyperopt_loss_function(results: DataFrame, trade_count: int,\n                               min_date: datetime, max_date: datetime,\n                               *args, **kwargs) -&gt; float:\n        \"\"\"\n        Objective function, returns smaller number for better results\n        This is the legacy algorithm (used until now in freqtrade).\n        Weights are distributed as follows:\n        * 0.4 to trade duration\n        * 0.25: Avoiding trade loss\n        * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above\n        \"\"\"\n        total_profit = results.profit_percent.sum()\n        trade_duration = results.trade_duration.mean()\n\n        trade_loss = 1 - 0.25 * exp(-(trade_count - TARGET_TRADES) ** 2 / 10 ** 5.8)\n        profit_loss = max(0, 1 - total_profit / EXPECTED_MAX_PROFIT)\n        duration_loss = 0.4 * min(trade_duration / MAX_ACCEPTED_TRADE_DURATION, 1)\n        result = trade_loss + profit_loss + duration_loss\n        return result\n</code></pre> <p>Currently, the arguments are:</p> <ul> <li><code>results</code>: DataFrame containing the result     The following columns are available in results (corresponds to the output-file of backtesting when used with <code>--export trades</code>): <code>pair, profit_percent, profit_abs, open_time, close_time, open_index, close_index, trade_duration, open_at_end, open_rate, close_rate, sell_reason</code></li> <li><code>trade_count</code>: Amount of trades (identical to <code>len(results)</code>)</li> <li><code>min_date</code>: Start date of the hyperopting TimeFrame</li> <li><code>min_date</code>: End date of the hyperopting TimeFrame</li> </ul> <p>This function needs to return a floating point number (<code>float</code>). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you.</p> <p>Note</p> <p>This function is called once per iteration - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily.</p> <p>Note</p> <p>Please keep the arguments <code>*args</code> and <code>**kwargs</code> in the interface to allow us to extend this interface later.</p>"},{"location":"hyperopt/#execute-hyperopt","title":"Execute Hyperopt","text":"<p>Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result. More time usually results in better results.</p> <p>We strongly recommend to use <code>screen</code> or <code>tmux</code> to prevent any connection loss.</p> <pre><code>freqtrade -c config.json hyperopt --customhyperopt &lt;hyperoptname&gt; -e 5000 --spaces all\n</code></pre> <p>Use  <code>&lt;hyperoptname&gt;</code> as the name of the custom hyperopt used.</p> <p>The <code>-e</code> flag will set how many evaluations hyperopt will do. We recommend running at least several thousand evaluations.</p> <p>The <code>--spaces all</code> flag determines that all possible parameters should be optimized. Possibilities are listed below.</p> <p>Note</p> <p>By default, hyperopt will erase previous results and start from scratch. Continuation can be archived by using <code>--continue</code>.</p> <p>Warning</p> <p>When switching parameters or changing configuration options, make sure to not use the argument <code>--continue</code> so temporary results can be removed.</p>"},{"location":"hyperopt/#execute-hyperopt-with-different-ticker-data-source","title":"Execute Hyperopt with Different Ticker-Data Source","text":"<p>If you would like to hyperopt parameters using an alternate ticker data that you have on-disk, use the <code>--datadir PATH</code> option. Default hyperopt will use data from directory <code>user_data/data</code>.</p>"},{"location":"hyperopt/#running-hyperopt-with-smaller-testset","title":"Running Hyperopt with Smaller Testset","text":"<p>Use the <code>--timerange</code> argument to change how much of the testset you want to use. For example, to use one month of data, pass the following parameter to the hyperopt call:</p> <pre><code>freqtrade hyperopt --timerange 20180401-20180501\n</code></pre>"},{"location":"hyperopt/#running-hyperopt-with-smaller-search-space","title":"Running Hyperopt with Smaller Search Space","text":"<p>Use the <code>--spaces</code> argument to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have.</p> <p>Legal values are:</p> <ul> <li><code>all</code>: optimize everything</li> <li><code>buy</code>: just search for a new buy strategy</li> <li><code>sell</code>: just search for a new sell strategy</li> <li><code>roi</code>: just optimize the minimal profit table for your strategy</li> <li><code>stoploss</code>: search for the best stoploss value</li> <li>space-separated list of any of the above values for example <code>--spaces roi stoploss</code></li> </ul>"},{"location":"hyperopt/#position-stacking-and-disabling-max-market-positions","title":"Position stacking and disabling max market positions","text":"<p>In some situations, you may need to run Hyperopt (and Backtesting) with the  <code>--eps</code>/<code>--enable-position-staking</code> and <code>--dmmp</code>/<code>--disable-max-market-positions</code> arguments.</p> <p>By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs  is also limited by the <code>max_open_trades</code> setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previosly open trades.</p> <p>The <code>--eps</code>/<code>--enable-position-stacking</code> argument allows emulation of buying the same pair multiple times, while <code>--dmmp</code>/<code>--disable-max-market-positions</code> disables applying <code>max_open_trades</code>  during Hyperopt/Backtesting (which is equal to setting <code>max_open_trades</code> to a very high number).</p> <p>Note</p> <p>Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality.</p> <p>You can also enable position stacking in the configuration file by explicitly setting  <code>\"position_stacking\"=true</code>.</p>"},{"location":"hyperopt/#understand-the-hyperopt-result","title":"Understand the Hyperopt Result","text":"<p>Once Hyperopt is completed you can use the result to create a new strategy. Given the following result from hyperopt:</p> <pre><code>Best result:\n   135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722\u03a3%). Avg duration 180.4 mins.\nwith values:\n{    'adx-value': 44,\n     'rsi-value': 29,\n     'adx-enabled': False,\n     'rsi-enabled': True,\n     'trigger': 'bb_lower'}\n</code></pre> <p>You should understand this result like:</p> <ul> <li>The buy trigger that worked best was <code>bb_lower</code>.</li> <li>You should not use ADX because <code>adx-enabled: False</code>)</li> <li>You should consider using the RSI indicator (<code>rsi-enabled: True</code> and the best value is <code>29.0</code> (<code>rsi-value: 29.0</code>)</li> </ul> <p>You have to look inside your strategy file into <code>buy_strategy_generator()</code> method, what those values match to.</p> <p>So for example you had <code>rsi-value: 29.0</code> so we would look at <code>rsi</code>-block, that translates to the following code block:</p> <pre><code>(dataframe['rsi'] &lt; 29.0)\n</code></pre> <p>Translating your whole hyperopt result as the new buy-signal would then look like:</p> <pre><code>def populate_buy_trend(self, dataframe: DataFrame) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (dataframe['rsi'] &lt; 29.0) &amp;  # rsi-value\n            dataframe['close'] &lt; dataframe['bb_lowerband']  # trigger\n        ),\n        'buy'] = 1\n    return dataframe\n</code></pre>"},{"location":"hyperopt/#understand-hyperopt-roi-results","title":"Understand Hyperopt ROI results","text":"<p>If you are optimizing ROI, you're result will look as follows and include a ROI table.</p> <pre><code>Best result:\n   135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722\u03a3%). Avg duration 180.4 mins.\nwith values:\n{   'adx-value': 44,\n    'rsi-value': 29,\n    'adx-enabled': false,\n    'rsi-enabled': True,\n    'trigger': 'bb_lower',\n    'roi_t1': 40,\n    'roi_t2': 57,\n    'roi_t3': 21,\n    'roi_p1': 0.03634636907306948,\n    'roi_p2': 0.055237357937802885,\n    'roi_p3': 0.015163796015548354,\n    'stoploss': -0.37996664668703606\n}\nROI table:\n{   0: 0.10674752302642071,\n    21: 0.09158372701087236,\n    78: 0.03634636907306948,\n    118: 0}\n</code></pre> <p>This would translate to the following ROI table:</p> <pre><code> minimal_roi = {\n        \"118\": 0,\n        \"78\": 0.0363463,\n        \"21\": 0.0915,\n        \"0\": 0.106\n    }\n</code></pre>"},{"location":"hyperopt/#validate-backtesting-results","title":"Validate backtesting results","text":"<p>Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected.</p> <p>To achieve same results (number of trades, their durations, profit, etc.) than during Hyperopt, please use same set of arguments <code>--dmmp</code>/<code>--disable-max-market-positions</code> and <code>--eps</code>/<code>--enable-position-stacking</code> for Backtesting.</p>"},{"location":"hyperopt/#next-step","title":"Next Step","text":"<p>Now you have a perfect bot and want to control it from Telegram. Your next step is to learn the Telegram usage.</p>"},{"location":"installation/","title":"Installation","text":"<p>This page explains how to prepare your environment for running the bot.</p>"},{"location":"installation/#prerequisite","title":"Prerequisite","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>Click each one for install guide:</p> <ul> <li>Python &gt;= 3.6.x</li> <li>pip</li> <li>git</li> <li>virtualenv (Recommended)</li> <li>TA-Lib (install instructions below)</li> </ul>"},{"location":"installation/#api-keys","title":"API keys","text":"<p>Before running your bot in production you will need to setup few external API. In production mode, the bot will require valid Exchange API credentials. We also recommend a Telegram bot (optional but recommended).</p>"},{"location":"installation/#setup-your-exchange-account","title":"Setup your exchange account","text":"<p>You will need to create API Keys (Usually you get <code>key</code> and <code>secret</code>) from the Exchange website and insert this into the appropriate fields in the configuration or when asked by the installation script.</p>"},{"location":"installation/#quick-start","title":"Quick start","text":"<p>Freqtrade provides a Linux/MacOS script to install all dependencies and help you to configure the bot.</p> <p>Note</p> <p>Python3.6 or higher and the corresponding pip are assumed to be available. The install-script will warn and stop if that's not the case.</p> <pre><code>git clone git@github.com:freqtrade/freqtrade.git\ncd freqtrade\ngit checkout develop\n./setup.sh --install\n</code></pre> <p>Note</p> <p>Windows installation is explained here.</p>"},{"location":"installation/#easy-installation-linux-script","title":"Easy Installation - Linux Script","text":"<p>If you are on Debian, Ubuntu or MacOS freqtrade provides a script to Install, Update, Configure, and Reset your bot.</p> <pre><code>$ ./setup.sh\nusage:\n    -i,--install    Install freqtrade from scratch\n    -u,--update     Command git pull to update.\n    -r,--reset      Hard reset your develop/master branch.\n    -c,--config     Easy config generator (Will override your existing file).\n</code></pre> <p>** --install **</p> <p>This script will install everything you need to run the bot:</p> <ul> <li>Mandatory software as: <code>ta-lib</code></li> <li>Setup your virtualenv</li> <li>Configure your <code>config.json</code> file</li> </ul> <p>This script is a combination of <code>install script</code> <code>--reset</code>, <code>--config</code></p> <p>** --update **</p> <p>Update parameter will pull the last version of your current branch and update your virtualenv.</p> <p>** --reset **</p> <p>Reset parameter will hard reset your branch (only if you are on <code>master</code> or <code>develop</code>) and recreate your virtualenv.</p> <p>** --config **</p> <p>Config parameter is a <code>config.json</code> configurator. This script will ask you questions to setup your bot and create your <code>config.json</code>.</p>"},{"location":"installation/#custom-installation","title":"Custom Installation","text":"<p>We've included/collected install instructions for Ubuntu 16.04, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the Common section below is necessary for all systems.</p> <p>Note</p> <p>Python3.6 or higher and the corresponding pip are assumed to be available.</p>"},{"location":"installation/#linux-ubuntu-1604","title":"Linux - Ubuntu 16.04","text":""},{"location":"installation/#install-necessary-dependencies","title":"Install necessary dependencies","text":"<pre><code>sudo apt-get update\nsudo apt-get install build-essential git\n</code></pre>"},{"location":"installation/#raspberry-pi-raspbian","title":"Raspberry Pi / Raspbian","text":"<p>Before installing FreqTrade on a Raspberry Pi running the official Raspbian Image, make sure you have at least Python 3.6 installed. The default image only provides Python 3.5. Probably the easiest way to get a recent version of python is miniconda.</p> <p>The following assumes that miniconda3 is installed and available in your environment. Last miniconda3 installation file use python 3.4, we will update to python 3.6 on this installation. It's recommended to use (mini)conda for this as installation/compilation of <code>numpy</code>, <code>scipy</code> and <code>pandas</code> takes a long time.</p> <p>Additional package to install on your Raspbian, <code>libffi-dev</code> required by cryptography (from python-telegram-bot).</p> <pre><code>conda config --add channels rpi\nconda install python=3.6\nconda create -n freqtrade python=3.6\nconda activate freqtrade\nconda install scipy pandas numpy\n\nsudo apt install libffi-dev\npython3 -m pip install -r requirements-common.txt\npython3 -m pip install -e .\n</code></pre>"},{"location":"installation/#common","title":"Common","text":""},{"location":"installation/#1-install-ta-lib","title":"1. Install TA-Lib","text":"<p>Official webpage: https://mrjbq7.github.io/ta-lib/install.html</p> <pre><code>wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz\ntar xvzf ta-lib-0.4.0-src.tar.gz\ncd ta-lib\nsed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h\n./configure --prefix=/usr/local\nmake\nsudo make install\ncd ..\nrm -rf ./ta-lib*\n</code></pre> <p>Note</p> <p>An already downloaded version of ta-lib is included in the repository, as the sourceforge.net source seems to have problems frequently.</p>"},{"location":"installation/#2-setup-your-python-virtual-environment-virtualenv","title":"2. Setup your Python virtual environment (virtualenv)","text":"<p>Note</p> <p>This step is optional but strongly recommended to keep your system organized</p> <pre><code>python3 -m venv .env\nsource .env/bin/activate\n</code></pre>"},{"location":"installation/#3-install-freqtrade","title":"3. Install FreqTrade","text":"<p>Clone the git repository:</p> <pre><code>git clone https://github.com/freqtrade/freqtrade.git\n</code></pre> <p>Optionally checkout the master branch to get the latest stable release:</p> <pre><code>git checkout master\n</code></pre>"},{"location":"installation/#4-initialize-the-configuration","title":"4. Initialize the configuration","text":"<pre><code>cd freqtrade\ncp config.json.example config.json\n</code></pre> <p>To edit the config please refer to Bot Configuration.</p>"},{"location":"installation/#5-install-python-dependencies","title":"5. Install python dependencies","text":"<pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install -r requirements.txt\npython3 -m pip install -e .\n</code></pre>"},{"location":"installation/#6-run-the-bot","title":"6. Run the Bot","text":"<p>If this is the first time you run the bot, ensure you are running it in Dry-run <code>\"dry_run\": true,</code> otherwise it will start to buy and sell coins.</p> <pre><code>freqtrade -c config.json\n</code></pre> <p>Note: If you run the bot on a server, you should consider using Docker or a terminal multiplexer like <code>screen</code> or <code>tmux</code> to avoid that the bot is stopped on logout.</p>"},{"location":"installation/#7-optional-configure-freqtrade-as-a-systemd-service","title":"7. [Optional] Configure <code>freqtrade</code> as a <code>systemd</code> service","text":"<p>From the freqtrade repo... copy <code>freqtrade.service</code> to your systemd user directory (usually <code>~/.config/systemd/user</code>) and update <code>WorkingDirectory</code> and <code>ExecStart</code> to match your setup.</p> <p>After that you can start the daemon with:</p> <pre><code>systemctl --user start freqtrade\n</code></pre> <p>For this to be persistent (run when user is logged out) you'll need to enable <code>linger</code> for your freqtrade user.</p> <pre><code>sudo loginctl enable-linger \"$USER\"\n</code></pre> <p>If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot  state and restarting it in the case of failures. If the <code>internals.sd_notify</code> parameter is set to true in the  configuration or the <code>--sd-notify</code> command line option is used, the bot will send keep-alive ping messages to systemd  using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped)  when it changes. </p> <p>The <code>freqtrade.service.watchdog</code> file contains an example of the service unit configuration file which uses systemd  as the watchdog.</p> <p>Note</p> <p>The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container.</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>We recommend that Windows users use Docker as this will work much easier and smoother (also more secure).</p> <p>If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. If that is not available on your system, feel free to try the instructions below, which led to success for some.</p>"},{"location":"installation/#install-freqtrade-manually","title":"Install freqtrade manually","text":""},{"location":"installation/#clone-the-git-repository","title":"Clone the git repository","text":"<pre><code>git clone https://github.com/freqtrade/freqtrade.git\n</code></pre>"},{"location":"installation/#install-ta-lib","title":"Install ta-lib","text":"<p>Install ta-lib according to the ta-lib documentation.</p> <p>As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), there is also a repository of unofficial precompiled windows Wheels here, which needs to be downloaded and installed using <code>pip install TA_Lib\u20110.4.17\u2011cp36\u2011cp36m\u2011win32.whl</code> (make sure to use the version matching your python version)</p> <pre><code>&gt;cd \\path\\freqtrade-develop\n&gt;python -m venv .env\n&gt;cd .env\\Scripts\n&gt;activate.bat\n&gt;cd \\path\\freqtrade-develop\nREM optionally install ta-lib from wheel\nREM &gt;pip install TA_Lib\u20110.4.17\u2011cp36\u2011cp36m\u2011win32.whl\n&gt;pip install -r requirements.txt\n&gt;pip install -e .\n&gt;python freqtrade\\main.py\n</code></pre> <p>Thanks Owdr for the commands. Source: Issue #222</p>"},{"location":"installation/#error-during-installation-under-windows","title":"Error during installation under Windows","text":"<pre><code>error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools\n</code></pre> <p>Unfortunately, many packages requiring compilation don't provide a pre-build wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use.</p> <p>The easiest way is to download install Microsoft Visual Studio Community here and make sure to install \"Common Tools for Visual C++\" to enable building c code on Windows. Unfortunately, this is a heavy download / dependency (~4Gb) so you might want to consider WSL or docker first.</p> <p>Now you have an environment ready, the next step is Bot Configuration.</p>"},{"location":"plotting/","title":"Plotting","text":"<p>This page explains how to plot prices, indicators and profits.</p>"},{"location":"plotting/#installation","title":"Installation","text":"<p>Plotting scripts use Plotly library. Install/upgrade it with:</p> <pre><code>pip install -U -r requirements-plot.txt\n</code></pre>"},{"location":"plotting/#plot-price-and-indicators","title":"Plot price and indicators","text":"<p>Usage for the price plotter:</p> <pre><code>python3 script/plot_dataframe.py [-h] [-p pairs] [--live]\n</code></pre> <p>Example</p> <pre><code>python3 scripts/plot_dataframe.py -p BTC/ETH\n</code></pre> <p>The <code>-p</code> pairs argument can be used to specify pairs you would like to plot.</p> <p>Specify custom indicators. Use <code>--indicators1</code> for the main plot and <code>--indicators2</code> for the subplot below (if values are in a different range than prices).</p> <pre><code>python3 scripts/plot_dataframe.py -p BTC/ETH --indicators1 sma,ema --indicators2 macd\n</code></pre>"},{"location":"plotting/#advanced-use","title":"Advanced use","text":"<p>To plot multiple pairs, separate them with a comma:</p> <pre><code>python3 scripts/plot_dataframe.py -p BTC/ETH,XRP/ETH\n</code></pre> <p>To plot the current live price use the <code>--live</code> flag:</p> <pre><code>python3 scripts/plot_dataframe.py -p BTC/ETH --live\n</code></pre> <p>To plot a timerange (to zoom in):</p> <pre><code>python3 scripts/plot_dataframe.py -p BTC/ETH --timerange=100-200\n</code></pre> <p>Timerange doesn't work with live data.</p> <p>To plot trades stored in a database use <code>--db-url</code> argument:</p> <pre><code>python3 scripts/plot_dataframe.py --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB\n</code></pre> <p>To plot trades from a backtesting result, use <code>--export-filename &lt;filename&gt;</code></p> <pre><code>python3 scripts/plot_dataframe.py --export-filename user_data/backtest_data/backtest-result.json -p BTC/ETH\n</code></pre> <p>To plot a custom strategy the strategy should have first be backtested. The results may then be plotted with the -s argument:</p> <pre><code>python3 scripts/plot_dataframe.py -s Strategy_Name -p BTC/ETH --datadir user_data/data/&lt;exchange_name&gt;/\n</code></pre>"},{"location":"plotting/#plot-profit","title":"Plot profit","text":"<p>The profit plotter shows a picture with three plots:</p> <p>1) Average closing price for all pairs 2) The summarized profit made by backtesting.    Note that this is not the real-world profit, but    more of an estimate. 3) Each pair individually profit</p> <p>The first graph is good to get a grip of how the overall market progresses.</p> <p>The second graph will show how your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less seldom, but makes big swings.</p> <p>The third graph can be useful to spot outliers, events in pairs that makes profit spikes.</p> <p>Usage for the profit plotter:</p> <pre><code>python3 script/plot_profit.py [-h] [-p pair] [--datadir directory] [--ticker_interval num]\n</code></pre> <p>The <code>-p</code> pair argument, can be used to plot a single pair</p> <p>Example</p> <pre><code>python3 scripts/plot_profit.py --datadir ../freqtrade/freqtrade/tests/testdata-20171221/ -p LTC/BTC\n</code></pre>"},{"location":"rest-api/","title":"REST API Usage","text":""},{"location":"rest-api/#configuration","title":"Configuration","text":"<p>Enable the rest API by adding the api_server section to your configuration and setting <code>api_server.enabled</code> to <code>true</code>.</p> <p>Sample configuration:</p> <pre><code>    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"127.0.0.1\",\n        \"listen_port\": 8080,\n        \"username\": \"Freqtrader\",\n        \"password\": \"SuperSecret1!\"\n    },\n</code></pre> <p>Danger</p> <p>By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot.</p> <p>Danger</p> <p>Please make sure to select a very strong, unique password to protect your bot from unauthorized access.</p> <p>You can then access the API by going to <code>http://127.0.0.1:8080/api/v1/version</code> to check if the API is running correctly.</p> <p>To generate a secure password, either use a password manager, or use the below code snipped.</p> <pre><code>import secrets\nsecrets.token_hex()\n</code></pre>"},{"location":"rest-api/#configuration-with-docker","title":"Configuration with docker","text":"<p>If you run your bot using docker, you'll need to have the bot listen to incomming connections. The security is then handled by docker.</p> <pre><code>    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"0.0.0.0\",\n        \"listen_port\": 8080\n    },\n</code></pre> <p>Add the following to your docker command:</p> <pre><code>  -p 127.0.0.1:8080:8080\n</code></pre> <p>A complete sample-command may then look as follows:</p> <pre><code>docker run -d \\\n  --name freqtrade \\\n  -v ~/.freqtrade/config.json:/freqtrade/config.json \\\n  -v ~/.freqtrade/user_data/:/freqtrade/user_data \\\n  -v ~/.freqtrade/tradesv3.sqlite:/freqtrade/tradesv3.sqlite \\\n  -p 127.0.0.1:8080:8080 \\\n  freqtrade --db-url sqlite:///tradesv3.sqlite --strategy MyAwesomeStrategy\n</code></pre> <p>Security warning</p> <p>By using <code>-p 8080:8080</code> the API is available to everyone connecting to the server under the correct port, so others may be able to control your bot.</p>"},{"location":"rest-api/#consuming-the-api","title":"Consuming the API","text":"<p>You can consume the API by using the script <code>scripts/rest_client.py</code>. The client script only requires the <code>requests</code> module, so FreqTrade does not need to be installed on the system.</p> <pre><code>python3 scripts/rest_client.py &lt;command&gt; [optional parameters]\n</code></pre> <p>By default, the script assumes <code>127.0.0.1</code> (localhost) and port <code>8080</code> to be used, however you can specify a configuration file to override this behaviour.</p>"},{"location":"rest-api/#minimalistic-client-config","title":"Minimalistic client config","text":"<pre><code>{\n    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"0.0.0.0\",\n        \"listen_port\": 8080\n    }\n}\n</code></pre> <pre><code>python3 scripts/rest_client.py --config rest_config.json &lt;command&gt; [optional parameters]\n</code></pre>"},{"location":"rest-api/#available-commands","title":"Available commands","text":"Command Default Description <code>start</code> Starts the trader <code>stop</code> Stops the trader <code>stopbuy</code> Stops the trader from opening new trades. Gracefully closes open trades according to their rules. <code>reload_conf</code> Reloads the configuration file <code>status</code> Lists all open trades <code>status table</code> List all open trades in a table format <code>count</code> Displays number of trades used and available <code>profit</code> Display a summary of your profit/loss from close trades and some stats about your performance <code>forcesell &lt;trade_id&gt;</code> Instantly sells the given trade  (Ignoring <code>minimum_roi</code>). <code>forcesell all</code> Instantly sells all open trades (Ignoring <code>minimum_roi</code>). <code>forcebuy &lt;pair&gt; [rate]</code> Instantly buys the given pair. Rate is optional. (<code>forcebuy_enable</code> must be set to True) <code>performance</code> Show performance of each finished trade grouped by pair <code>balance</code> Show account balance per currency <code>daily &lt;n&gt;</code> 7 Shows profit or loss per day, over the last n days <code>whitelist</code> Show the current whitelist <code>blacklist [pair]</code> Show the current blacklist, or adds a pair to the blacklist. <code>edge</code> Show validated pairs by Edge if it is enabled. <code>version</code> Show version <p>Possible commands can be listed from the rest-client script using the <code>help</code> command.</p> <pre><code>python3 scripts/rest_client.py help\n</code></pre> <pre><code>Possible commands:\nbalance\n        Get the account balance\n        :returns: json object\n\nblacklist\n        Show the current blacklist\n        :param add: List of coins to add (example: \"BNB/BTC\")\n        :returns: json object\n\ncount\n        Returns the amount of open trades\n        :returns: json object\n\ndaily\n        Returns the amount of open trades\n        :returns: json object\n\nedge\n        Returns information about edge\n        :returns: json object\n\nforcebuy\n        Buy an asset\n        :param pair: Pair to buy (ETH/BTC)\n        :param price: Optional - price to buy\n        :returns: json object of the trade\n\nforcesell\n        Force-sell a trade\n        :param tradeid: Id of the trade (can be received via status command)\n        :returns: json object\n\nperformance\n        Returns the performance of the different coins\n        :returns: json object\n\nprofit\n        Returns the profit summary\n        :returns: json object\n\nreload_conf\n        Reload configuration\n        :returns: json object\n\nstart\n        Start the bot if it's in stopped state.\n        :returns: json object\n\nstatus\n        Get the status of open trades\n        :returns: json object\n\nstop\n        Stop the bot. Use start to restart\n        :returns: json object\n\nstopbuy\n        Stop buying (but handle sells gracefully).\n        use reload_conf to reset\n        :returns: json object\n\nversion\n        Returns the version of the bot\n        :returns: json object containing the version\n\nwhitelist\n        Show the current whitelist\n        :returns: json object\n</code></pre>"},{"location":"sandbox-testing/","title":"Sandbox API testing","text":"<p>Where an exchange provides a sandbox for risk-free integration, or end-to-end, testing CCXT provides access to these.</p> <p>This document is a *light overview of configuring Freqtrade and GDAX sandbox. This can be useful to developers and trader alike as Freqtrade is quite customisable.</p> <p>When testing your API connectivity, make sure to use the following URLs. Website* https://public.sandbox.gdax.com REST API* https://api-public.sandbox.gdax.com</p>"},{"location":"sandbox-testing/#configure-a-sandbox-account-on-gdax","title":"Configure a Sandbox account on Gdax","text":"<p>Aim of this document section</p> <ul> <li>An sanbox account</li> <li>create 2FA (needed to create an API)</li> <li>Add test 50BTC to account </li> <li>Create :</li> <li> <ul> <li>API-KEY</li> </ul> </li> <li> <ul> <li>API-Secret</li> </ul> </li> <li> <ul> <li>API Password</li> </ul> </li> </ul>"},{"location":"sandbox-testing/#acccount","title":"Acccount","text":"<p>This link will redirect to the sandbox main page to login / create account dialogues: https://public.sandbox.pro.coinbase.com/orders/</p> <p>After registration and Email confimation you wil be redirected into your sanbox account.  It is easy to verify you're in sandbox by checking the URL bar.</p> <p>https://public.sandbox.pro.coinbase.com/</p>"},{"location":"sandbox-testing/#enable-2fa-a-prerequisite-to-creating-sandbox-api-keys","title":"Enable 2Fa (a prerequisite to creating sandbox API Keys)","text":"<p>From within sand box site select your profile, top right.</p> <p>Or as a direct link: https://public.sandbox.pro.coinbase.com/profile</p> <p>From the menu panel to the left of the screen select</p> <p>Security: \"View or Update\"</p> <p>In the new site select \"enable authenticator\" as typical google Authenticator.</p> <ul> <li>open Google Authenticator on your phone</li> <li>scan barcode</li> <li>enter your generated 2fa</li> </ul>"},{"location":"sandbox-testing/#enable-api-access","title":"Enable API Access","text":"<p>From within sandbox select profile&gt;api&gt;create api-keys</p> <p>or as a direct link: https://public.sandbox.pro.coinbase.com/profile/api</p> <p>Click on \"create one\" and ensure  view and trade  are \"checked\" and sumbit your 2FA</p> <ul> <li>Copy and paste the Passphase into a notepade this will be needed later</li> <li>Copy and paste the API Secret popup into a notepad this will needed later</li> <li>Copy and paste the API Key into a notepad this will needed later</li> </ul>"},{"location":"sandbox-testing/#add-50-btc-test-funds","title":"Add 50 BTC test funds","text":"<p>To add funds, use the web interface deposit and withdraw buttons.</p> <p>To begin select 'Wallets' from the top menu.</p> <p>Or as a direct link: https://public.sandbox.pro.coinbase.com/wallets</p> <ul> <li>Deposits (bottom left of screen)</li> <li> <ul> <li>Deposit Funds Bitcoin</li> </ul> </li> <li> <ul> <li> <ul> <li>Coinbase BTC Wallet</li> </ul> </li> </ul> </li> <li> <ul> <li> <ul> <li> <ul> <li>Max (50 BTC)</li> </ul> </li> </ul> </li> </ul> </li> <li> <ul> <li> <ul> <li> <ul> <li> <ul> <li>Deposit</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>This process may be repeated for other currencies, ETH as example</p>"},{"location":"sandbox-testing/#configure-freqtrade-to-use-gax-sandbox","title":"Configure Freqtrade to use Gax Sandbox","text":"<p>The aim of this document section</p> <ul> <li>Enable sandbox URLs in Freqtrade</li> <li>Configure API</li> <li> <ul> <li>secret</li> </ul> </li> <li> <ul> <li>key</li> </ul> </li> <li> <ul> <li>passphrase</li> </ul> </li> </ul>"},{"location":"sandbox-testing/#sandbox-urls","title":"Sandbox URLs","text":"<p>Freqtrade makes use of CCXT which in turn provides a list of URLs to Freqtrade. These include <code>['test']</code> and <code>['api']</code>.</p> <ul> <li><code>[Test]</code> if available will point to an Exchanges sandbox. </li> <li><code>[Api]</code> normally used, and resolves to live API target on the exchange </li> </ul> <p>To make use of sandbox / test add \"sandbox\": true, to your config.json</p> <pre><code>  \"exchange\": {\n        \"name\": \"gdax\",\n        \"sandbox\": true,\n        \"key\": \"5wowfxemogxeowo;heiohgmd\",\n        \"secret\": \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\",\n        \"password\": \"1bkjfkhfhfu6sr\",\n        \"outdated_offset\": 5\n        \"pair_whitelist\": [\n            \"BTC/USD\"\n</code></pre> <p>Also insert your </p> <ul> <li>api-key  (noted earlier)</li> <li>api-secret (noted earlier)</li> <li>password (the passphrase - noted earlier)</li> </ul>"},{"location":"sandbox-testing/#you-should-now-be-ready-to-test-your-sandbox","title":"You should now be ready to test your sandbox","text":"<p>Ensure Freqtrade logs show the sandbox URL, and trades made are shown in sandbox. ** Typically the  BTC/USD has the most activity in sandbox to test against.</p>"},{"location":"sandbox-testing/#gdax-old-candles-problem","title":"GDAX - Old Candles problem","text":"<p>It is my experience that GDAX sandbox candles may be 20+- minutes out of date. This can cause trades to fail as one of Freqtrades safety checks.</p> <p>To disable this check, add / change the <code>\"outdated_offset\"</code> parameter in the exchange section of your configuration to adjust for this delay. Example based on the above configuration:</p> <pre><code>  \"exchange\": {\n        \"name\": \"gdax\",\n        \"sandbox\": true,\n        \"key\": \"5wowfxemogxeowo;heiohgmd\",\n        \"secret\": \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\",\n        \"password\": \"1bkjfkhfhfu6sr\",\n        \"outdated_offset\": 30\n        \"pair_whitelist\": [\n            \"BTC/USD\"\n</code></pre>"},{"location":"sql_cheatsheet/","title":"SQL Helper","text":"<p>This page contains some help if you want to edit your sqlite db.</p>"},{"location":"sql_cheatsheet/#install-sqlite3","title":"Install sqlite3","text":"<p>Ubuntu/Debian installation <pre><code>sudo apt-get install sqlite3\n</code></pre></p>"},{"location":"sql_cheatsheet/#open-the-db","title":"Open the DB","text":"<pre><code>sqlite3\n.open &lt;filepath&gt;\n</code></pre>"},{"location":"sql_cheatsheet/#table-structure","title":"Table structure","text":""},{"location":"sql_cheatsheet/#list-tables","title":"List tables","text":"<pre><code>.tables\n</code></pre>"},{"location":"sql_cheatsheet/#display-table-structure","title":"Display table structure","text":"<pre><code>.schema &lt;table_name&gt;\n</code></pre>"},{"location":"sql_cheatsheet/#trade-table-structure","title":"Trade table structure","text":"<pre><code>CREATE TABLE trades (\n    id INTEGER NOT NULL,\n    exchange VARCHAR NOT NULL,\n    pair VARCHAR NOT NULL,\n    is_open BOOLEAN NOT NULL,\n    fee_open FLOAT NOT NULL,\n    fee_close FLOAT NOT NULL,\n    open_rate FLOAT,\n    open_rate_requested FLOAT,\n    close_rate FLOAT,\n    close_rate_requested FLOAT,\n    close_profit FLOAT,\n    stake_amount FLOAT NOT NULL,\n    amount FLOAT,\n    open_date DATETIME NOT NULL,\n    close_date DATETIME,\n    open_order_id VARCHAR,\n    stop_loss FLOAT,\n    initial_stop_loss FLOAT,\n    stoploss_order_id VARCHAR,\n    stoploss_last_update DATETIME,\n    max_rate FLOAT,\n    sell_reason VARCHAR,\n    strategy VARCHAR,\n    ticker_interval INTEGER,\n    PRIMARY KEY (id),\n    CHECK (is_open IN (0, 1))\n);\n</code></pre>"},{"location":"sql_cheatsheet/#get-all-trades-in-the-table","title":"Get all trades in the table","text":"<pre><code>SELECT * FROM trades;\n</code></pre>"},{"location":"sql_cheatsheet/#fix-trade-still-open-after-a-manual-sell-on-the-exchange","title":"Fix trade still open after a manual sell on the exchange","text":"<p>Warning</p> <p>Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, forcesell  should be used to accomplish the same thing.     It is strongly advised to backup your database file before making any manual changes. <p>Note</p> <p>This should not be necessary after /forcesell, as forcesell orders are closed automatically by the bot on the next iteration.</p> <pre><code>UPDATE trades\nSET is_open=0, close_date=&lt;close_date&gt;, close_rate=&lt;close_rate&gt;, close_profit=close_rate/open_rate-1, sell_reason=&lt;sell_reason&gt;  \nWHERE id=&lt;trade_ID_to_update&gt;;\n</code></pre>"},{"location":"sql_cheatsheet/#example","title":"Example","text":"<pre><code>UPDATE trades\nSET is_open=0, close_date='2017-12-20 03:08:45.103418', close_rate=0.19638016, close_profit=0.0496, sell_reason='force_sell'  \nWHERE id=31;\n</code></pre>"},{"location":"sql_cheatsheet/#insert-manually-a-new-trade","title":"Insert manually a new trade","text":"<pre><code>INSERT INTO trades (exchange, pair, is_open, fee_open, fee_close, open_rate, stake_amount, amount, open_date)\nVALUES ('bittrex', 'ETH/BTC', 1, 0.0025, 0.0025, &lt;open_rate&gt;, &lt;stake_amount&gt;, &lt;amount&gt;, '&lt;datetime&gt;')\n</code></pre>"},{"location":"sql_cheatsheet/#example_1","title":"Example:","text":"<pre><code>INSERT INTO trades (exchange, pair, is_open, fee_open, fee_close, open_rate, stake_amount, amount, open_date)\nVALUES ('bittrex', 'ETH/BTC', 1, 0.0025, 0.0025, 0.00258580, 0.002, 0.7715262081, '2017-11-28 12:44:24.000000')\n</code></pre>"},{"location":"sql_cheatsheet/#fix-wrong-fees-in-the-table","title":"Fix wrong fees in the table","text":"<p>If your DB was created before PR#200 was merged (before 12/23/17).</p> <pre><code>UPDATE trades SET fee=0.0025 WHERE fee=0.005;\n</code></pre>"},{"location":"stoploss/","title":"Stop Loss","text":"<p>The <code>stoploss</code> configuration parameter is loss in percentage that should trigger a sale. For example, value <code>-0.10</code> will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional.</p> <p>Most of the strategy files already include the optimal <code>stoploss</code> value. This parameter is optional. If you use it in the configuration file, it will take over the <code>stoploss</code> value from the strategy file.</p>"},{"location":"stoploss/#stop-loss-support","title":"Stop Loss support","text":"<p>At this stage the bot contains the following stoploss support modes:</p> <ol> <li>static stop loss, defined in either the strategy or configuration.</li> <li>trailing stop loss, defined in the configuration.</li> <li>trailing stop loss, custom positive loss, defined in configuration.</li> </ol> <p>Note</p> <p>All stoploss properties can be configured in either Strategy or configuration. Configuration values override strategy values.</p> <p>Those stoploss modes can be on exchange or off exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order happens successfuly. This will protect you against sudden crashes in market as the order will be in the queue immediately and if market goes down then the order has more chance of being fulfilled.</p> <p>In case of stoploss on exchange there is another parameter called <code>stoploss_on_exchange_interval</code>. This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. As an example in case of trailing stoploss if the order is on the exchange and the market is going up then the bot automatically cancels the previous stoploss order and put a new one with a stop value higher than previous one. It is clear that the bot cannot do it every 5 seconds otherwise it gets banned. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute).</p> <p>Note</p> <p>Stoploss on exchange is only supported for Binance as of now.</p>"},{"location":"stoploss/#static-stop-loss","title":"Static Stop Loss","text":"<p>This is very simple, basically you define a stop loss of x in your strategy file or alternative in the configuration, which will overwrite the strategy definition. This will basically try to sell your asset, the second the loss exceeds the defined loss.</p>"},{"location":"stoploss/#trailing-stop-loss","title":"Trailing Stop Loss","text":"<p>The initial value for this stop loss, is defined in your strategy or configuration. Just as you would define your Stop Loss normally. To enable this Feauture all you have to do is to define the configuration element:</p> <pre><code>\"trailing_stop\" : True\n</code></pre> <p>This will now activate an algorithm, which automatically moves your stop loss up every time the price of your asset increases.</p> <p>For example, simplified math,</p> <ul> <li>you buy an asset at a price of 100$</li> <li>your stop loss is defined at 2%</li> <li>which means your stop loss, gets triggered once your asset dropped below 98$</li> <li>assuming your asset now increases to 102$</li> <li>your stop loss, will now be 2% of 102$ or 99.96$</li> <li>now your asset drops in value to 101, your stop loss, will still be 99.96</li> </ul> <p>basically what this means is that your stop loss will be adjusted to be always be 2% of the highest observed price</p>"},{"location":"stoploss/#custom-positive-loss","title":"Custom positive loss","text":"<p>Due to demand, it is possible to have a default stop loss, when you are in the red with your buy, but once your profit surpasses a certain percentage, the system will utilize a new stop loss, which can be a different value. For example your default stop loss is 5%, but once you have 1.1% profit, it will be changed to be only a 1% stop loss, which trails the green candles until it goes below them.</p> <p>Both values can be configured in the main configuration file and requires <code>\"trailing_stop\": true</code> to be set to true.</p> <pre><code>    \"trailing_stop_positive\":  0.01,\n    \"trailing_stop_positive_offset\":  0.011,\n    \"trailing_only_offset_is_reached\": false\n</code></pre> <p>The 0.01 would translate to a 1% stop loss, once you hit 1.1% profit.</p> <p>You should also make sure to have this value (<code>trailing_stop_positive_offset</code>) lower than your minimal ROI, otherwise minimal ROI will apply first and sell your trade.</p> <p>If <code>\"trailing_only_offset_is_reached\": true</code> then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured<code>stoploss</code>.</p>"},{"location":"stoploss/#changing-stoploss-on-open-trades","title":"Changing stoploss on open trades","text":"<p>A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the <code>/reload_conf</code> command (alternatively, completely stopping and restarting the bot also works).</p> <p>The new stoploss value will be applied to open trades (and corresponding log-messages will be generated).</p>"},{"location":"stoploss/#limitations","title":"Limitations","text":"<p>Stoploss values cannot be changed if <code>trailing_stop</code> is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).</p>"},{"location":"strategy-customization/","title":"Optimization","text":"<p>This page explains where to customize your strategies, and add new indicators.</p>"},{"location":"strategy-customization/#install-a-custom-strategy-file","title":"Install a custom strategy file","text":"<p>This is very simple. Copy paste your strategy file into the directory <code>user_data/strategies</code>.</p> <p>Let assume you have a class called <code>AwesomeStrategy</code> in the file <code>awesome-strategy.py</code>:</p> <ol> <li>Move your file into <code>user_data/strategies</code> (you should have <code>user_data/strategies/awesome-strategy.py</code></li> <li>Start the bot with the param <code>--strategy AwesomeStrategy</code> (the parameter is the class name)</li> </ol> <pre><code>freqtrade --strategy AwesomeStrategy\n</code></pre>"},{"location":"strategy-customization/#change-your-strategy","title":"Change your strategy","text":"<p>The bot includes a default strategy file. However, we recommend you to use your own file to not have to lose your parameters every time the default strategy file will be updated on Github. Put your custom strategy file into the directory <code>user_data/strategies</code>.</p> <p>Best copy the test-strategy and modify this copy to avoid having bot-updates override your changes. <code>cp  user_data/strategies/test_strategy.py user_data/strategies/awesome-strategy.py</code></p>"},{"location":"strategy-customization/#anatomy-of-a-strategy","title":"Anatomy of a strategy","text":"<p>A strategy file contains all the information needed to build a good strategy:</p> <ul> <li>Indicators</li> <li>Buy strategy rules</li> <li>Sell strategy rules</li> <li>Minimal ROI recommended</li> <li>Stoploss strongly recommended</li> </ul> <p>The bot also include a sample strategy called <code>TestStrategy</code> you can update: <code>user_data/strategies/test_strategy.py</code>. You can test it with the parameter: <code>--strategy TestStrategy</code></p> <pre><code>freqtrade --strategy AwesomeStrategy\n</code></pre> <p>For the following section we will use the user_data/strategies/test_strategy.py file as reference.</p> <p>Note</p> <p>To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time-interval is passed to the <code>populate_*()</code> methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing (<code>df.iloc[-1]</code>), but instead use <code>df.shift()</code> to get to the previous candle.</p> <p>Warning</p> <p>Since backtesting passes the full time interval to the <code>populate_*()</code> methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Samples for usage of future data are <code>dataframe.shift(-1)</code>, <code>dataframe.resample(\"1h\")</code> (this uses the left border of the interval, so moves data from an hour to the start of the hour). They all use data which is not available during regular operations, so these strategies will perform well during backtesting, but will fail / perform badly in dry-runs.</p>"},{"location":"strategy-customization/#customize-indicators","title":"Customize Indicators","text":"<p>Buy and sell strategies need indicators. You can add more indicators by extending the list contained in the method <code>populate_indicators()</code> from your strategy file.</p> <p>You should only add the indicators used in either <code>populate_buy_trend()</code>, <code>populate_sell_trend()</code>, or to populate another indicator, otherwise performance may suffer.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>Sample:</p> <pre><code>def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Adds several different TA indicators to the given DataFrame\n\n    Performance Note: For the best performance be frugal on the number of indicators\n    you are using. Let uncomment only the indicator you are using in your strategies\n    or your hyperopt configuration, otherwise you will waste your memory and CPU usage.\n    :param dataframe: Raw data from the exchange and parsed by parse_ticker_dataframe()\n    :param metadata: Additional information, like the currently traded pair\n    :return: a Dataframe with all mandatory indicators for the strategies\n    \"\"\"\n    dataframe['sar'] = ta.SAR(dataframe)\n    dataframe['adx'] = ta.ADX(dataframe)\n    stoch = ta.STOCHF(dataframe)\n    dataframe['fastd'] = stoch['fastd']\n    dataframe['fastk'] = stoch['fastk']\n    dataframe['blower'] = ta.BBANDS(dataframe, nbdevup=2, nbdevdn=2)['lowerband']\n    dataframe['sma'] = ta.SMA(dataframe, timeperiod=40)\n    dataframe['tema'] = ta.TEMA(dataframe, timeperiod=9)\n    dataframe['mfi'] = ta.MFI(dataframe)\n    dataframe['rsi'] = ta.RSI(dataframe)\n    dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5)\n    dataframe['ema10'] = ta.EMA(dataframe, timeperiod=10)\n    dataframe['ema50'] = ta.EMA(dataframe, timeperiod=50)\n    dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100)\n    dataframe['ao'] = awesome_oscillator(dataframe)\n    macd = ta.MACD(dataframe)\n    dataframe['macd'] = macd['macd']\n    dataframe['macdsignal'] = macd['macdsignal']\n    dataframe['macdhist'] = macd['macdhist']\n    hilbert = ta.HT_SINE(dataframe)\n    dataframe['htsine'] = hilbert['sine']\n    dataframe['htleadsine'] = hilbert['leadsine']\n    dataframe['plus_dm'] = ta.PLUS_DM(dataframe)\n    dataframe['plus_di'] = ta.PLUS_DI(dataframe)\n    dataframe['minus_dm'] = ta.MINUS_DM(dataframe)\n    dataframe['minus_di'] = ta.MINUS_DI(dataframe)\n    return dataframe\n</code></pre> <p>Want more indicator examples?</p> <p>Look into the user_data/strategies/test_strategy.py. Then uncomment indicators you need.</p>"},{"location":"strategy-customization/#buy-signal-rules","title":"Buy signal rules","text":"<p>Edit the method <code>populate_buy_trend()</code> in your strategy file to update your buy strategy.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>This will method will also define a new column, <code>\"buy\"</code>, which needs to contain 1 for buys, and 0 for \"no action\".</p> <p>Sample from <code>user_data/strategies/test_strategy.py</code>:</p> <pre><code>def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Based on TA indicators, populates the buy signal for the given dataframe\n    :param dataframe: DataFrame populated with indicators\n    :param metadata: Additional information, like the currently traded pair\n    :return: DataFrame with buy column\n    \"\"\"\n    dataframe.loc[\n        (\n            (dataframe['adx'] &gt; 30) &amp;\n            (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1))\n        ),\n        'buy'] = 1\n\n    return dataframe\n</code></pre>"},{"location":"strategy-customization/#sell-signal-rules","title":"Sell signal rules","text":"<p>Edit the method <code>populate_sell_trend()</code> into your strategy file to update your sell strategy. Please note that the sell-signal is only used if <code>use_sell_signal</code> is set to true in the configuration.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>This will method will also define a new column, <code>\"sell\"</code>, which needs to contain 1 for sells, and 0 for \"no action\".</p> <p>Sample from <code>user_data/strategies/test_strategy.py</code>:</p> <pre><code>def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Based on TA indicators, populates the sell signal for the given dataframe\n    :param dataframe: DataFrame populated with indicators\n    :param metadata: Additional information, like the currently traded pair\n    :return: DataFrame with buy column\n    \"\"\"\n    dataframe.loc[\n        (\n            (dataframe['adx'] &gt; 70) &amp;\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1))\n        ),\n        'sell'] = 1\n    return dataframe\n</code></pre>"},{"location":"strategy-customization/#minimal-roi","title":"Minimal ROI","text":"<p>This dict defines the minimal Return On Investment (ROI) a trade should reach before selling, independent from the sell signal.</p> <p>It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage.</p> <pre><code>minimal_roi = {\n    \"40\": 0.0,\n    \"30\": 0.01,\n    \"20\": 0.02,\n    \"0\": 0.04\n}\n</code></pre> <p>The above configuration would therefore mean:</p> <ul> <li>Sell whenever 4% profit was reached</li> <li>Sell when 2% profit was reached (in effect after 20 minutes)</li> <li>Sell when 1% profit was reached (in effect after 30 minutes)</li> <li>Sell when trade is non-loosing (in effect after 40 minutes)</li> </ul> <p>The calculation does include fees.</p> <p>To disable ROI completely, set it to an insanely high number:</p> <pre><code>minimal_roi = {\n    \"0\": 100\n}\n</code></pre> <p>While technically not completely disabled, this would sell once the trade reaches 10000% Profit.</p>"},{"location":"strategy-customization/#stoploss","title":"Stoploss","text":"<p>Setting a stoploss is highly recommended to protect your capital from strong moves against you.</p> <p>Sample:</p> <pre><code>stoploss = -0.10\n</code></pre> <p>This would signify a stoploss of -10%.</p> <p>For the full documentation on stoploss features, look at the dedicated stoploss page.</p> <p>If your exchange supports it, it's recommended to also set <code>\"stoploss_on_exchange\"</code> in the order dict, so your stoploss is on the exchange and cannot be missed for network-problems (or other problems).</p> <p>For more information on order_types please look here.</p>"},{"location":"strategy-customization/#ticker-interval","title":"Ticker interval","text":"<p>This is the set of candles the bot should download and use for the analysis. Common values are <code>\"1m\"</code>, <code>\"5m\"</code>, <code>\"15m\"</code>, <code>\"1h\"</code>, however all values supported by your exchange should work.</p> <p>Please note that the same buy/sell signals may work with one interval, but not the other. This setting is accessible within the strategy by using <code>self.ticker_interval</code>.</p>"},{"location":"strategy-customization/#metadata-dict","title":"Metadata dict","text":"<p>The metadata-dict (available for <code>populate_buy_trend</code>, <code>populate_sell_trend</code>, <code>populate_indicators</code>) contains additional information. Currently this is <code>pair</code>, which can be accessed using <code>metadata['pair']</code> - and will return a pair in the format <code>XRP/BTC</code>.</p> <p>The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the section Storing information</p>"},{"location":"strategy-customization/#storing-information","title":"Storing information","text":"<p>Storing information can be accomplished by crating a new dictionary within the strategy class.</p> <p>The name of the variable can be choosen at will, but should be prefixed with <code>cust_</code> to avoid naming collisions with predefined strategy variables.</p> <pre><code>class Awesomestrategy(IStrategy):\n    # Create custom dictionary\n    cust_info = {}\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # Check if the entry already exists\n        if \"crosstime\" in self.cust_info[metadata[\"pair\"]:\n            self.cust_info[metadata[\"pair\"][\"crosstime\"] += 1\n        else:\n            self.cust_info[metadata[\"pair\"][\"crosstime\"] = 1\n</code></pre> <p>Warning</p> <p>The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash.</p> <p>Note</p> <p>If the data is pair-specific, make sure to use pair as one of the keys in the dictionary.</p>"},{"location":"strategy-customization/#additional-data-dataprovider","title":"Additional data (DataProvider)","text":"<p>The strategy provides access to the <code>DataProvider</code>. This allows you to get additional data to use in your strategy.</p> <p>All methods return <code>None</code> in case of failure (do not raise an exception).</p> <p>Please always check the mode of operation to select the correct method to get data (samples see below).</p>"},{"location":"strategy-customization/#possible-options-for-dataprovider","title":"Possible options for DataProvider","text":"<ul> <li><code>available_pairs</code> - Property with tuples listing cached pairs with their intervals. (pair, interval)</li> <li><code>ohlcv(pair, ticker_interval)</code> - Currently cached ticker data for all pairs in the whitelist, returns DataFrame or empty DataFrame</li> <li><code>historic_ohlcv(pair, ticker_interval)</code> - Data stored on disk</li> <li><code>runmode</code> - Property containing the current runmode.</li> </ul>"},{"location":"strategy-customization/#ohlcv-historic_ohlcv","title":"ohlcv / historic_ohlcv","text":"<pre><code>if self.dp:\n    if self.dp.runmode in ('live', 'dry_run'):\n        if (f'{self.stake_currency}/BTC', self.ticker_interval) in self.dp.available_pairs:\n            data_eth = self.dp.ohlcv(pair='{self.stake_currency}/BTC',\n                                     ticker_interval=self.ticker_interval)\n    else:\n        # Get historic ohlcv data (cached on disk).\n        history_eth = self.dp.historic_ohlcv(pair='{self.stake_currency}/BTC',\n                                             ticker_interval='1h')\n</code></pre> <p>Warning</p> <p>Be carefull when using dataprovider in backtesting. <code>historic_ohlcv()</code> provides the full time-range in one go, so please be aware of it and make sure to not \"look into the future\" to avoid surprises when running in dry/live mode).</p> <p>Warning</p> <p>This option cannot currently be used during hyperopt.</p>"},{"location":"strategy-customization/#orderbook","title":"Orderbook","text":"<p><pre><code>if self.dp:\n    if self.dp.runmode in ('live', 'dry_run'):\n        ob = self.dp.orderbook(metadata['pair'], 1)\n        dataframe['best_bid'] = ob['bids'][0][0]\n        dataframe['best_ask'] = ob['asks'][0][0]\n</code></pre> !Warning The order book is not part of the historic data which means backtesting and hyperopt will not work if this  method is used.</p>"},{"location":"strategy-customization/#available-pairs","title":"Available Pairs","text":"<pre><code>if self.dp:\n    for pair, ticker in self.dp.available_pairs:\n        print(f\"available {pair}, {ticker}\")\n</code></pre>"},{"location":"strategy-customization/#get-data-for-non-tradeable-pairs","title":"Get data for non-tradeable pairs","text":"<p>Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. Ohlcv data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via <code>DataProvider</code> just as other pairs (see above). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting.</p> <p>The pairs need to be specified as tuples in the format <code>(\"pair\", \"interval\")</code>, with pair as the first and time interval as the second argument.</p> <p>Sample:</p> <pre><code>def informative_pairs(self):\n    return [(\"ETH/USDT\", \"5m\"),\n            (\"BTC/TUSD\", \"15m\"),\n            ]\n</code></pre> <p>Warning</p> <p>As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All intervals and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer time-intervals when possible to avoid hammering the exchange with too many requests and risk beeing blocked.</p>"},{"location":"strategy-customization/#additional-data-wallets","title":"Additional data - Wallets","text":"<p>The strategy provides access to the <code>Wallets</code> object. This contains the current balances on the exchange.</p> <p>Note</p> <p>Wallets is not available during backtesting / hyperopt.</p> <p>Please always check if <code>Wallets</code> is available to avoid failures during backtesting.</p> <pre><code>if self.wallets:\n    free_eth = self.wallets.get_free('ETH')\n    used_eth = self.wallets.get_used('ETH')\n    total_eth = self.wallets.get_total('ETH')\n</code></pre>"},{"location":"strategy-customization/#possible-options-for-wallets","title":"Possible options for Wallets","text":"<ul> <li><code>get_free(asset)</code> - currently available balance to trade</li> <li><code>get_used(asset)</code> - currently tied up balance (open orders)</li> <li><code>get_total(asset)</code> - total available balance - sum of the 2 above</li> </ul>"},{"location":"strategy-customization/#print-created-dataframe","title":"Print created dataframe","text":"<p>To inspect the created dataframe, you can issue a print-statement in either <code>populate_buy_trend()</code> or <code>populate_sell_trend()</code>. You may also want to print the pair so it's clear what data is currently shown.</p> <pre><code>def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            #&gt;&gt; whatever condition&lt;&lt;&lt;\n        ),\n        'buy'] = 1\n\n    # Print the Analyzed pair\n    print(f\"result for {metadata['pair']}\")\n\n    # Inspect the last 5 rows\n    print(dataframe.tail())\n\n    return dataframe\n</code></pre> <p>Printing more than a few rows is also possible (simply use  <code>print(dataframe)</code> instead of <code>print(dataframe.tail())</code>), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds).</p>"},{"location":"strategy-customization/#where-is-the-default-strategy","title":"Where is the default strategy?","text":"<p>The default buy strategy is located in the file freqtrade/default_strategy.py.</p>"},{"location":"strategy-customization/#specify-custom-strategy-location","title":"Specify custom strategy location","text":"<p>If you want to use a strategy from a different directory you can pass <code>--strategy-path</code></p> <pre><code>freqtrade --strategy AwesomeStrategy --strategy-path /some/directory\n</code></pre>"},{"location":"strategy-customization/#further-strategy-ideas","title":"Further strategy ideas","text":"<p>To get additional Ideas for strategies, head over to our strategy repository. Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo.</p> <p>We also got a strategy-sharing channel in our Slack community which is a great place to get and/or share ideas.</p>"},{"location":"strategy-customization/#next-step","title":"Next step","text":"<p>Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting.</p>"},{"location":"telegram-usage/","title":"Telegram usage","text":""},{"location":"telegram-usage/#setup-your-telegram-bot","title":"Setup your Telegram bot","text":"<p>Below we explain how to create your Telegram Bot, and how to get your Telegram user id.</p>"},{"location":"telegram-usage/#1-create-your-telegram-bot","title":"1. Create your Telegram bot","text":"<p>Start a chat with the Telegram BotFather</p> <p>Send the message <code>/newbot</code>. </p> <p>BotFather response:</p> <p>Alright, a new bot. How are we going to call it? Please choose a name for your bot.</p> <p>Choose the public name of your bot (e.x. <code>Freqtrade bot</code>)</p> <p>BotFather response:</p> <p>Good. Now let's choose a username for your bot. It must end in <code>bot</code>. Like this, for example: TetrisBot or tetris_bot.</p> <p>Choose the name id of your bot and send it to the BotFather (e.g. \"<code>My_own_freqtrade_bot</code>\")</p> <p>BotFather response:</p> <p>Done! Congratulations on your new bot. You will find it at <code>t.me/yourbots_name_bot</code>. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.</p> <p>Use this token to access the HTTP API: <code>22222222:APITOKEN</code></p> <p>For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key)</p> <p>Copy the API Token (<code>22222222:APITOKEN</code> in the above example) and keep use it for the config parameter <code>token</code>.</p> <p>Don't forget to start the conversation with your bot, by clicking <code>/START</code> button</p>"},{"location":"telegram-usage/#2-get-your-user-id","title":"2. Get your user id","text":"<p>Talk to the userinfobot</p> <p>Get your \"Id\", you will use it for the config parameter <code>chat_id</code>.</p>"},{"location":"telegram-usage/#telegram-commands","title":"Telegram commands","text":"<p>Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with <code>/help</code>.</p> Command Default Description <code>/start</code> Starts the trader <code>/stop</code> Stops the trader <code>/stopbuy</code> Stops the trader from opening new trades. Gracefully closes open trades according to their rules. <code>/reload_conf</code> Reloads the configuration file <code>/status</code> Lists all open trades <code>/status table</code> List all open trades in a table format <code>/count</code> Displays number of trades used and available <code>/profit</code> Display a summary of your profit/loss from close trades and some stats about your performance <code>/forcesell &lt;trade_id&gt;</code> Instantly sells the given trade  (Ignoring <code>minimum_roi</code>). <code>/forcesell all</code> Instantly sells all open trades (Ignoring <code>minimum_roi</code>). <code>/forcebuy &lt;pair&gt; [rate]</code> Instantly buys the given pair. Rate is optional. (<code>forcebuy_enable</code> must be set to True) <code>/performance</code> Show performance of each finished trade grouped by pair <code>/balance</code> Show account balance per currency <code>/daily &lt;n&gt;</code> 7 Shows profit or loss per day, over the last n days <code>/whitelist</code> Show the current whitelist <code>/blacklist [pair]</code> Show the current blacklist, or adds a pair to the blacklist. <code>/edge</code> Show validated pairs by Edge if it is enabled. <code>/help</code> Show help message <code>/version</code> Show version"},{"location":"telegram-usage/#telegram-commands-in-action","title":"Telegram commands in action","text":"<p>Below, example of Telegram message you will receive for each command.</p>"},{"location":"telegram-usage/#start","title":"/start","text":"<p>Status: <code>running</code></p>"},{"location":"telegram-usage/#stop","title":"/stop","text":"<p><code>Stopping trader ...</code> Status: <code>stopped</code></p>"},{"location":"telegram-usage/#stopbuy","title":"/stopbuy","text":"<p>status: <code>Setting max_open_trades to 0. Run /reload_conf to reset.</code></p> <p>Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...).</p> <p>After this, give the bot time to close off open trades (can be checked via <code>/status table</code>). Once all positions are sold, run <code>/stop</code> to completely stop the bot.</p> <p><code>/reload_conf</code> resets \"max_open_trades\" to the value set in the configuration and resets this command. </p> <p>Warning</p> <p>The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset.</p>"},{"location":"telegram-usage/#status","title":"/status","text":"<p>For each open trade, the bot will send you the following message.</p> <p>Trade ID: <code>123</code> <code>(since 1 days ago)</code> Current Pair: CVC/BTC Open Since: <code>1 days ago</code> Amount: <code>26.64180098</code> Open Rate: <code>0.00007489</code> Current Rate: <code>0.00007489</code> Current Profit: <code>12.95%</code> Stoploss: <code>0.00007389 (-0.02%)</code> </p>"},{"location":"telegram-usage/#status-table","title":"/status table","text":"<p>Return the status of all open trades in a table format. <pre><code>   ID  Pair      Since    Profit\n----  --------  -------  --------\n  67  SC/BTC    1 d      13.33%\n 123  CVC/BTC   1 h      12.95%\n</code></pre></p>"},{"location":"telegram-usage/#count","title":"/count","text":"<p>Return the number of trades used and available. <pre><code>current    max\n---------  -----\n     2     10\n</code></pre></p>"},{"location":"telegram-usage/#profit","title":"/profit","text":"<p>Return a summary of your profit/loss and performance.</p> <p>ROI: Close trades   \u2219 <code>0.00485701 BTC (258.45%)</code>   \u2219 <code>62.968 USD</code> ROI: All trades   \u2219 <code>0.00255280 BTC (143.43%)</code>   \u2219 <code>33.095 EUR</code> </p> <p>Total Trade Count: <code>138</code> First Trade opened: <code>3 days ago</code> Latest Trade opened: <code>2 minutes ago</code> Avg. Duration: <code>2:33:45</code> Best Performing: <code>PAY/BTC: 50.23%</code> </p>"},{"location":"telegram-usage/#forcesell","title":"/forcesell   <p>BITTREX: Selling BTC/LTC with limit <code>0.01650000 (profit: ~-4.07%, -0.00008168)</code></p>","text":""},{"location":"telegram-usage/#forcebuy","title":"/forcebuy   <p>BITTREX: Buying ETH/BTC with limit <code>0.03400000</code> (<code>1.000000 ETH</code>, <code>225.290 USD</code>)</p>  <p>Note that for this to work, <code>forcebuy_enable</code> needs to be set to true.</p> <p>More details</p>","text":""},{"location":"telegram-usage/#performance","title":"/performance <p>Return the performance of each crypto-currency the bot has sold.</p>  <p>Performance: 1. <code>RCN/BTC 57.77%</code> 2. <code>PAY/BTC 56.91%</code> 3. <code>VIB/BTC 47.07%</code> 4. <code>SALT/BTC 30.24%</code> 5. <code>STORJ/BTC 27.24%</code> ...  </p>","text":""},{"location":"telegram-usage/#balance","title":"/balance <p>Return the balance of all crypto-currency your have on the exchange.</p>  <p>Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0  </p> <p>Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0  </p>","text":""},{"location":"telegram-usage/#daily","title":"/daily  <p>Per default <code>/daily</code> will return the 7 last days. The example below if for <code>/daily 3</code>:</p>  <p>Daily Profit over the last 3 days: <pre><code>Day         Profit BTC      Profit USD\n----------  --------------  ------------\n2018-01-03  0.00224175 BTC  29,142 USD\n2018-01-02  0.00033131 BTC   4,307 USD\n2018-01-01  0.00269130 BTC  34.986 USD\n</code></pre></p>","text":""},{"location":"telegram-usage/#whitelist","title":"/whitelist <p>Shows the current whitelist</p>  <p>Using whitelist <code>StaticPairList</code> with 22 pairs <code>IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC</code></p>","text":""},{"location":"telegram-usage/#blacklist-pair","title":"/blacklist [pair] <p>Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, seperated by a space. Use <code>/reload_conf</code> to reset the blacklist.</p>  <p>Using blacklist <code>StaticPairList</code> with 2 pairs <code>DODGE/BTC</code>, <code>HOT/BTC</code>.</p>","text":""},{"location":"telegram-usage/#edge","title":"/edge <p>Shows pairs validated by Edge along with their corresponding winrate, expectancy and stoploss values.</p>  <p>Edge only validated following pairs: <pre><code>Pair        Winrate    Expectancy    Stoploss\n--------  ---------  ------------  ----------\nDOCK/ETH   0.522727      0.881821       -0.03\nPHX/ETH    0.677419      0.560488       -0.03\nHOT/ETH    0.733333      0.490492       -0.03\nHC/ETH     0.588235      0.280988       -0.02\nARDR/ETH   0.366667      0.143059       -0.01\n</code></pre></p>","text":""},{"location":"telegram-usage/#version","title":"/version  <p>Version: <code>0.14.3</code></p>","text":""},{"location":"webhook-config/","title":"Webhook usage","text":""},{"location":"webhook-config/#configuration","title":"Configuration","text":"<p>Enable webhooks by adding a webhook-section to your configuration file, and setting <code>webhook.enabled</code> to <code>true</code>.</p> <p>Sample configuration (tested using IFTTT).</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://maker.ifttt.com/trigger/&lt;YOUREVENT&gt;/with/key/&lt;YOURKEY&gt;/\",\n        \"webhookbuy\": {\n            \"value1\": \"Buying {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"{stake_amount:8f} {stake_currency}\"\n        },\n        \"webhooksell\": {\n            \"value1\": \"Selling {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"profit: {profit_amount:8f} {stake_currency}\"\n        },\n        \"webhookstatus\": {\n            \"value1\": \"Status: {status}\",\n            \"value2\": \"\",\n            \"value3\": \"\"\n        }\n    },\n</code></pre> <p>The url in <code>webhook.url</code> should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert our event and key to the url.</p> <p>Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called.</p>"},{"location":"webhook-config/#webhookbuy","title":"Webhookbuy","text":"<p>The fields in <code>webhook.webhookbuy</code> are filled when the bot executes a buy. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>limit</code></li> <li><code>stake_amount</code></li> <li><code>stake_currency</code></li> <li><code>fiat_currency</code></li> <li><code>order_type</code></li> </ul>"},{"location":"webhook-config/#webhooksell","title":"Webhooksell","text":"<p>The fields in <code>webhook.webhooksell</code> are filled when the bot sells a trade. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>gain</code></li> <li><code>limit</code></li> <li><code>amount</code></li> <li><code>open_rate</code></li> <li><code>current_rate</code></li> <li><code>profit_amount</code></li> <li><code>profit_percent</code></li> <li><code>stake_currency</code></li> <li><code>fiat_currency</code></li> <li><code>sell_reason</code></li> <li><code>order_type</code></li> </ul>"},{"location":"webhook-config/#webhookstatus","title":"Webhookstatus","text":"<p>The fields in <code>webhook.webhookstatus</code> are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format.</p> <p>The only possible value here is <code>{status}</code>.</p>"}]}