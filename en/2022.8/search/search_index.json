{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Star Fork Download Introduction \u00b6 Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning. DISCLAIMER This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS. Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect. We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it. Features \u00b6 Develop your Strategy: Write your strategy in python, using pandas . Example strategies to inspire you are available in the strategy repository . Download market data: Download historical data of the exchange and the markets your may want to trade with. Backtest: Test your strategy on downloaded historical data. Optimize: Find the best parameters for your strategy using hyperoptimization which employs machining learning methods. You can optimize buy, sell, take profit (ROI), stop-loss and trailing stop-loss parameters for your strategy. Select markets: Create your static list or use an automatic one based on top traded volumes and/or prices (not available during backtesting). You can also explicitly blacklist markets you don't want to trade. Run: Test your strategy with simulated money (Dry-Run mode) or deploy it with real money (Live-Trade mode). Run using Edge (optional module): The concept is to find the best historical trade expectancy by markets based on variation of the stop-loss and then allow/reject markets to trade. The sizing of the trade is based on a risk of a percentage of your capital. Control/Monitor: Use Telegram or a WebUI (start/stop the bot, show profit/loss, daily summary, current open trades results, etc.). Analyse: Further analysis can be performed on either Backtesting data or Freqtrade trading history (SQL database), including automated standard plots, and methods to load the data into interactive environments . Supported exchange marketplaces \u00b6 Please read the exchange specific notes to learn about eventual, special configurations needed for each exchange. Binance Bittrex FTX Gate.io Huobi Kraken OKX (Former OKEX) potentially many others through . (We cannot guarantee they will work) Supported Futures Exchanges (experimental) \u00b6 Binance Gate.io OKX . Please make sure to read the exchange specific notes , as well as the trading with leverage documentation before diving in. Community tested \u00b6 Exchanges confirmed working by the community: Bitvavo Kucoin Requirements \u00b6 Hardware requirements \u00b6 To run this bot we recommend you a linux cloud instance with a minimum of: 2GB RAM 1GB disk space 2vCPU Software requirements \u00b6 Docker (Recommended) Alternatively Python 3.8+ pip (pip3) git TA-Lib virtualenv (Recommended) Support \u00b6 Help / Discord \u00b6 For any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server . Ready to try? \u00b6 Begin by reading the installation guide for docker (recommended), or for installation without docker .","title":"Home"},{"location":"#introduction","text":"Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning. DISCLAIMER This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS. Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect. We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it.","title":"Introduction"},{"location":"#features","text":"Develop your Strategy: Write your strategy in python, using pandas . Example strategies to inspire you are available in the strategy repository . Download market data: Download historical data of the exchange and the markets your may want to trade with. Backtest: Test your strategy on downloaded historical data. Optimize: Find the best parameters for your strategy using hyperoptimization which employs machining learning methods. You can optimize buy, sell, take profit (ROI), stop-loss and trailing stop-loss parameters for your strategy. Select markets: Create your static list or use an automatic one based on top traded volumes and/or prices (not available during backtesting). You can also explicitly blacklist markets you don't want to trade. Run: Test your strategy with simulated money (Dry-Run mode) or deploy it with real money (Live-Trade mode). Run using Edge (optional module): The concept is to find the best historical trade expectancy by markets based on variation of the stop-loss and then allow/reject markets to trade. The sizing of the trade is based on a risk of a percentage of your capital. Control/Monitor: Use Telegram or a WebUI (start/stop the bot, show profit/loss, daily summary, current open trades results, etc.). Analyse: Further analysis can be performed on either Backtesting data or Freqtrade trading history (SQL database), including automated standard plots, and methods to load the data into interactive environments .","title":"Features"},{"location":"#supported-exchange-marketplaces","text":"Please read the exchange specific notes to learn about eventual, special configurations needed for each exchange. Binance Bittrex FTX Gate.io Huobi Kraken OKX (Former OKEX) potentially many others through . (We cannot guarantee they will work)","title":"Supported exchange marketplaces"},{"location":"#supported-futures-exchanges-experimental","text":"Binance Gate.io OKX . Please make sure to read the exchange specific notes , as well as the trading with leverage documentation before diving in.","title":"Supported Futures Exchanges (experimental)"},{"location":"#community-tested","text":"Exchanges confirmed working by the community: Bitvavo Kucoin","title":"Community tested"},{"location":"#requirements","text":"","title":"Requirements"},{"location":"#hardware-requirements","text":"To run this bot we recommend you a linux cloud instance with a minimum of: 2GB RAM 1GB disk space 2vCPU","title":"Hardware requirements"},{"location":"#software-requirements","text":"Docker (Recommended) Alternatively Python 3.8+ pip (pip3) git TA-Lib virtualenv (Recommended)","title":"Software requirements"},{"location":"#support","text":"","title":"Support"},{"location":"#help-discord","text":"For any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server .","title":"Help / Discord"},{"location":"#ready-to-try","text":"Begin by reading the installation guide for docker (recommended), or for installation without docker .","title":"Ready to try?"},{"location":"advanced-backtesting/","text":"Advanced Backtesting Analysis \u00b6 Analyze the buy/entry and sell/exit tags \u00b6 It can be helpful to understand how a strategy behaves according to the buy/entry tags used to mark up different buy conditions. You might want to see more complex statistics about each buy and sell condition above those provided by the default backtesting output. You may also want to determine indicator values on the signal candle that resulted in a trade opening. Note The following buy reason analysis is only available for backtesting, not hyperopt . We need to run backtesting with the --export option set to signals to enable the exporting of signals and trades: freqtrade backtesting -c <config.json> --timeframe <tf> --strategy <strategy_name> --timerange = <timerange> --export = signals This will tell freqtrade to output a pickled dictionary of strategy, pairs and corresponding DataFrame of the candles that resulted in buy signals. Depending on how many buys your strategy makes, this file may get quite large, so periodically check your user_data/backtest_results folder to delete old exports. Before running your next backtest, make sure you either delete your old backtest results or run backtesting with the --cache none option to make sure no cached results are used. If all goes well, you should now see a backtest-result-{timestamp}_signals.pkl file in the user_data/backtest_results folder. To analyze the entry/exit tags, we now need to use the freqtrade backtesting-analysis command with --analysis-groups option provided with space-separated arguments (default 0 1 2 ): freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 1 2 3 4 This command will read from the last backtesting results. The --analysis-groups option is used to specify the various tabular outputs showing the profit fo each group or trade, ranging from the simplest (0) to the most detailed per pair, per buy and per sell tag (4): 1: profit summaries grouped by enter_tag 2: profit summaries grouped by enter_tag and exit_tag 3: profit summaries grouped by pair and enter_tag 4: profit summaries grouped by pair, enter_ and exit_tag (this can get quite large) More options are available by running with the -h option. Using export-filename \u00b6 Normally, backtesting-analysis uses the latest backtest results, but if you wanted to go back to a previous backtest output, you need to supply the --export-filename option. You can supply the same parameter to backtest-analysis with the name of the final backtest output file. This allows you to keep historical versions of backtest results and re-analyse them at a later date: freqtrade backtesting -c <config.json> --timeframe <tf> --strategy <strategy_name> --timerange = <timerange> --export = signals --export-filename = /tmp/mystrat_backtest.json You should see some output similar to below in the logs with the name of the timestamped filename that was exported: 2022-06-14 16:28:32,698 - freqtrade.misc - INFO - dumping json to \"/tmp/mystrat_backtest-2022-06-14_16-28-32.json\" You can then use that filename in backtesting-analysis : freqtrade backtesting-analysis -c <config.json> --export-filename=/tmp/mystrat_backtest-2022-06-14_16-28-32.json Tuning the buy tags and sell tags to display \u00b6 To show only certain buy and sell tags in the displayed output, use the following two options: --enter-reason-list : Space-separated list of enter signals to analyse. Default: \"all\" --exit-reason-list : Space-separated list of exit signals to analyse. Default: \"all\" For example: freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss Outputting signal candle indicators \u00b6 The real power of freqtrade backtesting-analysis comes from the ability to print out the indicator values present on signal candles to allow fine-grained investigation and tuning of buy signal indicators. To print out a column for a given set of indicators, use the --indicator-list option: freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss --indicator-list rsi rsi_1h bb_lowerband ema_9 macd macdsignal The indicators have to be present in your strategy's main DataFrame (either for your main timeframe or for informative timeframes) otherwise they will simply be ignored in the script output.","title":"Backtest analysis"},{"location":"advanced-backtesting/#advanced-backtesting-analysis","text":"","title":"Advanced Backtesting Analysis"},{"location":"advanced-backtesting/#analyze-the-buyentry-and-sellexit-tags","text":"It can be helpful to understand how a strategy behaves according to the buy/entry tags used to mark up different buy conditions. You might want to see more complex statistics about each buy and sell condition above those provided by the default backtesting output. You may also want to determine indicator values on the signal candle that resulted in a trade opening. Note The following buy reason analysis is only available for backtesting, not hyperopt . We need to run backtesting with the --export option set to signals to enable the exporting of signals and trades: freqtrade backtesting -c <config.json> --timeframe <tf> --strategy <strategy_name> --timerange = <timerange> --export = signals This will tell freqtrade to output a pickled dictionary of strategy, pairs and corresponding DataFrame of the candles that resulted in buy signals. Depending on how many buys your strategy makes, this file may get quite large, so periodically check your user_data/backtest_results folder to delete old exports. Before running your next backtest, make sure you either delete your old backtest results or run backtesting with the --cache none option to make sure no cached results are used. If all goes well, you should now see a backtest-result-{timestamp}_signals.pkl file in the user_data/backtest_results folder. To analyze the entry/exit tags, we now need to use the freqtrade backtesting-analysis command with --analysis-groups option provided with space-separated arguments (default 0 1 2 ): freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 1 2 3 4 This command will read from the last backtesting results. The --analysis-groups option is used to specify the various tabular outputs showing the profit fo each group or trade, ranging from the simplest (0) to the most detailed per pair, per buy and per sell tag (4): 1: profit summaries grouped by enter_tag 2: profit summaries grouped by enter_tag and exit_tag 3: profit summaries grouped by pair and enter_tag 4: profit summaries grouped by pair, enter_ and exit_tag (this can get quite large) More options are available by running with the -h option.","title":"Analyze the buy/entry and sell/exit tags"},{"location":"advanced-backtesting/#using-export-filename","text":"Normally, backtesting-analysis uses the latest backtest results, but if you wanted to go back to a previous backtest output, you need to supply the --export-filename option. You can supply the same parameter to backtest-analysis with the name of the final backtest output file. This allows you to keep historical versions of backtest results and re-analyse them at a later date: freqtrade backtesting -c <config.json> --timeframe <tf> --strategy <strategy_name> --timerange = <timerange> --export = signals --export-filename = /tmp/mystrat_backtest.json You should see some output similar to below in the logs with the name of the timestamped filename that was exported: 2022-06-14 16:28:32,698 - freqtrade.misc - INFO - dumping json to \"/tmp/mystrat_backtest-2022-06-14_16-28-32.json\" You can then use that filename in backtesting-analysis : freqtrade backtesting-analysis -c <config.json> --export-filename=/tmp/mystrat_backtest-2022-06-14_16-28-32.json","title":"Using export-filename"},{"location":"advanced-backtesting/#tuning-the-buy-tags-and-sell-tags-to-display","text":"To show only certain buy and sell tags in the displayed output, use the following two options: --enter-reason-list : Space-separated list of enter signals to analyse. Default: \"all\" --exit-reason-list : Space-separated list of exit signals to analyse. Default: \"all\" For example: freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss","title":"Tuning the buy tags and sell tags to display"},{"location":"advanced-backtesting/#outputting-signal-candle-indicators","text":"The real power of freqtrade backtesting-analysis comes from the ability to print out the indicator values present on signal candles to allow fine-grained investigation and tuning of buy signal indicators. To print out a column for a given set of indicators, use the --indicator-list option: freqtrade backtesting-analysis -c <config.json> --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss --indicator-list rsi rsi_1h bb_lowerband ema_9 macd macdsignal The indicators have to be present in your strategy's main DataFrame (either for your main timeframe or for informative timeframes) otherwise they will simply be ignored in the script output.","title":"Outputting signal candle indicators"},{"location":"advanced-hyperopt/","text":"Advanced Hyperopt \u00b6 This page explains some advanced Hyperopt topics that may require higher coding skills and Python knowledge than creation of an ordinal hyperoptimization class. Creating and using a custom loss function \u00b6 To use a custom loss function class, make sure that the function hyperopt_loss_function is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter --hyperopt-loss SuperDuperHyperOptLoss to your hyperopt call so this function is being used. A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found in userdata/hyperopts . from datetime import datetime from typing import Any , Dict from pandas import DataFrame from freqtrade.optimize.hyperopt import IHyperOptLoss TARGET_TRADES = 600 EXPECTED_MAX_PROFIT = 3.0 MAX_ACCEPTED_TRADE_DURATION = 300 class SuperDuperHyperOptLoss ( IHyperOptLoss ): \"\"\" Defines the default loss function for hyperopt \"\"\" @staticmethod def hyperopt_loss_function ( results : DataFrame , trade_count : int , min_date : datetime , max_date : datetime , config : Dict , processed : Dict [ str , DataFrame ], backtest_stats : Dict [ str , Any ], * args , ** kwargs ) -> float : \"\"\" Objective function, returns smaller number for better results This is the legacy algorithm (used until now in freqtrade). Weights are distributed as follows: * 0.4 to trade duration * 0.25: Avoiding trade loss * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above \"\"\" total_profit = results [ 'profit_ratio' ] . sum () trade_duration = results [ 'trade_duration' ] . mean () trade_loss = 1 - 0.25 * exp ( - ( trade_count - TARGET_TRADES ) ** 2 / 10 ** 5.8 ) profit_loss = max ( 0 , 1 - total_profit / EXPECTED_MAX_PROFIT ) duration_loss = 0.4 * min ( trade_duration / MAX_ACCEPTED_TRADE_DURATION , 1 ) result = trade_loss + profit_loss + duration_loss return result Currently, the arguments are: results : DataFrame containing the resulting trades. The following columns are available in results (corresponds to the output-file of backtesting when used with --export trades ): pair, profit_ratio, profit_abs, open_date, open_rate, fee_open, close_date, close_rate, fee_close, amount, trade_duration, is_open, exit_reason, stake_amount, min_rate, max_rate, stop_loss_ratio, stop_loss_abs trade_count : Amount of trades (identical to len(results) ) min_date : Start date of the timerange used min_date : End date of the timerange used config : Config object used (Note: Not all strategy-related parameters will be updated here if they are part of a hyperopt space). processed : Dict of Dataframes with the pair as keys containing the data used for backtesting. backtest_stats : Backtesting statistics using the same format as the backtesting file \"strategy\" substructure. Available fields can be seen in generate_strategy_stats() in optimize_reports.py . This function needs to return a floating point number ( float ). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you. Note This function is called once per epoch - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily. *args and **kwargs Please keep the arguments *args and **kwargs in the interface to allow us to extend this interface in the future. Overriding pre-defined spaces \u00b6 To override a pre-defined space ( roi_space , generate_roi_table , stoploss_space , trailing_space ), define a nested class called Hyperopt and define the required spaces as follows: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : # Define a custom stoploss space. def stoploss_space (): return [ SKDecimal ( - 0.05 , - 0.01 , decimals = 3 , name = 'stoploss' )] # Define custom ROI space def roi_space () -> List [ Dimension ]: return [ Integer ( 10 , 120 , name = 'roi_t1' ), Integer ( 10 , 60 , name = 'roi_t2' ), Integer ( 10 , 40 , name = 'roi_t3' ), SKDecimal ( 0.01 , 0.04 , decimals = 3 , name = 'roi_p1' ), SKDecimal ( 0.01 , 0.07 , decimals = 3 , name = 'roi_p2' ), SKDecimal ( 0.01 , 0.20 , decimals = 3 , name = 'roi_p3' ), ] Note All overrides are optional and can be mixed/matched as necessary. Dynamic parameters \u00b6 Parameters can also be defined dynamically, but must be available to the instance once the * bot_start() callback has been called. class MyAwesomeStrategy ( IStrategy ): def bot_start ( self , ** kwargs ) -> None : self . buy_adx = IntParameter ( 20 , 30 , default = 30 , optimize = True ) # ... Warning Parameters created this way will not show up in the list-strategies parameter count. Overriding Base estimator \u00b6 You can define your own estimator for Hyperopt by implementing generate_estimator() in the Hyperopt subclass. class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): return \"RF\" Possible values are either one of \"GP\", \"RF\", \"ET\", \"GBRT\" (Details can be found in the scikit-optimize documentation ), or \"an instance of a class that inherits from RegressorMixin (from sklearn) and where the predict method has an optional return_std argument, which returns std(Y | x) along with E[Y | x] \". Some research will be necessary to find additional Regressors. Example for ExtraTreesRegressor (\"ET\") with additional parameters: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): from skopt.learning import ExtraTreesRegressor # Corresponds to \"ET\" - but allows additional parameters. return ExtraTreesRegressor ( n_estimators = 100 ) The dimensions parameter is the list of skopt.space.Dimension objects corresponding to the parameters to be optimized. It can be used to create isotropic kernels for the skopt.learning.GaussianProcessRegressor estimator. Here's an example: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): from skopt.utils import cook_estimator from skopt.learning.gaussian_process.kernels import ( Matern , ConstantKernel ) kernel_bounds = ( 0.0001 , 10000 ) kernel = ( ConstantKernel ( 1.0 , kernel_bounds ) * Matern ( length_scale = np . ones ( len ( dimensions )), length_scale_bounds = [ kernel_bounds for d in dimensions ], nu = 2.5 ) ) kernel += ( ConstantKernel ( 1.0 , kernel_bounds ) * Matern ( length_scale = np . ones ( len ( dimensions )), length_scale_bounds = [ kernel_bounds for d in dimensions ], nu = 1.5 ) ) return cook_estimator ( \"GP\" , space = dimensions , kernel = kernel , n_restarts_optimizer = 2 ) Note While custom estimators can be provided, it's up to you as User to do research on possible parameters and analyze / understand which ones should be used. If you're unsure about this, best use one of the Defaults ( \"ET\" has proven to be the most versatile) without further parameters. Space options \u00b6 For the additional spaces, scikit-optimize (in combination with Freqtrade) provides the following space types: Categorical - Pick from a list of categories (e.g. Categorical(['a', 'b', 'c'], name=\"cat\") ) Integer - Pick from a range of whole numbers (e.g. Integer(1, 10, name='rsi') ) SKDecimal - Pick from a range of decimal numbers with limited precision (e.g. SKDecimal(0.1, 0.5, decimals=3, name='adx') ). Available only with freqtrade . Real - Pick from a range of decimal numbers with full precision (e.g. Real(0.1, 0.5, name='adx') You can import all of these from freqtrade.optimize.space , although Categorical , Integer and Real are only aliases for their corresponding scikit-optimize Spaces. SKDecimal is provided by freqtrade for faster optimizations. from freqtrade.optimize.space import Categorical , Dimension , Integer , SKDecimal , Real # noqa SKDecimal vs. Real We recommend to use SKDecimal instead of the Real space in almost all cases. While the Real space provides full accuracy (up to ~16 decimal places) - this precision is rarely needed, and leads to unnecessary long hyperopt times. Assuming the definition of a rather small space ( SKDecimal(0.10, 0.15, decimals=2, name='xxx') ) - SKDecimal will have 5 possibilities ( [0.10, 0.11, 0.12, 0.13, 0.14, 0.15] ). A corresponding real space Real(0.10, 0.15 name='xxx') on the other hand has an almost unlimited number of possibilities ( [0.10, 0.010000000001, 0.010000000002, ... 0.014999999999, 0.01500000000] ).","title":"Advanced Hyperopt"},{"location":"advanced-hyperopt/#advanced-hyperopt","text":"This page explains some advanced Hyperopt topics that may require higher coding skills and Python knowledge than creation of an ordinal hyperoptimization class.","title":"Advanced Hyperopt"},{"location":"advanced-hyperopt/#creating-and-using-a-custom-loss-function","text":"To use a custom loss function class, make sure that the function hyperopt_loss_function is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter --hyperopt-loss SuperDuperHyperOptLoss to your hyperopt call so this function is being used. A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found in userdata/hyperopts . from datetime import datetime from typing import Any , Dict from pandas import DataFrame from freqtrade.optimize.hyperopt import IHyperOptLoss TARGET_TRADES = 600 EXPECTED_MAX_PROFIT = 3.0 MAX_ACCEPTED_TRADE_DURATION = 300 class SuperDuperHyperOptLoss ( IHyperOptLoss ): \"\"\" Defines the default loss function for hyperopt \"\"\" @staticmethod def hyperopt_loss_function ( results : DataFrame , trade_count : int , min_date : datetime , max_date : datetime , config : Dict , processed : Dict [ str , DataFrame ], backtest_stats : Dict [ str , Any ], * args , ** kwargs ) -> float : \"\"\" Objective function, returns smaller number for better results This is the legacy algorithm (used until now in freqtrade). Weights are distributed as follows: * 0.4 to trade duration * 0.25: Avoiding trade loss * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above \"\"\" total_profit = results [ 'profit_ratio' ] . sum () trade_duration = results [ 'trade_duration' ] . mean () trade_loss = 1 - 0.25 * exp ( - ( trade_count - TARGET_TRADES ) ** 2 / 10 ** 5.8 ) profit_loss = max ( 0 , 1 - total_profit / EXPECTED_MAX_PROFIT ) duration_loss = 0.4 * min ( trade_duration / MAX_ACCEPTED_TRADE_DURATION , 1 ) result = trade_loss + profit_loss + duration_loss return result Currently, the arguments are: results : DataFrame containing the resulting trades. The following columns are available in results (corresponds to the output-file of backtesting when used with --export trades ): pair, profit_ratio, profit_abs, open_date, open_rate, fee_open, close_date, close_rate, fee_close, amount, trade_duration, is_open, exit_reason, stake_amount, min_rate, max_rate, stop_loss_ratio, stop_loss_abs trade_count : Amount of trades (identical to len(results) ) min_date : Start date of the timerange used min_date : End date of the timerange used config : Config object used (Note: Not all strategy-related parameters will be updated here if they are part of a hyperopt space). processed : Dict of Dataframes with the pair as keys containing the data used for backtesting. backtest_stats : Backtesting statistics using the same format as the backtesting file \"strategy\" substructure. Available fields can be seen in generate_strategy_stats() in optimize_reports.py . This function needs to return a floating point number ( float ). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you. Note This function is called once per epoch - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily. *args and **kwargs Please keep the arguments *args and **kwargs in the interface to allow us to extend this interface in the future.","title":"Creating and using a custom loss function"},{"location":"advanced-hyperopt/#overriding-pre-defined-spaces","text":"To override a pre-defined space ( roi_space , generate_roi_table , stoploss_space , trailing_space ), define a nested class called Hyperopt and define the required spaces as follows: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : # Define a custom stoploss space. def stoploss_space (): return [ SKDecimal ( - 0.05 , - 0.01 , decimals = 3 , name = 'stoploss' )] # Define custom ROI space def roi_space () -> List [ Dimension ]: return [ Integer ( 10 , 120 , name = 'roi_t1' ), Integer ( 10 , 60 , name = 'roi_t2' ), Integer ( 10 , 40 , name = 'roi_t3' ), SKDecimal ( 0.01 , 0.04 , decimals = 3 , name = 'roi_p1' ), SKDecimal ( 0.01 , 0.07 , decimals = 3 , name = 'roi_p2' ), SKDecimal ( 0.01 , 0.20 , decimals = 3 , name = 'roi_p3' ), ] Note All overrides are optional and can be mixed/matched as necessary.","title":"Overriding pre-defined spaces"},{"location":"advanced-hyperopt/#dynamic-parameters","text":"Parameters can also be defined dynamically, but must be available to the instance once the * bot_start() callback has been called. class MyAwesomeStrategy ( IStrategy ): def bot_start ( self , ** kwargs ) -> None : self . buy_adx = IntParameter ( 20 , 30 , default = 30 , optimize = True ) # ... Warning Parameters created this way will not show up in the list-strategies parameter count.","title":"Dynamic parameters"},{"location":"advanced-hyperopt/#overriding-base-estimator","text":"You can define your own estimator for Hyperopt by implementing generate_estimator() in the Hyperopt subclass. class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): return \"RF\" Possible values are either one of \"GP\", \"RF\", \"ET\", \"GBRT\" (Details can be found in the scikit-optimize documentation ), or \"an instance of a class that inherits from RegressorMixin (from sklearn) and where the predict method has an optional return_std argument, which returns std(Y | x) along with E[Y | x] \". Some research will be necessary to find additional Regressors. Example for ExtraTreesRegressor (\"ET\") with additional parameters: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): from skopt.learning import ExtraTreesRegressor # Corresponds to \"ET\" - but allows additional parameters. return ExtraTreesRegressor ( n_estimators = 100 ) The dimensions parameter is the list of skopt.space.Dimension objects corresponding to the parameters to be optimized. It can be used to create isotropic kernels for the skopt.learning.GaussianProcessRegressor estimator. Here's an example: class MyAwesomeStrategy ( IStrategy ): class HyperOpt : def generate_estimator ( dimensions : List [ 'Dimension' ], ** kwargs ): from skopt.utils import cook_estimator from skopt.learning.gaussian_process.kernels import ( Matern , ConstantKernel ) kernel_bounds = ( 0.0001 , 10000 ) kernel = ( ConstantKernel ( 1.0 , kernel_bounds ) * Matern ( length_scale = np . ones ( len ( dimensions )), length_scale_bounds = [ kernel_bounds for d in dimensions ], nu = 2.5 ) ) kernel += ( ConstantKernel ( 1.0 , kernel_bounds ) * Matern ( length_scale = np . ones ( len ( dimensions )), length_scale_bounds = [ kernel_bounds for d in dimensions ], nu = 1.5 ) ) return cook_estimator ( \"GP\" , space = dimensions , kernel = kernel , n_restarts_optimizer = 2 ) Note While custom estimators can be provided, it's up to you as User to do research on possible parameters and analyze / understand which ones should be used. If you're unsure about this, best use one of the Defaults ( \"ET\" has proven to be the most versatile) without further parameters.","title":"Overriding Base estimator"},{"location":"advanced-hyperopt/#space-options","text":"For the additional spaces, scikit-optimize (in combination with Freqtrade) provides the following space types: Categorical - Pick from a list of categories (e.g. Categorical(['a', 'b', 'c'], name=\"cat\") ) Integer - Pick from a range of whole numbers (e.g. Integer(1, 10, name='rsi') ) SKDecimal - Pick from a range of decimal numbers with limited precision (e.g. SKDecimal(0.1, 0.5, decimals=3, name='adx') ). Available only with freqtrade . Real - Pick from a range of decimal numbers with full precision (e.g. Real(0.1, 0.5, name='adx') You can import all of these from freqtrade.optimize.space , although Categorical , Integer and Real are only aliases for their corresponding scikit-optimize Spaces. SKDecimal is provided by freqtrade for faster optimizations. from freqtrade.optimize.space import Categorical , Dimension , Integer , SKDecimal , Real # noqa SKDecimal vs. Real We recommend to use SKDecimal instead of the Real space in almost all cases. While the Real space provides full accuracy (up to ~16 decimal places) - this precision is rarely needed, and leads to unnecessary long hyperopt times. Assuming the definition of a rather small space ( SKDecimal(0.10, 0.15, decimals=2, name='xxx') ) - SKDecimal will have 5 possibilities ( [0.10, 0.11, 0.12, 0.13, 0.14, 0.15] ). A corresponding real space Real(0.10, 0.15 name='xxx') on the other hand has an almost unlimited number of possibilities ( [0.10, 0.010000000001, 0.010000000002, ... 0.014999999999, 0.01500000000] ).","title":"Space options"},{"location":"advanced-setup/","text":"Advanced Post-installation Tasks \u00b6 This page explains some advanced tasks and configuration options that can be performed after the bot installation and may be uselful in some environments. If you do not know what things mentioned here mean, you probably do not need it. Running multiple instances of Freqtrade \u00b6 This section will show you how to run multiple bots at the same time, on the same machine. Things to consider \u00b6 Use different database files. Use different Telegram bots (requires multiple different configuration files; applies only when Telegram is enabled). Use different ports (applies only when Freqtrade REST API webserver is enabled). Different database files \u00b6 In order to keep track of your trades, profits, etc., freqtrade is using a SQLite database where it stores various types of information such as the trades you performed in the past and the current position(s) you are holding at any time. This allows you to keep track of your profits, but most importantly, keep track of ongoing activity if the bot process would be restarted or would be terminated unexpectedly. Freqtrade will, by default, use separate database files for dry-run and live bots (this assumes no database-url is given in either configuration nor via command line argument). For live trading mode, the default database will be tradesv3.sqlite and for dry-run it will be tradesv3.dryrun.sqlite . The optional argument to the trade command used to specify the path of these files is --db-url , which requires a valid SQLAlchemy url. So when you are starting a bot with only the config and strategy arguments in dry-run mode, the following 2 commands would have the same outcome. freqtrade trade -c MyConfig.json -s MyStrategy # is equivalent to freqtrade trade -c MyConfig.json -s MyStrategy --db-url sqlite:///tradesv3.dryrun.sqlite It means that if you are running the trade command in two different terminals, for example to test your strategy both for trades in USDT and in another instance for trades in BTC, you will have to run them with different databases. If you specify the URL of a database which does not exist, freqtrade will create one with the name you specified. So to test your custom strategy with BTC and USDT stake currencies, you could use the following commands (in 2 separate terminals): # Terminal 1: freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.dryrun.sqlite # Terminal 2: freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.dryrun.sqlite Conversely, if you wish to do the same thing in production mode, you will also have to create at least one new database (in addition to the default one) and specify the path to the \"live\" databases, for example: # Terminal 1: freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.live.sqlite # Terminal 2: freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.live.sqlite For more information regarding usage of the sqlite databases, for example to manually enter or remove trades, please refer to the SQL Cheatsheet . Multiple instances using docker \u00b6 To run multiple instances of freqtrade using docker you will need to edit the docker-compose.yml file and add all the instances you want as separate services. Remember, you can separate your configuration into multiple files, so it's a good idea to think about making them modular, then if you need to edit something common to all bots, you can do that in a single config file. --- version: '3' services: freqtrade1: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade1 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8080:8080\" # Default command used when running `docker compose up` command: > trade --logfile /freqtrade/user_data/logs/freqtrade1.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade1.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade1.json --strategy SampleStrategy freqtrade2: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade2 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8081:8080\" # Default command used when running `docker compose up` command: > trade --logfile /freqtrade/user_data/logs/freqtrade2.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade2.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade2.json --strategy SampleStrategy You can use whatever naming convention you want, freqtrade1 and 2 are arbitrary. Note, that you will need to use different database files, port mappings and telegram configurations for each instance, as mentioned above. Configure the bot running as a systemd service \u00b6 Copy the freqtrade.service file to your systemd user directory (usually ~/.config/systemd/user ) and update WorkingDirectory and ExecStart to match your setup. Note Certain systems (like Raspbian) don't load service unit files from the user directory. In this case, copy freqtrade.service into /etc/systemd/user/ (requires superuser permissions). After that you can start the daemon with: systemctl --user start freqtrade For this to be persistent (run when user is logged out) you'll need to enable linger for your freqtrade user. sudo loginctl enable-linger \" $USER \" If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot state and restarting it in the case of failures. If the internals.sd_notify parameter is set to true in the configuration or the --sd-notify command line option is used, the bot will send keep-alive ping messages to systemd using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped) when it changes. The freqtrade.service.watchdog file contains an example of the service unit configuration file which uses systemd as the watchdog. Note The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container. Advanced Logging \u00b6 On many Linux systems the bot can be configured to send its log messages to syslog or journald system services. Logging to a remote syslog server is also available on Windows. The special values for the --logfile command line option can be used for this. Logging to syslog \u00b6 To send Freqtrade log messages to a local or remote syslog service use the --logfile command line option with the value in the following format: --logfile syslog:<syslog_address> -- send log messages to syslog service using the <syslog_address> as the syslog address. The syslog address can be either a Unix domain socket (socket filename) or a UDP socket specification, consisting of IP address and UDP port, separated by the : character. So, the following are the examples of possible usages: --logfile syslog:/dev/log -- log to syslog (rsyslog) using the /dev/log socket, suitable for most systems. --logfile syslog -- same as above, the shortcut for /dev/log . --logfile syslog:/var/run/syslog -- log to syslog (rsyslog) using the /var/run/syslog socket. Use this on MacOS. --logfile syslog:localhost:514 -- log to local syslog using UDP socket, if it listens on port 514. --logfile syslog:<ip>:514 -- log to remote syslog at IP address and port 514. This may be used on Windows for remote logging to an external syslog server. Log messages are send to syslog with the user facility. So you can see them with the following commands: tail -f /var/log/user , or install a comprehensive graphical viewer (for instance, 'Log File Viewer' for Ubuntu). On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better. For rsyslog the messages from the bot can be redirected into a separate dedicated log file. To achieve this, add if $programname startswith \"freqtrade\" then -/var/log/freqtrade.log to one of the rsyslog configuration files, for example at the end of the /etc/rsyslog.d/50-default.conf . For syslog ( rsyslog ), the reduction mode can be switched on. This will reduce the number of repeating messages. For instance, multiple bot Heartbeat messages will be reduced to a single message when nothing else happens with the bot. To achieve this, set in /etc/rsyslog.conf : # Filter duplicated messages $RepeatedMsgReduction on Logging to journald \u00b6 This needs the systemd python package installed as the dependency, which is not available on Windows. Hence, the whole journald logging functionality is not available for a bot running on Windows. To send Freqtrade log messages to journald system service use the --logfile command line option with the value in the following format: --logfile journald -- send log messages to journald . Log messages are send to journald with the user facility. So you can see them with the following commands: journalctl -f -- shows Freqtrade log messages sent to journald along with other log messages fetched by journald . journalctl -f -u freqtrade.service -- this command can be used when the bot is run as a systemd service. There are many other options in the journalctl utility to filter the messages, see manual pages for this utility. On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better.","title":"Advanced Post-installation Tasks"},{"location":"advanced-setup/#advanced-post-installation-tasks","text":"This page explains some advanced tasks and configuration options that can be performed after the bot installation and may be uselful in some environments. If you do not know what things mentioned here mean, you probably do not need it.","title":"Advanced Post-installation Tasks"},{"location":"advanced-setup/#running-multiple-instances-of-freqtrade","text":"This section will show you how to run multiple bots at the same time, on the same machine.","title":"Running multiple instances of Freqtrade"},{"location":"advanced-setup/#things-to-consider","text":"Use different database files. Use different Telegram bots (requires multiple different configuration files; applies only when Telegram is enabled). Use different ports (applies only when Freqtrade REST API webserver is enabled).","title":"Things to consider"},{"location":"advanced-setup/#different-database-files","text":"In order to keep track of your trades, profits, etc., freqtrade is using a SQLite database where it stores various types of information such as the trades you performed in the past and the current position(s) you are holding at any time. This allows you to keep track of your profits, but most importantly, keep track of ongoing activity if the bot process would be restarted or would be terminated unexpectedly. Freqtrade will, by default, use separate database files for dry-run and live bots (this assumes no database-url is given in either configuration nor via command line argument). For live trading mode, the default database will be tradesv3.sqlite and for dry-run it will be tradesv3.dryrun.sqlite . The optional argument to the trade command used to specify the path of these files is --db-url , which requires a valid SQLAlchemy url. So when you are starting a bot with only the config and strategy arguments in dry-run mode, the following 2 commands would have the same outcome. freqtrade trade -c MyConfig.json -s MyStrategy # is equivalent to freqtrade trade -c MyConfig.json -s MyStrategy --db-url sqlite:///tradesv3.dryrun.sqlite It means that if you are running the trade command in two different terminals, for example to test your strategy both for trades in USDT and in another instance for trades in BTC, you will have to run them with different databases. If you specify the URL of a database which does not exist, freqtrade will create one with the name you specified. So to test your custom strategy with BTC and USDT stake currencies, you could use the following commands (in 2 separate terminals): # Terminal 1: freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.dryrun.sqlite # Terminal 2: freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.dryrun.sqlite Conversely, if you wish to do the same thing in production mode, you will also have to create at least one new database (in addition to the default one) and specify the path to the \"live\" databases, for example: # Terminal 1: freqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.live.sqlite # Terminal 2: freqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.live.sqlite For more information regarding usage of the sqlite databases, for example to manually enter or remove trades, please refer to the SQL Cheatsheet .","title":"Different database files"},{"location":"advanced-setup/#multiple-instances-using-docker","text":"To run multiple instances of freqtrade using docker you will need to edit the docker-compose.yml file and add all the instances you want as separate services. Remember, you can separate your configuration into multiple files, so it's a good idea to think about making them modular, then if you need to edit something common to all bots, you can do that in a single config file. --- version: '3' services: freqtrade1: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade1 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8080:8080\" # Default command used when running `docker compose up` command: > trade --logfile /freqtrade/user_data/logs/freqtrade1.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade1.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade1.json --strategy SampleStrategy freqtrade2: image: freqtradeorg/freqtrade:stable # image: freqtradeorg/freqtrade:develop # Use plotting image # image: freqtradeorg/freqtrade:develop_plot # Build step - only needed when additional dependencies are needed # build: # context: . # dockerfile: \"./docker/Dockerfile.custom\" restart: always container_name: freqtrade2 volumes: - \"./user_data:/freqtrade/user_data\" # Expose api on port 8080 (localhost only) # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation # before enabling this. ports: - \"127.0.0.1:8081:8080\" # Default command used when running `docker compose up` command: > trade --logfile /freqtrade/user_data/logs/freqtrade2.log --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade2.sqlite --config /freqtrade/user_data/config.json --config /freqtrade/user_data/config.freqtrade2.json --strategy SampleStrategy You can use whatever naming convention you want, freqtrade1 and 2 are arbitrary. Note, that you will need to use different database files, port mappings and telegram configurations for each instance, as mentioned above.","title":"Multiple instances using docker"},{"location":"advanced-setup/#configure-the-bot-running-as-a-systemd-service","text":"Copy the freqtrade.service file to your systemd user directory (usually ~/.config/systemd/user ) and update WorkingDirectory and ExecStart to match your setup. Note Certain systems (like Raspbian) don't load service unit files from the user directory. In this case, copy freqtrade.service into /etc/systemd/user/ (requires superuser permissions). After that you can start the daemon with: systemctl --user start freqtrade For this to be persistent (run when user is logged out) you'll need to enable linger for your freqtrade user. sudo loginctl enable-linger \" $USER \" If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot state and restarting it in the case of failures. If the internals.sd_notify parameter is set to true in the configuration or the --sd-notify command line option is used, the bot will send keep-alive ping messages to systemd using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped) when it changes. The freqtrade.service.watchdog file contains an example of the service unit configuration file which uses systemd as the watchdog. Note The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container.","title":"Configure the bot running as a systemd service"},{"location":"advanced-setup/#advanced-logging","text":"On many Linux systems the bot can be configured to send its log messages to syslog or journald system services. Logging to a remote syslog server is also available on Windows. The special values for the --logfile command line option can be used for this.","title":"Advanced Logging"},{"location":"advanced-setup/#logging-to-syslog","text":"To send Freqtrade log messages to a local or remote syslog service use the --logfile command line option with the value in the following format: --logfile syslog:<syslog_address> -- send log messages to syslog service using the <syslog_address> as the syslog address. The syslog address can be either a Unix domain socket (socket filename) or a UDP socket specification, consisting of IP address and UDP port, separated by the : character. So, the following are the examples of possible usages: --logfile syslog:/dev/log -- log to syslog (rsyslog) using the /dev/log socket, suitable for most systems. --logfile syslog -- same as above, the shortcut for /dev/log . --logfile syslog:/var/run/syslog -- log to syslog (rsyslog) using the /var/run/syslog socket. Use this on MacOS. --logfile syslog:localhost:514 -- log to local syslog using UDP socket, if it listens on port 514. --logfile syslog:<ip>:514 -- log to remote syslog at IP address and port 514. This may be used on Windows for remote logging to an external syslog server. Log messages are send to syslog with the user facility. So you can see them with the following commands: tail -f /var/log/user , or install a comprehensive graphical viewer (for instance, 'Log File Viewer' for Ubuntu). On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better. For rsyslog the messages from the bot can be redirected into a separate dedicated log file. To achieve this, add if $programname startswith \"freqtrade\" then -/var/log/freqtrade.log to one of the rsyslog configuration files, for example at the end of the /etc/rsyslog.d/50-default.conf . For syslog ( rsyslog ), the reduction mode can be switched on. This will reduce the number of repeating messages. For instance, multiple bot Heartbeat messages will be reduced to a single message when nothing else happens with the bot. To achieve this, set in /etc/rsyslog.conf : # Filter duplicated messages $RepeatedMsgReduction on","title":"Logging to syslog"},{"location":"advanced-setup/#logging-to-journald","text":"This needs the systemd python package installed as the dependency, which is not available on Windows. Hence, the whole journald logging functionality is not available for a bot running on Windows. To send Freqtrade log messages to journald system service use the --logfile command line option with the value in the following format: --logfile journald -- send log messages to journald . Log messages are send to journald with the user facility. So you can see them with the following commands: journalctl -f -- shows Freqtrade log messages sent to journald along with other log messages fetched by journald . journalctl -f -u freqtrade.service -- this command can be used when the bot is run as a systemd service. There are many other options in the journalctl utility to filter the messages, see manual pages for this utility. On many systems syslog ( rsyslog ) fetches data from journald (and vice versa), so both --logfile syslog or --logfile journald can be used and the messages be viewed with both journalctl and a syslog viewer utility. You can combine this in any way which suites you better.","title":"Logging to journald"},{"location":"backtesting/","text":"Backtesting \u00b6 This page explains how to validate your strategy performance by using Backtesting. Backtesting requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Backtesting command reference \u00b6 usage: freqtrade backtesting [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]] [--export {none,trades,signals}] [--export-filename PATH] [--breakdown {day,week,month} [{day,week,month} ...]] [--cache {none,day,week,month}] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying `max_open_trades` during backtest (same as setting `max_open_trades` to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting (`1m`, `5m`, `30m`, `1h`, `1d`). --strategy-list STRATEGY_LIST [STRATEGY_LIST ...] Provide a space-separated list of strategies to backtest. Please note that timeframe needs to be set either in config or via command line. When using this together with `--export trades`, the strategy-name is injected into the filename (so `backtest-data.json` becomes `backtest-data-SampleStrategy.json` --export {none,trades,signals} Export backtest results (default: trades). --export-filename PATH, --backtest-filename PATH Use this filename for backtest results.Requires `--export` to be set as well. Example: `--export-filen ame=user_data/backtest_results/backtest_today.json` --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. --cache {none,day,week,month} Load a cached backtest result no older than specified age (default: day). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. Test your strategy with Backtesting \u00b6 Now you have good Buy and Sell strategies and some historic data, you want to test it against real data. This is what we call backtesting . Backtesting will use the crypto-currencies (pairs) from your config file and load historical candle (OHLCV) data from user_data/data/<exchange> by default. If no data is available for the exchange / pair / timeframe combination, backtesting will ask you to download them first using freqtrade download-data . For details on downloading, please refer to the Data Downloading section in the documentation. The result of backtesting will confirm if your bot has better odds of making a profit than a loss. All profit calculations include fees, and freqtrade will use the exchange's default fees for the calculation. Using dynamic pairlists for backtesting Using dynamic pairlists is possible (not all of the handlers are allowed to be used in backtest mode), however it relies on the current market conditions - which will not reflect the historic status of the pairlist. Also, when using pairlists other than StaticPairlist, reproducibility of backtesting-results cannot be guaranteed. Please read the pairlists documentation for more information. To achieve reproducible results, best generate a pairlist via the test-pairlist command and use that as static pairlist. Note By default, Freqtrade will export backtesting results to user_data/backtest_results . The exported trades can be used for further analysis or can be used by the plotting sub-command ( freqtrade plot-dataframe ) in the scripts directory. Starting balance \u00b6 Backtesting will require a starting balance, which can be provided as --dry-run-wallet <balance> or --starting-balance <balance> command line argument, or via dry_run_wallet configuration setting. This amount must be higher than stake_amount , otherwise the bot will not be able to simulate any trade. Dynamic stake amount \u00b6 Backtesting supports dynamic stake amount by configuring stake_amount as \"unlimited\" , which will split the starting balance into max_open_trades pieces. Profits from early trades will result in subsequent higher stake amounts, resulting in compounding of profits over the backtesting period. Example backtesting commands \u00b6 With 5 min candle (OHLCV) data (per default) freqtrade backtesting --strategy AwesomeStrategy Where --strategy AwesomeStrategy / -s AwesomeStrategy refers to the class name of the strategy, which is within a python file in the user_data/strategies directory. With 1 min candle (OHLCV) data freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m Providing a custom starting balance of 1000 (in stake currency) freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000 Using a different on-disk historical candle (OHLCV) data source Assume you downloaded the history data from the Bittrex exchange and kept it in the user_data/data/bittrex-20180101 directory. You can then use this data for backtesting as follows: freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/bittrex-20180101 Comparing multiple Strategies freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m Where SampleStrategy1 and AwesomeStrategy refer to class names of strategies. Prevent exporting trades to file freqtrade backtesting --strategy backtesting --export none --config config.json Only use this if you're sure you'll not want to plot or analyze your results further. Exporting trades to file specifying a custom filename freqtrade backtesting --strategy backtesting --export trades --export-filename = backtest_samplestrategy.json Please also read about the strategy startup period . Supplying custom fee value Sometimes your account has certain fee rebates (fee reductions starting with a certain account size or monthly volume), which are not visible to ccxt. To account for this in backtesting, you can use the --fee command line option to supply this value to backtesting. This fee must be a ratio, and will be applied twice (once for trade entry, and once for trade exit). For example, if the buying and selling commission fee is 0.1% (i.e., 0.001 written as ratio), then you would run backtesting as the following: freqtrade backtesting --fee 0 .001 Note Only supply this option (or the corresponding configuration parameter) if you want to experiment with different fee values. By default, Backtesting fetches the default fee from the exchange pair/market info. Running backtest with smaller test-set by using timerange Use the --timerange argument to change how much of the test-set you want to use. For example, running backtesting with the --timerange=20190501- option will use all available data starting with May 1 st , 2019 from your input data. freqtrade backtesting --timerange = 20190501 - You can also specify particular date ranges. The full timerange specification: Use data until 2018/01/31: --timerange=-20180131 Use data since 2018/01/31: --timerange=20180131- Use data since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use data between POSIX / epoch timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Understand the backtesting result \u00b6 The most important in the backtesting is to understand the result. A backtesting result will look like that: ========================================================= BACKTESTING REPORT ========================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins Draws Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:-------------|-------------------------:| | ADA/BTC | 35 | -0.11 | -3.88 | -0.00019428 | -1.94 | 4:35:00 | 14 0 21 40.0 | | ARK/BTC | 11 | -0.41 | -4.52 | -0.00022647 | -2.26 | 2:03:00 | 3 0 8 27.3 | | BTS/BTC | 32 | 0.31 | 9.78 | 0.00048938 | 4.89 | 5:05:00 | 18 0 14 56.2 | | DASH/BTC | 13 | -0.08 | -1.07 | -0.00005343 | -0.53 | 4:39:00 | 6 0 7 46.2 | | ENG/BTC | 18 | 1.36 | 24.54 | 0.00122807 | 12.27 | 2:50:00 | 8 0 10 44.4 | | EOS/BTC | 36 | 0.08 | 3.06 | 0.00015304 | 1.53 | 3:34:00 | 16 0 20 44.4 | | ETC/BTC | 26 | 0.37 | 9.51 | 0.00047576 | 4.75 | 6:14:00 | 11 0 15 42.3 | | ETH/BTC | 33 | 0.30 | 9.96 | 0.00049856 | 4.98 | 7:31:00 | 16 0 17 48.5 | | IOTA/BTC | 32 | 0.03 | 1.09 | 0.00005444 | 0.54 | 3:12:00 | 14 0 18 43.8 | | LSK/BTC | 15 | 1.75 | 26.26 | 0.00131413 | 13.13 | 2:58:00 | 6 0 9 40.0 | | LTC/BTC | 32 | -0.04 | -1.38 | -0.00006886 | -0.69 | 4:49:00 | 11 0 21 34.4 | | NANO/BTC | 17 | 1.26 | 21.39 | 0.00107058 | 10.70 | 1:55:00 | 10 0 7 58.5 | | NEO/BTC | 23 | 0.82 | 18.97 | 0.00094936 | 9.48 | 2:59:00 | 10 0 13 43.5 | | REQ/BTC | 9 | 1.17 | 10.54 | 0.00052734 | 5.27 | 3:47:00 | 4 0 5 44.4 | | XLM/BTC | 16 | 1.22 | 19.54 | 0.00097800 | 9.77 | 3:15:00 | 7 0 9 43.8 | | XMR/BTC | 23 | -0.18 | -4.13 | -0.00020696 | -2.07 | 5:30:00 | 12 0 11 52.2 | | XRP/BTC | 35 | 0.66 | 22.96 | 0.00114897 | 11.48 | 3:49:00 | 12 0 23 34.3 | | ZEC/BTC | 22 | -0.46 | -10.18 | -0.00050971 | -5.09 | 2:22:00 | 7 0 15 31.8 | | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | ========================================================= EXIT REASON STATS ========================================================== | Exit Reason | Sells | Wins | Draws | Losses | |:-------------------|--------:|------:|-------:|--------:| | trailing_stop_loss | 205 | 150 | 0 | 55 | | stop_loss | 166 | 0 | 0 | 166 | | exit_signal | 56 | 36 | 0 | 20 | | force_exit | 2 | 0 | 0 | 2 | ====================================================== LEFT OPEN TRADES REPORT ====================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Win Draw Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|--------------------:| | ADA/BTC | 1 | 0.89 | 0.89 | 0.00004434 | 0.44 | 6:00:00 | 1 0 0 100 | | LTC/BTC | 1 | 0.68 | 0.68 | 0.00003421 | 0.34 | 2:00:00 | 1 0 0 100 | | TOTAL | 2 | 0.78 | 1.57 | 0.00007855 | 0.78 | 4:00:00 | 2 0 0 100 | ================== SUMMARY METRICS ================== | Metric | Value | |-----------------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades | 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | CAGR % | 460.87% | | Profit factor | 1.11 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Long / Short | 352 / 77 | | Total profit Long % | 1250.58% | | Total profit Short % | -15.02% | | Absolute profit Long | 0.00838792 BTC | | Absolute profit Short | -0.00076 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Entry signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | Canceled Trade Entries | 34 | | Canceled Entry Orders | 123 | | Replaced Entry Orders | 89 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Max % of account underwater | 25.19% | | Absolute Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | ===================================================== Backtesting report table \u00b6 The 1 st table contains all trades the bot made, including \"left open trades\". The last line will give you the overall performance of your strategy, here: | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | The bot has made 429 trades for an average duration of 4:12:00 , with a performance of 76.20% (profit), that means it has earned a total of 0.00762792 BTC starting with a capital of 0.01 BTC. The column Avg Profit % shows the average profit for all trades made while the column Cum Profit % sums up all the profits/losses. The column Tot Profit % shows instead the total profit % in relation to the starting balance. In the above results, we have a starting balance of 0.01 BTC and an absolute profit of 0.00762792 BTC - so the Tot Profit % will be (0.00762792 / 0.01) * 100 ~= 76.2% . Your strategy performance is influenced by your buy strategy, your exit strategy, and also by the minimal_roi and stop_loss you have set. For example, if your minimal_roi is only \"0\": 0.01 you cannot expect the bot to make more profit than 1% (because it will exit every time a trade reaches 1%). \"minimal_roi\" : { \"0\" : 0.01 }, On the other hand, if you set a too high minimal_roi like \"0\": 0.55 (55%), there is almost no chance that the bot will ever reach this profit. Hence, keep in mind that your performance is an integral mix of all different elements of the strategy, your configuration, and the crypto-currency pairs you have set up. Exit reasons table \u00b6 The 2 nd table contains a recap of exit reasons. This table can tell you which area needs some additional work (e.g. all or many of the exit_signal trades are losses, so you should work on improving the exit signal, or consider disabling it). Left open trades table \u00b6 The 3 rd table contains all trades the bot had to force_exit at the end of the backtesting period to present you the full picture. This is necessary to simulate realistic behavior, since the backtest period has to end at some point, while realistically, you could leave the bot running forever. These trades are also included in the first table, but are also shown separately in this table for clarity. Summary metrics \u00b6 The last element of the backtest report is the summary metrics table. It contains some useful key metrics about performance of your strategy on backtesting data. ================== SUMMARY METRICS ================== | Metric | Value | |-----------------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades | 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | CAGR % | 460.87% | | Profit factor | 1.11 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Long / Short | 352 / 77 | | Total profit Long % | 1250.58% | | Total profit Short % | -15.02% | | Absolute profit Long | 0.00838792 BTC | | Absolute profit Short | -0.00076 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Entry signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | Canceled Trade Entries | 34 | | Canceled Entry Orders | 123 | | Replaced Entry Orders | 89 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Max % of account underwater | 25.19% | | Absolute Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | ===================================================== Backtesting from / Backtesting to : Backtesting range (usually defined with the --timerange option). Max open trades : Setting of max_open_trades (or --max-open-trades ) - or number of pairs in the pairlist (whatever is lower). Total/Daily Avg Trades : Identical to the total trades of the backtest output table / Total trades divided by the backtesting duration in days (this will give you information about how many trades to expect from the strategy). Starting balance : Start balance - as given by dry-run-wallet (config or command line). Final balance : Final balance - starting balance + absolute profit. Absolute profit : Profit made in stake currency. Total profit % : Total profit. Aligned to the TOTAL row's Tot Profit % from the first table. Calculated as (End capital \u2212 Starting capital) / Starting capital . CAGR % : Compound annual growth rate. Profit factor : profit / loss. Avg. stake amount : Average stake amount, either stake_amount or the average when using dynamic stake amount. Total trade volume : Volume generated on the exchange to reach the above profit. Best Pair / Worst Pair : Best and worst performing pair, and it's corresponding Cum Profit % . Best Trade / Worst Trade : Biggest single winning trade and biggest single losing trade. Best day / Worst day : Best and worst day based on daily profit. Days win/draw/lose : Winning / Losing days (draws are usually days without closed trade). Avg. Duration Winners / Avg. Duration Loser : Average durations for winning and losing trades. Rejected Entry signals : Trade entry signals that could not be acted upon due to max_open_trades being reached. Entry/Exit Timeouts : Entry/exit orders which did not fill (only applicable if custom pricing is used). Canceled Trade Entries : Number of trades that have been canceled by user request via adjust_entry_price . Canceled Entry Orders : Number of entry orders that have been canceled by user request via adjust_entry_price . Replaced Entry Orders : Number of entry orders that have been replaced by user request via adjust_entry_price . Min balance / Max balance : Lowest and Highest Wallet balance during the backtest period. Max % of account underwater : Maximum percentage your account has decreased from the top since the simulation started. Calculated as the maximum of (Max Balance - Current Balance) / (Max Balance) . Absolute Drawdown (Account) : Maximum Account Drawdown experienced. Calculated as (Absolute Drawdown) / (DrawdownHigh + startingBalance) . Drawdown : Maximum, absolute drawdown experienced. Difference between Drawdown High and Subsequent Low point. Drawdown high / Drawdown low : Profit at the beginning and end of the largest drawdown period. A negative low value means initial capital lost. Drawdown Start / Drawdown End : Start and end datetime for this largest drawdown (can also be visualized via the plot-dataframe sub-command). Market change : Change of the market during the backtest period. Calculated as average of all pairs changes from the first to the last candle using the \"close\" column. Long / Short : Split long/short values (Only shown when short trades were made). Total profit Long % / Absolute profit Long : Profit long trades only (Only shown when short trades were made). Total profit Short % / Absolute profit Short : Profit short trades only (Only shown when short trades were made). Daily / Weekly / Monthly breakdown \u00b6 You can get an overview over daily / weekly or monthly results by using the --breakdown <> switch. To visualize daily and weekly breakdowns, you can use the following: freqtrade backtesting --strategy MyAwesomeStrategy --breakdown day week ======================== DAY BREAKDOWN ========================= | Day | Tot Profit USDT | Wins | Draws | Losses | |------------+-------------------+--------+---------+----------| | 03/07/2021 | 200.0 | 2 | 0 | 0 | | 04/07/2021 | -50.31 | 0 | 0 | 2 | | 05/07/2021 | 220.611 | 3 | 2 | 0 | | 06/07/2021 | 150.974 | 3 | 0 | 2 | | 07/07/2021 | -70.193 | 1 | 0 | 2 | | 08/07/2021 | 212.413 | 2 | 0 | 3 | The output will show a table containing the realized absolute Profit (in stake currency) for the given timeperiod, as well as wins, draws and losses that materialized (closed) on this day. Below that there will be a second table for the summarized values of weeks indicated by the date of the closing Sunday. The same would apply to a monthly breakdown indicated by the last day of the month. Backtest result caching \u00b6 To save time, by default backtest will reuse a cached result from within the last day when the backtested strategy and config match that of a previous backtest. To force a new backtest despite existing result for an identical run specify --cache none parameter. Warning Caching is automatically disabled for open-ended timeranges ( --timerange 20210101- ), as freqtrade cannot ensure reliably that the underlying data didn't change. It can also use cached results where it shouldn't if the original backtest had missing data at the end, which was fixed by downloading more data. In this instance, please use --cache none once to force a fresh backtest. Further backtest-result analysis \u00b6 To further analyze your backtest results, you can export the trades . You can then load the trades to perform further analysis as shown in the data analysis backtesting section. Assumptions made by backtesting \u00b6 Since backtesting lacks some detailed information about what happens within a candle, it needs to take a few assumptions: Exchange trading limits are respected Buys happen at open-price All orders are filled at the requested price (no slippage, no unfilled orders) Exit-signal exits happen at open-price of the consecutive candle Exit-signal is favored over Stoploss, because exit-signals are assumed to trigger on candle's open ROI exits are compared to high - but the ROI value is used (e.g. ROI = 2%, high=5% - so the exit will be at 2%) exits are never \"below the candle\", so a ROI of 2% may result in a exit at 2.4% if low was at 2.4% profit Forceexits caused by <N>=-1 ROI entries use low as exit value, unless N falls on the candle open (e.g. 120: -1 for 1h candles) Stoploss exits happen exactly at stoploss price, even if low was lower, but the loss will be 2 * fees higher than the stoploss price Stoploss is evaluated before ROI within one candle. So you can often see more trades with the stoploss exit reason comparing to the results obtained with the same strategy in the Dry Run/Live Trade modes Low happens before high for stoploss, protecting capital first Trailing stoploss Trailing Stoploss is only adjusted if it's below the candle's low (otherwise it would be triggered) On trade entry candles that trigger trailing stoploss, the \"minimum offset\" ( stop_positive_offset ) is assumed (instead of high) - and the stop is calculated from this point High happens first - adjusting stoploss Low uses the adjusted stoploss (so exits with large high-low difference are backtested correctly) ROI applies before trailing-stop, ensuring profits are \"top-capped\" at ROI if both ROI and trailing stop applies Exit-reason does not explain if a trade was positive or negative, just what triggered the exit (this can look odd if negative ROI values are used) Evaluation sequence (if multiple signals happen on the same candle) Exit-signal Stoploss ROI Trailing stoploss Taking these assumptions, backtesting tries to mirror real trading as closely as possible. However, backtesting will never replace running a strategy in dry-run mode. Also, keep in mind that past results don't guarantee future success. In addition to the above assumptions, strategy authors should carefully read the Common Mistakes section, to avoid using data in backtesting which is not available in real market conditions. Trading limits in backtesting \u00b6 Exchanges have certain trading limits, like minimum base currency, or minimum stake (quote) currency. These limits are usually listed in the exchange documentation as \"trading rules\" or similar. Backtesting (as well as live and dry-run) does honor these limits, and will ensure that a stoploss can be placed below this value - so the value will be slightly higher than what the exchange specifies. Freqtrade has however no information about historic limits. This can lead to situations where trading-limits are inflated by using a historic price, resulting in minimum amounts > 50$. For example: BTC minimum tradable amount is 0.001. BTC trades at 22.000$ today (0.001 BTC is related to this) - but the backtesting period includes prices as high as 50.000$. Today's minimum would be 0.001 * 22_000 - or 22$. However the limit could also be 50$ - based on 0.001 * 50_000 in some historic setting. Trading precision limits \u00b6 Most exchanges pose precision limits on both price and amounts, so you cannot buy 1.0020401 of a pair, or at a price of 1.24567123123. Instead, these prices and amounts will be rounded or truncated (based on the exchange definition) to the defined trading precision. The above values may for example be rounded to an amount of 1.002, and a price of 1.24567. These precision values are based on current exchange limits (as described in the above section ), as historic precision limits are not available. Improved backtest accuracy \u00b6 One big limitation of backtesting is it's inability to know how prices moved intra-candle (was high before close, or viceversa?). So assuming you run backtesting with a 1h timeframe, there will be 4 prices for that candle (Open, High, Low, Close). While backtesting does take some assumptions (read above) about this - this can never be perfect, and will always be biased in one way or the other. To mitigate this, freqtrade can use a lower (faster) timeframe to simulate intra-candle movements. To utilize this, you can append --timeframe-detail 5m to your regular backtesting command. freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m This will load 1h data as well as 5m data for the timeframe. The strategy will be analyzed with the 1h timeframe - and for every \"open trade candle\" (candles where a trade is open) the 5m data will be used to simulate intra-candle movements. All callback functions ( custom_exit() , custom_stoploss() , ... ) will be running for each 5m candle once the trade is opened (so 12 times in the above example of 1h timeframe, and 5m detailed timeframe). --timeframe-detail must be smaller than the original timeframe, otherwise backtesting will fail to start. Obviously this will require more memory (5m data is bigger than 1h data), and will also impact runtime (depending on the amount of trades and trade durations). Also, data must be available / downloaded already. Tip You can use this function as the last part of strategy development, to ensure your strategy is not exploiting one of the backtesting assumptions . Strategies that perform similarly well with this mode have a good chance to perform well in dry/live modes too (although only forward-testing (dry-mode) can really confirm a strategy). Backtesting multiple strategies \u00b6 To compare multiple strategies, a list of Strategies can be provided to backtesting. This is limited to 1 timeframe value per run. However, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this will give a nice runtime boost. All listed Strategies need to be in the same directory. freqtrade backtesting --timerange 20180401 -20180410 --timeframe 5m --strategy-list Strategy001 Strategy002 --export trades This will save the results to user_data/backtest_results/backtest-result-<strategy>.json , injecting the strategy-name into the target filename. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up to see the details per strategy. =========================================================== STRATEGY SUMMARY ========================================================================= | Strategy | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins | Draws | Losses | Drawdown % | |:------------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|------:|-------:|-------:|-----------:| | Strategy1 | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 | 0 | 243 | 45.2 | | Strategy2 | 1487 | -0.13 | -197.58 | -0.00988917 | -98.79 | 4:43:00 | 662 | 0 | 825 | 241.68 | Next step \u00b6 Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt","title":"Backtesting"},{"location":"backtesting/#backtesting","text":"This page explains how to validate your strategy performance by using Backtesting. Backtesting requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.","title":"Backtesting"},{"location":"backtesting/#backtesting-command-reference","text":"usage: freqtrade backtesting [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]] [--export {none,trades,signals}] [--export-filename PATH] [--breakdown {day,week,month} [{day,week,month} ...]] [--cache {none,day,week,month}] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying `max_open_trades` during backtest (same as setting `max_open_trades` to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting (`1m`, `5m`, `30m`, `1h`, `1d`). --strategy-list STRATEGY_LIST [STRATEGY_LIST ...] Provide a space-separated list of strategies to backtest. Please note that timeframe needs to be set either in config or via command line. When using this together with `--export trades`, the strategy-name is injected into the filename (so `backtest-data.json` becomes `backtest-data-SampleStrategy.json` --export {none,trades,signals} Export backtest results (default: trades). --export-filename PATH, --backtest-filename PATH Use this filename for backtest results.Requires `--export` to be set as well. Example: `--export-filen ame=user_data/backtest_results/backtest_today.json` --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. --cache {none,day,week,month} Load a cached backtest result no older than specified age (default: day). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path.","title":"Backtesting command reference"},{"location":"backtesting/#test-your-strategy-with-backtesting","text":"Now you have good Buy and Sell strategies and some historic data, you want to test it against real data. This is what we call backtesting . Backtesting will use the crypto-currencies (pairs) from your config file and load historical candle (OHLCV) data from user_data/data/<exchange> by default. If no data is available for the exchange / pair / timeframe combination, backtesting will ask you to download them first using freqtrade download-data . For details on downloading, please refer to the Data Downloading section in the documentation. The result of backtesting will confirm if your bot has better odds of making a profit than a loss. All profit calculations include fees, and freqtrade will use the exchange's default fees for the calculation. Using dynamic pairlists for backtesting Using dynamic pairlists is possible (not all of the handlers are allowed to be used in backtest mode), however it relies on the current market conditions - which will not reflect the historic status of the pairlist. Also, when using pairlists other than StaticPairlist, reproducibility of backtesting-results cannot be guaranteed. Please read the pairlists documentation for more information. To achieve reproducible results, best generate a pairlist via the test-pairlist command and use that as static pairlist. Note By default, Freqtrade will export backtesting results to user_data/backtest_results . The exported trades can be used for further analysis or can be used by the plotting sub-command ( freqtrade plot-dataframe ) in the scripts directory.","title":"Test your strategy with Backtesting"},{"location":"backtesting/#starting-balance","text":"Backtesting will require a starting balance, which can be provided as --dry-run-wallet <balance> or --starting-balance <balance> command line argument, or via dry_run_wallet configuration setting. This amount must be higher than stake_amount , otherwise the bot will not be able to simulate any trade.","title":"Starting balance"},{"location":"backtesting/#dynamic-stake-amount","text":"Backtesting supports dynamic stake amount by configuring stake_amount as \"unlimited\" , which will split the starting balance into max_open_trades pieces. Profits from early trades will result in subsequent higher stake amounts, resulting in compounding of profits over the backtesting period.","title":"Dynamic stake amount"},{"location":"backtesting/#example-backtesting-commands","text":"With 5 min candle (OHLCV) data (per default) freqtrade backtesting --strategy AwesomeStrategy Where --strategy AwesomeStrategy / -s AwesomeStrategy refers to the class name of the strategy, which is within a python file in the user_data/strategies directory. With 1 min candle (OHLCV) data freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m Providing a custom starting balance of 1000 (in stake currency) freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000 Using a different on-disk historical candle (OHLCV) data source Assume you downloaded the history data from the Bittrex exchange and kept it in the user_data/data/bittrex-20180101 directory. You can then use this data for backtesting as follows: freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/bittrex-20180101 Comparing multiple Strategies freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m Where SampleStrategy1 and AwesomeStrategy refer to class names of strategies. Prevent exporting trades to file freqtrade backtesting --strategy backtesting --export none --config config.json Only use this if you're sure you'll not want to plot or analyze your results further. Exporting trades to file specifying a custom filename freqtrade backtesting --strategy backtesting --export trades --export-filename = backtest_samplestrategy.json Please also read about the strategy startup period . Supplying custom fee value Sometimes your account has certain fee rebates (fee reductions starting with a certain account size or monthly volume), which are not visible to ccxt. To account for this in backtesting, you can use the --fee command line option to supply this value to backtesting. This fee must be a ratio, and will be applied twice (once for trade entry, and once for trade exit). For example, if the buying and selling commission fee is 0.1% (i.e., 0.001 written as ratio), then you would run backtesting as the following: freqtrade backtesting --fee 0 .001 Note Only supply this option (or the corresponding configuration parameter) if you want to experiment with different fee values. By default, Backtesting fetches the default fee from the exchange pair/market info. Running backtest with smaller test-set by using timerange Use the --timerange argument to change how much of the test-set you want to use. For example, running backtesting with the --timerange=20190501- option will use all available data starting with May 1 st , 2019 from your input data. freqtrade backtesting --timerange = 20190501 - You can also specify particular date ranges. The full timerange specification: Use data until 2018/01/31: --timerange=-20180131 Use data since 2018/01/31: --timerange=20180131- Use data since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use data between POSIX / epoch timestamps 1527595200 1527618600: --timerange=1527595200-1527618600","title":"Example backtesting commands"},{"location":"backtesting/#understand-the-backtesting-result","text":"The most important in the backtesting is to understand the result. A backtesting result will look like that: ========================================================= BACKTESTING REPORT ========================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins Draws Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:-------------|-------------------------:| | ADA/BTC | 35 | -0.11 | -3.88 | -0.00019428 | -1.94 | 4:35:00 | 14 0 21 40.0 | | ARK/BTC | 11 | -0.41 | -4.52 | -0.00022647 | -2.26 | 2:03:00 | 3 0 8 27.3 | | BTS/BTC | 32 | 0.31 | 9.78 | 0.00048938 | 4.89 | 5:05:00 | 18 0 14 56.2 | | DASH/BTC | 13 | -0.08 | -1.07 | -0.00005343 | -0.53 | 4:39:00 | 6 0 7 46.2 | | ENG/BTC | 18 | 1.36 | 24.54 | 0.00122807 | 12.27 | 2:50:00 | 8 0 10 44.4 | | EOS/BTC | 36 | 0.08 | 3.06 | 0.00015304 | 1.53 | 3:34:00 | 16 0 20 44.4 | | ETC/BTC | 26 | 0.37 | 9.51 | 0.00047576 | 4.75 | 6:14:00 | 11 0 15 42.3 | | ETH/BTC | 33 | 0.30 | 9.96 | 0.00049856 | 4.98 | 7:31:00 | 16 0 17 48.5 | | IOTA/BTC | 32 | 0.03 | 1.09 | 0.00005444 | 0.54 | 3:12:00 | 14 0 18 43.8 | | LSK/BTC | 15 | 1.75 | 26.26 | 0.00131413 | 13.13 | 2:58:00 | 6 0 9 40.0 | | LTC/BTC | 32 | -0.04 | -1.38 | -0.00006886 | -0.69 | 4:49:00 | 11 0 21 34.4 | | NANO/BTC | 17 | 1.26 | 21.39 | 0.00107058 | 10.70 | 1:55:00 | 10 0 7 58.5 | | NEO/BTC | 23 | 0.82 | 18.97 | 0.00094936 | 9.48 | 2:59:00 | 10 0 13 43.5 | | REQ/BTC | 9 | 1.17 | 10.54 | 0.00052734 | 5.27 | 3:47:00 | 4 0 5 44.4 | | XLM/BTC | 16 | 1.22 | 19.54 | 0.00097800 | 9.77 | 3:15:00 | 7 0 9 43.8 | | XMR/BTC | 23 | -0.18 | -4.13 | -0.00020696 | -2.07 | 5:30:00 | 12 0 11 52.2 | | XRP/BTC | 35 | 0.66 | 22.96 | 0.00114897 | 11.48 | 3:49:00 | 12 0 23 34.3 | | ZEC/BTC | 22 | -0.46 | -10.18 | -0.00050971 | -5.09 | 2:22:00 | 7 0 15 31.8 | | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | ========================================================= EXIT REASON STATS ========================================================== | Exit Reason | Sells | Wins | Draws | Losses | |:-------------------|--------:|------:|-------:|--------:| | trailing_stop_loss | 205 | 150 | 0 | 55 | | stop_loss | 166 | 0 | 0 | 166 | | exit_signal | 56 | 36 | 0 | 20 | | force_exit | 2 | 0 | 0 | 2 | ====================================================== LEFT OPEN TRADES REPORT ====================================================== | Pair | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Win Draw Loss Win% | |:---------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|--------------------:| | ADA/BTC | 1 | 0.89 | 0.89 | 0.00004434 | 0.44 | 6:00:00 | 1 0 0 100 | | LTC/BTC | 1 | 0.68 | 0.68 | 0.00003421 | 0.34 | 2:00:00 | 1 0 0 100 | | TOTAL | 2 | 0.78 | 1.57 | 0.00007855 | 0.78 | 4:00:00 | 2 0 0 100 | ================== SUMMARY METRICS ================== | Metric | Value | |-----------------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades | 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | CAGR % | 460.87% | | Profit factor | 1.11 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Long / Short | 352 / 77 | | Total profit Long % | 1250.58% | | Total profit Short % | -15.02% | | Absolute profit Long | 0.00838792 BTC | | Absolute profit Short | -0.00076 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Entry signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | Canceled Trade Entries | 34 | | Canceled Entry Orders | 123 | | Replaced Entry Orders | 89 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Max % of account underwater | 25.19% | | Absolute Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | =====================================================","title":"Understand the backtesting result"},{"location":"backtesting/#backtesting-report-table","text":"The 1 st table contains all trades the bot made, including \"left open trades\". The last line will give you the overall performance of your strategy, here: | TOTAL | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 0 243 43.4 | The bot has made 429 trades for an average duration of 4:12:00 , with a performance of 76.20% (profit), that means it has earned a total of 0.00762792 BTC starting with a capital of 0.01 BTC. The column Avg Profit % shows the average profit for all trades made while the column Cum Profit % sums up all the profits/losses. The column Tot Profit % shows instead the total profit % in relation to the starting balance. In the above results, we have a starting balance of 0.01 BTC and an absolute profit of 0.00762792 BTC - so the Tot Profit % will be (0.00762792 / 0.01) * 100 ~= 76.2% . Your strategy performance is influenced by your buy strategy, your exit strategy, and also by the minimal_roi and stop_loss you have set. For example, if your minimal_roi is only \"0\": 0.01 you cannot expect the bot to make more profit than 1% (because it will exit every time a trade reaches 1%). \"minimal_roi\" : { \"0\" : 0.01 }, On the other hand, if you set a too high minimal_roi like \"0\": 0.55 (55%), there is almost no chance that the bot will ever reach this profit. Hence, keep in mind that your performance is an integral mix of all different elements of the strategy, your configuration, and the crypto-currency pairs you have set up.","title":"Backtesting report table"},{"location":"backtesting/#exit-reasons-table","text":"The 2 nd table contains a recap of exit reasons. This table can tell you which area needs some additional work (e.g. all or many of the exit_signal trades are losses, so you should work on improving the exit signal, or consider disabling it).","title":"Exit reasons table"},{"location":"backtesting/#left-open-trades-table","text":"The 3 rd table contains all trades the bot had to force_exit at the end of the backtesting period to present you the full picture. This is necessary to simulate realistic behavior, since the backtest period has to end at some point, while realistically, you could leave the bot running forever. These trades are also included in the first table, but are also shown separately in this table for clarity.","title":"Left open trades table"},{"location":"backtesting/#summary-metrics","text":"The last element of the backtest report is the summary metrics table. It contains some useful key metrics about performance of your strategy on backtesting data. ================== SUMMARY METRICS ================== | Metric | Value | |-----------------------------+---------------------| | Backtesting from | 2019-01-01 00:00:00 | | Backtesting to | 2019-05-01 00:00:00 | | Max open trades | 3 | | | | | Total/Daily Avg Trades | 429 / 3.575 | | Starting balance | 0.01000000 BTC | | Final balance | 0.01762792 BTC | | Absolute profit | 0.00762792 BTC | | Total profit % | 76.2% | | CAGR % | 460.87% | | Profit factor | 1.11 | | Avg. stake amount | 0.001 BTC | | Total trade volume | 0.429 BTC | | | | | Long / Short | 352 / 77 | | Total profit Long % | 1250.58% | | Total profit Short % | -15.02% | | Absolute profit Long | 0.00838792 BTC | | Absolute profit Short | -0.00076 BTC | | | | | Best Pair | LSK/BTC 26.26% | | Worst Pair | ZEC/BTC -10.18% | | Best Trade | LSK/BTC 4.25% | | Worst Trade | ZEC/BTC -10.25% | | Best day | 0.00076 BTC | | Worst day | -0.00036 BTC | | Days win/draw/lose | 12 / 82 / 25 | | Avg. Duration Winners | 4:23:00 | | Avg. Duration Loser | 6:55:00 | | Rejected Entry signals | 3089 | | Entry/Exit Timeouts | 0 / 0 | | Canceled Trade Entries | 34 | | Canceled Entry Orders | 123 | | Replaced Entry Orders | 89 | | | | | Min balance | 0.00945123 BTC | | Max balance | 0.01846651 BTC | | Max % of account underwater | 25.19% | | Absolute Drawdown (Account) | 13.33% | | Drawdown | 0.0015 BTC | | Drawdown high | 0.0013 BTC | | Drawdown low | -0.0002 BTC | | Drawdown Start | 2019-02-15 14:10:00 | | Drawdown End | 2019-04-11 18:15:00 | | Market change | -5.88% | ===================================================== Backtesting from / Backtesting to : Backtesting range (usually defined with the --timerange option). Max open trades : Setting of max_open_trades (or --max-open-trades ) - or number of pairs in the pairlist (whatever is lower). Total/Daily Avg Trades : Identical to the total trades of the backtest output table / Total trades divided by the backtesting duration in days (this will give you information about how many trades to expect from the strategy). Starting balance : Start balance - as given by dry-run-wallet (config or command line). Final balance : Final balance - starting balance + absolute profit. Absolute profit : Profit made in stake currency. Total profit % : Total profit. Aligned to the TOTAL row's Tot Profit % from the first table. Calculated as (End capital \u2212 Starting capital) / Starting capital . CAGR % : Compound annual growth rate. Profit factor : profit / loss. Avg. stake amount : Average stake amount, either stake_amount or the average when using dynamic stake amount. Total trade volume : Volume generated on the exchange to reach the above profit. Best Pair / Worst Pair : Best and worst performing pair, and it's corresponding Cum Profit % . Best Trade / Worst Trade : Biggest single winning trade and biggest single losing trade. Best day / Worst day : Best and worst day based on daily profit. Days win/draw/lose : Winning / Losing days (draws are usually days without closed trade). Avg. Duration Winners / Avg. Duration Loser : Average durations for winning and losing trades. Rejected Entry signals : Trade entry signals that could not be acted upon due to max_open_trades being reached. Entry/Exit Timeouts : Entry/exit orders which did not fill (only applicable if custom pricing is used). Canceled Trade Entries : Number of trades that have been canceled by user request via adjust_entry_price . Canceled Entry Orders : Number of entry orders that have been canceled by user request via adjust_entry_price . Replaced Entry Orders : Number of entry orders that have been replaced by user request via adjust_entry_price . Min balance / Max balance : Lowest and Highest Wallet balance during the backtest period. Max % of account underwater : Maximum percentage your account has decreased from the top since the simulation started. Calculated as the maximum of (Max Balance - Current Balance) / (Max Balance) . Absolute Drawdown (Account) : Maximum Account Drawdown experienced. Calculated as (Absolute Drawdown) / (DrawdownHigh + startingBalance) . Drawdown : Maximum, absolute drawdown experienced. Difference between Drawdown High and Subsequent Low point. Drawdown high / Drawdown low : Profit at the beginning and end of the largest drawdown period. A negative low value means initial capital lost. Drawdown Start / Drawdown End : Start and end datetime for this largest drawdown (can also be visualized via the plot-dataframe sub-command). Market change : Change of the market during the backtest period. Calculated as average of all pairs changes from the first to the last candle using the \"close\" column. Long / Short : Split long/short values (Only shown when short trades were made). Total profit Long % / Absolute profit Long : Profit long trades only (Only shown when short trades were made). Total profit Short % / Absolute profit Short : Profit short trades only (Only shown when short trades were made).","title":"Summary metrics"},{"location":"backtesting/#daily-weekly-monthly-breakdown","text":"You can get an overview over daily / weekly or monthly results by using the --breakdown <> switch. To visualize daily and weekly breakdowns, you can use the following: freqtrade backtesting --strategy MyAwesomeStrategy --breakdown day week ======================== DAY BREAKDOWN ========================= | Day | Tot Profit USDT | Wins | Draws | Losses | |------------+-------------------+--------+---------+----------| | 03/07/2021 | 200.0 | 2 | 0 | 0 | | 04/07/2021 | -50.31 | 0 | 0 | 2 | | 05/07/2021 | 220.611 | 3 | 2 | 0 | | 06/07/2021 | 150.974 | 3 | 0 | 2 | | 07/07/2021 | -70.193 | 1 | 0 | 2 | | 08/07/2021 | 212.413 | 2 | 0 | 3 | The output will show a table containing the realized absolute Profit (in stake currency) for the given timeperiod, as well as wins, draws and losses that materialized (closed) on this day. Below that there will be a second table for the summarized values of weeks indicated by the date of the closing Sunday. The same would apply to a monthly breakdown indicated by the last day of the month.","title":"Daily / Weekly / Monthly breakdown"},{"location":"backtesting/#backtest-result-caching","text":"To save time, by default backtest will reuse a cached result from within the last day when the backtested strategy and config match that of a previous backtest. To force a new backtest despite existing result for an identical run specify --cache none parameter. Warning Caching is automatically disabled for open-ended timeranges ( --timerange 20210101- ), as freqtrade cannot ensure reliably that the underlying data didn't change. It can also use cached results where it shouldn't if the original backtest had missing data at the end, which was fixed by downloading more data. In this instance, please use --cache none once to force a fresh backtest.","title":"Backtest result caching"},{"location":"backtesting/#further-backtest-result-analysis","text":"To further analyze your backtest results, you can export the trades . You can then load the trades to perform further analysis as shown in the data analysis backtesting section.","title":"Further backtest-result analysis"},{"location":"backtesting/#assumptions-made-by-backtesting","text":"Since backtesting lacks some detailed information about what happens within a candle, it needs to take a few assumptions: Exchange trading limits are respected Buys happen at open-price All orders are filled at the requested price (no slippage, no unfilled orders) Exit-signal exits happen at open-price of the consecutive candle Exit-signal is favored over Stoploss, because exit-signals are assumed to trigger on candle's open ROI exits are compared to high - but the ROI value is used (e.g. ROI = 2%, high=5% - so the exit will be at 2%) exits are never \"below the candle\", so a ROI of 2% may result in a exit at 2.4% if low was at 2.4% profit Forceexits caused by <N>=-1 ROI entries use low as exit value, unless N falls on the candle open (e.g. 120: -1 for 1h candles) Stoploss exits happen exactly at stoploss price, even if low was lower, but the loss will be 2 * fees higher than the stoploss price Stoploss is evaluated before ROI within one candle. So you can often see more trades with the stoploss exit reason comparing to the results obtained with the same strategy in the Dry Run/Live Trade modes Low happens before high for stoploss, protecting capital first Trailing stoploss Trailing Stoploss is only adjusted if it's below the candle's low (otherwise it would be triggered) On trade entry candles that trigger trailing stoploss, the \"minimum offset\" ( stop_positive_offset ) is assumed (instead of high) - and the stop is calculated from this point High happens first - adjusting stoploss Low uses the adjusted stoploss (so exits with large high-low difference are backtested correctly) ROI applies before trailing-stop, ensuring profits are \"top-capped\" at ROI if both ROI and trailing stop applies Exit-reason does not explain if a trade was positive or negative, just what triggered the exit (this can look odd if negative ROI values are used) Evaluation sequence (if multiple signals happen on the same candle) Exit-signal Stoploss ROI Trailing stoploss Taking these assumptions, backtesting tries to mirror real trading as closely as possible. However, backtesting will never replace running a strategy in dry-run mode. Also, keep in mind that past results don't guarantee future success. In addition to the above assumptions, strategy authors should carefully read the Common Mistakes section, to avoid using data in backtesting which is not available in real market conditions.","title":"Assumptions made by backtesting"},{"location":"backtesting/#trading-limits-in-backtesting","text":"Exchanges have certain trading limits, like minimum base currency, or minimum stake (quote) currency. These limits are usually listed in the exchange documentation as \"trading rules\" or similar. Backtesting (as well as live and dry-run) does honor these limits, and will ensure that a stoploss can be placed below this value - so the value will be slightly higher than what the exchange specifies. Freqtrade has however no information about historic limits. This can lead to situations where trading-limits are inflated by using a historic price, resulting in minimum amounts > 50$. For example: BTC minimum tradable amount is 0.001. BTC trades at 22.000$ today (0.001 BTC is related to this) - but the backtesting period includes prices as high as 50.000$. Today's minimum would be 0.001 * 22_000 - or 22$. However the limit could also be 50$ - based on 0.001 * 50_000 in some historic setting.","title":"Trading limits in backtesting"},{"location":"backtesting/#trading-precision-limits","text":"Most exchanges pose precision limits on both price and amounts, so you cannot buy 1.0020401 of a pair, or at a price of 1.24567123123. Instead, these prices and amounts will be rounded or truncated (based on the exchange definition) to the defined trading precision. The above values may for example be rounded to an amount of 1.002, and a price of 1.24567. These precision values are based on current exchange limits (as described in the above section ), as historic precision limits are not available.","title":"Trading precision limits"},{"location":"backtesting/#improved-backtest-accuracy","text":"One big limitation of backtesting is it's inability to know how prices moved intra-candle (was high before close, or viceversa?). So assuming you run backtesting with a 1h timeframe, there will be 4 prices for that candle (Open, High, Low, Close). While backtesting does take some assumptions (read above) about this - this can never be perfect, and will always be biased in one way or the other. To mitigate this, freqtrade can use a lower (faster) timeframe to simulate intra-candle movements. To utilize this, you can append --timeframe-detail 5m to your regular backtesting command. freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m This will load 1h data as well as 5m data for the timeframe. The strategy will be analyzed with the 1h timeframe - and for every \"open trade candle\" (candles where a trade is open) the 5m data will be used to simulate intra-candle movements. All callback functions ( custom_exit() , custom_stoploss() , ... ) will be running for each 5m candle once the trade is opened (so 12 times in the above example of 1h timeframe, and 5m detailed timeframe). --timeframe-detail must be smaller than the original timeframe, otherwise backtesting will fail to start. Obviously this will require more memory (5m data is bigger than 1h data), and will also impact runtime (depending on the amount of trades and trade durations). Also, data must be available / downloaded already. Tip You can use this function as the last part of strategy development, to ensure your strategy is not exploiting one of the backtesting assumptions . Strategies that perform similarly well with this mode have a good chance to perform well in dry/live modes too (although only forward-testing (dry-mode) can really confirm a strategy).","title":"Improved backtest accuracy"},{"location":"backtesting/#backtesting-multiple-strategies","text":"To compare multiple strategies, a list of Strategies can be provided to backtesting. This is limited to 1 timeframe value per run. However, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this will give a nice runtime boost. All listed Strategies need to be in the same directory. freqtrade backtesting --timerange 20180401 -20180410 --timeframe 5m --strategy-list Strategy001 Strategy002 --export trades This will save the results to user_data/backtest_results/backtest-result-<strategy>.json , injecting the strategy-name into the target filename. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up to see the details per strategy. =========================================================== STRATEGY SUMMARY ========================================================================= | Strategy | Buys | Avg Profit % | Cum Profit % | Tot Profit BTC | Tot Profit % | Avg Duration | Wins | Draws | Losses | Drawdown % | |:------------|-------:|---------------:|---------------:|-----------------:|---------------:|:---------------|------:|-------:|-------:|-----------:| | Strategy1 | 429 | 0.36 | 152.41 | 0.00762792 | 76.20 | 4:12:00 | 186 | 0 | 243 | 45.2 | | Strategy2 | 1487 | -0.13 | -197.58 | -0.00988917 | -98.79 | 4:43:00 | 662 | 0 | 825 | 241.68 |","title":"Backtesting multiple strategies"},{"location":"backtesting/#next-step","text":"Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt","title":"Next step"},{"location":"bot-basics/","text":"Freqtrade basics \u00b6 This page provides you some basic concepts on how Freqtrade works and operates. Freqtrade terminology \u00b6 Strategy : Your trading strategy, telling the bot what to do. Trade : Open position. Open Order : Order which is currently placed on the exchange, and is not yet complete. Pair : Tradable pair, usually in the format of Base/Quote (e.g. XRP/USDT). Timeframe : Candle length to use (e.g. \"5m\" , \"1h\" , ...). Indicators : Technical indicators (SMA, EMA, RSI, ...). Limit order : Limit orders which execute at the defined limit price or better. Market order : Guaranteed to fill, may move price depending on the order size. Fee handling \u00b6 All profit calculations of Freqtrade include fees. For Backtesting / Hyperopt / Dry-run modes, the exchange default fee is used (lowest tier on the exchange). For live operations, fees are used as applied by the exchange (this includes BNB rebates etc.). Bot execution logic \u00b6 Starting freqtrade in dry-run or live mode (using freqtrade trade ) will start the bot and start the bot iteration loop. This will also run the bot_start() callback. By default, the bot loop runs every few seconds ( internals.process_throttle_secs ) and performs the following actions: Fetch open trades from persistence. Calculate current list of tradable pairs. Download OHLCV data for the pairlist including all informative pairs This step is only executed once per Candle to avoid unnecessary network traffic. Call bot_loop_start() strategy callback. Analyze strategy per pair. Call populate_indicators() Call populate_entry_trend() Call populate_exit_trend() Check timeouts for open orders. Calls check_entry_timeout() strategy callback for open entry orders. Calls check_exit_timeout() strategy callback for open exit orders. Calls adjust_entry_price() strategy callback for open entry orders. Verifies existing positions and eventually places exit orders. Considers stoploss, ROI and exit-signal, custom_exit() and custom_stoploss() . Determine exit-price based on exit_pricing configuration setting or by using the custom_exit_price() callback. Before a exit order is placed, confirm_trade_exit() strategy callback is called. Check position adjustments for open trades if enabled by calling adjust_trade_position() and place additional order if required. Check if trade-slots are still available (if max_open_trades is reached). Verifies entry signal trying to enter new positions. Determine entry-price based on entry_pricing configuration setting, or by using the custom_entry_price() callback. In Margin and Futures mode, leverage() strategy callback is called to determine the desired leverage. Determine stake size by calling the custom_stake_amount() callback. Before an entry order is placed, confirm_trade_entry() strategy callback is called. This loop will be repeated again and again until the bot is stopped. Backtesting / Hyperopt execution logic \u00b6 backtesting or hyperopt do only part of the above logic, since most of the trading operations are fully simulated. Load historic data for configured pairlist. Calls bot_start() once. Calls bot_loop_start() once. Calculate indicators (calls populate_indicators() once per pair). Calculate entry / exit signals (calls populate_entry_trend() and populate_exit_trend() once per pair). Loops per candle simulating entry and exit points. Check for Order timeouts, either via the unfilledtimeout configuration, or via check_entry_timeout() / check_exit_timeout() strategy callbacks. Calls adjust_entry_price() strategy callback for open entry orders. Check for trade entry signals ( enter_long / enter_short columns). Confirm trade entry / exits (calls confirm_trade_entry() and confirm_trade_exit() if implemented in the strategy). Call custom_entry_price() (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle). In Margin and Futures mode, leverage() strategy callback is called to determine the desired leverage. Determine stake size by calling the custom_stake_amount() callback. Check position adjustments for open trades if enabled and call adjust_trade_position() to determine if an additional order is requested. Call custom_stoploss() and custom_exit() to find custom exit points. For exits based on exit-signal, custom-exit and partial exits: Call custom_exit_price() to determine exit price (Prices are moved to be within the closing candle). Generate backtest report output Note Both Backtesting and Hyperopt include exchange default Fees in the calculation. Custom fees can be passed to backtesting / hyperopt by specifying the --fee argument.","title":"Freqtrade Basics"},{"location":"bot-basics/#freqtrade-basics","text":"This page provides you some basic concepts on how Freqtrade works and operates.","title":"Freqtrade basics"},{"location":"bot-basics/#freqtrade-terminology","text":"Strategy : Your trading strategy, telling the bot what to do. Trade : Open position. Open Order : Order which is currently placed on the exchange, and is not yet complete. Pair : Tradable pair, usually in the format of Base/Quote (e.g. XRP/USDT). Timeframe : Candle length to use (e.g. \"5m\" , \"1h\" , ...). Indicators : Technical indicators (SMA, EMA, RSI, ...). Limit order : Limit orders which execute at the defined limit price or better. Market order : Guaranteed to fill, may move price depending on the order size.","title":"Freqtrade terminology"},{"location":"bot-basics/#fee-handling","text":"All profit calculations of Freqtrade include fees. For Backtesting / Hyperopt / Dry-run modes, the exchange default fee is used (lowest tier on the exchange). For live operations, fees are used as applied by the exchange (this includes BNB rebates etc.).","title":"Fee handling"},{"location":"bot-basics/#bot-execution-logic","text":"Starting freqtrade in dry-run or live mode (using freqtrade trade ) will start the bot and start the bot iteration loop. This will also run the bot_start() callback. By default, the bot loop runs every few seconds ( internals.process_throttle_secs ) and performs the following actions: Fetch open trades from persistence. Calculate current list of tradable pairs. Download OHLCV data for the pairlist including all informative pairs This step is only executed once per Candle to avoid unnecessary network traffic. Call bot_loop_start() strategy callback. Analyze strategy per pair. Call populate_indicators() Call populate_entry_trend() Call populate_exit_trend() Check timeouts for open orders. Calls check_entry_timeout() strategy callback for open entry orders. Calls check_exit_timeout() strategy callback for open exit orders. Calls adjust_entry_price() strategy callback for open entry orders. Verifies existing positions and eventually places exit orders. Considers stoploss, ROI and exit-signal, custom_exit() and custom_stoploss() . Determine exit-price based on exit_pricing configuration setting or by using the custom_exit_price() callback. Before a exit order is placed, confirm_trade_exit() strategy callback is called. Check position adjustments for open trades if enabled by calling adjust_trade_position() and place additional order if required. Check if trade-slots are still available (if max_open_trades is reached). Verifies entry signal trying to enter new positions. Determine entry-price based on entry_pricing configuration setting, or by using the custom_entry_price() callback. In Margin and Futures mode, leverage() strategy callback is called to determine the desired leverage. Determine stake size by calling the custom_stake_amount() callback. Before an entry order is placed, confirm_trade_entry() strategy callback is called. This loop will be repeated again and again until the bot is stopped.","title":"Bot execution logic"},{"location":"bot-basics/#backtesting-hyperopt-execution-logic","text":"backtesting or hyperopt do only part of the above logic, since most of the trading operations are fully simulated. Load historic data for configured pairlist. Calls bot_start() once. Calls bot_loop_start() once. Calculate indicators (calls populate_indicators() once per pair). Calculate entry / exit signals (calls populate_entry_trend() and populate_exit_trend() once per pair). Loops per candle simulating entry and exit points. Check for Order timeouts, either via the unfilledtimeout configuration, or via check_entry_timeout() / check_exit_timeout() strategy callbacks. Calls adjust_entry_price() strategy callback for open entry orders. Check for trade entry signals ( enter_long / enter_short columns). Confirm trade entry / exits (calls confirm_trade_entry() and confirm_trade_exit() if implemented in the strategy). Call custom_entry_price() (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle). In Margin and Futures mode, leverage() strategy callback is called to determine the desired leverage. Determine stake size by calling the custom_stake_amount() callback. Check position adjustments for open trades if enabled and call adjust_trade_position() to determine if an additional order is requested. Call custom_stoploss() and custom_exit() to find custom exit points. For exits based on exit-signal, custom-exit and partial exits: Call custom_exit_price() to determine exit price (Prices are moved to be within the closing candle). Generate backtest report output Note Both Backtesting and Hyperopt include exchange default Fees in the calculation. Custom fees can be passed to backtesting / hyperopt by specifying the --fee argument.","title":"Backtesting / Hyperopt execution logic"},{"location":"bot-usage/","text":"Start the bot \u00b6 This page explains the different parameters of the bot and how to run it. Note If you've used setup.sh , don't forget to activate your virtual environment ( source .env/bin/activate ) before running freqtrade commands. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges. Bot commands \u00b6 usage: freqtrade [-h] [-V] {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} ... Free, open source crypto trading bot positional arguments: {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} trade Trade module. create-userdir Create user-data directory. new-config Create new config new-strategy Create new strategy download-data Download backtesting data. convert-data Convert candle (OHLCV) data from one format to another. convert-trade-data Convert trade data from one format to another. list-data List downloaded data. backtesting Backtesting module. edge Edge module. hyperopt Hyperopt module. hyperopt-list List Hyperopt results hyperopt-show Show details of Hyperopt results list-exchanges Print available exchanges. list-hyperopts Print available hyperopt classes. list-markets Print markets on exchange. list-pairs Print pairs on exchange. list-strategies Print available strategies. list-timeframes Print available timeframes for the exchange. show-trades Show trades. test-pairlist Test your pairlist configuration. install-ui Install FreqUI plot-dataframe Plot candles with indicators. plot-profit Generate plot showing profits. webserver Webserver module. optional arguments: -h, --help show this help message and exit -V, --version show program's version number and exit Bot trading commands \u00b6 usage: freqtrade trade [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--db-url PATH] [--sd-notify] [--dry-run] [--dry-run-wallet DRY_RUN_WALLET] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --sd-notify Notify systemd service manager. --dry-run Enforce dry-run for trading (removes Exchange secrets and simulates trades). --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. How to specify which configuration file be used? \u00b6 The bot allows you to select which configuration file you want to use by means of the -c/--config command line option: freqtrade trade -c path/far/far/away/config.json Per default, the bot loads the config.json configuration file from the current working directory. How to use multiple configuration files? \u00b6 The bot allows you to use multiple configuration files by specifying multiple -c/--config options in the command line. Configuration parameters defined in the latter configuration files override parameters with the same name defined in the previous configuration files specified in the command line earlier. For example, you can make a separate configuration file with your key and secret for the Exchange you use for trading, specify default configuration file with empty key and secret values while running in the Dry Mode (which does not actually require them): freqtrade trade -c ./config.json and specify both configuration files when running in the normal Live Trade Mode: freqtrade trade -c ./config.json -c path/to/secrets/keys.config.json This could help you hide your private Exchange key and Exchange secret on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet. See more details on this technique with examples in the documentation page on configuration . Where to store custom data \u00b6 Freqtrade allows the creation of a user-data directory using freqtrade create-userdir --userdir someDirectory . This directory will look as follows: user_data/ \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopts \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies You can add the entry \"user_data_dir\" setting to your configuration, to always point your bot to this directory. Alternatively, pass in --userdir to every command. The bot will fail to start if the directory does not exist, but will create necessary subdirectories. This directory should contain your custom strategies, custom hyperopts and hyperopt loss functions, backtesting historical data (downloaded using either backtesting command or the download script) and plot outputs. It is recommended to use version control to keep track of changes to your strategies. How to use --strategy ? \u00b6 This parameter will allow you to load your custom strategy class. To test the bot installation, you can use the SampleStrategy installed by the create-userdir subcommand (usually user_data/strategy/sample_strategy.py ). The bot will search your strategy file within user_data/strategies . To use other directories, please read the next section about --strategy-path . To load a strategy, simply pass the class name (e.g.: CustomStrategy ) in this parameter. Example: In user_data/strategies you have a file my_awesome_strategy.py which has a strategy class called AwesomeStrategy to load it: freqtrade trade --strategy AwesomeStrategy If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code). Learn more about strategy file in Strategy Customization . How to use --strategy-path ? \u00b6 This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!): freqtrade trade --strategy AwesomeStrategy --strategy-path /some/directory How to install a strategy? \u00b6 This is very simple. Copy paste your strategy file into the directory user_data/strategies or use --strategy-path . And voila, the bot is ready to use it. How to use --db-url ? \u00b6 When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using --db-url . This can also be used to specify a custom database in production mode. Example command: freqtrade trade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite Next step \u00b6 The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization .","title":"Start the bot"},{"location":"bot-usage/#start-the-bot","text":"This page explains the different parameters of the bot and how to run it. Note If you've used setup.sh , don't forget to activate your virtual environment ( source .env/bin/activate ) before running freqtrade commands. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.","title":"Start the bot"},{"location":"bot-usage/#bot-commands","text":"usage: freqtrade [-h] [-V] {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} ... Free, open source crypto trading bot positional arguments: {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver} trade Trade module. create-userdir Create user-data directory. new-config Create new config new-strategy Create new strategy download-data Download backtesting data. convert-data Convert candle (OHLCV) data from one format to another. convert-trade-data Convert trade data from one format to another. list-data List downloaded data. backtesting Backtesting module. edge Edge module. hyperopt Hyperopt module. hyperopt-list List Hyperopt results hyperopt-show Show details of Hyperopt results list-exchanges Print available exchanges. list-hyperopts Print available hyperopt classes. list-markets Print markets on exchange. list-pairs Print pairs on exchange. list-strategies Print available strategies. list-timeframes Print available timeframes for the exchange. show-trades Show trades. test-pairlist Test your pairlist configuration. install-ui Install FreqUI plot-dataframe Plot candles with indicators. plot-profit Generate plot showing profits. webserver Webserver module. optional arguments: -h, --help show this help message and exit -V, --version show program's version number and exit","title":"Bot commands"},{"location":"bot-usage/#bot-trading-commands","text":"usage: freqtrade trade [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--db-url PATH] [--sd-notify] [--dry-run] [--dry-run-wallet DRY_RUN_WALLET] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --sd-notify Notify systemd service manager. --dry-run Enforce dry-run for trading (removes Exchange secrets and simulates trades). --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path.","title":"Bot trading commands"},{"location":"bot-usage/#how-to-specify-which-configuration-file-be-used","text":"The bot allows you to select which configuration file you want to use by means of the -c/--config command line option: freqtrade trade -c path/far/far/away/config.json Per default, the bot loads the config.json configuration file from the current working directory.","title":"How to specify which configuration file be used?"},{"location":"bot-usage/#how-to-use-multiple-configuration-files","text":"The bot allows you to use multiple configuration files by specifying multiple -c/--config options in the command line. Configuration parameters defined in the latter configuration files override parameters with the same name defined in the previous configuration files specified in the command line earlier. For example, you can make a separate configuration file with your key and secret for the Exchange you use for trading, specify default configuration file with empty key and secret values while running in the Dry Mode (which does not actually require them): freqtrade trade -c ./config.json and specify both configuration files when running in the normal Live Trade Mode: freqtrade trade -c ./config.json -c path/to/secrets/keys.config.json This could help you hide your private Exchange key and Exchange secret on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet. See more details on this technique with examples in the documentation page on configuration .","title":"How to use multiple configuration files?"},{"location":"bot-usage/#where-to-store-custom-data","text":"Freqtrade allows the creation of a user-data directory using freqtrade create-userdir --userdir someDirectory . This directory will look as follows: user_data/ \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopts \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies You can add the entry \"user_data_dir\" setting to your configuration, to always point your bot to this directory. Alternatively, pass in --userdir to every command. The bot will fail to start if the directory does not exist, but will create necessary subdirectories. This directory should contain your custom strategies, custom hyperopts and hyperopt loss functions, backtesting historical data (downloaded using either backtesting command or the download script) and plot outputs. It is recommended to use version control to keep track of changes to your strategies.","title":"Where to store custom data"},{"location":"bot-usage/#how-to-use-strategy","text":"This parameter will allow you to load your custom strategy class. To test the bot installation, you can use the SampleStrategy installed by the create-userdir subcommand (usually user_data/strategy/sample_strategy.py ). The bot will search your strategy file within user_data/strategies . To use other directories, please read the next section about --strategy-path . To load a strategy, simply pass the class name (e.g.: CustomStrategy ) in this parameter. Example: In user_data/strategies you have a file my_awesome_strategy.py which has a strategy class called AwesomeStrategy to load it: freqtrade trade --strategy AwesomeStrategy If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code). Learn more about strategy file in Strategy Customization .","title":"How to use --strategy?"},{"location":"bot-usage/#how-to-use-strategy-path","text":"This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!): freqtrade trade --strategy AwesomeStrategy --strategy-path /some/directory","title":"How to use --strategy-path?"},{"location":"bot-usage/#how-to-install-a-strategy","text":"This is very simple. Copy paste your strategy file into the directory user_data/strategies or use --strategy-path . And voila, the bot is ready to use it.","title":"How to install a strategy?"},{"location":"bot-usage/#how-to-use-db-url","text":"When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using --db-url . This can also be used to specify a custom database in production mode. Example command: freqtrade trade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite","title":"How to use --db-url?"},{"location":"bot-usage/#next-step","text":"The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization .","title":"Next step"},{"location":"configuration/","text":"Configure the bot \u00b6 Freqtrade has many configurable features and possibilities. By default, these settings are configured via the configuration file (see below). The Freqtrade configuration file \u00b6 The bot uses a set of configuration parameters during its operation that all together conform to the bot configuration. It normally reads its configuration from a file (Freqtrade configuration file). Per default, the bot loads the configuration from the config.json file, located in the current working directory. You can specify a different configuration file used by the bot with the -c/--config command-line option. If you used the Quick start method for installing the bot, the installation script should have already created the default configuration file ( config.json ) for you. If the default configuration file is not created we recommend to use freqtrade new-config --config config.json to generate a basic configuration file. The Freqtrade configuration file is to be written in JSON format. Additionally to the standard JSON syntax, you may use one-line // ... and multi-line /* ... */ comments in your configuration files and trailing commas in the lists of parameters. Do not worry if you are not familiar with JSON format -- simply open the configuration file with an editor of your choice, make some changes to the parameters you need, save your changes and, finally, restart the bot or, if it was previously stopped, run it again with the changes you made to the configuration. The bot validates the syntax of the configuration file at startup and will warn you if you made any errors editing it, pointing out problematic lines. Environment variables \u00b6 Set options in the Freqtrade configuration via environment variables. This takes priority over the corresponding value in configuration or strategy. Environment variables must be prefixed with FREQTRADE__ to be loaded to the freqtrade configuration. __ serves as level separator, so the format used should correspond to FREQTRADE__{section}__{key} . As such - an environment variable defined as export FREQTRADE__STAKE_AMOUNT=200 would result in {stake_amount: 200} . A more complex example might be export FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> to keep your exchange key secret. This will move the value to the exchange.key section of the configuration. Using this scheme, all configuration settings will also be available as environment variables. Please note that Environment variables will overwrite corresponding settings in your configuration, but command line Arguments will always win. Common example: FREQTRADE__TELEGRAM__CHAT_ID=<telegramchatid> FREQTRADE__TELEGRAM__TOKEN=<telegramToken> FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> FREQTRADE__EXCHANGE__SECRET=<yourExchangeSecret> Note Environment variables detected are logged at startup - so if you can't find why a value is not what you think it should be based on the configuration, make sure it's not loaded from an environment variable. Multiple configuration files \u00b6 Multiple configuration files can be specified and used by the bot or the bot can read its configuration parameters from the process standard input stream. You can specify additional configuration files in add_config_files . Files specified in this parameter will be loaded and merged with the initial config file. The files are resolved relative to the initial configuration file. This is similar to using multiple --config parameters, but simpler in usage as you don't have to specify all files for all commands. Use multiple configuration files to keep secrets secret You can use a 2 nd configuration file containing your secrets. That way you can share your \"primary\" configuration file, while still keeping your API keys for yourself. user_data/config.json \"add_config_files\" : [ \"config-private.json\" ] freqtrade trade --config user_data/config.json <...> The 2 nd file should only specify what you intend to override. If a key is in more than one of the configurations, then the \"last specified configuration\" wins (in the above example, config-private.json ). For one-off commands, you can also use the below syntax by specifying multiple \"--config\" parameters. freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> This is equivalent to the example above - but config-private.json is specified as cli argument. config collision handling If the same configuration setting takes place in both config.json and config-import.json , then the parent configuration wins. In the below case, max_open_trades would be 3 after the merging - as the reusable \"import\" configuration has this key overwritten. user_data/config.json { \"max_open_trades\" : 3 , \"stake_currency\" : \"USDT\" , \"add_config_files\" : [ \"config-import.json\" ] } user_data/config-import.json { \"max_open_trades\" : 10 , \"stake_amount\" : \"unlimited\" , } Resulting combined configuration: Result { \"max_open_trades\" : 3 , \"stake_currency\" : \"USDT\" , \"stake_amount\" : \"unlimited\" } Configuration parameters \u00b6 The table below will list all configuration parameters available. Freqtrade can also load many options via command line (CLI) arguments (check out the commands --help output for details). Configuration option prevalence \u00b6 The prevalence for all Options is as follows: CLI arguments override any other option Environment Variables Configuration files are used in sequence (the last file wins) and override Strategy configurations. Strategy configurations are only used if they are not set via configuration or command-line arguments. These options are marked with Strategy Override in the below table. Parameters table \u00b6 Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description max_open_trades Required. Number of open trades your bot is allowed to have. Only one open trade per pair is possible, so the length of your pairlist is another limitation that can apply. If -1 then it is ignored (i.e. potentially unlimited open trades, limited by the pairlist). More information below . Datatype: Positive integer or -1. stake_currency Required. Crypto-currency used for trading. Datatype: String stake_amount Required. Amount of crypto-currency your bot will use for each trade. Set it to \"unlimited\" to allow the bot to use all available balance. More information below . Datatype: Positive float or \"unlimited\" . tradable_balance_ratio Ratio of the total account balance the bot is allowed to trade. More information below . Defaults to 0.99 99%). Datatype: Positive float between 0.1 and 1.0 . available_capital Available starting capital for the bot. Useful when running multiple bots on the same exchange account. More information below . Datatype: Positive float. amend_last_stake_amount Use reduced last stake amount if necessary. More information below . Defaults to false . Datatype: Boolean last_stake_amount_min_ratio Defines minimum stake amount that has to be left and executed. Applies only to the last stake amount when it's amended to a reduced value (i.e. if amend_last_stake_amount is set to true ). More information below . Defaults to 0.5 . Datatype: Float (as ratio) amount_reserve_percent Reserve some amount in min pair stake amount. The bot will reserve amount_reserve_percent + stoploss value when calculating min pair stake amount in order to avoid possible trade refusals. Defaults to 0.05 (5%). Datatype: Positive Float as ratio. timeframe The timeframe to use (e.g 1m , 5m , 15m , 30m , 1h ...). Usually missing in configuration, and specified in the strategy. Strategy Override . Datatype: String fiat_display_currency Fiat currency used to show your profits. More information below . Datatype: String dry_run Required. Define if the bot must be in Dry Run or production mode. Defaults to true . Datatype: Boolean dry_run_wallet Define the starting amount in stake currency for the simulated wallet used by the bot running in Dry Run mode. Defaults to 1000 . Datatype: Float cancel_open_orders_on_exit Cancel open orders when the /stop RPC command is issued, Ctrl+C is pressed or the bot dies unexpectedly. When set to true , this allows you to use /stop to cancel unfilled and partially filled orders in the event of a market crash. It does not impact open positions. Defaults to false . Datatype: Boolean process_only_new_candles Enable processing of indicators only when new candles arrive. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override . Defaults to true . Datatype: Boolean minimal_roi Required. Set the threshold as ratio the bot will use to exit a trade. More information below . Strategy Override . Datatype: Dict stoploss Required. Value as ratio of the stoploss used by the bot. More details in the stoploss documentation . Strategy Override . Datatype: Float (as ratio) trailing_stop Enables trailing stoploss (based on stoploss in either configuration or strategy file). More details in the stoploss documentation . Strategy Override . Datatype: Boolean trailing_stop_positive Changes stoploss once profit has been reached. More details in the stoploss documentation . Strategy Override . Datatype: Float trailing_stop_positive_offset Offset on when to apply trailing_stop_positive . Percentage value which should be positive. More details in the stoploss documentation . Strategy Override . Defaults to 0.0 (no offset). Datatype: Float trailing_only_offset_is_reached Only apply trailing stoploss when the offset is reached. stoploss documentation . Strategy Override . Defaults to false . Datatype: Boolean fee Fee used during backtesting / dry-runs. Should normally not be configured, which has freqtrade fall back to the exchange default fee. Set as ratio (e.g. 0.001 = 0.1%). Fee is applied twice for each trade, once when buying, once when selling. Datatype: Float (as ratio) futures_funding_rate User-specified funding rate to be used when historical funding rates are not available from the exchange. This does not overwrite real historical rates. It is recommended that this be set to 0 unless you are testing a specific coin and you understand how the funding rate will affect freqtrade's profit calculations. More information here Defaults to None. Datatype: Float trading_mode Specifies if you want to trade regularly, trade with leverage, or trade contracts whose prices are derived from matching cryptocurrency prices. leverage documentation . Defaults to \"spot\" . Datatype: String margin_mode When trading with leverage, this determines if the collateral owned by the trader will be shared or isolated to each trading pair leverage documentation . Datatype: String liquidation_buffer A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price leverage documentation . Defaults to 0.05 . Datatype: Float Unfilled timeout unfilledtimeout.entry Required. How long (in minutes or seconds) the bot will wait for an unfilled entry order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.exit Required. How long (in minutes or seconds) the bot will wait for an unfilled exit order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.unit Unit to use in unfilledtimeout setting. Note: If you set unfilledtimeout.unit to \"seconds\", \"internals.process_throttle_secs\" must be inferior or equal to timeout Strategy Override . Defaults to minutes . Datatype: String unfilledtimeout.exit_timeout_count How many times can exit orders time out. Once this number of timeouts is reached, an emergency exit is triggered. 0 to disable and allow unlimited order cancels. Strategy Override . Defaults to 0 . Datatype: Integer Pricing entry_pricing.price_side Select the side of the spread the bot should look at to get the entry rate. More information below . Defaults to same . Datatype: String (either ask , bid , same or other ). entry_pricing.price_last_balance Required. Interpolate the bidding price. More information below . entry_pricing.use_order_book Enable entering using the rates in Order Book Entry . Defaults to True . Datatype: Boolean entry_pricing.order_book_top Bot will use the top N rate in Order Book \"price_side\" to enter a trade. I.e. a value of 2 will allow the bot to pick the 2 nd entry in Order Book Entry . Defaults to 1 . Datatype: Positive Integer entry_pricing. check_depth_of_market.enabled Do not enter if the difference of buy orders and sell orders is met in Order Book. Check market depth . Defaults to false . Datatype: Boolean entry_pricing. check_depth_of_market.bids_to_ask_delta The difference ratio of buy orders and sell orders found in Order Book. A value below 1 means sell order size is greater, while value greater than 1 means buy order size is higher. Check market depth Defaults to 0 . Datatype: Float (as ratio) exit_pricing.price_side Select the side of the spread the bot should look at to get the exit rate. More information below . Defaults to same . Datatype: String (either ask , bid , same or other ). exit_pricing.price_last_balance Interpolate the exiting price. More information below . exit_pricing.use_order_book Enable exiting of open trades using Order Book Exit . Defaults to True . Datatype: Boolean exit_pricing.order_book_top Bot will use the top N rate in Order Book \"price_side\" to exit. I.e. a value of 2 will allow the bot to pick the 2 nd ask rate in Order Book Exit Defaults to 1 . Datatype: Positive Integer custom_price_max_distance_ratio Configure maximum distance ratio between current and custom entry or exit price. Defaults to 0.02 2%). Datatype: Positive float TODO use_exit_signal Use exit signals produced by the strategy in addition to the minimal_roi . Strategy Override . Defaults to true . Datatype: Boolean exit_profit_only Wait until the bot reaches exit_profit_offset before taking an exit decision. Strategy Override . Defaults to false . Datatype: Boolean exit_profit_offset Exit-signal is only active above this value. Only active in combination with exit_profit_only=True . Strategy Override . Defaults to 0.0 . Datatype: Float (as ratio) ignore_roi_if_entry_signal Do not exit if the entry signal is still active. This setting takes preference over minimal_roi and use_exit_signal . Strategy Override . Defaults to false . Datatype: Boolean ignore_buying_expired_candle_after Specifies the number of seconds until a buy signal is no longer used. Datatype: Integer order_types Configure order-types depending on the action ( \"entry\" , \"exit\" , \"stoploss\" , \"stoploss_on_exchange\" ). More information below . Strategy Override . Datatype: Dict order_time_in_force Configure time in force for entry and exit orders. More information below . Strategy Override . Datatype: Dict position_adjustment_enable Enables the strategy to use position adjustments (additional buys or sells). More information here . Strategy Override . Defaults to false . Datatype: Boolean max_entry_position_adjustment Maximum additional order(s) for each open trade on top of the first entry Order. Set it to -1 for unlimited additional orders. More information here . Strategy Override . Defaults to -1 . Datatype: Positive Integer or -1 Exchange exchange.name Required. Name of the exchange class to use. List below . Datatype: String exchange.sandbox Use the 'sandbox' version of the exchange, where the exchange provides a sandbox for risk-free integration. See here in more details. Datatype: Boolean exchange.key API key to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.secret API secret to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.password API password to use for the exchange. Only required when you are in production mode and for exchanges that use password for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.uid API uid to use for the exchange. Only required when you are in production mode and for exchanges that use uid for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.pair_whitelist List of pairs to use by the bot for trading and to check for potential trades during backtesting. Supports regex pairs as .*/BTC . Not used by VolumePairList. More information . Datatype: List exchange.pair_blacklist List of pairs the bot must absolutely avoid for trading and backtesting. More information . Datatype: List exchange.ccxt_config Additional CCXT parameters passed to both ccxt instances (sync and async). This is usually the correct place for additional ccxt configurations. Parameters may differ from exchange to exchange and are documented in the ccxt documentation . Please avoid adding exchange secrets here (use the dedicated fields instead), as they may be contained in logs. Datatype: Dict exchange.ccxt_sync_config Additional CCXT parameters passed to the regular (sync) ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.ccxt_async_config Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.markets_refresh_interval The interval in minutes in which markets are reloaded. Defaults to 60 minutes. Datatype: Positive Integer exchange.skip_pair_validation Skip pairlist validation on startup. Defaults to false Datatype: * Boolean exchange.skip_open_order_update Skips open order updates on startup should the exchange cause problems. Only relevant in live conditions. Defaults to false Datatype: * Boolean exchange.unknown_fee_rate Fallback value to use when calculating trading fees. This can be useful for exchanges which have fees in non-tradable currencies. The value provided here will be multiplied with the \"fee cost\". Defaults to None Datatype: * float exchange.log_responses Log relevant exchange responses. For debug mode only - use with care. Defaults to false Datatype: * Boolean experimental.block_bad_exchanges Block exchanges known to not work with freqtrade. Leave on default unless you want to test if that exchange works now. Defaults to true . Datatype: Boolean Plugins edge.* Please refer to edge configuration document for detailed explanation of all possible configuration options. pairlists Define one or more pairlists to be used. More information . Defaults to StaticPairList . Datatype: List of Dicts protections Define one or more protections to be used. More information . Datatype: List of Dicts Telegram telegram.enabled Enable the usage of Telegram. Datatype: Boolean telegram.token Your Telegram bot token. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.chat_id Your personal Telegram account id. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.balance_dust_level Dust-level (in stake currency) - currencies with a balance below this will not be shown by /balance . Datatype: float telegram.reload Allow \"reload\" buttons on telegram messages. Defaults to True . Datatype: * boolean telegram.notification_settings.* Detailed notification settings. Refer to the telegram documentation for details. Datatype: dictionary Webhook webhook.enabled Enable usage of Webhook notifications Datatype: Boolean webhook.url URL for the webhook. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentry Payload to send on entry. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentrycancel Payload to send on entry order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentryfill Payload to send on entry order filled. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexit Payload to send on exit. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexitcancel Payload to send on exit order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexitfill Payload to send on exit order filled. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookstatus Payload to send on status calls. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String Rest API / FreqUI api_server.enabled Enable usage of API Server. See the API Server documentation for more details. Datatype: Boolean api_server.listen_ip_address Bind IP address. See the API Server documentation for more details. Datatype: IPv4 api_server.listen_port Bind Port. See the API Server documentation for more details. Datatype: Integer between 1024 and 65535 api_server.verbosity Logging verbosity. info will print all RPC Calls, while \"error\" will only display errors. Datatype: Enum, either info or error . Defaults to info . api_server.username Username for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String api_server.password Password for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String bot_name Name of the bot. Passed via API to a client - can be shown to distinguish / name bots. Defaults to freqtrade Datatype: String Other initial_state Defines the initial application state. If set to stopped, then the bot has to be explicitly started via /start RPC command. Defaults to stopped . Datatype: Enum, either stopped or running force_entry_enable Enables the RPC Commands to force a Trade entry. More information below. Datatype: Boolean disable_dataframe_checks Disable checking the OHLCV dataframe returned from the strategy methods for correctness. Only use when intentionally changing the dataframe and understand what you are doing. Strategy Override . Defaults to False . Datatype: Boolean internals.process_throttle_secs Set the process throttle, or minimum loop duration for one bot iteration loop. Value in second. Defaults to 5 seconds. Datatype: Positive Integer internals.heartbeat_interval Print heartbeat message every N seconds. Set to 0 to disable heartbeat messages. Defaults to 60 seconds. Datatype: Positive Integer or 0 internals.sd_notify Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details. Datatype: Boolean strategy Required Defines Strategy class to use. Recommended to be set via --strategy NAME . Datatype: ClassName strategy_path Adds an additional strategy lookup path (must be a directory). Datatype: String recursive_strategy_search Set to true to recursively search sub-directories inside user_data/strategies for a strategy. Datatype: Boolean user_data_dir Directory containing user data. Defaults to ./user_data/ . Datatype: String db_url Declares database URL to use. NOTE: This defaults to sqlite:///tradesv3.dryrun.sqlite if dry_run is true , and to sqlite:///tradesv3.sqlite for production instances. Datatype: String, SQLAlchemy connect string logfile Specifies logfile name. Uses a rolling strategy for log file rotation for 10 files with the 1MB limit per file. Datatype: String add_config_files Additional config files. These files will be loaded and merged with the current config file. The files are resolved relative to the initial file. Defaults to [] . Datatype: List of strings dataformat_ohlcv Data format to use to store historical candle (OHLCV) data. Defaults to json . Datatype: String dataformat_trades Data format to use to store historical trades data. Defaults to jsongz . Datatype: String Parameters in the strategy \u00b6 The following parameters can be set in the configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy. minimal_roi timeframe stoploss trailing_stop trailing_stop_positive trailing_stop_positive_offset trailing_only_offset_is_reached use_custom_stoploss process_only_new_candles order_types order_time_in_force unfilledtimeout disable_dataframe_checks use_exit_signal exit_profit_only exit_profit_offset ignore_roi_if_entry_signal ignore_buying_expired_candle_after position_adjustment_enable max_entry_position_adjustment Configuring amount per trade \u00b6 There are several methods to configure how much of the stake currency the bot will use to enter a trade. All methods respect the available balance configuration as explained below. Minimum trade stake \u00b6 The minimum stake amount will depend on exchange and pair and is usually listed in the exchange support pages. Assuming the minimum tradable amount for XRP/USD is 20 XRP (given by the exchange), and the price is 0.6 \\(, the minimum stake amount to buy this pair is 20 * 0.6 ~= 12 . This exchange has also a limit on USD - where all orders must be > 10\\) - which however does not apply in this case. To guarantee safe execution, freqtrade will not allow buying with a stake-amount of 10.1$, instead, it'll make sure that there's enough space to place a stoploss below the pair (+ an offset, defined by amount_reserve_percent , which defaults to 5%). With a reserve of 5%, the minimum stake amount would be ~12.6$ ( 12 * (1 + 0.05) ). If we take into account a stoploss of 10% on top of that - we'd end up with a value of ~14$ ( 12.6 / (1 - 0.1) ). To limit this calculation in case of large stoploss values, the calculated minimum stake-limit will never be more than 50% above the real limit. Warning Since the limits on exchanges are usually stable and are not updated often, some pairs can show pretty high minimum limits, simply because the price increased a lot since the last limit adjustment by the exchange. Freqtrade adjusts the stake-amount to this value, unless it's > 30% more than the calculated/desired stake-amount - in which case the trade is rejected. Tradable balance \u00b6 By default, the bot assumes that the complete amount - 1% is at it's disposal, and when using dynamic stake amount , it will split the complete balance into max_open_trades buckets per trade. Freqtrade will reserve 1% for eventual fees when entering a trade and will therefore not touch that by default. You can configure the \"untouched\" amount by using the tradable_balance_ratio setting. For example, if you have 10 ETH available in your wallet on the exchange and tradable_balance_ratio=0.5 (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers this as an available balance. The rest of the wallet is untouched by the trades. Danger This setting should not be used when running multiple bots on the same account. Please look at Available Capital to the bot instead. Warning The tradable_balance_ratio setting applies to the current balance (free balance + tied up in trades). Therefore, assuming the starting balance of 1000, a configuration with tradable_balance_ratio=0.99 will not guarantee that 10 currency units will always remain available on the exchange. For example, the free amount may reduce to 5 units if the total balance is reduced to 500 (either by a losing streak or by withdrawing balance). Assign available Capital \u00b6 To fully utilize compounding profits when using multiple bots on the same exchange account, you'll want to limit each bot to a certain starting balance. This can be accomplished by setting available_capital to the desired starting balance. Assuming your account has 10.000 USDT and you want to run 2 different strategies on this exchange. You'd set available_capital=5000 - granting each bot an initial capital of 5000 USDT. The bot will then split this starting balance equally into max_open_trades buckets. Profitable trades will result in increased stake-sizes for this bot - without affecting the stake-sizes of the other bot. Incompatible with tradable_balance_ratio Setting this option will replace any configuration of tradable_balance_ratio . Amend last stake amount \u00b6 Assuming we have the tradable balance of 1000 USDT, stake_amount=400 , and max_open_trades=3 . The bot would open 2 trades and will be unable to fill the last trading slot, since the requested 400 USDT are no longer available since 800 USDT are already tied in other trades. To overcome this, the option amend_last_stake_amount can be set to True , which will enable the bot to reduce stake_amount to the available balance to fill the last trade slot. In the example above this would mean: Trade1: 400 USDT Trade2: 400 USDT Trade3: 200 USDT Note This option only applies with Static stake amount - since Dynamic stake amount divides the balances evenly. Note The minimum last stake amount can be configured using last_stake_amount_min_ratio - which defaults to 0.5 (50%). This means that the minimum stake amount that's ever used is stake_amount * 0.5 . This avoids very low stake amounts, that are close to the minimum tradable amount for the pair and can be refused by the exchange. Static stake amount \u00b6 The stake_amount configuration statically configures the amount of stake-currency your bot will use for each trade. The minimal configuration value is 0.0001, however, please check your exchange's trading minimums for the stake currency you're using to avoid problems. This setting works in combination with max_open_trades . The maximum capital engaged in trades is stake_amount * max_open_trades . For example, the bot will at most use (0.05 BTC x 3) = 0.15 BTC, assuming a configuration of max_open_trades=3 and stake_amount=0.05 . Note This setting respects the available balance configuration . Dynamic stake amount \u00b6 Alternatively, you can use a dynamic stake amount, which will use the available balance on the exchange, and divide that equally by the number of allowed trades ( max_open_trades ). To configure this, set stake_amount=\"unlimited\" . We also recommend to set tradable_balance_ratio=0.99 (99%) - to keep a minimum balance for eventual fees. In this case a trade amount is calculated as: currency_balance / ( max_open_trades - current_open_trades ) To allow the bot to trade all the available stake_currency in your account (minus tradable_balance_ratio ) set \"stake_amount\" : \"unlimited\" , \"tradable_balance_ratio\" : 0.99 , Compounding profits This configuration will allow increasing/decreasing stakes depending on the performance of the bot (lower stake if the bot is losing, higher stakes if the bot has a winning record since higher balances are available), and will result in profit compounding. When using Dry-Run Mode When using \"stake_amount\" : \"unlimited\", in combination with Dry-Run, Backtesting or Hyperopt, the balance will be simulated starting with a stake of dry_run_wallet which will evolve. It is therefore important to set dry_run_wallet to a sensible value (like 0.05 or 0.01 for BTC and 1000 or 100 for USDT, for example), otherwise, it may simulate trades with 100 BTC (or more) or 0.05 USDT (or less) at once - which may not correspond to your real available balance or is less than the exchange minimal limit for the order amount for the stake currency. Dynamic stake amount with position adjustment \u00b6 When you want to use position adjustment with unlimited stakes, you must also implement custom_stake_amount to a return a value depending on your strategy. Typical value would be in the range of 25% - 50% of the proposed stakes, but depends highly on your strategy and how much you wish to leave into the wallet as position adjustment buffer. For example if your position adjustment assumes it can do 2 additional buys with the same stake amounts then your buffer should be 66.6667% of the initially proposed unlimited stake amount. Or another example if your position adjustment assumes it can do 1 additional buy with 3x the original stake amount then custom_stake_amount should return 25% of proposed stake amount and leave 75% for possible later position adjustments. Prices used for orders \u00b6 Prices for regular orders can be controlled via the parameter structures entry_pricing for trade entries and exit_pricing for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders. Entry price \u00b6 Enter price side \u00b6 The configuration setting entry_pricing.price_side defines the side of the orderbook the bot looks for when buying. The following displays an orderbook. ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If entry_pricing.price_side is set to \"bid\" , then the bot will use 99 as entry price. In line with that, if entry_pricing.price_side is set to \"ask\" , then the bot will use 101 as entry price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price). Entry price with Orderbook enabled \u00b6 When entering a trade with the orderbook enabled ( entry_pricing.use_order_book=True ), Freqtrade fetches the entry_pricing.order_book_top entries from the orderbook and uses the entry specified as entry_pricing.order_book_top on the configured side ( entry_pricing.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Entry price without Orderbook enabled \u00b6 The following section uses side as the configured entry_pricing.price_side (defaults to \"same\" ). When not using orderbook ( entry_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on entry_pricing.price_last_balance . The entry_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price. Check depth of market \u00b6 When check depth of market is enabled ( entry_pricing.check_depth_of_market.enabled=True ), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the entry_pricing.check_depth_of_market.bids_to_ask_delta parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side). Exit price \u00b6 Exit price side \u00b6 The configuration setting exit_pricing.price_side defines the side of the spread the bot looks for when exiting a trade. The following displays an orderbook: ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If exit_pricing.price_side is set to \"ask\" , then the bot will use 101 as exiting price. In line with that, if exit_pricing.price_side is set to \"bid\" , then the bot will use 99 as exiting price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes Exit price with Orderbook enabled \u00b6 When exiting with the orderbook enabled ( exit_pricing.use_order_book=True ), Freqtrade fetches the exit_pricing.order_book_top entries in the orderbook and uses the entry specified as exit_pricing.order_book_top from the configured side ( exit_pricing.price_side ) as trade exit price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Exit price without Orderbook enabled \u00b6 The following section uses side as the configured exit_pricing.price_side (defaults to \"ask\" ). When not using orderbook ( exit_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on exit_pricing.price_last_balance . The exit_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price. Market order pricing \u00b6 When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used \"order_types\": { \"entry\": \"market\", \"exit\": \"market\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used. Understand minimal_roi \u00b6 The minimal_roi configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI as a ratio. See the example below: \"minimal_roi\" : { \"40\" : 0.0 , # Exi t a fter 40 mi nutes i f t he pro f i t is n o t ne ga t ive \"30\" : 0.01 , # Exi t a fter 30 mi nutes i f t here is a t leas t 1 % pro f i t \"20\" : 0.02 , # Exi t a fter 20 mi nutes i f t here is a t leas t 2 % pro f i t \"0\" : 0.04 # Exi t immedia tel y i f t here is a t leas t 4 % pro f i t }, Most of the strategy files already include the optimal minimal_roi value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the minimal_roi value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% {\"0\": 10} is used, and minimal ROI is disabled unless your trade generates 1000% profit. Special case to forceexit after a specific time A special case presents using \"<N>\": -1 as ROI. This forces the bot to exit a trade after N Minutes, no matter if it's positive or negative, so represents a time-limited force-exit. Understand force_entry_enable \u00b6 The force_entry_enable configuration parameter enables the usage of force-enter ( /forcelong , /forceshort ) commands via Telegram and REST API. For security reasons, it's disabled by default, and freqtrade will show a warning message on startup if enabled. For example, you can send /forceenter ETH/BTC to the bot, which will result in freqtrade buying the pair and holds it until a regular exit-signal (ROI, stoploss, /forceexit) appears. This can be dangerous with some strategies, so use with care. See the telegram documentation for details on usage. Ignoring expired candles \u00b6 When working with larger timeframes (for example 1h or more) and using a low max_open_trades value, the last candle can be processed as soon as a trade slot becomes available. When processing the last candle, this can lead to a situation where it may not be desirable to use the buy signal on that candle. For example, when using a condition in your strategy where you use a cross-over, that point may have passed too long ago for you to start a trade on it. In these situations, you can enable the functionality to ignore candles that are beyond a specified period by setting ignore_buying_expired_candle_after to a positive number, indicating the number of seconds after which the buy signal becomes expired. For example, if your strategy is using a 1h timeframe, and you only want to buy within the first 5 minutes when a new candle comes in, you can add the following configuration to your strategy: { //... \"ignore_buying_expired_candle_after\" : 300 , // ... } Note This setting resets with each new candle, so it will not prevent sticking-signals from executing on the 2 nd or 3 rd candle they're active. Best use a \"trigger\" selector for buy signals, which are only active for one candle. Understand order_types \u00b6 The order_types configuration parameter maps actions ( entry , exit , stoploss , emergency_exit , force_exit , force_entry ) to order-types ( market , limit , ...) as well as configures stoploss to be on the exchange and defines stoploss on exchange update interval in seconds. This allows to enter using limit orders, exit using limit-orders, and create stoplosses using market orders. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled. order_types set in the configuration file overwrites values set in the strategy as a whole, so you need to configure the whole order_types dictionary in one place. If this is configured, the following 4 values ( entry , exit , stoploss and stoploss_on_exchange ) need to be present, otherwise, the bot will fail to start. For information on ( emergency_exit , force_exit , force_entry , stoploss_on_exchange , stoploss_on_exchange_interval , stoploss_on_exchange_limit_ratio ) please see stop loss documentation stop loss on exchange Syntax for Strategy: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_entry\" : \"market\" , \"force_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : False , \"stoploss_on_exchange_interval\" : 60 , \"stoploss_on_exchange_limit_ratio\" : 0.99 , } Configuration: \"order_types\" : { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_entry\" : \"market\" , \"force_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 } Market order support Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: \"Exchange <yourexchange> does not support market orders.\" and the bot will refuse to start. Using market orders Please carefully read the section Market order pricing section when using market orders. Stoploss on exchange stoploss_on_exchange_interval is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please refer to the stoploss documentation . If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. Warning: stoploss_on_exchange failures If stoploss on exchange creation fails for some reason, then an \"emergency exit\" is initiated. By default, this will exit the trade using a market order. The order-type for the emergency-exit can be changed by setting the emergency_exit value in the order_types dictionary - however, this is not advised. Understand order_time_in_force \u00b6 The order_time_in_force configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are: GTC (Good Till Canceled): This is most of the time the default time in force. It means the order will remain on exchange till it is cancelled by the user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled. FOK (Fill Or Kill): It means if the order is not executed immediately AND fully then it is cancelled by the exchange. IOC (Immediate Or Canceled): It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange. The order_time_in_force parameter contains a dict with buy and sell time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy. The possible values are: gtc (default), fok or ioc . \"order_time_in_force\" : { \"entry\" : \"gtc\" , \"exit\" : \"gtc\" }, Warning This is ongoing work. For now, it is supported only for binance and kucoin. Please don't change the default value unless you know what you are doing and have researched the impact of using different values for your particular exchange. What values can be used for fiat_display_currency? \u00b6 The fiat_display_currency configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports. The valid values are: \"AUD\" , \"BRL\" , \"CAD\" , \"CHF\" , \"CLP\" , \"CNY\" , \"CZK\" , \"DKK\" , \"EUR\" , \"GBP\" , \"HKD\" , \"HUF\" , \"IDR\" , \"ILS\" , \"INR\" , \"JPY\" , \"KRW\" , \"MXN\" , \"MYR\" , \"NOK\" , \"NZD\" , \"PHP\" , \"PKR\" , \"PLN\" , \"RUB\" , \"SEK\" , \"SGD\" , \"THB\" , \"TRY\" , \"TWD\" , \"ZAR\" , \"USD\" In addition to fiat currencies, a range of crypto currencies is supported. The valid values are: \"BTC\" , \"ETH\" , \"XRP\" , \"LTC\" , \"BCH\" , \"USDT\" Using Dry-run mode \u00b6 We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode, the bot does not engage your money. It only runs a live simulation without creating trades on the exchange. Edit your config.json configuration file. Switch dry-run to true and specify db_url for a persistence database. \"dry_run\" : true , \"db_url\" : \"sqlite:///tradesv3.dryrun.sqlite\" , Remove your Exchange API key and secret (change them by empty values or fake credentials): \"exchange\" : { \"name\" : \"bittrex\" , \"key\" : \"key\" , \"secret\" : \"secret\" , ... } Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode. Note A simulated wallet is available during dry-run mode and will assume a starting capital of dry_run_wallet (defaults to 1000). Considerations for dry-run \u00b6 API-keys may or may not be provided. Only Read-Only operations (i.e. operations that do not alter account state) on the exchange are performed in dry-run mode. Wallets ( /balance ) are simulated based on dry_run_wallet . Orders are simulated, and will not be posted to the exchange. Market orders fill based on orderbook volume the moment the order is placed. Limit orders fill once the price reaches the defined level - or time out based on unfilledtimeout settings. In combination with stoploss_on_exchange , the stop_loss price is assumed to be filled. Open orders (not trades, which are stored in the database) are kept open after bot restarts, with the assumption that they were not filled while being offline. Switch to production mode \u00b6 In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode. When switching to Production mode, please make sure to use a different / fresh database to avoid dry-run trades messing with your exchange money and eventually tainting your statistics. Setup your exchange account \u00b6 You will need to create API Keys (usually you get key and secret , some exchanges require an additional password ) from the Exchange website and you'll need to insert this into the appropriate fields in the configuration or when asked by the freqtrade new-config command. API Keys are usually only required for live trading (trading for real money, bot running in \"production mode\", executing real orders on the exchange) and are not required for the bot running in dry-run (trade simulation) mode. When you set up the bot in dry-run mode, you may fill these fields with empty values. To switch your bot in production mode \u00b6 Edit your config.json file. Switch dry-run to false and don't forget to adapt your database URL if set: \"dry_run\" : false , Insert your Exchange API key (change them by fake API keys): { \"exchange\" : { \"name\" : \"bittrex\" , \"key\" : \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\" , \"secret\" : \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\" , //\"password\": \"\", // Optional, not needed by all exchanges) // ... } //... } You should also make sure to read the Exchanges section of the documentation to be aware of potential configuration details specific to your exchange. Keep your secrets secret To keep your secrets secret, we recommend using a 2 nd configuration for your API keys. Simply use the above snippet in a new configuration file (e.g. config-private.json ) and keep your settings in this file. You can then start the bot with freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> to have your keys loaded. NEVER share your private configuration file or your exchange keys with anyone! Using proxy with Freqtrade \u00b6 To use a proxy with freqtrade, add the kwarg \"aiohttp_trust_env\"=true to the \"ccxt_async_kwargs\" dict in the exchange section of the configuration. An example for this can be found in config_examples/config_full.example.json \"ccxt_async_config\" : { \"aiohttp_trust_env\" : true } Then, export your proxy settings using the variables \"HTTP_PROXY\" and \"HTTPS_PROXY\" set to the appropriate values export HTTP_PROXY = \"http://addr:port\" export HTTPS_PROXY = \"http://addr:port\" freqtrade Next step \u00b6 Now you have configured your config.json, the next step is to start your bot .","title":"Configuration"},{"location":"configuration/#configure-the-bot","text":"Freqtrade has many configurable features and possibilities. By default, these settings are configured via the configuration file (see below).","title":"Configure the bot"},{"location":"configuration/#the-freqtrade-configuration-file","text":"The bot uses a set of configuration parameters during its operation that all together conform to the bot configuration. It normally reads its configuration from a file (Freqtrade configuration file). Per default, the bot loads the configuration from the config.json file, located in the current working directory. You can specify a different configuration file used by the bot with the -c/--config command-line option. If you used the Quick start method for installing the bot, the installation script should have already created the default configuration file ( config.json ) for you. If the default configuration file is not created we recommend to use freqtrade new-config --config config.json to generate a basic configuration file. The Freqtrade configuration file is to be written in JSON format. Additionally to the standard JSON syntax, you may use one-line // ... and multi-line /* ... */ comments in your configuration files and trailing commas in the lists of parameters. Do not worry if you are not familiar with JSON format -- simply open the configuration file with an editor of your choice, make some changes to the parameters you need, save your changes and, finally, restart the bot or, if it was previously stopped, run it again with the changes you made to the configuration. The bot validates the syntax of the configuration file at startup and will warn you if you made any errors editing it, pointing out problematic lines.","title":"The Freqtrade configuration file"},{"location":"configuration/#environment-variables","text":"Set options in the Freqtrade configuration via environment variables. This takes priority over the corresponding value in configuration or strategy. Environment variables must be prefixed with FREQTRADE__ to be loaded to the freqtrade configuration. __ serves as level separator, so the format used should correspond to FREQTRADE__{section}__{key} . As such - an environment variable defined as export FREQTRADE__STAKE_AMOUNT=200 would result in {stake_amount: 200} . A more complex example might be export FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> to keep your exchange key secret. This will move the value to the exchange.key section of the configuration. Using this scheme, all configuration settings will also be available as environment variables. Please note that Environment variables will overwrite corresponding settings in your configuration, but command line Arguments will always win. Common example: FREQTRADE__TELEGRAM__CHAT_ID=<telegramchatid> FREQTRADE__TELEGRAM__TOKEN=<telegramToken> FREQTRADE__EXCHANGE__KEY=<yourExchangeKey> FREQTRADE__EXCHANGE__SECRET=<yourExchangeSecret> Note Environment variables detected are logged at startup - so if you can't find why a value is not what you think it should be based on the configuration, make sure it's not loaded from an environment variable.","title":"Environment variables"},{"location":"configuration/#multiple-configuration-files","text":"Multiple configuration files can be specified and used by the bot or the bot can read its configuration parameters from the process standard input stream. You can specify additional configuration files in add_config_files . Files specified in this parameter will be loaded and merged with the initial config file. The files are resolved relative to the initial configuration file. This is similar to using multiple --config parameters, but simpler in usage as you don't have to specify all files for all commands. Use multiple configuration files to keep secrets secret You can use a 2 nd configuration file containing your secrets. That way you can share your \"primary\" configuration file, while still keeping your API keys for yourself. user_data/config.json \"add_config_files\" : [ \"config-private.json\" ] freqtrade trade --config user_data/config.json <...> The 2 nd file should only specify what you intend to override. If a key is in more than one of the configurations, then the \"last specified configuration\" wins (in the above example, config-private.json ). For one-off commands, you can also use the below syntax by specifying multiple \"--config\" parameters. freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> This is equivalent to the example above - but config-private.json is specified as cli argument. config collision handling If the same configuration setting takes place in both config.json and config-import.json , then the parent configuration wins. In the below case, max_open_trades would be 3 after the merging - as the reusable \"import\" configuration has this key overwritten. user_data/config.json { \"max_open_trades\" : 3 , \"stake_currency\" : \"USDT\" , \"add_config_files\" : [ \"config-import.json\" ] } user_data/config-import.json { \"max_open_trades\" : 10 , \"stake_amount\" : \"unlimited\" , } Resulting combined configuration: Result { \"max_open_trades\" : 3 , \"stake_currency\" : \"USDT\" , \"stake_amount\" : \"unlimited\" }","title":"Multiple configuration files"},{"location":"configuration/#configuration-parameters","text":"The table below will list all configuration parameters available. Freqtrade can also load many options via command line (CLI) arguments (check out the commands --help output for details).","title":"Configuration parameters"},{"location":"configuration/#configuration-option-prevalence","text":"The prevalence for all Options is as follows: CLI arguments override any other option Environment Variables Configuration files are used in sequence (the last file wins) and override Strategy configurations. Strategy configurations are only used if they are not set via configuration or command-line arguments. These options are marked with Strategy Override in the below table.","title":"Configuration option prevalence"},{"location":"configuration/#parameters-table","text":"Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description max_open_trades Required. Number of open trades your bot is allowed to have. Only one open trade per pair is possible, so the length of your pairlist is another limitation that can apply. If -1 then it is ignored (i.e. potentially unlimited open trades, limited by the pairlist). More information below . Datatype: Positive integer or -1. stake_currency Required. Crypto-currency used for trading. Datatype: String stake_amount Required. Amount of crypto-currency your bot will use for each trade. Set it to \"unlimited\" to allow the bot to use all available balance. More information below . Datatype: Positive float or \"unlimited\" . tradable_balance_ratio Ratio of the total account balance the bot is allowed to trade. More information below . Defaults to 0.99 99%). Datatype: Positive float between 0.1 and 1.0 . available_capital Available starting capital for the bot. Useful when running multiple bots on the same exchange account. More information below . Datatype: Positive float. amend_last_stake_amount Use reduced last stake amount if necessary. More information below . Defaults to false . Datatype: Boolean last_stake_amount_min_ratio Defines minimum stake amount that has to be left and executed. Applies only to the last stake amount when it's amended to a reduced value (i.e. if amend_last_stake_amount is set to true ). More information below . Defaults to 0.5 . Datatype: Float (as ratio) amount_reserve_percent Reserve some amount in min pair stake amount. The bot will reserve amount_reserve_percent + stoploss value when calculating min pair stake amount in order to avoid possible trade refusals. Defaults to 0.05 (5%). Datatype: Positive Float as ratio. timeframe The timeframe to use (e.g 1m , 5m , 15m , 30m , 1h ...). Usually missing in configuration, and specified in the strategy. Strategy Override . Datatype: String fiat_display_currency Fiat currency used to show your profits. More information below . Datatype: String dry_run Required. Define if the bot must be in Dry Run or production mode. Defaults to true . Datatype: Boolean dry_run_wallet Define the starting amount in stake currency for the simulated wallet used by the bot running in Dry Run mode. Defaults to 1000 . Datatype: Float cancel_open_orders_on_exit Cancel open orders when the /stop RPC command is issued, Ctrl+C is pressed or the bot dies unexpectedly. When set to true , this allows you to use /stop to cancel unfilled and partially filled orders in the event of a market crash. It does not impact open positions. Defaults to false . Datatype: Boolean process_only_new_candles Enable processing of indicators only when new candles arrive. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override . Defaults to true . Datatype: Boolean minimal_roi Required. Set the threshold as ratio the bot will use to exit a trade. More information below . Strategy Override . Datatype: Dict stoploss Required. Value as ratio of the stoploss used by the bot. More details in the stoploss documentation . Strategy Override . Datatype: Float (as ratio) trailing_stop Enables trailing stoploss (based on stoploss in either configuration or strategy file). More details in the stoploss documentation . Strategy Override . Datatype: Boolean trailing_stop_positive Changes stoploss once profit has been reached. More details in the stoploss documentation . Strategy Override . Datatype: Float trailing_stop_positive_offset Offset on when to apply trailing_stop_positive . Percentage value which should be positive. More details in the stoploss documentation . Strategy Override . Defaults to 0.0 (no offset). Datatype: Float trailing_only_offset_is_reached Only apply trailing stoploss when the offset is reached. stoploss documentation . Strategy Override . Defaults to false . Datatype: Boolean fee Fee used during backtesting / dry-runs. Should normally not be configured, which has freqtrade fall back to the exchange default fee. Set as ratio (e.g. 0.001 = 0.1%). Fee is applied twice for each trade, once when buying, once when selling. Datatype: Float (as ratio) futures_funding_rate User-specified funding rate to be used when historical funding rates are not available from the exchange. This does not overwrite real historical rates. It is recommended that this be set to 0 unless you are testing a specific coin and you understand how the funding rate will affect freqtrade's profit calculations. More information here Defaults to None. Datatype: Float trading_mode Specifies if you want to trade regularly, trade with leverage, or trade contracts whose prices are derived from matching cryptocurrency prices. leverage documentation . Defaults to \"spot\" . Datatype: String margin_mode When trading with leverage, this determines if the collateral owned by the trader will be shared or isolated to each trading pair leverage documentation . Datatype: String liquidation_buffer A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price leverage documentation . Defaults to 0.05 . Datatype: Float Unfilled timeout unfilledtimeout.entry Required. How long (in minutes or seconds) the bot will wait for an unfilled entry order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.exit Required. How long (in minutes or seconds) the bot will wait for an unfilled exit order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override . Datatype: Integer unfilledtimeout.unit Unit to use in unfilledtimeout setting. Note: If you set unfilledtimeout.unit to \"seconds\", \"internals.process_throttle_secs\" must be inferior or equal to timeout Strategy Override . Defaults to minutes . Datatype: String unfilledtimeout.exit_timeout_count How many times can exit orders time out. Once this number of timeouts is reached, an emergency exit is triggered. 0 to disable and allow unlimited order cancels. Strategy Override . Defaults to 0 . Datatype: Integer Pricing entry_pricing.price_side Select the side of the spread the bot should look at to get the entry rate. More information below . Defaults to same . Datatype: String (either ask , bid , same or other ). entry_pricing.price_last_balance Required. Interpolate the bidding price. More information below . entry_pricing.use_order_book Enable entering using the rates in Order Book Entry . Defaults to True . Datatype: Boolean entry_pricing.order_book_top Bot will use the top N rate in Order Book \"price_side\" to enter a trade. I.e. a value of 2 will allow the bot to pick the 2 nd entry in Order Book Entry . Defaults to 1 . Datatype: Positive Integer entry_pricing. check_depth_of_market.enabled Do not enter if the difference of buy orders and sell orders is met in Order Book. Check market depth . Defaults to false . Datatype: Boolean entry_pricing. check_depth_of_market.bids_to_ask_delta The difference ratio of buy orders and sell orders found in Order Book. A value below 1 means sell order size is greater, while value greater than 1 means buy order size is higher. Check market depth Defaults to 0 . Datatype: Float (as ratio) exit_pricing.price_side Select the side of the spread the bot should look at to get the exit rate. More information below . Defaults to same . Datatype: String (either ask , bid , same or other ). exit_pricing.price_last_balance Interpolate the exiting price. More information below . exit_pricing.use_order_book Enable exiting of open trades using Order Book Exit . Defaults to True . Datatype: Boolean exit_pricing.order_book_top Bot will use the top N rate in Order Book \"price_side\" to exit. I.e. a value of 2 will allow the bot to pick the 2 nd ask rate in Order Book Exit Defaults to 1 . Datatype: Positive Integer custom_price_max_distance_ratio Configure maximum distance ratio between current and custom entry or exit price. Defaults to 0.02 2%). Datatype: Positive float TODO use_exit_signal Use exit signals produced by the strategy in addition to the minimal_roi . Strategy Override . Defaults to true . Datatype: Boolean exit_profit_only Wait until the bot reaches exit_profit_offset before taking an exit decision. Strategy Override . Defaults to false . Datatype: Boolean exit_profit_offset Exit-signal is only active above this value. Only active in combination with exit_profit_only=True . Strategy Override . Defaults to 0.0 . Datatype: Float (as ratio) ignore_roi_if_entry_signal Do not exit if the entry signal is still active. This setting takes preference over minimal_roi and use_exit_signal . Strategy Override . Defaults to false . Datatype: Boolean ignore_buying_expired_candle_after Specifies the number of seconds until a buy signal is no longer used. Datatype: Integer order_types Configure order-types depending on the action ( \"entry\" , \"exit\" , \"stoploss\" , \"stoploss_on_exchange\" ). More information below . Strategy Override . Datatype: Dict order_time_in_force Configure time in force for entry and exit orders. More information below . Strategy Override . Datatype: Dict position_adjustment_enable Enables the strategy to use position adjustments (additional buys or sells). More information here . Strategy Override . Defaults to false . Datatype: Boolean max_entry_position_adjustment Maximum additional order(s) for each open trade on top of the first entry Order. Set it to -1 for unlimited additional orders. More information here . Strategy Override . Defaults to -1 . Datatype: Positive Integer or -1 Exchange exchange.name Required. Name of the exchange class to use. List below . Datatype: String exchange.sandbox Use the 'sandbox' version of the exchange, where the exchange provides a sandbox for risk-free integration. See here in more details. Datatype: Boolean exchange.key API key to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.secret API secret to use for the exchange. Only required when you are in production mode. Keep it in secret, do not disclose publicly. Datatype: String exchange.password API password to use for the exchange. Only required when you are in production mode and for exchanges that use password for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.uid API uid to use for the exchange. Only required when you are in production mode and for exchanges that use uid for API requests. Keep it in secret, do not disclose publicly. Datatype: String exchange.pair_whitelist List of pairs to use by the bot for trading and to check for potential trades during backtesting. Supports regex pairs as .*/BTC . Not used by VolumePairList. More information . Datatype: List exchange.pair_blacklist List of pairs the bot must absolutely avoid for trading and backtesting. More information . Datatype: List exchange.ccxt_config Additional CCXT parameters passed to both ccxt instances (sync and async). This is usually the correct place for additional ccxt configurations. Parameters may differ from exchange to exchange and are documented in the ccxt documentation . Please avoid adding exchange secrets here (use the dedicated fields instead), as they may be contained in logs. Datatype: Dict exchange.ccxt_sync_config Additional CCXT parameters passed to the regular (sync) ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.ccxt_async_config Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict exchange.markets_refresh_interval The interval in minutes in which markets are reloaded. Defaults to 60 minutes. Datatype: Positive Integer exchange.skip_pair_validation Skip pairlist validation on startup. Defaults to false Datatype: * Boolean exchange.skip_open_order_update Skips open order updates on startup should the exchange cause problems. Only relevant in live conditions. Defaults to false Datatype: * Boolean exchange.unknown_fee_rate Fallback value to use when calculating trading fees. This can be useful for exchanges which have fees in non-tradable currencies. The value provided here will be multiplied with the \"fee cost\". Defaults to None Datatype: * float exchange.log_responses Log relevant exchange responses. For debug mode only - use with care. Defaults to false Datatype: * Boolean experimental.block_bad_exchanges Block exchanges known to not work with freqtrade. Leave on default unless you want to test if that exchange works now. Defaults to true . Datatype: Boolean Plugins edge.* Please refer to edge configuration document for detailed explanation of all possible configuration options. pairlists Define one or more pairlists to be used. More information . Defaults to StaticPairList . Datatype: List of Dicts protections Define one or more protections to be used. More information . Datatype: List of Dicts Telegram telegram.enabled Enable the usage of Telegram. Datatype: Boolean telegram.token Your Telegram bot token. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.chat_id Your personal Telegram account id. Only required if telegram.enabled is true . Keep it in secret, do not disclose publicly. Datatype: String telegram.balance_dust_level Dust-level (in stake currency) - currencies with a balance below this will not be shown by /balance . Datatype: float telegram.reload Allow \"reload\" buttons on telegram messages. Defaults to True . Datatype: * boolean telegram.notification_settings.* Detailed notification settings. Refer to the telegram documentation for details. Datatype: dictionary Webhook webhook.enabled Enable usage of Webhook notifications Datatype: Boolean webhook.url URL for the webhook. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentry Payload to send on entry. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentrycancel Payload to send on entry order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookentryfill Payload to send on entry order filled. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexit Payload to send on exit. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexitcancel Payload to send on exit order cancel. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookexitfill Payload to send on exit order filled. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String webhook.webhookstatus Payload to send on status calls. Only required if webhook.enabled is true . See the webhook documentation for more details. Datatype: String Rest API / FreqUI api_server.enabled Enable usage of API Server. See the API Server documentation for more details. Datatype: Boolean api_server.listen_ip_address Bind IP address. See the API Server documentation for more details. Datatype: IPv4 api_server.listen_port Bind Port. See the API Server documentation for more details. Datatype: Integer between 1024 and 65535 api_server.verbosity Logging verbosity. info will print all RPC Calls, while \"error\" will only display errors. Datatype: Enum, either info or error . Defaults to info . api_server.username Username for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String api_server.password Password for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String bot_name Name of the bot. Passed via API to a client - can be shown to distinguish / name bots. Defaults to freqtrade Datatype: String Other initial_state Defines the initial application state. If set to stopped, then the bot has to be explicitly started via /start RPC command. Defaults to stopped . Datatype: Enum, either stopped or running force_entry_enable Enables the RPC Commands to force a Trade entry. More information below. Datatype: Boolean disable_dataframe_checks Disable checking the OHLCV dataframe returned from the strategy methods for correctness. Only use when intentionally changing the dataframe and understand what you are doing. Strategy Override . Defaults to False . Datatype: Boolean internals.process_throttle_secs Set the process throttle, or minimum loop duration for one bot iteration loop. Value in second. Defaults to 5 seconds. Datatype: Positive Integer internals.heartbeat_interval Print heartbeat message every N seconds. Set to 0 to disable heartbeat messages. Defaults to 60 seconds. Datatype: Positive Integer or 0 internals.sd_notify Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details. Datatype: Boolean strategy Required Defines Strategy class to use. Recommended to be set via --strategy NAME . Datatype: ClassName strategy_path Adds an additional strategy lookup path (must be a directory). Datatype: String recursive_strategy_search Set to true to recursively search sub-directories inside user_data/strategies for a strategy. Datatype: Boolean user_data_dir Directory containing user data. Defaults to ./user_data/ . Datatype: String db_url Declares database URL to use. NOTE: This defaults to sqlite:///tradesv3.dryrun.sqlite if dry_run is true , and to sqlite:///tradesv3.sqlite for production instances. Datatype: String, SQLAlchemy connect string logfile Specifies logfile name. Uses a rolling strategy for log file rotation for 10 files with the 1MB limit per file. Datatype: String add_config_files Additional config files. These files will be loaded and merged with the current config file. The files are resolved relative to the initial file. Defaults to [] . Datatype: List of strings dataformat_ohlcv Data format to use to store historical candle (OHLCV) data. Defaults to json . Datatype: String dataformat_trades Data format to use to store historical trades data. Defaults to jsongz . Datatype: String","title":"Parameters table"},{"location":"configuration/#parameters-in-the-strategy","text":"The following parameters can be set in the configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy. minimal_roi timeframe stoploss trailing_stop trailing_stop_positive trailing_stop_positive_offset trailing_only_offset_is_reached use_custom_stoploss process_only_new_candles order_types order_time_in_force unfilledtimeout disable_dataframe_checks use_exit_signal exit_profit_only exit_profit_offset ignore_roi_if_entry_signal ignore_buying_expired_candle_after position_adjustment_enable max_entry_position_adjustment","title":"Parameters in the strategy"},{"location":"configuration/#configuring-amount-per-trade","text":"There are several methods to configure how much of the stake currency the bot will use to enter a trade. All methods respect the available balance configuration as explained below.","title":"Configuring amount per trade"},{"location":"configuration/#minimum-trade-stake","text":"The minimum stake amount will depend on exchange and pair and is usually listed in the exchange support pages. Assuming the minimum tradable amount for XRP/USD is 20 XRP (given by the exchange), and the price is 0.6 \\(, the minimum stake amount to buy this pair is 20 * 0.6 ~= 12 . This exchange has also a limit on USD - where all orders must be > 10\\) - which however does not apply in this case. To guarantee safe execution, freqtrade will not allow buying with a stake-amount of 10.1$, instead, it'll make sure that there's enough space to place a stoploss below the pair (+ an offset, defined by amount_reserve_percent , which defaults to 5%). With a reserve of 5%, the minimum stake amount would be ~12.6$ ( 12 * (1 + 0.05) ). If we take into account a stoploss of 10% on top of that - we'd end up with a value of ~14$ ( 12.6 / (1 - 0.1) ). To limit this calculation in case of large stoploss values, the calculated minimum stake-limit will never be more than 50% above the real limit. Warning Since the limits on exchanges are usually stable and are not updated often, some pairs can show pretty high minimum limits, simply because the price increased a lot since the last limit adjustment by the exchange. Freqtrade adjusts the stake-amount to this value, unless it's > 30% more than the calculated/desired stake-amount - in which case the trade is rejected.","title":"Minimum trade stake"},{"location":"configuration/#tradable-balance","text":"By default, the bot assumes that the complete amount - 1% is at it's disposal, and when using dynamic stake amount , it will split the complete balance into max_open_trades buckets per trade. Freqtrade will reserve 1% for eventual fees when entering a trade and will therefore not touch that by default. You can configure the \"untouched\" amount by using the tradable_balance_ratio setting. For example, if you have 10 ETH available in your wallet on the exchange and tradable_balance_ratio=0.5 (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers this as an available balance. The rest of the wallet is untouched by the trades. Danger This setting should not be used when running multiple bots on the same account. Please look at Available Capital to the bot instead. Warning The tradable_balance_ratio setting applies to the current balance (free balance + tied up in trades). Therefore, assuming the starting balance of 1000, a configuration with tradable_balance_ratio=0.99 will not guarantee that 10 currency units will always remain available on the exchange. For example, the free amount may reduce to 5 units if the total balance is reduced to 500 (either by a losing streak or by withdrawing balance).","title":"Tradable balance"},{"location":"configuration/#assign-available-capital","text":"To fully utilize compounding profits when using multiple bots on the same exchange account, you'll want to limit each bot to a certain starting balance. This can be accomplished by setting available_capital to the desired starting balance. Assuming your account has 10.000 USDT and you want to run 2 different strategies on this exchange. You'd set available_capital=5000 - granting each bot an initial capital of 5000 USDT. The bot will then split this starting balance equally into max_open_trades buckets. Profitable trades will result in increased stake-sizes for this bot - without affecting the stake-sizes of the other bot. Incompatible with tradable_balance_ratio Setting this option will replace any configuration of tradable_balance_ratio .","title":"Assign available Capital"},{"location":"configuration/#amend-last-stake-amount","text":"Assuming we have the tradable balance of 1000 USDT, stake_amount=400 , and max_open_trades=3 . The bot would open 2 trades and will be unable to fill the last trading slot, since the requested 400 USDT are no longer available since 800 USDT are already tied in other trades. To overcome this, the option amend_last_stake_amount can be set to True , which will enable the bot to reduce stake_amount to the available balance to fill the last trade slot. In the example above this would mean: Trade1: 400 USDT Trade2: 400 USDT Trade3: 200 USDT Note This option only applies with Static stake amount - since Dynamic stake amount divides the balances evenly. Note The minimum last stake amount can be configured using last_stake_amount_min_ratio - which defaults to 0.5 (50%). This means that the minimum stake amount that's ever used is stake_amount * 0.5 . This avoids very low stake amounts, that are close to the minimum tradable amount for the pair and can be refused by the exchange.","title":"Amend last stake amount"},{"location":"configuration/#static-stake-amount","text":"The stake_amount configuration statically configures the amount of stake-currency your bot will use for each trade. The minimal configuration value is 0.0001, however, please check your exchange's trading minimums for the stake currency you're using to avoid problems. This setting works in combination with max_open_trades . The maximum capital engaged in trades is stake_amount * max_open_trades . For example, the bot will at most use (0.05 BTC x 3) = 0.15 BTC, assuming a configuration of max_open_trades=3 and stake_amount=0.05 . Note This setting respects the available balance configuration .","title":"Static stake amount"},{"location":"configuration/#dynamic-stake-amount","text":"Alternatively, you can use a dynamic stake amount, which will use the available balance on the exchange, and divide that equally by the number of allowed trades ( max_open_trades ). To configure this, set stake_amount=\"unlimited\" . We also recommend to set tradable_balance_ratio=0.99 (99%) - to keep a minimum balance for eventual fees. In this case a trade amount is calculated as: currency_balance / ( max_open_trades - current_open_trades ) To allow the bot to trade all the available stake_currency in your account (minus tradable_balance_ratio ) set \"stake_amount\" : \"unlimited\" , \"tradable_balance_ratio\" : 0.99 , Compounding profits This configuration will allow increasing/decreasing stakes depending on the performance of the bot (lower stake if the bot is losing, higher stakes if the bot has a winning record since higher balances are available), and will result in profit compounding. When using Dry-Run Mode When using \"stake_amount\" : \"unlimited\", in combination with Dry-Run, Backtesting or Hyperopt, the balance will be simulated starting with a stake of dry_run_wallet which will evolve. It is therefore important to set dry_run_wallet to a sensible value (like 0.05 or 0.01 for BTC and 1000 or 100 for USDT, for example), otherwise, it may simulate trades with 100 BTC (or more) or 0.05 USDT (or less) at once - which may not correspond to your real available balance or is less than the exchange minimal limit for the order amount for the stake currency.","title":"Dynamic stake amount"},{"location":"configuration/#dynamic-stake-amount-with-position-adjustment","text":"When you want to use position adjustment with unlimited stakes, you must also implement custom_stake_amount to a return a value depending on your strategy. Typical value would be in the range of 25% - 50% of the proposed stakes, but depends highly on your strategy and how much you wish to leave into the wallet as position adjustment buffer. For example if your position adjustment assumes it can do 2 additional buys with the same stake amounts then your buffer should be 66.6667% of the initially proposed unlimited stake amount. Or another example if your position adjustment assumes it can do 1 additional buy with 3x the original stake amount then custom_stake_amount should return 25% of proposed stake amount and leave 75% for possible later position adjustments.","title":"Dynamic stake amount with position adjustment"},{"location":"configuration/#prices-used-for-orders","text":"Prices for regular orders can be controlled via the parameter structures entry_pricing for trade entries and exit_pricing for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders.","title":"Prices used for orders"},{"location":"configuration/#entry-price","text":"","title":"Entry price"},{"location":"configuration/#enter-price-side","text":"The configuration setting entry_pricing.price_side defines the side of the orderbook the bot looks for when buying. The following displays an orderbook. ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If entry_pricing.price_side is set to \"bid\" , then the bot will use 99 as entry price. In line with that, if entry_pricing.price_side is set to \"ask\" , then the bot will use 101 as entry price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).","title":"Enter price side"},{"location":"configuration/#entry-price-with-orderbook-enabled","text":"When entering a trade with the orderbook enabled ( entry_pricing.use_order_book=True ), Freqtrade fetches the entry_pricing.order_book_top entries from the orderbook and uses the entry specified as entry_pricing.order_book_top on the configured side ( entry_pricing.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Entry price with Orderbook enabled"},{"location":"configuration/#entry-price-without-orderbook-enabled","text":"The following section uses side as the configured entry_pricing.price_side (defaults to \"same\" ). When not using orderbook ( entry_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on entry_pricing.price_last_balance . The entry_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price.","title":"Entry price without Orderbook enabled"},{"location":"configuration/#check-depth-of-market","text":"When check depth of market is enabled ( entry_pricing.check_depth_of_market.enabled=True ), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the entry_pricing.check_depth_of_market.bids_to_ask_delta parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).","title":"Check depth of market"},{"location":"configuration/#exit-price","text":"","title":"Exit price"},{"location":"configuration/#exit-price-side","text":"The configuration setting exit_pricing.price_side defines the side of the spread the bot looks for when exiting a trade. The following displays an orderbook: ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If exit_pricing.price_side is set to \"ask\" , then the bot will use 101 as exiting price. In line with that, if exit_pricing.price_side is set to \"bid\" , then the bot will use 99 as exiting price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes","title":"Exit price side"},{"location":"configuration/#exit-price-with-orderbook-enabled","text":"When exiting with the orderbook enabled ( exit_pricing.use_order_book=True ), Freqtrade fetches the exit_pricing.order_book_top entries in the orderbook and uses the entry specified as exit_pricing.order_book_top from the configured side ( exit_pricing.price_side ) as trade exit price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Exit price with Orderbook enabled"},{"location":"configuration/#exit-price-without-orderbook-enabled","text":"The following section uses side as the configured exit_pricing.price_side (defaults to \"ask\" ). When not using orderbook ( exit_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on exit_pricing.price_last_balance . The exit_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price.","title":"Exit price without Orderbook enabled"},{"location":"configuration/#market-order-pricing","text":"When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used \"order_types\": { \"entry\": \"market\", \"exit\": \"market\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Market order pricing"},{"location":"configuration/#understand-minimal_roi","text":"The minimal_roi configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI as a ratio. See the example below: \"minimal_roi\" : { \"40\" : 0.0 , # Exi t a fter 40 mi nutes i f t he pro f i t is n o t ne ga t ive \"30\" : 0.01 , # Exi t a fter 30 mi nutes i f t here is a t leas t 1 % pro f i t \"20\" : 0.02 , # Exi t a fter 20 mi nutes i f t here is a t leas t 2 % pro f i t \"0\" : 0.04 # Exi t immedia tel y i f t here is a t leas t 4 % pro f i t }, Most of the strategy files already include the optimal minimal_roi value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the minimal_roi value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% {\"0\": 10} is used, and minimal ROI is disabled unless your trade generates 1000% profit. Special case to forceexit after a specific time A special case presents using \"<N>\": -1 as ROI. This forces the bot to exit a trade after N Minutes, no matter if it's positive or negative, so represents a time-limited force-exit.","title":"Understand minimal_roi"},{"location":"configuration/#understand-force_entry_enable","text":"The force_entry_enable configuration parameter enables the usage of force-enter ( /forcelong , /forceshort ) commands via Telegram and REST API. For security reasons, it's disabled by default, and freqtrade will show a warning message on startup if enabled. For example, you can send /forceenter ETH/BTC to the bot, which will result in freqtrade buying the pair and holds it until a regular exit-signal (ROI, stoploss, /forceexit) appears. This can be dangerous with some strategies, so use with care. See the telegram documentation for details on usage.","title":"Understand force_entry_enable"},{"location":"configuration/#ignoring-expired-candles","text":"When working with larger timeframes (for example 1h or more) and using a low max_open_trades value, the last candle can be processed as soon as a trade slot becomes available. When processing the last candle, this can lead to a situation where it may not be desirable to use the buy signal on that candle. For example, when using a condition in your strategy where you use a cross-over, that point may have passed too long ago for you to start a trade on it. In these situations, you can enable the functionality to ignore candles that are beyond a specified period by setting ignore_buying_expired_candle_after to a positive number, indicating the number of seconds after which the buy signal becomes expired. For example, if your strategy is using a 1h timeframe, and you only want to buy within the first 5 minutes when a new candle comes in, you can add the following configuration to your strategy: { //... \"ignore_buying_expired_candle_after\" : 300 , // ... } Note This setting resets with each new candle, so it will not prevent sticking-signals from executing on the 2 nd or 3 rd candle they're active. Best use a \"trigger\" selector for buy signals, which are only active for one candle.","title":"Ignoring expired candles"},{"location":"configuration/#understand-order_types","text":"The order_types configuration parameter maps actions ( entry , exit , stoploss , emergency_exit , force_exit , force_entry ) to order-types ( market , limit , ...) as well as configures stoploss to be on the exchange and defines stoploss on exchange update interval in seconds. This allows to enter using limit orders, exit using limit-orders, and create stoplosses using market orders. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled. order_types set in the configuration file overwrites values set in the strategy as a whole, so you need to configure the whole order_types dictionary in one place. If this is configured, the following 4 values ( entry , exit , stoploss and stoploss_on_exchange ) need to be present, otherwise, the bot will fail to start. For information on ( emergency_exit , force_exit , force_entry , stoploss_on_exchange , stoploss_on_exchange_interval , stoploss_on_exchange_limit_ratio ) please see stop loss documentation stop loss on exchange Syntax for Strategy: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_entry\" : \"market\" , \"force_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : False , \"stoploss_on_exchange_interval\" : 60 , \"stoploss_on_exchange_limit_ratio\" : 0.99 , } Configuration: \"order_types\" : { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_entry\" : \"market\" , \"force_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 } Market order support Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: \"Exchange <yourexchange> does not support market orders.\" and the bot will refuse to start. Using market orders Please carefully read the section Market order pricing section when using market orders. Stoploss on exchange stoploss_on_exchange_interval is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please refer to the stoploss documentation . If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. Warning: stoploss_on_exchange failures If stoploss on exchange creation fails for some reason, then an \"emergency exit\" is initiated. By default, this will exit the trade using a market order. The order-type for the emergency-exit can be changed by setting the emergency_exit value in the order_types dictionary - however, this is not advised.","title":"Understand order_types"},{"location":"configuration/#understand-order_time_in_force","text":"The order_time_in_force configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are: GTC (Good Till Canceled): This is most of the time the default time in force. It means the order will remain on exchange till it is cancelled by the user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled. FOK (Fill Or Kill): It means if the order is not executed immediately AND fully then it is cancelled by the exchange. IOC (Immediate Or Canceled): It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange. The order_time_in_force parameter contains a dict with buy and sell time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy. The possible values are: gtc (default), fok or ioc . \"order_time_in_force\" : { \"entry\" : \"gtc\" , \"exit\" : \"gtc\" }, Warning This is ongoing work. For now, it is supported only for binance and kucoin. Please don't change the default value unless you know what you are doing and have researched the impact of using different values for your particular exchange.","title":"Understand order_time_in_force"},{"location":"configuration/#what-values-can-be-used-for-fiat_display_currency","text":"The fiat_display_currency configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports. The valid values are: \"AUD\" , \"BRL\" , \"CAD\" , \"CHF\" , \"CLP\" , \"CNY\" , \"CZK\" , \"DKK\" , \"EUR\" , \"GBP\" , \"HKD\" , \"HUF\" , \"IDR\" , \"ILS\" , \"INR\" , \"JPY\" , \"KRW\" , \"MXN\" , \"MYR\" , \"NOK\" , \"NZD\" , \"PHP\" , \"PKR\" , \"PLN\" , \"RUB\" , \"SEK\" , \"SGD\" , \"THB\" , \"TRY\" , \"TWD\" , \"ZAR\" , \"USD\" In addition to fiat currencies, a range of crypto currencies is supported. The valid values are: \"BTC\" , \"ETH\" , \"XRP\" , \"LTC\" , \"BCH\" , \"USDT\"","title":"What values can be used for fiat_display_currency?"},{"location":"configuration/#using-dry-run-mode","text":"We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode, the bot does not engage your money. It only runs a live simulation without creating trades on the exchange. Edit your config.json configuration file. Switch dry-run to true and specify db_url for a persistence database. \"dry_run\" : true , \"db_url\" : \"sqlite:///tradesv3.dryrun.sqlite\" , Remove your Exchange API key and secret (change them by empty values or fake credentials): \"exchange\" : { \"name\" : \"bittrex\" , \"key\" : \"key\" , \"secret\" : \"secret\" , ... } Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode. Note A simulated wallet is available during dry-run mode and will assume a starting capital of dry_run_wallet (defaults to 1000).","title":"Using Dry-run mode"},{"location":"configuration/#considerations-for-dry-run","text":"API-keys may or may not be provided. Only Read-Only operations (i.e. operations that do not alter account state) on the exchange are performed in dry-run mode. Wallets ( /balance ) are simulated based on dry_run_wallet . Orders are simulated, and will not be posted to the exchange. Market orders fill based on orderbook volume the moment the order is placed. Limit orders fill once the price reaches the defined level - or time out based on unfilledtimeout settings. In combination with stoploss_on_exchange , the stop_loss price is assumed to be filled. Open orders (not trades, which are stored in the database) are kept open after bot restarts, with the assumption that they were not filled while being offline.","title":"Considerations for dry-run"},{"location":"configuration/#switch-to-production-mode","text":"In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode. When switching to Production mode, please make sure to use a different / fresh database to avoid dry-run trades messing with your exchange money and eventually tainting your statistics.","title":"Switch to production mode"},{"location":"configuration/#setup-your-exchange-account","text":"You will need to create API Keys (usually you get key and secret , some exchanges require an additional password ) from the Exchange website and you'll need to insert this into the appropriate fields in the configuration or when asked by the freqtrade new-config command. API Keys are usually only required for live trading (trading for real money, bot running in \"production mode\", executing real orders on the exchange) and are not required for the bot running in dry-run (trade simulation) mode. When you set up the bot in dry-run mode, you may fill these fields with empty values.","title":"Setup your exchange account"},{"location":"configuration/#to-switch-your-bot-in-production-mode","text":"Edit your config.json file. Switch dry-run to false and don't forget to adapt your database URL if set: \"dry_run\" : false , Insert your Exchange API key (change them by fake API keys): { \"exchange\" : { \"name\" : \"bittrex\" , \"key\" : \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\" , \"secret\" : \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\" , //\"password\": \"\", // Optional, not needed by all exchanges) // ... } //... } You should also make sure to read the Exchanges section of the documentation to be aware of potential configuration details specific to your exchange. Keep your secrets secret To keep your secrets secret, we recommend using a 2 nd configuration for your API keys. Simply use the above snippet in a new configuration file (e.g. config-private.json ) and keep your settings in this file. You can then start the bot with freqtrade trade --config user_data/config.json --config user_data/config-private.json <...> to have your keys loaded. NEVER share your private configuration file or your exchange keys with anyone!","title":"To switch your bot in production mode"},{"location":"configuration/#using-proxy-with-freqtrade","text":"To use a proxy with freqtrade, add the kwarg \"aiohttp_trust_env\"=true to the \"ccxt_async_kwargs\" dict in the exchange section of the configuration. An example for this can be found in config_examples/config_full.example.json \"ccxt_async_config\" : { \"aiohttp_trust_env\" : true } Then, export your proxy settings using the variables \"HTTP_PROXY\" and \"HTTPS_PROXY\" set to the appropriate values export HTTP_PROXY = \"http://addr:port\" export HTTPS_PROXY = \"http://addr:port\" freqtrade","title":"Using proxy with Freqtrade"},{"location":"configuration/#next-step","text":"Now you have configured your config.json, the next step is to start your bot .","title":"Next step"},{"location":"data-analysis/","text":"Analyzing bot data with Jupyter notebooks \u00b6 You can analyze the results of backtests and trading history easily using Jupyter notebooks. Sample notebooks are located at user_data/notebooks/ after initializing the user directory with freqtrade create-userdir --userdir user_data . Quick start with docker \u00b6 Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a dockercontainer running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. For more information, Please visit the Data analysis with Docker section. Pro tips \u00b6 See jupyter.org for usage instructions. Don't forget to start a Jupyter notebook server from within your conda or venv environment or use nb_conda_kernels * Copy the example notebook before use so your changes don't get overwritten with the next freqtrade update. Using virtual environment with system-wide Jupyter installation \u00b6 Sometimes it can be desired to use a system-wide installation of Jupyter notebook, and use a jupyter kernel from the virtual environment. This prevents you from installing the full jupyter suite multiple times per system, and provides an easy way to switch between tasks (freqtrade / other analytics tasks). For this to work, first activate your virtual environment and run the following commands: # Activate virtual environment source .env/bin/activate pip install ipykernel ipython kernel install --user --name = freqtrade # Restart jupyter (lab / notebook) # select kernel \"freqtrade\" in the notebook Note This section is provided for completeness, the Freqtrade Team won't provide full support for problems with this setup and will recommend to install Jupyter in the virtual environment directly, as that is the easiest way to get jupyter notebooks up and running. For help with this setup please refer to the Project Jupyter documentation or help channels . Warning Some tasks don't work especially well in notebooks. For example, anything using asynchronous execution is a problem for Jupyter. Also, freqtrade's primary entry point is the shell cli, so using pure python in a notebook bypasses arguments that provide required objects and parameters to helper functions. You may need to set those values or create expected objects manually. Recommended workflow \u00b6 Task Tool Bot operations CLI Repetitive tasks Shell scripts Data analysis & visualization Notebook Use the CLI to * download historical data * run a backtest * run with real-time data * export results Collect these actions in shell scripts * save complicated commands with arguments * execute multi-step operations * automate testing strategies and preparing data for analysis Use a notebook to * visualize data * mangle and plot to generate insights Example utility snippets \u00b6 Change directory to root \u00b6 Jupyter notebooks execute from the notebook directory. The following snippet searches for the project root, so relative paths remain consistent. import os from pathlib import Path # Change directory # Modify this cell to insure that the output shows the correct path. # Define all paths relative to the project root shown in the cell output project_root = \"somedir/freqtrade\" i = 0 try : os . chdirdir ( project_root ) assert Path ( 'LICENSE' ) . is_file () except : while i < 4 and ( not Path ( 'LICENSE' ) . is_file ()): os . chdir ( Path ( Path . cwd (), '../' )) i += 1 project_root = Path . cwd () print ( Path . cwd ()) Load multiple configuration files \u00b6 This option can be useful to inspect the results of passing in multiple configs. This will also run through the whole Configuration initialization, so the configuration is completely initialized to be passed to other methods. import json from freqtrade.configuration import Configuration # Load config from multiple files config = Configuration . from_files ([ \"config1.json\" , \"config2.json\" ]) # Show the config in memory print ( json . dumps ( config [ 'original_config' ], indent = 2 )) For Interactive environments, have an additional configuration specifying user_data_dir and pass this in last, so you don't have to change directories while running the bot. Best avoid relative paths, since this starts at the storage location of the jupyter notebook, unless the directory is changed. { \"user_data_dir\" : \"~/.freqtrade/\" } Further Data analysis documentation \u00b6 Strategy debugging - also available as Jupyter notebook ( user_data/notebooks/strategy_analysis_example.ipynb ) Plotting Tag Analysis Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Jupyter Notebooks"},{"location":"data-analysis/#analyzing-bot-data-with-jupyter-notebooks","text":"You can analyze the results of backtests and trading history easily using Jupyter notebooks. Sample notebooks are located at user_data/notebooks/ after initializing the user directory with freqtrade create-userdir --userdir user_data .","title":"Analyzing bot data with Jupyter notebooks"},{"location":"data-analysis/#quick-start-with-docker","text":"Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a dockercontainer running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. For more information, Please visit the Data analysis with Docker section.","title":"Quick start with docker"},{"location":"data-analysis/#pro-tips","text":"See jupyter.org for usage instructions. Don't forget to start a Jupyter notebook server from within your conda or venv environment or use nb_conda_kernels * Copy the example notebook before use so your changes don't get overwritten with the next freqtrade update.","title":"Pro tips"},{"location":"data-analysis/#using-virtual-environment-with-system-wide-jupyter-installation","text":"Sometimes it can be desired to use a system-wide installation of Jupyter notebook, and use a jupyter kernel from the virtual environment. This prevents you from installing the full jupyter suite multiple times per system, and provides an easy way to switch between tasks (freqtrade / other analytics tasks). For this to work, first activate your virtual environment and run the following commands: # Activate virtual environment source .env/bin/activate pip install ipykernel ipython kernel install --user --name = freqtrade # Restart jupyter (lab / notebook) # select kernel \"freqtrade\" in the notebook Note This section is provided for completeness, the Freqtrade Team won't provide full support for problems with this setup and will recommend to install Jupyter in the virtual environment directly, as that is the easiest way to get jupyter notebooks up and running. For help with this setup please refer to the Project Jupyter documentation or help channels . Warning Some tasks don't work especially well in notebooks. For example, anything using asynchronous execution is a problem for Jupyter. Also, freqtrade's primary entry point is the shell cli, so using pure python in a notebook bypasses arguments that provide required objects and parameters to helper functions. You may need to set those values or create expected objects manually.","title":"Using virtual environment with system-wide Jupyter installation"},{"location":"data-analysis/#recommended-workflow","text":"Task Tool Bot operations CLI Repetitive tasks Shell scripts Data analysis & visualization Notebook Use the CLI to * download historical data * run a backtest * run with real-time data * export results Collect these actions in shell scripts * save complicated commands with arguments * execute multi-step operations * automate testing strategies and preparing data for analysis Use a notebook to * visualize data * mangle and plot to generate insights","title":"Recommended workflow"},{"location":"data-analysis/#example-utility-snippets","text":"","title":"Example utility snippets"},{"location":"data-analysis/#change-directory-to-root","text":"Jupyter notebooks execute from the notebook directory. The following snippet searches for the project root, so relative paths remain consistent. import os from pathlib import Path # Change directory # Modify this cell to insure that the output shows the correct path. # Define all paths relative to the project root shown in the cell output project_root = \"somedir/freqtrade\" i = 0 try : os . chdirdir ( project_root ) assert Path ( 'LICENSE' ) . is_file () except : while i < 4 and ( not Path ( 'LICENSE' ) . is_file ()): os . chdir ( Path ( Path . cwd (), '../' )) i += 1 project_root = Path . cwd () print ( Path . cwd ())","title":"Change directory to root"},{"location":"data-analysis/#load-multiple-configuration-files","text":"This option can be useful to inspect the results of passing in multiple configs. This will also run through the whole Configuration initialization, so the configuration is completely initialized to be passed to other methods. import json from freqtrade.configuration import Configuration # Load config from multiple files config = Configuration . from_files ([ \"config1.json\" , \"config2.json\" ]) # Show the config in memory print ( json . dumps ( config [ 'original_config' ], indent = 2 )) For Interactive environments, have an additional configuration specifying user_data_dir and pass this in last, so you don't have to change directories while running the bot. Best avoid relative paths, since this starts at the storage location of the jupyter notebook, unless the directory is changed. { \"user_data_dir\" : \"~/.freqtrade/\" }","title":"Load multiple configuration files"},{"location":"data-analysis/#further-data-analysis-documentation","text":"Strategy debugging - also available as Jupyter notebook ( user_data/notebooks/strategy_analysis_example.ipynb ) Plotting Tag Analysis Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Further Data analysis documentation"},{"location":"data-download/","text":"Data Downloading \u00b6 Getting data for backtesting and hyperopt \u00b6 To download data (candles / OHLCV) needed for backtesting and hyperoptimization use the freqtrade download-data command. If no additional parameter is specified, freqtrade will download data for \"1m\" and \"5m\" timeframes for the last 30 days. Exchange and pairs will come from config.json (if specified using -c/--config ). Otherwise --exchange becomes mandatory. You can use a relative timerange ( --days 20 ) or an absolute starting point ( --timerange 20200101- ). For incremental downloads, the relative approach should be used. Tip: Updating existing data If you already have backtesting data available in your data-directory and would like to refresh this data up to today, freqtrade will automatically calculate the data missing for the existing pairs and the download will occur from the latest available point until \"now\", neither --days or --timerange parameters are required. Freqtrade will keep the available data and only download the missing data. If you are updating existing data after inserting new pairs that you have no data for, use --new-pairs-days xx parameter. Specified number of days will be downloaded for new pairs while old pairs will be updated with missing data only. If you use --days xx parameter alone - data for specified number of days will be downloaded for all pairs. Be careful, if specified number of days is smaller than gap between now and last downloaded candle - freqtrade will delete all existing data to avoid gaps in candle data. Usage \u00b6 usage: freqtrade download-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [--pairs-file FILE] [--days INT] [--new-pairs-days INT] [--include-inactive-pairs] [--timerange TIMERANGE] [--dl-trades] [--exchange EXCHANGE] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--erase] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] [--trading-mode {spot,margin,futures}] [--prepend] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --pairs-file FILE File containing a list of pairs to download. --days INT Download data for given number of days. --new-pairs-days INT Download data of new pairs for given number of days. Default: `None`. --include-inactive-pairs Also download data from inactive pairs. --timerange TIMERANGE Specify what timerange of data to use. --dl-trades Download trades instead of OHLCV data. The bot will resample trades to the desired timeframe as specified as --timeframes/-t. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --erase Clean all existing data for the selected exchange/pairs/timeframes. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: `jsongz`). --trading-mode {spot,margin,futures} Select Trading mode --prepend Allow data prepending. (Data-appending is disabled) Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Startup period download-data is a strategy-independent command. The idea is to download a big chunk of data once, and then iteratively increase the amount of data stored. For that reason, download-data does not care about the \"startup-period\" defined in a strategy. It's up to the user to download additional days if the backtest should start at a specific point in time (while respecting startup period). Pairs file \u00b6 In alternative to the whitelist from config.json , a pairs.json file can be used. If you are using Binance for example: create a directory user_data/data/binance and copy or create the pairs.json file in that directory. update the pairs.json file to contain the currency pairs you are interested in. mkdir -p user_data/data/binance touch user_data/data/binance/pairs.json The format of the pairs.json file is a simple json list. Mixing different stake-currencies is allowed for this file, since it's only used for downloading. [ \"ETH/BTC\" , \"ETH/USDT\" , \"BTC/USDT\" , \"XRP/ETH\" ] Downloading all data for one quote currency Often, you'll want to download data for all pairs of a specific quote-currency. In such cases, you can use the following shorthand: freqtrade download-data --exchange binance --pairs .*/USDT <...> . The provided \"pairs\" string will be expanded to contain all active pairs on the exchange. To also download data for inactive (delisted) pairs, add --include-inactive-pairs to the command. Permission denied errors If your configuration directory user_data was made by docker, you may get the following error: cp: cannot create regular file 'user_data/data/binance/pairs.json': Permission denied You can fix the permissions of your user-data directory as follows: sudo chown -R $UID:$GID user_data Start download \u00b6 Then run: freqtrade download-data --exchange binance This will download historical candle (OHLCV) data for all the currency pairs you defined in pairs.json . Alternatively, specify the pairs directly freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT or as regex (to download all active USDT pairs) freqtrade download-data --exchange binance --pairs .*/USDT Other Notes \u00b6 To use a different directory than the exchange specific default, use --datadir user_data/data/some_directory . To change the exchange used to download the historical data from, please use a different configuration file (you'll probably need to adjust rate limits etc.) To use pairs.json from some other directory, use --pairs-file some_other_dir/pairs.json . To download historical candle (OHLCV) data for only 10 days, use --days 10 (defaults to 30 days). To download historical candle (OHLCV) data from a fixed starting point, use --timerange 20200101- - which will download all data from January 1 st , 2020. Use --timeframes to specify what timeframe download the historical candle (OHLCV) data for. Default is --timeframes 1m 5m which will download 1-minute and 5-minute data. To use exchange, timeframe and list of pairs as defined in your configuration file, use the -c/--config option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine -c/--config with most other options. Download additional data before the current timerange \u00b6 Assuming you downloaded all data from 2022 ( --timerange 20220101- ) - but you'd now like to also backtest with earlier data. You can do so by using the --prepend flag, combined with --timerange - specifying an end-date. freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT --prepend --timerange 20210101 -20220101 Note Freqtrade will ignore the end-date in this mode if data is available, updating the end-date to the existing data start point. Data format \u00b6 Freqtrade currently supports 3 data-formats for both OHLCV and trades data: json (plain \"text\" json files) jsongz (a gzip-zipped version of json files) hdf5 (a high performance datastore) By default, OHLCV data is stored as json data, while trades data is stored as jsongz data. This can be changed via the --data-format-ohlcv and --data-format-trades command line arguments respectively. To persist this change, you should also add the following snippet to your configuration, so you don't have to insert the above arguments each time: // ... \"dataformat_ohlcv\": \"hdf5\", \"dataformat_trades\": \"hdf5\", // ... If the default data-format has been changed during download, then the keys dataformat_ohlcv and dataformat_trades in the configuration file need to be adjusted to the selected dataformat as well. Note You can convert between data-formats using the convert-data and convert-trade-data methods. Sub-command convert data \u00b6 usage: freqtrade convert-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--trading-mode {spot,margin,futures}] [--candle-types {spot,,futures,mark,index,premiumIndex,funding_rate} [{spot,,futures,mark,index,premiumIndex,funding_rate} ...]] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --trading-mode {spot,margin,futures} Select Trading mode --candle-types {spot,,futures,mark,index,premiumIndex,funding_rate} [{spot,,futures,mark,index,premiumIndex,funding_rate} ...] Select candle type to use Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example converting data \u00b6 The following command will convert all candle (OHLCV) data available in ~/.freqtrade/data/binance from json to jsongz, saving diskspace in the process. It'll also remove original json data files ( --erase parameter). freqtrade convert-data --format-from json --format-to jsongz --datadir ~/.freqtrade/data/binance -t 5m 15m --erase Sub-command convert trade data \u00b6 usage: freqtrade convert-trade-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example converting trades \u00b6 The following command will convert all available trade-data in ~/.freqtrade/data/kraken from jsongz to json. It'll also remove original jsongz data files ( --erase parameter). freqtrade convert-trade-data --format-from jsongz --format-to json --datadir ~/.freqtrade/data/kraken --erase Sub-command trades to ohlcv \u00b6 When you need to use --dl-trades (kraken only) to download data, conversion of trades data to ohlcv data is the last step. This command will allow you to repeat this last step for additional timeframes without re-downloading the data. usage: freqtrade trades-to-ohlcv [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: `jsongz`). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example trade-to-ohlcv conversion \u00b6 freqtrade trades-to-ohlcv --exchange kraken -t 5m 1h 1d --pairs BTC/EUR ETH/EUR Sub-command list-data \u00b6 You can get a list of downloaded data using the list-data sub-command. usage: freqtrade list-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [-p PAIRS [PAIRS ...]] [--trading-mode {spot,margin,futures}] [--show-timerange] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --trading-mode {spot,margin,futures} Select Trading mode --show-timerange Show timerange available for available data. (May take a while to calculate). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example list-data \u00b6 > freqtrade list-data --userdir ~/.freqtrade/user_data/ Found 33 pair / timeframe combinations. pairs timeframe ---------- ----------------------------------------- ADA/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ADA/ETH 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/USDT 5m, 15m, 30m, 1h, 2h, 4h Trades (tick) data \u00b6 By default, download-data sub-command downloads Candles (OHLCV) data. Some exchanges also provide historic trade-data via their API. This data can be useful if you need many different timeframes, since it is only downloaded once, and then resampled locally to the desired timeframes. Since this data is large by default, the files use gzip by default. They are stored in your data-directory with the naming convention of <pair>-trades.json.gz ( ETH_BTC-trades.json.gz ). Incremental mode is also supported, as for historic OHLCV data, so downloading the data once per week with --days 8 will create an incremental data-repository. To use this mode, simply add --dl-trades to your call. This will swap the download method to download trades, and resamples the data locally. do not use You should not use this unless you're a kraken user. Most other exchanges provide OHLCV data with sufficient history. Example call: freqtrade download-data --exchange kraken --pairs XRP/EUR ETH/EUR --days 20 --dl-trades Note While this method uses async calls, it will be slow, since it requires the result of the previous call to generate the next request to the exchange. Warning The historic trades are not available during Freqtrade dry-run and live trade modes because all exchanges tested provide this data with a delay of few 100 candles, so it's not suitable for real-time trading. Kraken user Kraken users should read this before starting to download data. Next step \u00b6 Great, you now have backtest data downloaded, so you can now start backtesting your strategy.","title":"Data Downloading"},{"location":"data-download/#data-downloading","text":"","title":"Data Downloading"},{"location":"data-download/#getting-data-for-backtesting-and-hyperopt","text":"To download data (candles / OHLCV) needed for backtesting and hyperoptimization use the freqtrade download-data command. If no additional parameter is specified, freqtrade will download data for \"1m\" and \"5m\" timeframes for the last 30 days. Exchange and pairs will come from config.json (if specified using -c/--config ). Otherwise --exchange becomes mandatory. You can use a relative timerange ( --days 20 ) or an absolute starting point ( --timerange 20200101- ). For incremental downloads, the relative approach should be used. Tip: Updating existing data If you already have backtesting data available in your data-directory and would like to refresh this data up to today, freqtrade will automatically calculate the data missing for the existing pairs and the download will occur from the latest available point until \"now\", neither --days or --timerange parameters are required. Freqtrade will keep the available data and only download the missing data. If you are updating existing data after inserting new pairs that you have no data for, use --new-pairs-days xx parameter. Specified number of days will be downloaded for new pairs while old pairs will be updated with missing data only. If you use --days xx parameter alone - data for specified number of days will be downloaded for all pairs. Be careful, if specified number of days is smaller than gap between now and last downloaded candle - freqtrade will delete all existing data to avoid gaps in candle data.","title":"Getting data for backtesting and hyperopt"},{"location":"data-download/#usage","text":"usage: freqtrade download-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [--pairs-file FILE] [--days INT] [--new-pairs-days INT] [--include-inactive-pairs] [--timerange TIMERANGE] [--dl-trades] [--exchange EXCHANGE] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--erase] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] [--trading-mode {spot,margin,futures}] [--prepend] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --pairs-file FILE File containing a list of pairs to download. --days INT Download data for given number of days. --new-pairs-days INT Download data of new pairs for given number of days. Default: `None`. --include-inactive-pairs Also download data from inactive pairs. --timerange TIMERANGE Specify what timerange of data to use. --dl-trades Download trades instead of OHLCV data. The bot will resample trades to the desired timeframe as specified as --timeframes/-t. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --erase Clean all existing data for the selected exchange/pairs/timeframes. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: `jsongz`). --trading-mode {spot,margin,futures} Select Trading mode --prepend Allow data prepending. (Data-appending is disabled) Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Startup period download-data is a strategy-independent command. The idea is to download a big chunk of data once, and then iteratively increase the amount of data stored. For that reason, download-data does not care about the \"startup-period\" defined in a strategy. It's up to the user to download additional days if the backtest should start at a specific point in time (while respecting startup period).","title":"Usage"},{"location":"data-download/#pairs-file","text":"In alternative to the whitelist from config.json , a pairs.json file can be used. If you are using Binance for example: create a directory user_data/data/binance and copy or create the pairs.json file in that directory. update the pairs.json file to contain the currency pairs you are interested in. mkdir -p user_data/data/binance touch user_data/data/binance/pairs.json The format of the pairs.json file is a simple json list. Mixing different stake-currencies is allowed for this file, since it's only used for downloading. [ \"ETH/BTC\" , \"ETH/USDT\" , \"BTC/USDT\" , \"XRP/ETH\" ] Downloading all data for one quote currency Often, you'll want to download data for all pairs of a specific quote-currency. In such cases, you can use the following shorthand: freqtrade download-data --exchange binance --pairs .*/USDT <...> . The provided \"pairs\" string will be expanded to contain all active pairs on the exchange. To also download data for inactive (delisted) pairs, add --include-inactive-pairs to the command. Permission denied errors If your configuration directory user_data was made by docker, you may get the following error: cp: cannot create regular file 'user_data/data/binance/pairs.json': Permission denied You can fix the permissions of your user-data directory as follows: sudo chown -R $UID:$GID user_data","title":"Pairs file"},{"location":"data-download/#start-download","text":"Then run: freqtrade download-data --exchange binance This will download historical candle (OHLCV) data for all the currency pairs you defined in pairs.json . Alternatively, specify the pairs directly freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT or as regex (to download all active USDT pairs) freqtrade download-data --exchange binance --pairs .*/USDT","title":"Start download"},{"location":"data-download/#other-notes","text":"To use a different directory than the exchange specific default, use --datadir user_data/data/some_directory . To change the exchange used to download the historical data from, please use a different configuration file (you'll probably need to adjust rate limits etc.) To use pairs.json from some other directory, use --pairs-file some_other_dir/pairs.json . To download historical candle (OHLCV) data for only 10 days, use --days 10 (defaults to 30 days). To download historical candle (OHLCV) data from a fixed starting point, use --timerange 20200101- - which will download all data from January 1 st , 2020. Use --timeframes to specify what timeframe download the historical candle (OHLCV) data for. Default is --timeframes 1m 5m which will download 1-minute and 5-minute data. To use exchange, timeframe and list of pairs as defined in your configuration file, use the -c/--config option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine -c/--config with most other options.","title":"Other Notes"},{"location":"data-download/#download-additional-data-before-the-current-timerange","text":"Assuming you downloaded all data from 2022 ( --timerange 20220101- ) - but you'd now like to also backtest with earlier data. You can do so by using the --prepend flag, combined with --timerange - specifying an end-date. freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT --prepend --timerange 20210101 -20220101 Note Freqtrade will ignore the end-date in this mode if data is available, updating the end-date to the existing data start point.","title":"Download additional data before the current timerange"},{"location":"data-download/#data-format","text":"Freqtrade currently supports 3 data-formats for both OHLCV and trades data: json (plain \"text\" json files) jsongz (a gzip-zipped version of json files) hdf5 (a high performance datastore) By default, OHLCV data is stored as json data, while trades data is stored as jsongz data. This can be changed via the --data-format-ohlcv and --data-format-trades command line arguments respectively. To persist this change, you should also add the following snippet to your configuration, so you don't have to insert the above arguments each time: // ... \"dataformat_ohlcv\": \"hdf5\", \"dataformat_trades\": \"hdf5\", // ... If the default data-format has been changed during download, then the keys dataformat_ohlcv and dataformat_trades in the configuration file need to be adjusted to the selected dataformat as well. Note You can convert between data-formats using the convert-data and convert-trade-data methods.","title":"Data format"},{"location":"data-download/#sub-command-convert-data","text":"usage: freqtrade convert-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--trading-mode {spot,margin,futures}] [--candle-types {spot,,futures,mark,index,premiumIndex,funding_rate} [{spot,,futures,mark,index,premiumIndex,funding_rate} ...]] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --trading-mode {spot,margin,futures} Select Trading mode --candle-types {spot,,futures,mark,index,premiumIndex,funding_rate} [{spot,,futures,mark,index,premiumIndex,funding_rate} ...] Select candle type to use Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Sub-command convert data"},{"location":"data-download/#example-converting-data","text":"The following command will convert all candle (OHLCV) data available in ~/.freqtrade/data/binance from json to jsongz, saving diskspace in the process. It'll also remove original json data files ( --erase parameter). freqtrade convert-data --format-from json --format-to jsongz --datadir ~/.freqtrade/data/binance -t 5m 15m --erase","title":"Example converting data"},{"location":"data-download/#sub-command-convert-trade-data","text":"usage: freqtrade convert-trade-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] --format-from {json,jsongz,hdf5} --format-to {json,jsongz,hdf5} [--erase] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Show profits for only these pairs. Pairs are space- separated. --format-from {json,jsongz,hdf5} Source format for data conversion. --format-to {json,jsongz,hdf5} Destination format for data conversion. --erase Clean all existing data for the selected exchange/pairs/timeframes. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Sub-command convert trade data"},{"location":"data-download/#example-converting-trades","text":"The following command will convert all available trade-data in ~/.freqtrade/data/kraken from jsongz to json. It'll also remove original jsongz data files ( --erase parameter). freqtrade convert-trade-data --format-from jsongz --format-to json --datadir ~/.freqtrade/data/kraken --erase","title":"Example converting trades"},{"location":"data-download/#sub-command-trades-to-ohlcv","text":"When you need to use --dl-trades (kraken only) to download data, conversion of trades data to ohlcv data is the last step. This command will allow you to repeat this last step for additional timeframes without re-downloading the data. usage: freqtrade trades-to-ohlcv [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-p PAIRS [PAIRS ...]] [-t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...]] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--data-format-trades {json,jsongz,hdf5}] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. -t {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...], --timeframes {1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} [{1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,2w,1M,1y} ...] Specify which tickers to download. Space-separated list. Default: `1m 5m`. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --data-format-trades {json,jsongz,hdf5} Storage format for downloaded trades data. (default: `jsongz`). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Sub-command trades to ohlcv"},{"location":"data-download/#example-trade-to-ohlcv-conversion","text":"freqtrade trades-to-ohlcv --exchange kraken -t 5m 1h 1d --pairs BTC/EUR ETH/EUR","title":"Example trade-to-ohlcv conversion"},{"location":"data-download/#sub-command-list-data","text":"You can get a list of downloaded data using the list-data sub-command. usage: freqtrade list-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [-p PAIRS [PAIRS ...]] [--trading-mode {spot,margin,futures}] [--show-timerange] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --trading-mode {spot,margin,futures} Select Trading mode --show-timerange Show timerange available for available data. (May take a while to calculate). Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Sub-command list-data"},{"location":"data-download/#example-list-data","text":"> freqtrade list-data --userdir ~/.freqtrade/user_data/ Found 33 pair / timeframe combinations. pairs timeframe ---------- ----------------------------------------- ADA/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ADA/ETH 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/BTC 5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d ETH/USDT 5m, 15m, 30m, 1h, 2h, 4h","title":"Example list-data"},{"location":"data-download/#trades-tick-data","text":"By default, download-data sub-command downloads Candles (OHLCV) data. Some exchanges also provide historic trade-data via their API. This data can be useful if you need many different timeframes, since it is only downloaded once, and then resampled locally to the desired timeframes. Since this data is large by default, the files use gzip by default. They are stored in your data-directory with the naming convention of <pair>-trades.json.gz ( ETH_BTC-trades.json.gz ). Incremental mode is also supported, as for historic OHLCV data, so downloading the data once per week with --days 8 will create an incremental data-repository. To use this mode, simply add --dl-trades to your call. This will swap the download method to download trades, and resamples the data locally. do not use You should not use this unless you're a kraken user. Most other exchanges provide OHLCV data with sufficient history. Example call: freqtrade download-data --exchange kraken --pairs XRP/EUR ETH/EUR --days 20 --dl-trades Note While this method uses async calls, it will be slow, since it requires the result of the previous call to generate the next request to the exchange. Warning The historic trades are not available during Freqtrade dry-run and live trade modes because all exchanges tested provide this data with a delay of few 100 candles, so it's not suitable for real-time trading. Kraken user Kraken users should read this before starting to download data.","title":"Trades (tick) data"},{"location":"data-download/#next-step","text":"Great, you now have backtest data downloaded, so you can now start backtesting your strategy.","title":"Next step"},{"location":"deprecated/","text":"Deprecated features \u00b6 This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration. Removed features \u00b6 the --refresh-pairs-cached command line option \u00b6 --refresh-pairs-cached in the context of backtesting, hyperopt and edge allows to refresh candle data for backtesting. Since this leads to much confusion, and slows down backtesting (while not being part of backtesting) this has been singled out as a separate freqtrade sub-command freqtrade download-data . This command line option was deprecated in 2019.7-dev (develop branch) and removed in 2019.9. The --dynamic-whitelist command line option \u00b6 This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7. Please refer to pairlists instead. the --live command line option \u00b6 --live in the context of backtesting allowed to download the latest tick data for backtesting. Did only download the latest 500 candles, so was ineffective in getting good backtest data. Removed in 2019-7-dev (develop branch) and in freqtrade 2019.8. ticker_interval (now timeframe ) \u00b6 Support for ticker_interval terminology was deprecated in 2020.6 in favor of timeframe - and compatibility code was removed in 2022.3. Allow running multiple pairlists in sequence \u00b6 The former \"pairlist\" section in the configuration has been removed, and is replaced by \"pairlists\" - being a list to specify a sequence of pairlists. The old section of configuration parameters ( \"pairlist\" ) has been deprecated in 2019.11 and has been removed in 2020.4. deprecation of bidVolume and askVolume from volume-pairlist \u00b6 Since only quoteVolume can be compared between assets, the other options (bidVolume, askVolume) have been deprecated in 2020.4, and have been removed in 2020.9. Using order book steps for exit price \u00b6 Using order_book_min and order_book_max used to allow stepping the orderbook and trying to find the next ROI slot - trying to place sell-orders early. As this does however increase risk and provides no benefit, it's been removed for maintainability purposes in 2021.7. Legacy Hyperopt mode \u00b6 Using separate hyperopt files was deprecated in 2021.4 and was removed in 2021.9. Please switch to the new Parametrized Strategies to benefit from the new hyperopt interface. Strategy changes between V2 and V3 \u00b6 Isolated Futures / short trading was introduced in 2022.4. This required major changes to configuration settings, strategy interfaces, ... We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets, there are no changes necessary. While we may drop support for the current interface sometime in the future, we will announce this separately and have an appropriate transition period. Please follow the Strategy migration guide to migrate your strategy to the new format to start using the new functionalities. webhooks - changes with 2022.4 \u00b6 buy_tag has been renamed to enter_tag \u00b6 This should apply only to your strategy and potentially to webhooks. We will keep a compatibility layer for 1-2 versions (so both buy_tag and enter_tag will still work), but support for this in webhooks will disappear after that. Naming changes \u00b6 Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to \"entry\". webhookbuy -> webhookentry webhookbuyfill -> webhookentryfill webhookbuycancel -> webhookentrycancel webhooksell -> webhookexit webhooksellfill -> webhookexitfill webhooksellcancel -> webhookexitcancel","title":"Deprecated Features"},{"location":"deprecated/#deprecated-features","text":"This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration.","title":"Deprecated features"},{"location":"deprecated/#removed-features","text":"","title":"Removed features"},{"location":"deprecated/#the-refresh-pairs-cached-command-line-option","text":"--refresh-pairs-cached in the context of backtesting, hyperopt and edge allows to refresh candle data for backtesting. Since this leads to much confusion, and slows down backtesting (while not being part of backtesting) this has been singled out as a separate freqtrade sub-command freqtrade download-data . This command line option was deprecated in 2019.7-dev (develop branch) and removed in 2019.9.","title":"the --refresh-pairs-cached command line option"},{"location":"deprecated/#the-dynamic-whitelist-command-line-option","text":"This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7. Please refer to pairlists instead.","title":"The --dynamic-whitelist command line option"},{"location":"deprecated/#the-live-command-line-option","text":"--live in the context of backtesting allowed to download the latest tick data for backtesting. Did only download the latest 500 candles, so was ineffective in getting good backtest data. Removed in 2019-7-dev (develop branch) and in freqtrade 2019.8.","title":"the --live command line option"},{"location":"deprecated/#ticker_interval-now-timeframe","text":"Support for ticker_interval terminology was deprecated in 2020.6 in favor of timeframe - and compatibility code was removed in 2022.3.","title":"ticker_interval (now timeframe)"},{"location":"deprecated/#allow-running-multiple-pairlists-in-sequence","text":"The former \"pairlist\" section in the configuration has been removed, and is replaced by \"pairlists\" - being a list to specify a sequence of pairlists. The old section of configuration parameters ( \"pairlist\" ) has been deprecated in 2019.11 and has been removed in 2020.4.","title":"Allow running multiple pairlists in sequence"},{"location":"deprecated/#deprecation-of-bidvolume-and-askvolume-from-volume-pairlist","text":"Since only quoteVolume can be compared between assets, the other options (bidVolume, askVolume) have been deprecated in 2020.4, and have been removed in 2020.9.","title":"deprecation of bidVolume and askVolume from volume-pairlist"},{"location":"deprecated/#using-order-book-steps-for-exit-price","text":"Using order_book_min and order_book_max used to allow stepping the orderbook and trying to find the next ROI slot - trying to place sell-orders early. As this does however increase risk and provides no benefit, it's been removed for maintainability purposes in 2021.7.","title":"Using order book steps for exit price"},{"location":"deprecated/#legacy-hyperopt-mode","text":"Using separate hyperopt files was deprecated in 2021.4 and was removed in 2021.9. Please switch to the new Parametrized Strategies to benefit from the new hyperopt interface.","title":"Legacy Hyperopt mode"},{"location":"deprecated/#strategy-changes-between-v2-and-v3","text":"Isolated Futures / short trading was introduced in 2022.4. This required major changes to configuration settings, strategy interfaces, ... We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets, there are no changes necessary. While we may drop support for the current interface sometime in the future, we will announce this separately and have an appropriate transition period. Please follow the Strategy migration guide to migrate your strategy to the new format to start using the new functionalities.","title":"Strategy changes between V2 and V3"},{"location":"deprecated/#webhooks-changes-with-20224","text":"","title":"webhooks - changes with 2022.4"},{"location":"deprecated/#buy_tag-has-been-renamed-to-enter_tag","text":"This should apply only to your strategy and potentially to webhooks. We will keep a compatibility layer for 1-2 versions (so both buy_tag and enter_tag will still work), but support for this in webhooks will disappear after that.","title":"buy_tag has been renamed to enter_tag"},{"location":"deprecated/#naming-changes","text":"Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to \"entry\". webhookbuy -> webhookentry webhookbuyfill -> webhookentryfill webhookbuycancel -> webhookentrycancel webhooksell -> webhookexit webhooksellfill -> webhookexitfill webhooksellcancel -> webhookexitcancel","title":"Naming changes"},{"location":"developer/","text":"Development Help \u00b6 This page is intended for developers of Freqtrade, people who want to contribute to the Freqtrade codebase or documentation, or people who want to understand the source code of the application they're running. All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel on discord where you can ask questions. Documentation \u00b6 Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR. Special fields for the documentation (like Note boxes, ...) can be found here . To test the documentation locally use the following commands. pip install -r docs/requirements-docs.txt mkdocs serve This will spin up a local server (usually on port 8000) so you can see if everything looks as you'd like it to. Developer setup \u00b6 To configure a development environment, you can either use the provided DevContainer , or use the setup.sh script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (e.g. if your system is not supported by the setup.sh script), follow the manual installation process and run pip3 install -e .[all] . This will install all required tools for development, including pytest , flake8 , mypy , and coveralls . Then install the git hook scripts by running pre-commit install , so your changes will be verified locally before committing. This avoids a lot of waiting for CI already, as some basic formatting checks are done locally on your machine. Before opening a pull request, please familiarize yourself with our Contributing Guidelines . Devcontainer setup \u00b6 The fastest and easiest way to get started is to use VSCode with the Remote container extension. This gives developers the ability to start the bot with all required dependencies without needing to install any freqtrade specific dependencies on your local machine. Devcontainer dependencies \u00b6 VSCode docker Remote container extension documentation For more information about the Remote container extension , best consult the documentation. Tests \u00b6 New code should be covered by basic unittests. Depending on the complexity of the feature, Reviewers may request more in-depth unittests. If necessary, the Freqtrade team can assist and give guidance with writing good tests (however please don't expect anyone to write the tests for you). Checking log content in tests \u00b6 Freqtrade uses 2 main methods to check log content in tests, log_has() and log_has_re() (to check using regex, in case of dynamic log-messages). These are available from conftest.py and can be imported in any test module. A sample check looks as follows: from tests.conftest import log_has , log_has_re def test_method_to_test ( caplog ): method_to_test () assert log_has ( \"This event happened\" , caplog ) # Check regex with trailing number ... assert log_has_re ( r \"This dynamic event happened and produced \\d+\" , caplog ) Debug configuration \u00b6 To debug freqtrade, we recommend VSCode with the following launch configuration (located in .vscode/launch.json ). Details will obviously vary between setups - but this should work to get you started. { \"name\" : \"freqtrade trade\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"module\" : \"freqtrade\" , \"console\" : \"integratedTerminal\" , \"args\" : [ \"trade\" , // Optional: // \"--userdir\", \"user_data\", \"--strategy\" , \"MyAwesomeStrategy\" , ] }, Command line arguments can be added in the \"args\" array. This method can also be used to debug a strategy, by setting the breakpoints within the strategy. A similar setup can also be taken for Pycharm - using freqtrade as module name, and setting the command line arguments as \"parameters\". Startup directory This assumes that you have the repository checked out, and the editor is started at the repository root level (so setup.py is at the top level of your repository). ErrorHandling \u00b6 Freqtrade Exceptions all inherit from FreqtradeException . This general class of error should however not be used directly. Instead, multiple specialized sub-Exceptions exist. Below is an outline of exception inheritance hierarchy: + FreqtradeException | +---+ OperationalException | +---+ DependencyException | | | +---+ PricingError | | | +---+ ExchangeError | | | +---+ TemporaryError | | | +---+ DDosProtection | | | +---+ InvalidOrderException | | | +---+ RetryableOrderError | | | +---+ InsufficientFundsError | +---+ StrategyError Plugins \u00b6 Pairlists \u00b6 You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream. Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist Handler. First of all, have a look at the VolumePairList Handler, and best copy this file with a name of your new Pairlist Handler. This is a simple Handler, which however serves as a good example on how to start developing. Next, modify the class-name of the Handler (ideally align this with the module filename). The base-class provides an instance of the exchange ( self._exchange ) the pairlist manager ( self._pairlistmanager ), as well as the main configuration ( self._config ), the pairlist dedicated configuration ( self._pairlistconfig ) and the absolute position within the list of pairlists. self . _exchange = exchange self . _pairlistmanager = pairlistmanager self . _config = config self . _pairlistconfig = pairlistconfig self . _pairlist_pos = pairlist_pos Tip Don't forget to register your pairlist in constants.py under the variable AVAILABLE_PAIRLISTS - otherwise it will not be selectable. Now, let's step through the methods which require actions: Pairlist configuration \u00b6 Configuration for the chain of Pairlist Handlers is done in the bot configuration file in the element \"pairlists\" , an array of configuration parameters for each Pairlist Handlers in the chain. By convention, \"number_assets\" is used to specify the maximum number of pairs to keep in the pairlist. Please follow this to ensure a consistent user experience. Additional parameters can be configured as needed. For instance, VolumePairList uses \"sort_key\" to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successful and dynamic. short_desc \u00b6 Returns a description used for Telegram messages. This should contain the name of the Pairlist Handler, as well as a short description containing the number of assets. Please follow the format \"PairlistName - top/bottom X pairs\" . gen_pairlist \u00b6 Override this method if the Pairlist Handler can be used as the leading Pairlist Handler in the chain, defining the initial pairlist which is then handled by all Pairlist Handlers in the chain. Examples are StaticPairList and VolumePairList . This is called with each iteration of the bot (only if the Pairlist Handler is at the first location) - so consider implementing caching for compute/network heavy calculations. It must return the resulting pairlist (which may then be passed into the chain of Pairlist Handlers). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filtering. Use this if you limit your result to a certain number of pairs - so the end-result is not shorter than expected. filter_pairlist \u00b6 This method is called for each Pairlist Handler in the chain by the pairlist manager. This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations. It gets passed a pairlist (which can be the result of previous pairlists) as well as tickers , a pre-fetched version of get_tickers() . The default implementation in the base class simply calls the _validate_pair() method for each pair in the pairlist, but you may override it. So you should either implement the _validate_pair() in your Pairlist Handler or override filter_pairlist() to do something else. If overridden, it must return the resulting pairlist (which may then be passed into the next Pairlist Handler in the chain). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filters. Use this if you limit your result to a certain number of pairs - so the end result is not shorter than expected. In VolumePairList , this implements different methods of sorting, does early validation so only the expected number of pairs is returned. sample \u00b6 def filter_pairlist ( self , pairlist : List [ str ], tickers : Dict ) -> List [ str ]: # Generate dynamic whitelist pairs = self . _calculate_pairlist ( pairlist , tickers ) return pairs Protections \u00b6 Best read the Protection documentation to understand protections. This Guide is directed towards Developers who want to develop a new protection. No protection should use datetime directly, but use the provided date_now variable for date calculations. This preserves the ability to backtest protections. Writing a new Protection Best copy one of the existing Protections to have a good example. Don't forget to register your protection in constants.py under the variable AVAILABLE_PROTECTIONS - otherwise it will not be selectable. Implementation of a new protection \u00b6 All Protection implementations must have IProtection as parent class. For that reason, they must implement the following methods: short_desc() global_stop() stop_per_pair() . global_stop() and stop_per_pair() must return a ProtectionReturn object, which consists of: lock pair - boolean lock until - datetime - until when should the pair be locked (will be rounded up to the next new candle) reason - string, used for logging and storage in the database lock_side - long, short or '*'. The until portion should be calculated using the provided calculate_lock_end() method. All Protections should use \"stop_duration\" / \"stop_duration_candles\" to define how long a a pair (or all pairs) should be locked. The content of this is made available as self._stop_duration to the each Protection. If your protection requires a look-back period, please use \"lookback_period\" / \"lockback_period_candles\" to keep all protections aligned. Global vs. local stops \u00b6 Protections can have 2 different ways to stop trading for a limited : Per pair (local) For all Pairs (globally) Protections - per pair \u00b6 Protections that implement the per pair approach must set has_local_stop=True . The method stop_per_pair() will be called whenever a trade closed (exit order completed). Protections - global protection \u00b6 These Protections should do their evaluation across all pairs, and consequently will also lock all pairs from trading (called a global PairLock). Global protection must set has_global_stop=True to be evaluated for global stops. The method global_stop() will be called whenever a trade closed (exit order completed). Protections - calculating lock end time \u00b6 Protections should calculate the lock end time based on the last trade it considers. This avoids re-locking should the lookback-period be longer than the actual lock period. The IProtection parent class provides a helper method for this in calculate_lock_end() . Implement a new Exchange (WIP) \u00b6 Note This section is a Work in Progress and is not a complete guide on how to test a new exchange with Freqtrade. Note Make sure to use an up-to-date version of CCXT before running any of the below tests. You can get the latest version of ccxt by running pip install -U ccxt with activated virtual environment. Native docker is not supported for these tests, however the available dev-container will support all required actions and eventually necessary changes. Most exchanges supported by CCXT should work out of the box. To quickly test the public endpoints of an exchange, add a configuration for your exchange to test_ccxt_compat.py and run these tests with pytest --longrun tests/exchange/test_ccxt_compat.py . Completing these tests successfully a good basis point (it's a requirement, actually), however these won't guarantee correct exchange functioning, as this only tests public endpoints, but no private endpoint (like generate order or similar). Also try to use freqtrade download-data for an extended timerange (multiple months) and verify that the data downloaded correctly (no holes, the specified timerange was actually downloaded). These are prerequisites to have an exchange listed as either Supported or Community tested (listed on the homepage). The below are \"extras\", which will make an exchange better (feature-complete) - but are not absolutely necessary for either of the 2 categories. Additional tests / steps to complete: Verify data provided by fetch_ohlcv() - and eventually adjust ohlcv_candle_limit for this exchange Check L2 orderbook limit range (API documentation) - and eventually set as necessary Check if balance shows correctly (*) Create market order (*) Create limit order (*) Complete trade (enter + exit) (*) Compare result calculation between exchange and bot Ensure fees are applied correctly (check the database against the exchange) (*) Requires API keys and Balance on the exchange. Stoploss On Exchange \u00b6 Check if the new exchange supports Stoploss on Exchange orders through their API. Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselves. Best look at binance.py for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects. Incomplete candles \u00b6 While fetching candle (OHLCV) data, we may end up getting incomplete candles (depending on the exchange). To demonstrate this, we'll use daily candles ( \"1d\" ) to keep things simple. We query the api ( ct.fetch_ohlcv() ) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete. To check how the new exchange behaves, you can use the following snippet: import ccxt from datetime import datetime from freqtrade.data.converter import ohlcv_to_dataframe ct = ccxt . binance () timeframe = \"1d\" pair = \"XLM/BTC\" # Make sure to use a pair that exists on that exchange! raw = ct . fetch_ohlcv ( pair , timeframe = timeframe ) # convert to dataframe df1 = ohlcv_to_dataframe ( raw , timeframe , pair = pair , drop_incomplete = False ) print ( df1 . tail ( 1 )) print ( datetime . utcnow ()) date open high low close volume 499 2019-06-08 00:00:00+00:00 0.000007 0.000007 0.000007 0.000007 26264344.0 2019-06-09 12:30:27.873327 The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting \"ohlcv_partial_candle\" from the exchange-class untouched / True). Otherwise, set \"ohlcv_partial_candle\" to False to not drop Candles (shown in the example above). Another way is to run this command multiple times in a row and observe if the volume is changing (while the date remains the same). Update binance cached leverage tiers \u00b6 Updating leveraged tiers should be done regularly - and requires an authenticated account with futures enabled. import ccxt import json from pathlib import Path exchange = ccxt . binance ({ 'apiKey' : '<apikey>' , 'secret' : '<secret>' 'options' : { 'defaultType' : 'future' } }) _ = exchange . load_markets () lev_tiers = exchange . fetch_leverage_tiers () # Assumes this is running in the root of the repository. file = Path ( 'freqtrade/exchange/binance_leverage_tiers.json' ) json . dump ( dict ( sorted ( lev_tiers . items ())), file . open ( 'w' ), indent = 2 ) This file should then be contributed upstream, so others can benefit from this, too. Updating example notebooks \u00b6 To keep the jupyter notebooks aligned with the documentation, the following should be ran after updating a example notebook. jupyter nbconvert --ClearOutputPreprocessor.enabled = True --inplace freqtrade/templates/strategy_analysis_example.ipynb jupyter nbconvert --ClearOutputPreprocessor.enabled = True --to markdown freqtrade/templates/strategy_analysis_example.ipynb --stdout > docs/strategy_analysis_example.md Continuous integration \u00b6 This documents some decisions taken for the CI Pipeline. CI runs on all OS variants, Linux (ubuntu), macOS and Windows. Docker images are build for the branches stable and develop , and are built as multiarch builds, supporting multiple platforms via the same tag. Docker images containing Plot dependencies are also available as stable_plot and develop_plot . Docker images contain a file, /freqtrade/freqtrade_commit containing the commit this image is based of. Full docker image rebuilds are run once a week via schedule. Deployments run on ubuntu. ta-lib binaries are contained in the build_helpers directory to avoid fails related to external unavailability. All tests must pass for a PR to be merged to stable or develop . Creating a release \u00b6 This part of the documentation is aimed at maintainers, and shows how to create a release. Create release branch \u00b6 First, pick a commit that's about one week old (to not include latest additions to releases). # create new branch git checkout -b new_release <commitid> Determine if crucial bugfixes have been made between this commit and the current state, and eventually cherry-pick these. Merge the release branch (stable) into this branch. Edit freqtrade/__init__.py and add the version matching the current date (for example 2019.7 for July 2019). Minor versions can be 2019.7.1 should we need to do a second release that month. Version numbers must follow allowed versions from PEP0440 to avoid failures pushing to pypi. Commit this part push that branch to the remote and create a PR against the stable branch Create changelog from git commits \u00b6 Note Make sure that the stable branch is up-to-date! # Needs to be done before merging / pulling that branch. git log --oneline --no-decorate --no-merges stable..new_release To keep the release-log short, best wrap the full git changelog into a collapsible details section. <details> <summary>Expand full changelog</summary> ... Full git changelog </details> Create github release / tag \u00b6 Once the PR against stable is merged (best right after merging): Use the button \"Draft a new release\" in the Github UI (subsection releases). Use the version-number specified as tag. Use \"stable\" as reference (this step comes after the above PR is merged). Use the above changelog as release comment (as codeblock) Releases \u00b6 pypi \u00b6 Note This process is now automated as part of Github Actions. To create a pypi release, please run the following commands: Additional requirement: wheel , twine (for uploading), account on pypi with proper permissions. python setup.py sdist bdist_wheel # For pypi test (to check if some change to the installation did work) twine upload --repository-url https://test.pypi.org/legacy/ dist/* # For production: twine upload dist/* Please don't push non-releases to the productive / real pypi instance.","title":"Contributors Guide"},{"location":"developer/#development-help","text":"This page is intended for developers of Freqtrade, people who want to contribute to the Freqtrade codebase or documentation, or people who want to understand the source code of the application they're running. All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel on discord where you can ask questions.","title":"Development Help"},{"location":"developer/#documentation","text":"Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR. Special fields for the documentation (like Note boxes, ...) can be found here . To test the documentation locally use the following commands. pip install -r docs/requirements-docs.txt mkdocs serve This will spin up a local server (usually on port 8000) so you can see if everything looks as you'd like it to.","title":"Documentation"},{"location":"developer/#developer-setup","text":"To configure a development environment, you can either use the provided DevContainer , or use the setup.sh script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (e.g. if your system is not supported by the setup.sh script), follow the manual installation process and run pip3 install -e .[all] . This will install all required tools for development, including pytest , flake8 , mypy , and coveralls . Then install the git hook scripts by running pre-commit install , so your changes will be verified locally before committing. This avoids a lot of waiting for CI already, as some basic formatting checks are done locally on your machine. Before opening a pull request, please familiarize yourself with our Contributing Guidelines .","title":"Developer setup"},{"location":"developer/#devcontainer-setup","text":"The fastest and easiest way to get started is to use VSCode with the Remote container extension. This gives developers the ability to start the bot with all required dependencies without needing to install any freqtrade specific dependencies on your local machine.","title":"Devcontainer setup"},{"location":"developer/#devcontainer-dependencies","text":"VSCode docker Remote container extension documentation For more information about the Remote container extension , best consult the documentation.","title":"Devcontainer dependencies"},{"location":"developer/#tests","text":"New code should be covered by basic unittests. Depending on the complexity of the feature, Reviewers may request more in-depth unittests. If necessary, the Freqtrade team can assist and give guidance with writing good tests (however please don't expect anyone to write the tests for you).","title":"Tests"},{"location":"developer/#checking-log-content-in-tests","text":"Freqtrade uses 2 main methods to check log content in tests, log_has() and log_has_re() (to check using regex, in case of dynamic log-messages). These are available from conftest.py and can be imported in any test module. A sample check looks as follows: from tests.conftest import log_has , log_has_re def test_method_to_test ( caplog ): method_to_test () assert log_has ( \"This event happened\" , caplog ) # Check regex with trailing number ... assert log_has_re ( r \"This dynamic event happened and produced \\d+\" , caplog )","title":"Checking log content in tests"},{"location":"developer/#debug-configuration","text":"To debug freqtrade, we recommend VSCode with the following launch configuration (located in .vscode/launch.json ). Details will obviously vary between setups - but this should work to get you started. { \"name\" : \"freqtrade trade\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"module\" : \"freqtrade\" , \"console\" : \"integratedTerminal\" , \"args\" : [ \"trade\" , // Optional: // \"--userdir\", \"user_data\", \"--strategy\" , \"MyAwesomeStrategy\" , ] }, Command line arguments can be added in the \"args\" array. This method can also be used to debug a strategy, by setting the breakpoints within the strategy. A similar setup can also be taken for Pycharm - using freqtrade as module name, and setting the command line arguments as \"parameters\". Startup directory This assumes that you have the repository checked out, and the editor is started at the repository root level (so setup.py is at the top level of your repository).","title":"Debug configuration"},{"location":"developer/#errorhandling","text":"Freqtrade Exceptions all inherit from FreqtradeException . This general class of error should however not be used directly. Instead, multiple specialized sub-Exceptions exist. Below is an outline of exception inheritance hierarchy: + FreqtradeException | +---+ OperationalException | +---+ DependencyException | | | +---+ PricingError | | | +---+ ExchangeError | | | +---+ TemporaryError | | | +---+ DDosProtection | | | +---+ InvalidOrderException | | | +---+ RetryableOrderError | | | +---+ InsufficientFundsError | +---+ StrategyError","title":"ErrorHandling"},{"location":"developer/#plugins","text":"","title":"Plugins"},{"location":"developer/#pairlists","text":"You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream. Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist Handler. First of all, have a look at the VolumePairList Handler, and best copy this file with a name of your new Pairlist Handler. This is a simple Handler, which however serves as a good example on how to start developing. Next, modify the class-name of the Handler (ideally align this with the module filename). The base-class provides an instance of the exchange ( self._exchange ) the pairlist manager ( self._pairlistmanager ), as well as the main configuration ( self._config ), the pairlist dedicated configuration ( self._pairlistconfig ) and the absolute position within the list of pairlists. self . _exchange = exchange self . _pairlistmanager = pairlistmanager self . _config = config self . _pairlistconfig = pairlistconfig self . _pairlist_pos = pairlist_pos Tip Don't forget to register your pairlist in constants.py under the variable AVAILABLE_PAIRLISTS - otherwise it will not be selectable. Now, let's step through the methods which require actions:","title":"Pairlists"},{"location":"developer/#pairlist-configuration","text":"Configuration for the chain of Pairlist Handlers is done in the bot configuration file in the element \"pairlists\" , an array of configuration parameters for each Pairlist Handlers in the chain. By convention, \"number_assets\" is used to specify the maximum number of pairs to keep in the pairlist. Please follow this to ensure a consistent user experience. Additional parameters can be configured as needed. For instance, VolumePairList uses \"sort_key\" to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successful and dynamic.","title":"Pairlist configuration"},{"location":"developer/#short_desc","text":"Returns a description used for Telegram messages. This should contain the name of the Pairlist Handler, as well as a short description containing the number of assets. Please follow the format \"PairlistName - top/bottom X pairs\" .","title":"short_desc"},{"location":"developer/#gen_pairlist","text":"Override this method if the Pairlist Handler can be used as the leading Pairlist Handler in the chain, defining the initial pairlist which is then handled by all Pairlist Handlers in the chain. Examples are StaticPairList and VolumePairList . This is called with each iteration of the bot (only if the Pairlist Handler is at the first location) - so consider implementing caching for compute/network heavy calculations. It must return the resulting pairlist (which may then be passed into the chain of Pairlist Handlers). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filtering. Use this if you limit your result to a certain number of pairs - so the end-result is not shorter than expected.","title":"gen_pairlist"},{"location":"developer/#filter_pairlist","text":"This method is called for each Pairlist Handler in the chain by the pairlist manager. This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations. It gets passed a pairlist (which can be the result of previous pairlists) as well as tickers , a pre-fetched version of get_tickers() . The default implementation in the base class simply calls the _validate_pair() method for each pair in the pairlist, but you may override it. So you should either implement the _validate_pair() in your Pairlist Handler or override filter_pairlist() to do something else. If overridden, it must return the resulting pairlist (which may then be passed into the next Pairlist Handler in the chain). Validations are optional, the parent class exposes a _verify_blacklist(pairlist) and _whitelist_for_active_markets(pairlist) to do default filters. Use this if you limit your result to a certain number of pairs - so the end result is not shorter than expected. In VolumePairList , this implements different methods of sorting, does early validation so only the expected number of pairs is returned.","title":"filter_pairlist"},{"location":"developer/#sample","text":"def filter_pairlist ( self , pairlist : List [ str ], tickers : Dict ) -> List [ str ]: # Generate dynamic whitelist pairs = self . _calculate_pairlist ( pairlist , tickers ) return pairs","title":"sample"},{"location":"developer/#protections","text":"Best read the Protection documentation to understand protections. This Guide is directed towards Developers who want to develop a new protection. No protection should use datetime directly, but use the provided date_now variable for date calculations. This preserves the ability to backtest protections. Writing a new Protection Best copy one of the existing Protections to have a good example. Don't forget to register your protection in constants.py under the variable AVAILABLE_PROTECTIONS - otherwise it will not be selectable.","title":"Protections"},{"location":"developer/#implementation-of-a-new-protection","text":"All Protection implementations must have IProtection as parent class. For that reason, they must implement the following methods: short_desc() global_stop() stop_per_pair() . global_stop() and stop_per_pair() must return a ProtectionReturn object, which consists of: lock pair - boolean lock until - datetime - until when should the pair be locked (will be rounded up to the next new candle) reason - string, used for logging and storage in the database lock_side - long, short or '*'. The until portion should be calculated using the provided calculate_lock_end() method. All Protections should use \"stop_duration\" / \"stop_duration_candles\" to define how long a a pair (or all pairs) should be locked. The content of this is made available as self._stop_duration to the each Protection. If your protection requires a look-back period, please use \"lookback_period\" / \"lockback_period_candles\" to keep all protections aligned.","title":"Implementation of a new protection"},{"location":"developer/#global-vs-local-stops","text":"Protections can have 2 different ways to stop trading for a limited : Per pair (local) For all Pairs (globally)","title":"Global vs. local stops"},{"location":"developer/#protections-per-pair","text":"Protections that implement the per pair approach must set has_local_stop=True . The method stop_per_pair() will be called whenever a trade closed (exit order completed).","title":"Protections - per pair"},{"location":"developer/#protections-global-protection","text":"These Protections should do their evaluation across all pairs, and consequently will also lock all pairs from trading (called a global PairLock). Global protection must set has_global_stop=True to be evaluated for global stops. The method global_stop() will be called whenever a trade closed (exit order completed).","title":"Protections - global protection"},{"location":"developer/#protections-calculating-lock-end-time","text":"Protections should calculate the lock end time based on the last trade it considers. This avoids re-locking should the lookback-period be longer than the actual lock period. The IProtection parent class provides a helper method for this in calculate_lock_end() .","title":"Protections - calculating lock end time"},{"location":"developer/#implement-a-new-exchange-wip","text":"Note This section is a Work in Progress and is not a complete guide on how to test a new exchange with Freqtrade. Note Make sure to use an up-to-date version of CCXT before running any of the below tests. You can get the latest version of ccxt by running pip install -U ccxt with activated virtual environment. Native docker is not supported for these tests, however the available dev-container will support all required actions and eventually necessary changes. Most exchanges supported by CCXT should work out of the box. To quickly test the public endpoints of an exchange, add a configuration for your exchange to test_ccxt_compat.py and run these tests with pytest --longrun tests/exchange/test_ccxt_compat.py . Completing these tests successfully a good basis point (it's a requirement, actually), however these won't guarantee correct exchange functioning, as this only tests public endpoints, but no private endpoint (like generate order or similar). Also try to use freqtrade download-data for an extended timerange (multiple months) and verify that the data downloaded correctly (no holes, the specified timerange was actually downloaded). These are prerequisites to have an exchange listed as either Supported or Community tested (listed on the homepage). The below are \"extras\", which will make an exchange better (feature-complete) - but are not absolutely necessary for either of the 2 categories. Additional tests / steps to complete: Verify data provided by fetch_ohlcv() - and eventually adjust ohlcv_candle_limit for this exchange Check L2 orderbook limit range (API documentation) - and eventually set as necessary Check if balance shows correctly (*) Create market order (*) Create limit order (*) Complete trade (enter + exit) (*) Compare result calculation between exchange and bot Ensure fees are applied correctly (check the database against the exchange) (*) Requires API keys and Balance on the exchange.","title":"Implement a new Exchange (WIP)"},{"location":"developer/#stoploss-on-exchange","text":"Check if the new exchange supports Stoploss on Exchange orders through their API. Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselves. Best look at binance.py for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects.","title":"Stoploss On Exchange"},{"location":"developer/#incomplete-candles","text":"While fetching candle (OHLCV) data, we may end up getting incomplete candles (depending on the exchange). To demonstrate this, we'll use daily candles ( \"1d\" ) to keep things simple. We query the api ( ct.fetch_ohlcv() ) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete. To check how the new exchange behaves, you can use the following snippet: import ccxt from datetime import datetime from freqtrade.data.converter import ohlcv_to_dataframe ct = ccxt . binance () timeframe = \"1d\" pair = \"XLM/BTC\" # Make sure to use a pair that exists on that exchange! raw = ct . fetch_ohlcv ( pair , timeframe = timeframe ) # convert to dataframe df1 = ohlcv_to_dataframe ( raw , timeframe , pair = pair , drop_incomplete = False ) print ( df1 . tail ( 1 )) print ( datetime . utcnow ()) date open high low close volume 499 2019-06-08 00:00:00+00:00 0.000007 0.000007 0.000007 0.000007 26264344.0 2019-06-09 12:30:27.873327 The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting \"ohlcv_partial_candle\" from the exchange-class untouched / True). Otherwise, set \"ohlcv_partial_candle\" to False to not drop Candles (shown in the example above). Another way is to run this command multiple times in a row and observe if the volume is changing (while the date remains the same).","title":"Incomplete candles"},{"location":"developer/#update-binance-cached-leverage-tiers","text":"Updating leveraged tiers should be done regularly - and requires an authenticated account with futures enabled. import ccxt import json from pathlib import Path exchange = ccxt . binance ({ 'apiKey' : '<apikey>' , 'secret' : '<secret>' 'options' : { 'defaultType' : 'future' } }) _ = exchange . load_markets () lev_tiers = exchange . fetch_leverage_tiers () # Assumes this is running in the root of the repository. file = Path ( 'freqtrade/exchange/binance_leverage_tiers.json' ) json . dump ( dict ( sorted ( lev_tiers . items ())), file . open ( 'w' ), indent = 2 ) This file should then be contributed upstream, so others can benefit from this, too.","title":"Update binance cached leverage tiers"},{"location":"developer/#updating-example-notebooks","text":"To keep the jupyter notebooks aligned with the documentation, the following should be ran after updating a example notebook. jupyter nbconvert --ClearOutputPreprocessor.enabled = True --inplace freqtrade/templates/strategy_analysis_example.ipynb jupyter nbconvert --ClearOutputPreprocessor.enabled = True --to markdown freqtrade/templates/strategy_analysis_example.ipynb --stdout > docs/strategy_analysis_example.md","title":"Updating example notebooks"},{"location":"developer/#continuous-integration","text":"This documents some decisions taken for the CI Pipeline. CI runs on all OS variants, Linux (ubuntu), macOS and Windows. Docker images are build for the branches stable and develop , and are built as multiarch builds, supporting multiple platforms via the same tag. Docker images containing Plot dependencies are also available as stable_plot and develop_plot . Docker images contain a file, /freqtrade/freqtrade_commit containing the commit this image is based of. Full docker image rebuilds are run once a week via schedule. Deployments run on ubuntu. ta-lib binaries are contained in the build_helpers directory to avoid fails related to external unavailability. All tests must pass for a PR to be merged to stable or develop .","title":"Continuous integration"},{"location":"developer/#creating-a-release","text":"This part of the documentation is aimed at maintainers, and shows how to create a release.","title":"Creating a release"},{"location":"developer/#create-release-branch","text":"First, pick a commit that's about one week old (to not include latest additions to releases). # create new branch git checkout -b new_release <commitid> Determine if crucial bugfixes have been made between this commit and the current state, and eventually cherry-pick these. Merge the release branch (stable) into this branch. Edit freqtrade/__init__.py and add the version matching the current date (for example 2019.7 for July 2019). Minor versions can be 2019.7.1 should we need to do a second release that month. Version numbers must follow allowed versions from PEP0440 to avoid failures pushing to pypi. Commit this part push that branch to the remote and create a PR against the stable branch","title":"Create release branch"},{"location":"developer/#create-changelog-from-git-commits","text":"Note Make sure that the stable branch is up-to-date! # Needs to be done before merging / pulling that branch. git log --oneline --no-decorate --no-merges stable..new_release To keep the release-log short, best wrap the full git changelog into a collapsible details section. <details> <summary>Expand full changelog</summary> ... Full git changelog </details>","title":"Create changelog from git commits"},{"location":"developer/#create-github-release-tag","text":"Once the PR against stable is merged (best right after merging): Use the button \"Draft a new release\" in the Github UI (subsection releases). Use the version-number specified as tag. Use \"stable\" as reference (this step comes after the above PR is merged). Use the above changelog as release comment (as codeblock)","title":"Create github release / tag"},{"location":"developer/#releases","text":"","title":"Releases"},{"location":"developer/#pypi","text":"Note This process is now automated as part of Github Actions. To create a pypi release, please run the following commands: Additional requirement: wheel , twine (for uploading), account on pypi with proper permissions. python setup.py sdist bdist_wheel # For pypi test (to check if some change to the installation did work) twine upload --repository-url https://test.pypi.org/legacy/ dist/* # For production: twine upload dist/* Please don't push non-releases to the productive / real pypi instance.","title":"pypi"},{"location":"docker_quickstart/","text":"Using Freqtrade with Docker \u00b6 This page explains how to run the bot with Docker. It is not meant to work out of the box. You'll still need to read through the documentation and understand how to properly configure it. Install Docker \u00b6 Start by downloading and installing Docker CE for your platform: Mac Windows Linux To simplify running freqtrade, docker-compose should be installed and available to follow the below docker quick start guide . Freqtrade with docker-compose \u00b6 Freqtrade provides an official Docker image on Dockerhub , as well as a docker-compose file ready for usage. Note The following section assumes that docker and docker-compose are installed and available to the logged in user. All below commands use relative directories and will have to be executed from the directory containing the docker-compose.yml file. Docker quick start \u00b6 Create a new directory and place the docker-compose file in this directory. mkdir ft_userdata cd ft_userdata/ # Download the docker-compose file from the repository curl https://raw.githubusercontent.com/freqtrade/freqtrade/stable/docker-compose.yml -o docker-compose.yml # Pull the freqtrade image docker-compose pull # Create user directory structure docker-compose run --rm freqtrade create-userdir --userdir user_data # Create configuration - Requires answering interactive questions docker-compose run --rm freqtrade new-config --config user_data/config.json The above snippet creates a new directory called ft_userdata , downloads the latest compose file and pulls the freqtrade image. The last 2 steps in the snippet create the directory with user_data , as well as (interactively) the default configuration based on your selections. How to edit the bot configuration? You can edit the configuration at any time, which is available as user_data/config.json (within the directory ft_userdata ) when using the above configuration. You can also change the both Strategy and commands by editing the command section of your docker-compose.yml file. Adding a custom strategy \u00b6 The configuration is now available as user_data/config.json Copy a custom strategy to the directory user_data/strategies/ Add the Strategy' class name to the docker-compose.yml file The SampleStrategy is run by default. SampleStrategy is just a demo! The SampleStrategy is there for your reference and give you ideas for your own strategy. Please always backtest your strategy and use dry-run for some time before risking real money! You will find more information about Strategy development in the Strategy documentation . Once this is done, you're ready to launch the bot in trading mode (Dry-run or Live-trading, depending on your answer to the corresponding question you made above). docker-compose up -d Default configuration While the configuration generated will be mostly functional, you will still need to verify that all options correspond to what you want (like Pricing, pairlist, ...) before starting the bot. Accessing the UI \u00b6 If you've selected to enable FreqUI in the new-config step, you will have freqUI available at port localhost:8080 . You can now access the UI by typing localhost:8080 in your browser. UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. Please also read the API configuration with docker section to learn more about this configuration. Monitoring the bot \u00b6 You can check for running instances with docker-compose ps . This should list the service freqtrade as running . If that's not the case, best check the logs (see next point). Docker-compose logs \u00b6 Logs will be written to: user_data/logs/freqtrade.log . You can also check the latest log with the command docker-compose logs -f . Database \u00b6 The database will be located at: user_data/tradesv3.sqlite Updating freqtrade with docker-compose \u00b6 Updating freqtrade when using docker-compose is as simple as running the following 2 commands: # Download the latest image docker-compose pull # Restart the image docker-compose up -d This will first pull the latest image, and will then restart the container with the just pulled version. Check the Changelog You should always check the changelog for breaking changes / manual interventions required and make sure the bot starts correctly after the update. Editing the docker-compose file \u00b6 Advanced users may edit the docker-compose file further to include all possible options or arguments. All freqtrade arguments will be available by running docker-compose run --rm freqtrade <command> <optional arguments> . docker-compose for trade commands Trade commands ( freqtrade trade <...> ) should not be ran via docker-compose run - but should use docker-compose up -d instead. This makes sure that the container is properly started (including port forwardings) and will make sure that the container will restart after a system reboot. If you intend to use freqUI, please also ensure to adjust the configuration accordingly , otherwise the UI will not be available. docker-compose run --rm Including --rm will remove the container after completion, and is highly recommended for all modes except trading mode (running with freqtrade trade command). Using docker without docker-compose \" docker-compose run --rm \" will require a compose file to be provided. Some freqtrade commands that don't require authentication such as list-pairs can be run with \" docker run --rm \" instead. For example docker run --rm freqtradeorg/freqtrade:stable list-pairs --exchange binance --quote BTC --print-json . This can be useful for fetching exchange information to add to your config.json without affecting your running containers. Example: Download data with docker-compose \u00b6 Download backtesting data for 5 days for the pair ETH/BTC and 1h timeframe from Binance. The data will be stored in the directory user_data/data/ on the host. docker-compose run --rm freqtrade download-data --pairs ETH/BTC --exchange binance --days 5 -t 1h Head over to the Data Downloading Documentation for more details on downloading data. Example: Backtest with docker-compose \u00b6 Run backtesting in docker-containers for SampleStrategy and specified timerange of historical data, on 5m timeframe: docker-compose run --rm freqtrade backtesting --config user_data/config.json --strategy SampleStrategy --timerange 20190801 -20191001 -i 5m Head over to the Backtesting Documentation to learn more. Additional dependencies with docker-compose \u00b6 If your strategy requires dependencies not included in the default image - it will be necessary to build the image on your host. For this, please create a Dockerfile containing installation steps for the additional dependencies (have a look at docker/Dockerfile.custom for an example). You'll then also need to modify the docker-compose.yml file and uncomment the build step, as well as rename the image to avoid naming collisions. image : freqtrade_custom build : context : . dockerfile : \"./Dockerfile.<yourextension>\" You can then run docker-compose build --pull to build the docker image, and run it using the commands described above. Plotting with docker-compose \u00b6 Commands freqtrade plot-profit and freqtrade plot-dataframe ( Documentation ) are available by changing the image to *_plot in your docker-compose.yml file. You can then use these commands as follows: docker-compose run --rm freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange = 20180801 -20180805 The output will be stored in the user_data/plot directory, and can be opened with any modern browser. Data analysis using docker compose \u00b6 Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a docker-container running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. Since part of this image is built on your machine, it is recommended to rebuild the image from time to time to keep freqtrade (and dependencies) up-to-date. docker-compose -f docker/docker-compose-jupyter.yml build --no-cache Troubleshooting \u00b6 Docker on Windows \u00b6 Error: \"Timestamp for this request is outside of the recvWindow.\" The market api requests require a synchronized clock but the time in the docker container shifts a bit over time into the past. To fix this issue temporarily you need to run wsl --shutdown and restart docker again (a popup on windows 10 will ask you to do so). A permanent solution is either to host the docker container on a linux host or restart the wsl from time to time with the scheduler. taskkill /IM \"Docker Desktop.exe\" /F wsl --shutdown start \"\" \"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\" Warning Due to the above, we do not recommend the usage of docker on windows for production setups, but only for experimentation, datadownload and backtesting. Best use a linux-VPS for running freqtrade reliably.","title":"Quickstart with Docker"},{"location":"docker_quickstart/#using-freqtrade-with-docker","text":"This page explains how to run the bot with Docker. It is not meant to work out of the box. You'll still need to read through the documentation and understand how to properly configure it.","title":"Using Freqtrade with Docker"},{"location":"docker_quickstart/#install-docker","text":"Start by downloading and installing Docker CE for your platform: Mac Windows Linux To simplify running freqtrade, docker-compose should be installed and available to follow the below docker quick start guide .","title":"Install Docker"},{"location":"docker_quickstart/#freqtrade-with-docker-compose","text":"Freqtrade provides an official Docker image on Dockerhub , as well as a docker-compose file ready for usage. Note The following section assumes that docker and docker-compose are installed and available to the logged in user. All below commands use relative directories and will have to be executed from the directory containing the docker-compose.yml file.","title":"Freqtrade with docker-compose"},{"location":"docker_quickstart/#docker-quick-start","text":"Create a new directory and place the docker-compose file in this directory. mkdir ft_userdata cd ft_userdata/ # Download the docker-compose file from the repository curl https://raw.githubusercontent.com/freqtrade/freqtrade/stable/docker-compose.yml -o docker-compose.yml # Pull the freqtrade image docker-compose pull # Create user directory structure docker-compose run --rm freqtrade create-userdir --userdir user_data # Create configuration - Requires answering interactive questions docker-compose run --rm freqtrade new-config --config user_data/config.json The above snippet creates a new directory called ft_userdata , downloads the latest compose file and pulls the freqtrade image. The last 2 steps in the snippet create the directory with user_data , as well as (interactively) the default configuration based on your selections. How to edit the bot configuration? You can edit the configuration at any time, which is available as user_data/config.json (within the directory ft_userdata ) when using the above configuration. You can also change the both Strategy and commands by editing the command section of your docker-compose.yml file.","title":"Docker quick start"},{"location":"docker_quickstart/#adding-a-custom-strategy","text":"The configuration is now available as user_data/config.json Copy a custom strategy to the directory user_data/strategies/ Add the Strategy' class name to the docker-compose.yml file The SampleStrategy is run by default. SampleStrategy is just a demo! The SampleStrategy is there for your reference and give you ideas for your own strategy. Please always backtest your strategy and use dry-run for some time before risking real money! You will find more information about Strategy development in the Strategy documentation . Once this is done, you're ready to launch the bot in trading mode (Dry-run or Live-trading, depending on your answer to the corresponding question you made above). docker-compose up -d Default configuration While the configuration generated will be mostly functional, you will still need to verify that all options correspond to what you want (like Pricing, pairlist, ...) before starting the bot.","title":"Adding a custom strategy"},{"location":"docker_quickstart/#accessing-the-ui","text":"If you've selected to enable FreqUI in the new-config step, you will have freqUI available at port localhost:8080 . You can now access the UI by typing localhost:8080 in your browser. UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. Please also read the API configuration with docker section to learn more about this configuration.","title":"Accessing the UI"},{"location":"docker_quickstart/#monitoring-the-bot","text":"You can check for running instances with docker-compose ps . This should list the service freqtrade as running . If that's not the case, best check the logs (see next point).","title":"Monitoring the bot"},{"location":"docker_quickstart/#docker-compose-logs","text":"Logs will be written to: user_data/logs/freqtrade.log . You can also check the latest log with the command docker-compose logs -f .","title":"Docker-compose logs"},{"location":"docker_quickstart/#database","text":"The database will be located at: user_data/tradesv3.sqlite","title":"Database"},{"location":"docker_quickstart/#updating-freqtrade-with-docker-compose","text":"Updating freqtrade when using docker-compose is as simple as running the following 2 commands: # Download the latest image docker-compose pull # Restart the image docker-compose up -d This will first pull the latest image, and will then restart the container with the just pulled version. Check the Changelog You should always check the changelog for breaking changes / manual interventions required and make sure the bot starts correctly after the update.","title":"Updating freqtrade with docker-compose"},{"location":"docker_quickstart/#editing-the-docker-compose-file","text":"Advanced users may edit the docker-compose file further to include all possible options or arguments. All freqtrade arguments will be available by running docker-compose run --rm freqtrade <command> <optional arguments> . docker-compose for trade commands Trade commands ( freqtrade trade <...> ) should not be ran via docker-compose run - but should use docker-compose up -d instead. This makes sure that the container is properly started (including port forwardings) and will make sure that the container will restart after a system reboot. If you intend to use freqUI, please also ensure to adjust the configuration accordingly , otherwise the UI will not be available. docker-compose run --rm Including --rm will remove the container after completion, and is highly recommended for all modes except trading mode (running with freqtrade trade command). Using docker without docker-compose \" docker-compose run --rm \" will require a compose file to be provided. Some freqtrade commands that don't require authentication such as list-pairs can be run with \" docker run --rm \" instead. For example docker run --rm freqtradeorg/freqtrade:stable list-pairs --exchange binance --quote BTC --print-json . This can be useful for fetching exchange information to add to your config.json without affecting your running containers.","title":"Editing the docker-compose file"},{"location":"docker_quickstart/#example-download-data-with-docker-compose","text":"Download backtesting data for 5 days for the pair ETH/BTC and 1h timeframe from Binance. The data will be stored in the directory user_data/data/ on the host. docker-compose run --rm freqtrade download-data --pairs ETH/BTC --exchange binance --days 5 -t 1h Head over to the Data Downloading Documentation for more details on downloading data.","title":"Example: Download data with docker-compose"},{"location":"docker_quickstart/#example-backtest-with-docker-compose","text":"Run backtesting in docker-containers for SampleStrategy and specified timerange of historical data, on 5m timeframe: docker-compose run --rm freqtrade backtesting --config user_data/config.json --strategy SampleStrategy --timerange 20190801 -20191001 -i 5m Head over to the Backtesting Documentation to learn more.","title":"Example: Backtest with docker-compose"},{"location":"docker_quickstart/#additional-dependencies-with-docker-compose","text":"If your strategy requires dependencies not included in the default image - it will be necessary to build the image on your host. For this, please create a Dockerfile containing installation steps for the additional dependencies (have a look at docker/Dockerfile.custom for an example). You'll then also need to modify the docker-compose.yml file and uncomment the build step, as well as rename the image to avoid naming collisions. image : freqtrade_custom build : context : . dockerfile : \"./Dockerfile.<yourextension>\" You can then run docker-compose build --pull to build the docker image, and run it using the commands described above.","title":"Additional dependencies with docker-compose"},{"location":"docker_quickstart/#plotting-with-docker-compose","text":"Commands freqtrade plot-profit and freqtrade plot-dataframe ( Documentation ) are available by changing the image to *_plot in your docker-compose.yml file. You can then use these commands as follows: docker-compose run --rm freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange = 20180801 -20180805 The output will be stored in the user_data/plot directory, and can be opened with any modern browser.","title":"Plotting with docker-compose"},{"location":"docker_quickstart/#data-analysis-using-docker-compose","text":"Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: docker-compose -f docker/docker-compose-jupyter.yml up This will create a docker-container running jupyter lab, which will be accessible using https://127.0.0.1:8888/lab . Please use the link that's printed in the console after startup for simplified login. Since part of this image is built on your machine, it is recommended to rebuild the image from time to time to keep freqtrade (and dependencies) up-to-date. docker-compose -f docker/docker-compose-jupyter.yml build --no-cache","title":"Data analysis using docker compose"},{"location":"docker_quickstart/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"docker_quickstart/#docker-on-windows","text":"Error: \"Timestamp for this request is outside of the recvWindow.\" The market api requests require a synchronized clock but the time in the docker container shifts a bit over time into the past. To fix this issue temporarily you need to run wsl --shutdown and restart docker again (a popup on windows 10 will ask you to do so). A permanent solution is either to host the docker container on a linux host or restart the wsl from time to time with the scheduler. taskkill /IM \"Docker Desktop.exe\" /F wsl --shutdown start \"\" \"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\" Warning Due to the above, we do not recommend the usage of docker on windows for production setups, but only for experimentation, datadownload and backtesting. Best use a linux-VPS for running freqtrade reliably.","title":"Docker on Windows"},{"location":"edge/","text":"Edge positioning \u00b6 The Edge Positioning module uses probability to calculate your win rate and risk reward ratio. It will use these statistics to control your strategy trade entry points, position size and, stoploss. Warning When using Edge positioning with a dynamic whitelist (VolumePairList), make sure to also use AgeFilter and set it to at least calculate_since_number_of_days to avoid problems with missing data. Note Edge Positioning only considers its own buy/sell/stoploss signals. It ignores the stoploss, trailing stoploss, and ROI settings in the strategy configuration file. Edge Positioning improves the performance of some trading strategies and decreases the performance of others. Introduction \u00b6 Trading strategies are not perfect. They are frameworks that are susceptible to the market and its indicators. Because the market is not at all predictable, sometimes a strategy will win and sometimes the same strategy will lose. To obtain an edge in the market, a strategy has to make more money than it loses. Making money in trading is not only about how often the strategy makes or loses money. It doesn't matter how often, but how much! A bad strategy might make 1 penny in ten transactions but lose 1 dollar in one transaction. If one only checks the number of winning trades, it would be misleading to think that the strategy is actually making a profit. The Edge Positioning module seeks to improve a strategy's winning probability and the money that the strategy will make on the long run . We raise the following question 1 : Which trade is a better option? a) A trade with 80% of chance of losing 100$ and 20% chance of winning 200$ b) A trade with 100% of chance of losing 30$ Answer The expected value of a) is smaller than the expected value of b) . Hence, b ) represents a smaller loss in the long run. However, the answer is: it depends Another way to look at it is to ask a similar question: Which trade is a better option? a) A trade with 80% of chance of winning 100$ and 20% chance of losing 200$ b) A trade with 100% of chance of winning 30$ Edge positioning tries to answer the hard questions about risk/reward and position size automatically, seeking to minimizes the chances of losing of a given strategy. Trading, winning and losing \u00b6 Let's call \\(o\\) the return of a single transaction \\(o\\) where \\(o \\in \\mathbb{R}\\) . The collection \\(O = \\{o_1, o_2, ..., o_N\\}\\) is the set of all returns of transactions made during a trading session. We say that \\(N\\) is the cardinality of \\(O\\) , or, in lay terms, it is the number of transactions made in a trading session. Example In a session where a strategy made three transactions we can say that \\(O = \\{3.5, -1, 15\\}\\) . That means that \\(N = 3\\) and \\(o_1 = 3.5\\) , \\(o_2 = -1\\) , \\(o_3 = 15\\) . A winning trade is a trade where a strategy made money. Making money means that the strategy closed the position in a value that returned a profit, after all deducted fees. Formally, a winning trade will have a return \\(o_i > 0\\) . Similarly, a losing trade will have a return \\(o_j \\leq 0\\) . With that, we can discover the set of all winning trades, \\(T_{win}\\) , as follows: \\[ T_{win} = \\{ o \\in O | o > 0 \\} \\] Similarly, we can discover the set of losing trades \\(T_{lose}\\) as follows: \\[ T_{lose} = \\{o \\in O | o \\leq 0\\} \\] Example In a section where a strategy made four transactions \\(O = \\{3.5, -1, 15, 0\\}\\) : \\(T_{win} = \\{3.5, 15\\}\\) \\(T_{lose} = \\{-1, 0\\}\\) Win Rate and Lose Rate \u00b6 The win rate \\(W\\) is the proportion of winning trades with respect to all the trades made by a strategy. We use the following function to compute the win rate: \\[W = \\frac{|T_{win}|}{N}\\] Where \\(W\\) is the win rate, \\(N\\) is the number of trades and, \\(T_{win}\\) is the set of all trades where the strategy made money. Similarly, we can compute the rate of losing trades: \\[ L = \\frac{|T_{lose}|}{N} \\] Where \\(L\\) is the lose rate, \\(N\\) is the amount of trades made and, \\(T_{lose}\\) is the set of all trades where the strategy lost money. Note that the above formula is the same as calculating \\(L = 1 \u2013 W\\) or \\(W = 1 \u2013 L\\) Risk Reward Ratio \u00b6 Risk Reward Ratio ( \\(R\\) ) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose. Formally: \\[ R = \\frac{\\text{potential_profit}}{\\text{potential_loss}} \\] Worked example of \\(R\\) calculation Let's say that you think that the price of stonecoin today is 10.0$. You believe that, because they will start mining stonecoin, it will go up to 15.0$ tomorrow. There is the risk that the stone is too hard, and the GPUs can't mine it, so the price might go to 0$ tomorrow. You are planning to invest 100$, which will give you 10 shares (100 / 10). Your potential profit is calculated as: \\(\\begin{aligned} \\text{potential_profit} &= (\\text{potential_price} - \\text{entry_price}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (15 - 10) * (100 / 10) \\\\ &= 50 \\end{aligned}\\) Since the price might go to 0$, the 100$ dollars invested could turn into 0. We do however use a stoploss of 15% - so in the worst case, we'll sell 15% below entry price (or at 8.5$). \\(\\begin{aligned} \\text{potential_loss} &= (\\text{entry_price} - \\text{stoploss}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (10 - 8.5) * (100 / 10)\\\\ &= 15 \\end{aligned}\\) We can compute the Risk Reward Ratio as follows: \\(\\begin{aligned} R &= \\frac{\\text{potential_profit}}{\\text{potential_loss}}\\\\ &= \\frac{50}{15}\\\\ &= 3.33 \\end{aligned}\\) What it effectively means is that the strategy have the potential to make 3.33$ for each 1$ invested. On a long horizon, that is, on many trades, we can calculate the risk reward by dividing the strategy' average profit on winning trades by the strategy' average loss on losing trades. We can calculate the average profit, \\(\\mu_{win}\\) , as follows: \\[ \\text{average_profit} = \\mu_{win} = \\frac{\\text{sum_of_profits}}{\\text{count_winning_trades}} = \\frac{\\sum^{o \\in T_{win}} o}{|T_{win}|} \\] Similarly, we can calculate the average loss, \\(\\mu_{lose}\\) , as follows: \\[ \\text{average_loss} = \\mu_{lose} = \\frac{\\text{sum_of_losses}}{\\text{count_losing_trades}} = \\frac{\\sum^{o \\in T_{lose}} o}{|T_{lose}|} \\] Finally, we can calculate the Risk Reward ratio, \\(R\\) , as follows: \\[ R = \\frac{\\text{average_profit}}{\\text{average_loss}} = \\frac{\\mu_{win}}{\\mu_{lose}}\\\\ \\] Worked example of \\(R\\) calculation using mean profit/loss Let's say the strategy that we are using makes an average win \\(\\mu_{win} = 2.06\\) and an average loss \\(\\mu_{loss} = 4.11\\) . We calculate the risk reward ratio as follows: \\(R = \\frac{\\mu_{win}}{\\mu_{loss}} = \\frac{2.06}{4.11} = 0.5012...\\) Expectancy \u00b6 By combining the Win Rate \\(W\\) and and the Risk Reward ratio \\(R\\) to create an expectancy ratio \\(E\\) . A expectance ratio is the expected return of the investment made in a trade. We can compute the value of \\(E\\) as follows: \\[E = R * W - L\\] Calculating \\(E\\) Let's say that a strategy has a win rate \\(W = 0.28\\) and a risk reward ratio \\(R = 5\\) . What this means is that the strategy is expected to make 5 times the investment around on 28% of the trades it makes. Working out the example: \\(E = R * W - L = 5 * 0.28 - 0.72 = 0.68\\) The expectancy worked out in the example above means that, on average, this strategy' trades will return 1.68 times the size of its losses. Said another way, the strategy makes 1.68$ for every 1$ it loses, on average. This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ. It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future. You can also use this value to evaluate the effectiveness of modifications to this system. Note It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades. How does it work? \u00b6 Edge combines dynamic stoploss, dynamic positions, and whitelist generation into one isolated module which is then applied to the trading strategy. If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example: Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at \\(3%\\) leads to the maximum expectancy according to historical data. Edge module then forces stoploss value it evaluated to your strategy dynamically. Position size \u00b6 Edge dictates the amount at stake for each trade to the bot according to the following factors: Allowed capital at risk Stoploss Allowed capital at risk is calculated as follows: Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade) Stoploss is calculated as described above with respect to historical data. The position size is calculated as follows: Position size = (Allowed capital at risk) / Stoploss Example: Let's say the stake currency is ETH and there is \\(10\\) ETH on the wallet. The capital available percentage is \\(50%\\) and the allowed risk per trade is \\(1\\%\\) . Thus, the available capital for trading is \\(10 * 0.5 = 5\\) ETH and the allowed capital at risk would be \\(5 * 0.01 = 0.05\\) ETH . Trade 1: The strategy detects a new buy signal in the XLM/ETH market. Edge Positioning calculates a stoploss of \\(2\\%\\) and a position of \\(0.05 / 0.02 = 2.5\\) ETH . The bot takes a position of \\(2.5\\) ETH in the XLM/ETH market. Trade 2: The strategy detects a buy signal on the BTC/ETH market while Trade 1 is still open. Edge Positioning calculates the stoploss of \\(4\\%\\) on this market. Thus, Trade 2 position size is \\(0.05 / 0.04 = 1.25\\) ETH . Available Capital \\(\\neq\\) Available in wallet The available capital for trading didn't change in Trade 2 even with Trade 1 still open. The available capital is not the free amount in the wallet. Trade 3: The strategy detects a buy signal in the ADA/ETH market. Edge Positioning calculates a stoploss of \\(1\\%\\) and a position of \\(0.05 / 0.01 = 5\\) ETH . Since Trade 1 has \\(2.5\\) ETH blocked and Trade 2 has \\(1.25\\) ETH blocked, there is only \\(5 - 1.25 - 2.5 = 1.25\\) ETH available. Hence, the position size of Trade 3 is \\(1.25\\) ETH . Available Capital Updates The available capital does not change before a position is sold. After a trade is closed the Available Capital goes up if the trade was profitable or goes down if the trade was a loss. The strategy detects a sell signal in the XLM/ETH market. The bot exits Trade 1 for a profit of \\(1\\) ETH . The total capital in the wallet becomes \\(11\\) ETH and the available capital for trading becomes \\(5.5\\) ETH . Trade 4 The strategy detects a new buy signal int the XLM/ETH market. Edge Positioning calculates the stoploss of \\(2\\%\\) , and the position size of \\(0.055 / 0.02 = 2.75\\) ETH . Edge command reference \u00b6 usage: freqtrade edge [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--stoplosses STOPLOSS_RANGE] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `None`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --stoplosses STOPLOSS_RANGE Defines a range of stoploss values against which edge will assess the strategy. The format is \"min,max,step\" (without any space). Example: `--stoplosses=-0.01,-0.1,-0.001` Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. Configurations \u00b6 Edge module has following configuration options: Parameter Description enabled If true, then Edge will run periodically. Defaults to false . Datatype: Boolean process_throttle_secs How often should Edge run in seconds. Defaults to 3600 (once per hour). Datatype: Integer calculate_since_number_of_days Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy. Note that it downloads historical data so increasing this number would lead to slowing down the bot. Defaults to 7 . Datatype: Integer allowed_risk Ratio of allowed risk per trade. Defaults to 0.01 (1%)). Datatype: Float stoploss_range_min Minimum stoploss. Defaults to -0.01 . Datatype: Float stoploss_range_max Maximum stoploss. Defaults to -0.10 . Datatype: Float stoploss_range_step As an example if this is set to -0.01 then Edge will test the strategy for [-0.01, -0,02, -0,03 ..., -0.09, -0.10] ranges. Note than having a smaller step means having a bigger range which could lead to slow calculation. If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10. Defaults to -0.001 . Datatype: Float minimum_winrate It filters out pairs which don't have at least minimum_winrate. This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio. Defaults to 0.60 . Datatype: Float minimum_expectancy It filters out pairs which have the expectancy lower than this number. Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return. Defaults to 0.20 . Datatype: Float min_trade_number When calculating W , R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable. Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something. Defaults to 10 (it is highly recommended not to decrease this number). Datatype: Integer max_trade_duration_minute Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign. NOTICE: While configuring this value, you should take into consideration your timeframe. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.). Defaults to 1440 (one day). Datatype: Integer remove_pumps Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off. Defaults to false . Datatype: Boolean Running Edge independently \u00b6 You can run Edge independently in order to see in details the result. Here is an example: freqtrade edge An example of its output: pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59 Edge produced the above table by comparing calculate_since_number_of_days to minimum_expectancy to find min_trade_number historical information based on the config file. The timerange Edge uses for its comparisons can be further limited by using the --timerange switch. In live and dry-run modes, after the process_throttle_secs has passed, Edge will again process calculate_since_number_of_days against minimum_expectancy to find min_trade_number . If no min_trade_number is found, the bot will return \"whitelist empty\". Depending on the trade strategy being deployed, \"whitelist empty\" may be return much of the time - or all of the time. The use of Edge may also cause trading to occur in bursts, though this is rare. If you encounter \"whitelist empty\" a lot, condsider tuning calculate_since_number_of_days , minimum_expectancy and min_trade_number to align to the trading frequency of your strategy. Update cached pairs with the latest data \u00b6 Edge requires historic data the same way as backtesting does. Please refer to the Data Downloading section of the documentation for details. Precising stoploss range \u00b6 freqtrade edge --stoplosses = -0.01,-0.1,-0.001 #min,max,step Advanced use of timerange \u00b6 freqtrade edge --timerange = 20181110 -20181113 Doing --timerange=-20190901 will get all available data until September 1 st (excluding September 1 st 2019). The full timerange specification: Use tickframes till 2018/01/31: --timerange=-20180131 Use tickframes since 2018/01/31: --timerange=20180131- Use tickframes since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use tickframes between POSIX timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Question extracted from MIT Opencourseware S096 - Mathematics with applications in Finance: https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/ \u21a9","title":"Edge Positioning"},{"location":"edge/#edge-positioning","text":"The Edge Positioning module uses probability to calculate your win rate and risk reward ratio. It will use these statistics to control your strategy trade entry points, position size and, stoploss. Warning When using Edge positioning with a dynamic whitelist (VolumePairList), make sure to also use AgeFilter and set it to at least calculate_since_number_of_days to avoid problems with missing data. Note Edge Positioning only considers its own buy/sell/stoploss signals. It ignores the stoploss, trailing stoploss, and ROI settings in the strategy configuration file. Edge Positioning improves the performance of some trading strategies and decreases the performance of others.","title":"Edge positioning"},{"location":"edge/#introduction","text":"Trading strategies are not perfect. They are frameworks that are susceptible to the market and its indicators. Because the market is not at all predictable, sometimes a strategy will win and sometimes the same strategy will lose. To obtain an edge in the market, a strategy has to make more money than it loses. Making money in trading is not only about how often the strategy makes or loses money. It doesn't matter how often, but how much! A bad strategy might make 1 penny in ten transactions but lose 1 dollar in one transaction. If one only checks the number of winning trades, it would be misleading to think that the strategy is actually making a profit. The Edge Positioning module seeks to improve a strategy's winning probability and the money that the strategy will make on the long run . We raise the following question 1 : Which trade is a better option? a) A trade with 80% of chance of losing 100$ and 20% chance of winning 200$ b) A trade with 100% of chance of losing 30$ Answer The expected value of a) is smaller than the expected value of b) . Hence, b ) represents a smaller loss in the long run. However, the answer is: it depends Another way to look at it is to ask a similar question: Which trade is a better option? a) A trade with 80% of chance of winning 100$ and 20% chance of losing 200$ b) A trade with 100% of chance of winning 30$ Edge positioning tries to answer the hard questions about risk/reward and position size automatically, seeking to minimizes the chances of losing of a given strategy.","title":"Introduction"},{"location":"edge/#trading-winning-and-losing","text":"Let's call \\(o\\) the return of a single transaction \\(o\\) where \\(o \\in \\mathbb{R}\\) . The collection \\(O = \\{o_1, o_2, ..., o_N\\}\\) is the set of all returns of transactions made during a trading session. We say that \\(N\\) is the cardinality of \\(O\\) , or, in lay terms, it is the number of transactions made in a trading session. Example In a session where a strategy made three transactions we can say that \\(O = \\{3.5, -1, 15\\}\\) . That means that \\(N = 3\\) and \\(o_1 = 3.5\\) , \\(o_2 = -1\\) , \\(o_3 = 15\\) . A winning trade is a trade where a strategy made money. Making money means that the strategy closed the position in a value that returned a profit, after all deducted fees. Formally, a winning trade will have a return \\(o_i > 0\\) . Similarly, a losing trade will have a return \\(o_j \\leq 0\\) . With that, we can discover the set of all winning trades, \\(T_{win}\\) , as follows: \\[ T_{win} = \\{ o \\in O | o > 0 \\} \\] Similarly, we can discover the set of losing trades \\(T_{lose}\\) as follows: \\[ T_{lose} = \\{o \\in O | o \\leq 0\\} \\] Example In a section where a strategy made four transactions \\(O = \\{3.5, -1, 15, 0\\}\\) : \\(T_{win} = \\{3.5, 15\\}\\) \\(T_{lose} = \\{-1, 0\\}\\)","title":"Trading, winning and losing"},{"location":"edge/#win-rate-and-lose-rate","text":"The win rate \\(W\\) is the proportion of winning trades with respect to all the trades made by a strategy. We use the following function to compute the win rate: \\[W = \\frac{|T_{win}|}{N}\\] Where \\(W\\) is the win rate, \\(N\\) is the number of trades and, \\(T_{win}\\) is the set of all trades where the strategy made money. Similarly, we can compute the rate of losing trades: \\[ L = \\frac{|T_{lose}|}{N} \\] Where \\(L\\) is the lose rate, \\(N\\) is the amount of trades made and, \\(T_{lose}\\) is the set of all trades where the strategy lost money. Note that the above formula is the same as calculating \\(L = 1 \u2013 W\\) or \\(W = 1 \u2013 L\\)","title":"Win Rate and Lose Rate"},{"location":"edge/#risk-reward-ratio","text":"Risk Reward Ratio ( \\(R\\) ) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose. Formally: \\[ R = \\frac{\\text{potential_profit}}{\\text{potential_loss}} \\] Worked example of \\(R\\) calculation Let's say that you think that the price of stonecoin today is 10.0$. You believe that, because they will start mining stonecoin, it will go up to 15.0$ tomorrow. There is the risk that the stone is too hard, and the GPUs can't mine it, so the price might go to 0$ tomorrow. You are planning to invest 100$, which will give you 10 shares (100 / 10). Your potential profit is calculated as: \\(\\begin{aligned} \\text{potential_profit} &= (\\text{potential_price} - \\text{entry_price}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (15 - 10) * (100 / 10) \\\\ &= 50 \\end{aligned}\\) Since the price might go to 0$, the 100$ dollars invested could turn into 0. We do however use a stoploss of 15% - so in the worst case, we'll sell 15% below entry price (or at 8.5$). \\(\\begin{aligned} \\text{potential_loss} &= (\\text{entry_price} - \\text{stoploss}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\ &= (10 - 8.5) * (100 / 10)\\\\ &= 15 \\end{aligned}\\) We can compute the Risk Reward Ratio as follows: \\(\\begin{aligned} R &= \\frac{\\text{potential_profit}}{\\text{potential_loss}}\\\\ &= \\frac{50}{15}\\\\ &= 3.33 \\end{aligned}\\) What it effectively means is that the strategy have the potential to make 3.33$ for each 1$ invested. On a long horizon, that is, on many trades, we can calculate the risk reward by dividing the strategy' average profit on winning trades by the strategy' average loss on losing trades. We can calculate the average profit, \\(\\mu_{win}\\) , as follows: \\[ \\text{average_profit} = \\mu_{win} = \\frac{\\text{sum_of_profits}}{\\text{count_winning_trades}} = \\frac{\\sum^{o \\in T_{win}} o}{|T_{win}|} \\] Similarly, we can calculate the average loss, \\(\\mu_{lose}\\) , as follows: \\[ \\text{average_loss} = \\mu_{lose} = \\frac{\\text{sum_of_losses}}{\\text{count_losing_trades}} = \\frac{\\sum^{o \\in T_{lose}} o}{|T_{lose}|} \\] Finally, we can calculate the Risk Reward ratio, \\(R\\) , as follows: \\[ R = \\frac{\\text{average_profit}}{\\text{average_loss}} = \\frac{\\mu_{win}}{\\mu_{lose}}\\\\ \\] Worked example of \\(R\\) calculation using mean profit/loss Let's say the strategy that we are using makes an average win \\(\\mu_{win} = 2.06\\) and an average loss \\(\\mu_{loss} = 4.11\\) . We calculate the risk reward ratio as follows: \\(R = \\frac{\\mu_{win}}{\\mu_{loss}} = \\frac{2.06}{4.11} = 0.5012...\\)","title":"Risk Reward Ratio"},{"location":"edge/#expectancy","text":"By combining the Win Rate \\(W\\) and and the Risk Reward ratio \\(R\\) to create an expectancy ratio \\(E\\) . A expectance ratio is the expected return of the investment made in a trade. We can compute the value of \\(E\\) as follows: \\[E = R * W - L\\] Calculating \\(E\\) Let's say that a strategy has a win rate \\(W = 0.28\\) and a risk reward ratio \\(R = 5\\) . What this means is that the strategy is expected to make 5 times the investment around on 28% of the trades it makes. Working out the example: \\(E = R * W - L = 5 * 0.28 - 0.72 = 0.68\\) The expectancy worked out in the example above means that, on average, this strategy' trades will return 1.68 times the size of its losses. Said another way, the strategy makes 1.68$ for every 1$ it loses, on average. This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ. It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future. You can also use this value to evaluate the effectiveness of modifications to this system. Note It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades.","title":"Expectancy"},{"location":"edge/#how-does-it-work","text":"Edge combines dynamic stoploss, dynamic positions, and whitelist generation into one isolated module which is then applied to the trading strategy. If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example: Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at \\(3%\\) leads to the maximum expectancy according to historical data. Edge module then forces stoploss value it evaluated to your strategy dynamically.","title":"How does it work?"},{"location":"edge/#position-size","text":"Edge dictates the amount at stake for each trade to the bot according to the following factors: Allowed capital at risk Stoploss Allowed capital at risk is calculated as follows: Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade) Stoploss is calculated as described above with respect to historical data. The position size is calculated as follows: Position size = (Allowed capital at risk) / Stoploss Example: Let's say the stake currency is ETH and there is \\(10\\) ETH on the wallet. The capital available percentage is \\(50%\\) and the allowed risk per trade is \\(1\\%\\) . Thus, the available capital for trading is \\(10 * 0.5 = 5\\) ETH and the allowed capital at risk would be \\(5 * 0.01 = 0.05\\) ETH . Trade 1: The strategy detects a new buy signal in the XLM/ETH market. Edge Positioning calculates a stoploss of \\(2\\%\\) and a position of \\(0.05 / 0.02 = 2.5\\) ETH . The bot takes a position of \\(2.5\\) ETH in the XLM/ETH market. Trade 2: The strategy detects a buy signal on the BTC/ETH market while Trade 1 is still open. Edge Positioning calculates the stoploss of \\(4\\%\\) on this market. Thus, Trade 2 position size is \\(0.05 / 0.04 = 1.25\\) ETH . Available Capital \\(\\neq\\) Available in wallet The available capital for trading didn't change in Trade 2 even with Trade 1 still open. The available capital is not the free amount in the wallet. Trade 3: The strategy detects a buy signal in the ADA/ETH market. Edge Positioning calculates a stoploss of \\(1\\%\\) and a position of \\(0.05 / 0.01 = 5\\) ETH . Since Trade 1 has \\(2.5\\) ETH blocked and Trade 2 has \\(1.25\\) ETH blocked, there is only \\(5 - 1.25 - 2.5 = 1.25\\) ETH available. Hence, the position size of Trade 3 is \\(1.25\\) ETH . Available Capital Updates The available capital does not change before a position is sold. After a trade is closed the Available Capital goes up if the trade was profitable or goes down if the trade was a loss. The strategy detects a sell signal in the XLM/ETH market. The bot exits Trade 1 for a profit of \\(1\\) ETH . The total capital in the wallet becomes \\(11\\) ETH and the available capital for trading becomes \\(5.5\\) ETH . Trade 4 The strategy detects a new buy signal int the XLM/ETH market. Edge Positioning calculates the stoploss of \\(2\\%\\) , and the position size of \\(0.055 / 0.02 = 2.75\\) ETH .","title":"Position size"},{"location":"edge/#edge-command-reference","text":"usage: freqtrade edge [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--stoplosses STOPLOSS_RANGE] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `None`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --stoplosses STOPLOSS_RANGE Defines a range of stoploss values against which edge will assess the strategy. The format is \"min,max,step\" (without any space). Example: `--stoplosses=-0.01,-0.1,-0.001` Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path.","title":"Edge command reference"},{"location":"edge/#configurations","text":"Edge module has following configuration options: Parameter Description enabled If true, then Edge will run periodically. Defaults to false . Datatype: Boolean process_throttle_secs How often should Edge run in seconds. Defaults to 3600 (once per hour). Datatype: Integer calculate_since_number_of_days Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy. Note that it downloads historical data so increasing this number would lead to slowing down the bot. Defaults to 7 . Datatype: Integer allowed_risk Ratio of allowed risk per trade. Defaults to 0.01 (1%)). Datatype: Float stoploss_range_min Minimum stoploss. Defaults to -0.01 . Datatype: Float stoploss_range_max Maximum stoploss. Defaults to -0.10 . Datatype: Float stoploss_range_step As an example if this is set to -0.01 then Edge will test the strategy for [-0.01, -0,02, -0,03 ..., -0.09, -0.10] ranges. Note than having a smaller step means having a bigger range which could lead to slow calculation. If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10. Defaults to -0.001 . Datatype: Float minimum_winrate It filters out pairs which don't have at least minimum_winrate. This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio. Defaults to 0.60 . Datatype: Float minimum_expectancy It filters out pairs which have the expectancy lower than this number. Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return. Defaults to 0.20 . Datatype: Float min_trade_number When calculating W , R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable. Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something. Defaults to 10 (it is highly recommended not to decrease this number). Datatype: Integer max_trade_duration_minute Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign. NOTICE: While configuring this value, you should take into consideration your timeframe. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.). Defaults to 1440 (one day). Datatype: Integer remove_pumps Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off. Defaults to false . Datatype: Boolean","title":"Configurations"},{"location":"edge/#running-edge-independently","text":"You can run Edge independently in order to see in details the result. Here is an example: freqtrade edge An example of its output: pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59 Edge produced the above table by comparing calculate_since_number_of_days to minimum_expectancy to find min_trade_number historical information based on the config file. The timerange Edge uses for its comparisons can be further limited by using the --timerange switch. In live and dry-run modes, after the process_throttle_secs has passed, Edge will again process calculate_since_number_of_days against minimum_expectancy to find min_trade_number . If no min_trade_number is found, the bot will return \"whitelist empty\". Depending on the trade strategy being deployed, \"whitelist empty\" may be return much of the time - or all of the time. The use of Edge may also cause trading to occur in bursts, though this is rare. If you encounter \"whitelist empty\" a lot, condsider tuning calculate_since_number_of_days , minimum_expectancy and min_trade_number to align to the trading frequency of your strategy.","title":"Running Edge independently"},{"location":"edge/#update-cached-pairs-with-the-latest-data","text":"Edge requires historic data the same way as backtesting does. Please refer to the Data Downloading section of the documentation for details.","title":"Update cached pairs with the latest data"},{"location":"edge/#precising-stoploss-range","text":"freqtrade edge --stoplosses = -0.01,-0.1,-0.001 #min,max,step","title":"Precising stoploss range"},{"location":"edge/#advanced-use-of-timerange","text":"freqtrade edge --timerange = 20181110 -20181113 Doing --timerange=-20190901 will get all available data until September 1 st (excluding September 1 st 2019). The full timerange specification: Use tickframes till 2018/01/31: --timerange=-20180131 Use tickframes since 2018/01/31: --timerange=20180131- Use tickframes since 2018/01/31 till 2018/03/01 : --timerange=20180131-20180301 Use tickframes between POSIX timestamps 1527595200 1527618600: --timerange=1527595200-1527618600 Question extracted from MIT Opencourseware S096 - Mathematics with applications in Finance: https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/ \u21a9","title":"Advanced use of timerange"},{"location":"exchanges/","text":"Exchange-specific Notes \u00b6 This page combines common gotchas and Information which are exchange-specific and most likely don't apply to other exchanges. Exchange configuration \u00b6 Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage . However, the bot was tested by the development team with only a few exchanges. A current list of these can be found in the \"Home\" section of this documentation. Feel free to test other exchanges and submit your feedback or PR to improve the bot or confirm exchanges that work flawlessly.. Some exchanges require special configuration, which can be found below. Sample exchange configuration \u00b6 A exchange configuration for \"binance\" would look as follows: \"exchange\" : { \"name\" : \"binance\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"ccxt_config\" : {}, \"ccxt_async_config\" : {}, // ... Setting rate limits \u00b6 Usually, rate limits set by CCXT are reliable and work well. In case of problems related to rate-limits (usually DDOS Exceptions in your logs), it's easy to change rateLimit settings to other values. \"exchange\" : { \"name\" : \"kraken\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"ccxt_config\" : { \"enableRateLimit\" : true }, \"ccxt_async_config\" : { \"enableRateLimit\" : true , \"rateLimit\" : 3100 }, This configuration enables kraken, as well as rate-limiting to avoid bans from the exchange. \"rateLimit\": 3100 defines a wait-event of 3.1s between each call. This can also be completely disabled by setting \"enableRateLimit\" to false. Note Optimal settings for rate-limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that \"enableRateLimit\" is enabled and increase the \"rateLimit\" parameter step by step. Binance \u00b6 Binance supports time_in_force . Stoploss on Exchange Binance supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Binance Blacklist \u00b6 For Binance, please add \"BNB/<STAKE>\" to your blacklist to avoid issues. Accounts having BNB accounts use this to pay for fees - if your first trade happens to be on BNB , further trades will consume this position and make the initial BNB trade unsellable as the expected amount is not there anymore. Binance Futures \u00b6 Binance has specific (unfortunately complex) Futures Trading Quantitative Rules which need to be followed, and which prohibit a too low stake-amount (among others) for too many orders. Violating these rules will result in a trading restriction. When trading on Binance Futures market, orderbook must be used because there is no price ticker data for futures. \"entry_pricing\": { \"use_order_book\": true, \"order_book_top\": 1, \"check_depth_of_market\": { \"enabled\": false, \"bids_to_ask_delta\": 1 } }, \"exit_pricing\": { \"use_order_book\": true, \"order_book_top\": 1 }, Binance sites \u00b6 Binance has been split into 2, and users must use the correct ccxt exchange ID for their exchange, otherwise API keys are not recognized. binance.com - International users. Use exchange id: binance . binance.us - US based users. Use exchange id: binanceus . Kraken \u00b6 Stoploss on Exchange Kraken supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type to use. Historic Kraken data \u00b6 The Kraken API does only provide 720 historic candles, which is sufficient for Freqtrade dry-run and live trade modes, but is a problem for backtesting. To download data for the Kraken exchange, using --dl-trades is mandatory, otherwise the bot will download the same 720 candles over and over, and you'll not have enough backtest data. Due to the heavy rate-limiting applied by Kraken, the following configuration section should be used to download data: \"ccxt_async_config\" : { \"enableRateLimit\" : true , \"rateLimit\" : 3100 }, Downloading data from kraken Downloading kraken data will require significantly more memory (RAM) than any other exchange, as the trades-data needs to be converted into candles on your machine. It will also take a long time, as freqtrade will need to download every single trade that happened on the exchange for the pair / timerange combination, therefore please be patient. rateLimit tuning Please pay attention that rateLimit configuration entry holds delay in milliseconds between requests, NOT requests\\sec rate. So, in order to mitigate Kraken API \"Rate limit exceeded\" exception, this configuration should be increased, NOT decreased. Bittrex \u00b6 Order types \u00b6 Bittrex does not support market orders. If you have a message at the bot startup about this, you should change order type values set in your configuration and/or in the strategy from \"market\" to \"limit\" . See some more details on this here in the FAQ . Bittrex also does not support VolumePairlist due to limited / split API constellation at the moment. Please use StaticPairlist . Other pairlists (other than VolumePairlist ) should not be affected. Volume pairlist \u00b6 Bittrex does not support the direct usage of VolumePairList. This can however be worked around by using the advanced mode with lookback_days: 1 (or more), which will emulate 24h volume. Read more in the pairlist documentation . Restricted markets \u00b6 Bittrex split its exchange into US and International versions. The International version has more pairs available, however the API always returns all pairs, so there is currently no automated way to detect if you're affected by the restriction. If you have restricted pairs in your whitelist, you'll get a warning message in the log on Freqtrade startup for each restricted pair. The warning message will look similar to the following: [...] Message: bittrex {\"success\":false,\"message\":\"RESTRICTED_MARKET\",\"result\":null,\"explanation\":null}\" If you're an \"International\" customer on the Bittrex exchange, then this warning will probably not impact you. If you're a US customer, the bot will fail to create orders for these pairs, and you should remove them from your whitelist. You can get a list of restricted markets by using the following snippet: import ccxt ct = ccxt . bittrex () lm = ct . load_markets () res = [ p for p , x in lm . items () if 'US' in x [ 'info' ][ 'prohibitedIn' ]] print ( res ) FTX \u00b6 Stoploss on Exchange FTX supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used. Using subaccounts \u00b6 To use subaccounts with FTX, you need to edit the configuration and add the following: \"exchange\" : { \"ccxt_config\" : { \"headers\" : { \"FTX-SUBACCOUNT\" : \"name\" } }, } Kucoin \u00b6 Kucoin requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: \"exchange\" : { \"name\" : \"kucoin\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"password\" : \"your_exchange_api_key_password\" , // ... } Kucoin supports time_in_force . Stoploss on Exchange Kucoin supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used. Kucoin Blacklists \u00b6 For Kucoin, please add \"KCS/<STAKE>\" to your blacklist to avoid issues. Accounts having KCS accounts use this to pay for fees - if your first trade happens to be on KCS , further trades will consume this position and make the initial KCS trade unsellable as the expected amount is not there anymore. Huobi \u00b6 Stoploss on Exchange Huobi supports stoploss_on_exchange and uses stop-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange. OKX (former OKEX) \u00b6 OKX requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: \"exchange\" : { \"name\" : \"okx\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"password\" : \"your_exchange_api_key_password\" , // ... } Warning OKX only provides 100 candles per api call. Therefore, the strategy will only have a pretty low amount of data available in backtesting mode. Futures OKX Futures has the concept of \"position mode\" - which can be Net or long/short (hedge mode). Freqtrade supports both modes - but changing the mode mid-trading is not supported and will lead to exceptions and failures to place trades. OKX also only provides MARK candles for the past ~3 months. Backtesting futures prior to that date will therefore lead to slight deviations, as funding-fees cannot be calculated correctly without this data. Gate.io \u00b6 Stoploss on Exchange Gate.io supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Gate.io allows the use of POINT to pay for fees. As this is not a tradable currency (no regular market available), automatic fee calculations will fail (and default to a fee of 0). The configuration parameter exchange.unknown_fee_rate can be used to specify the exchange rate between Point and the stake currency. Obviously, changing the stake-currency will also require changes to this value. All exchanges \u00b6 Should you experience constant errors with Nonce (like InvalidNonce ), it is best to regenerate the API keys. Resetting Nonce is difficult and it's usually easier to regenerate the API keys. Random notes for other exchanges \u00b6 The Ocean (exchange id: theocean ) exchange uses Web3 functionality and requires web3 python package to be installed: $ pip3 install web3 Getting latest price / Incomplete candles \u00b6 Most exchanges return current incomplete candle via their OHLCV/klines API interface. By default, Freqtrade assumes that incomplete candle is fetched from the exchange and removes the last candle assuming it's the incomplete candle. Whether your exchange returns incomplete candles or not can be checked using the helper script from the Contributor documentation. Due to the danger of repainting, Freqtrade does not allow you to use this incomplete candle. However, if it is based on the need for the latest price for your strategy - then this requirement can be acquired using the data provider from within the strategy. Advanced Freqtrade Exchange configuration \u00b6 Advanced options can be configured using the _ft_has_params setting, which will override Defaults and exchange-specific behavior. Available options are listed in the exchange-class as _ft_has_default . For example, to test the order type FOK with Kraken, and modify candle limit to 200 (so you only get 200 candles per API call): \"exchange\" : { \"name\" : \"kraken\" , \"_ft_has_params\" : { \"order_time_in_force\" : [ \"gtc\" , \"fok\" ], \"ohlcv_candle_limit\" : 200 } //... } Warning Please make sure to fully understand the impacts of these settings before modifying them.","title":"Exchange-specific Notes"},{"location":"exchanges/#exchange-specific-notes","text":"This page combines common gotchas and Information which are exchange-specific and most likely don't apply to other exchanges.","title":"Exchange-specific Notes"},{"location":"exchanges/#exchange-configuration","text":"Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage . However, the bot was tested by the development team with only a few exchanges. A current list of these can be found in the \"Home\" section of this documentation. Feel free to test other exchanges and submit your feedback or PR to improve the bot or confirm exchanges that work flawlessly.. Some exchanges require special configuration, which can be found below.","title":"Exchange configuration"},{"location":"exchanges/#sample-exchange-configuration","text":"A exchange configuration for \"binance\" would look as follows: \"exchange\" : { \"name\" : \"binance\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"ccxt_config\" : {}, \"ccxt_async_config\" : {}, // ...","title":"Sample exchange configuration"},{"location":"exchanges/#setting-rate-limits","text":"Usually, rate limits set by CCXT are reliable and work well. In case of problems related to rate-limits (usually DDOS Exceptions in your logs), it's easy to change rateLimit settings to other values. \"exchange\" : { \"name\" : \"kraken\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"ccxt_config\" : { \"enableRateLimit\" : true }, \"ccxt_async_config\" : { \"enableRateLimit\" : true , \"rateLimit\" : 3100 }, This configuration enables kraken, as well as rate-limiting to avoid bans from the exchange. \"rateLimit\": 3100 defines a wait-event of 3.1s between each call. This can also be completely disabled by setting \"enableRateLimit\" to false. Note Optimal settings for rate-limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that \"enableRateLimit\" is enabled and increase the \"rateLimit\" parameter step by step.","title":"Setting rate limits"},{"location":"exchanges/#binance","text":"Binance supports time_in_force . Stoploss on Exchange Binance supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange..","title":"Binance"},{"location":"exchanges/#binance-blacklist","text":"For Binance, please add \"BNB/<STAKE>\" to your blacklist to avoid issues. Accounts having BNB accounts use this to pay for fees - if your first trade happens to be on BNB , further trades will consume this position and make the initial BNB trade unsellable as the expected amount is not there anymore.","title":"Binance Blacklist"},{"location":"exchanges/#binance-futures","text":"Binance has specific (unfortunately complex) Futures Trading Quantitative Rules which need to be followed, and which prohibit a too low stake-amount (among others) for too many orders. Violating these rules will result in a trading restriction. When trading on Binance Futures market, orderbook must be used because there is no price ticker data for futures. \"entry_pricing\": { \"use_order_book\": true, \"order_book_top\": 1, \"check_depth_of_market\": { \"enabled\": false, \"bids_to_ask_delta\": 1 } }, \"exit_pricing\": { \"use_order_book\": true, \"order_book_top\": 1 },","title":"Binance Futures"},{"location":"exchanges/#binance-sites","text":"Binance has been split into 2, and users must use the correct ccxt exchange ID for their exchange, otherwise API keys are not recognized. binance.com - International users. Use exchange id: binance . binance.us - US based users. Use exchange id: binanceus .","title":"Binance sites"},{"location":"exchanges/#kraken","text":"Stoploss on Exchange Kraken supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type to use.","title":"Kraken"},{"location":"exchanges/#historic-kraken-data","text":"The Kraken API does only provide 720 historic candles, which is sufficient for Freqtrade dry-run and live trade modes, but is a problem for backtesting. To download data for the Kraken exchange, using --dl-trades is mandatory, otherwise the bot will download the same 720 candles over and over, and you'll not have enough backtest data. Due to the heavy rate-limiting applied by Kraken, the following configuration section should be used to download data: \"ccxt_async_config\" : { \"enableRateLimit\" : true , \"rateLimit\" : 3100 }, Downloading data from kraken Downloading kraken data will require significantly more memory (RAM) than any other exchange, as the trades-data needs to be converted into candles on your machine. It will also take a long time, as freqtrade will need to download every single trade that happened on the exchange for the pair / timerange combination, therefore please be patient. rateLimit tuning Please pay attention that rateLimit configuration entry holds delay in milliseconds between requests, NOT requests\\sec rate. So, in order to mitigate Kraken API \"Rate limit exceeded\" exception, this configuration should be increased, NOT decreased.","title":"Historic Kraken data"},{"location":"exchanges/#bittrex","text":"","title":"Bittrex"},{"location":"exchanges/#order-types","text":"Bittrex does not support market orders. If you have a message at the bot startup about this, you should change order type values set in your configuration and/or in the strategy from \"market\" to \"limit\" . See some more details on this here in the FAQ . Bittrex also does not support VolumePairlist due to limited / split API constellation at the moment. Please use StaticPairlist . Other pairlists (other than VolumePairlist ) should not be affected.","title":"Order types"},{"location":"exchanges/#volume-pairlist","text":"Bittrex does not support the direct usage of VolumePairList. This can however be worked around by using the advanced mode with lookback_days: 1 (or more), which will emulate 24h volume. Read more in the pairlist documentation .","title":"Volume pairlist"},{"location":"exchanges/#restricted-markets","text":"Bittrex split its exchange into US and International versions. The International version has more pairs available, however the API always returns all pairs, so there is currently no automated way to detect if you're affected by the restriction. If you have restricted pairs in your whitelist, you'll get a warning message in the log on Freqtrade startup for each restricted pair. The warning message will look similar to the following: [...] Message: bittrex {\"success\":false,\"message\":\"RESTRICTED_MARKET\",\"result\":null,\"explanation\":null}\" If you're an \"International\" customer on the Bittrex exchange, then this warning will probably not impact you. If you're a US customer, the bot will fail to create orders for these pairs, and you should remove them from your whitelist. You can get a list of restricted markets by using the following snippet: import ccxt ct = ccxt . bittrex () lm = ct . load_markets () res = [ p for p , x in lm . items () if 'US' in x [ 'info' ][ 'prohibitedIn' ]] print ( res )","title":"Restricted markets"},{"location":"exchanges/#ftx","text":"Stoploss on Exchange FTX supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used.","title":"FTX"},{"location":"exchanges/#using-subaccounts","text":"To use subaccounts with FTX, you need to edit the configuration and add the following: \"exchange\" : { \"ccxt_config\" : { \"headers\" : { \"FTX-SUBACCOUNT\" : \"name\" } }, }","title":"Using subaccounts"},{"location":"exchanges/#kucoin","text":"Kucoin requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: \"exchange\" : { \"name\" : \"kucoin\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"password\" : \"your_exchange_api_key_password\" , // ... } Kucoin supports time_in_force . Stoploss on Exchange Kucoin supports stoploss_on_exchange and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either \"limit\" or \"market\" in the order_types.stoploss configuration setting to decide which type of stoploss shall be used.","title":"Kucoin"},{"location":"exchanges/#kucoin-blacklists","text":"For Kucoin, please add \"KCS/<STAKE>\" to your blacklist to avoid issues. Accounts having KCS accounts use this to pay for fees - if your first trade happens to be on KCS , further trades will consume this position and make the initial KCS trade unsellable as the expected amount is not there anymore.","title":"Kucoin Blacklists"},{"location":"exchanges/#huobi","text":"Stoploss on Exchange Huobi supports stoploss_on_exchange and uses stop-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.","title":"Huobi"},{"location":"exchanges/#okx-former-okex","text":"OKX requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows: \"exchange\" : { \"name\" : \"okx\" , \"key\" : \"your_exchange_key\" , \"secret\" : \"your_exchange_secret\" , \"password\" : \"your_exchange_api_key_password\" , // ... } Warning OKX only provides 100 candles per api call. Therefore, the strategy will only have a pretty low amount of data available in backtesting mode. Futures OKX Futures has the concept of \"position mode\" - which can be Net or long/short (hedge mode). Freqtrade supports both modes - but changing the mode mid-trading is not supported and will lead to exceptions and failures to place trades. OKX also only provides MARK candles for the past ~3 months. Backtesting futures prior to that date will therefore lead to slight deviations, as funding-fees cannot be calculated correctly without this data.","title":"OKX (former OKEX)"},{"location":"exchanges/#gateio","text":"Stoploss on Exchange Gate.io supports stoploss_on_exchange and uses stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.. Gate.io allows the use of POINT to pay for fees. As this is not a tradable currency (no regular market available), automatic fee calculations will fail (and default to a fee of 0). The configuration parameter exchange.unknown_fee_rate can be used to specify the exchange rate between Point and the stake currency. Obviously, changing the stake-currency will also require changes to this value.","title":"Gate.io"},{"location":"exchanges/#all-exchanges","text":"Should you experience constant errors with Nonce (like InvalidNonce ), it is best to regenerate the API keys. Resetting Nonce is difficult and it's usually easier to regenerate the API keys.","title":"All exchanges"},{"location":"exchanges/#random-notes-for-other-exchanges","text":"The Ocean (exchange id: theocean ) exchange uses Web3 functionality and requires web3 python package to be installed: $ pip3 install web3","title":"Random notes for other exchanges"},{"location":"exchanges/#getting-latest-price-incomplete-candles","text":"Most exchanges return current incomplete candle via their OHLCV/klines API interface. By default, Freqtrade assumes that incomplete candle is fetched from the exchange and removes the last candle assuming it's the incomplete candle. Whether your exchange returns incomplete candles or not can be checked using the helper script from the Contributor documentation. Due to the danger of repainting, Freqtrade does not allow you to use this incomplete candle. However, if it is based on the need for the latest price for your strategy - then this requirement can be acquired using the data provider from within the strategy.","title":"Getting latest price / Incomplete candles"},{"location":"exchanges/#advanced-freqtrade-exchange-configuration","text":"Advanced options can be configured using the _ft_has_params setting, which will override Defaults and exchange-specific behavior. Available options are listed in the exchange-class as _ft_has_default . For example, to test the order type FOK with Kraken, and modify candle limit to 200 (so you only get 200 candles per API call): \"exchange\" : { \"name\" : \"kraken\" , \"_ft_has_params\" : { \"order_time_in_force\" : [ \"gtc\" , \"fok\" ], \"ohlcv_candle_limit\" : 200 } //... } Warning Please make sure to fully understand the impacts of these settings before modifying them.","title":"Advanced Freqtrade Exchange configuration"},{"location":"faq/","text":"Freqtrade FAQ \u00b6 Supported Markets \u00b6 Freqtrade supports spot trading only. Can I open short positions? \u00b6 Freqtrade can open short positions in futures markets. This requires the strategy to be made for this - and \"trading_mode\": \"futures\" in the configuration. Please make sure to read the relevant documentation page first. In spot markets, you can in some cases use leveraged spot tokens, which reflect an inverted pair (eg. BTCUP/USD, BTCDOWN/USD, ETHBULL/USD, ETHBEAR/USD,...) which can be traded with Freqtrade. Can I trade options or futures? \u00b6 Futures trading is supported for selected exchanges. Beginner Tips & Tricks \u00b6 When you work with your strategy & hyperopt file you should use a proper code editor like VSCode or PyCharm. A good code editor will provide syntax highlighting as well as line numbers, making it easy to find syntax errors (most likely pointed out by Freqtrade during startup). Freqtrade common issues \u00b6 The bot does not start \u00b6 Running the bot with freqtrade trade --config config.json shows the output freqtrade: command not found . This could be caused by the following reasons: The virtual environment is not active. Run source .env/bin/activate to activate the virtual environment. The installation did not work correctly. Please check the Installation documentation . I have waited 5 minutes, why hasn't the bot made any trades yet? \u00b6 Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find a good entry position for a trade. Be patient! It may be because of a configuration error. It's best to check the logs, they usually tell you if the bot is simply not getting buy signals (only heartbeat messages), or if there is something wrong (errors / exceptions in the log). I have made 12 trades already, why is my total profit negative? \u00b6 I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that the current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades. I\u2019d like to make changes to the config. Can I do that without having to kill the bot? \u00b6 Yes. You can edit your config and use the /reload_config command to reload the configuration. The bot will stop, reload the configuration and strategy and will restart with the new configuration and strategy. Why does my bot not sell everything it bought? \u00b6 This is called \"coin dust\" and can happen on all exchanges. It happens because many exchanges subtract fees from the \"receiving currency\" - so you buy 100 COIN - but you only get 99.9 COIN. As COIN is trading in full lot sizes (1COIN steps), you cannot sell 0.9 COIN (or 99.9 COIN) - but you need to round down to 99 COIN. This is not a bot-problem, but will also happen while manual trading. While freqtrade can handle this (it'll sell 99 COIN), fees are often below the minimum tradable lot-size (you can only trade full COIN, not 0.9 COIN). Leaving the dust (0.9 COIN) on the exchange makes usually sense, as the next time freqtrade buys COIN, it'll eat into the remaining small balance, this time selling everything it bought, and therefore slowly declining the dust balance (although it most likely will never reach exactly 0). Where possible (e.g. on binance), the use of the exchange's dedicated fee currency will fix this. On binance, it's sufficient to have BNB in your account, and have \"Pay fees in BNB\" enabled in your profile. Your BNB balance will slowly decline (as it's used to pay fees) - but you'll no longer encounter dust (Freqtrade will include the fees in the profit calculations). Other exchanges don't offer such possibilities, where it's simply something you'll have to accept or move to a different exchange. I want to use incomplete candles \u00b6 Freqtrade will not provide incomplete candles to strategies. Using incomplete candles will lead to repainting and consequently to strategies with \"ghost\" buys, which are impossible to both backtest, and verify after they happened. You can use \"current\" market data by using the dataprovider 's orderbook or ticker methods - which however cannot be used during backtesting. Is there a setting to only Exit the trades being held and not perform any new Entries? \u00b6 You can use the /stopentry command in Telegram to prevent future trade entry, followed by /forceexit all (sell all open trades). I want to run multiple bots on the same machine \u00b6 Please look at the advanced setup documentation Page . I'm getting \"Missing data fillup\" messages in the log \u00b6 This message is just a warning that the latest candles had missing candles in them. Depending on the exchange, this can indicate that the pair didn't have a trade for the timeframe you are using - and the exchange does only return candles with volume. On low volume pairs, this is a rather common occurrence. If this happens for all pairs in the pairlist, this might indicate a recent exchange downtime. Please check your exchange's public channels for details. Irrespectively of the reason, Freqtrade will fill up these candles with \"empty\" candles, where open, high, low and close are set to the previous candle close - and volume is empty. In a chart, this will look like a _ - and is aligned with how exchanges usually represent 0 volume candles. I'm getting \"Outdated history for pair xxx\" in the log \u00b6 The bot is trying to tell you that it got an outdated last candle (not the last complete candle). As a consequence, Freqtrade will not enter a trade for this pair - as trading on old information is usually not what is desired. This warning can point to one of the below problems: Exchange downtime -> Check your exchange status page / blog / twitter feed for details. Wrong system time -> Ensure your system-time is correct. Barely traded pair -> Check the pair on the exchange webpage, look at the timeframe your strategy uses. If the pair does not have any volume in some candles (usually visualized with a \"volume 0\" bar, and a \"_\" as candle), this pair did not have any trades in this timeframe. These pairs should ideally be avoided, as they can cause problems with order-filling. API problem -> API returns wrong data (this only here for completeness, and should not happen with supported exchanges). I'm getting the \"RESTRICTED_MARKET\" message in the log \u00b6 Currently known to happen for US Bittrex users. Read the Bittrex section about restricted markets for more information. I'm getting the \"Exchange XXX does not support market orders.\" message and cannot run my strategy \u00b6 As the message says, your exchange does not support market orders and you have one of the order types set to \"market\". Your strategy was probably written with other exchanges in mind and sets \"market\" orders for \"stoploss\" orders, which is correct and preferable for most of the exchanges supporting market orders (but not for Bittrex and Gate.io). To fix this, redefine order types in the strategy to use \"limit\" instead of \"market\": order_types = { ... \"stoploss\" : \"limit\" , ... } The same fix should be applied in the configuration file, if order types are defined in your custom config rather than in the strategy. How do I search the bot logs for something? \u00b6 By default, the bot writes its log into stderr stream. This is implemented this way so that you can easily separate the bot's diagnostics messages from Backtesting, Edge and Hyperopt results, output from other various Freqtrade utility sub-commands, as well as from the output of your custom print() 's you may have inserted into your strategy. So if you need to search the log messages with the grep utility, you need to redirect stderr to stdout and disregard stdout. In unix shells, this normally can be done as simple as: $ freqtrade --some-options 2 > & 1 >/dev/null | grep 'something' (note, 2>&1 and >/dev/null should be written in this order) Bash interpreter also supports so called process substitution syntax, you can grep the log for a string with it as: $ freqtrade --some-options 2 > > ( grep 'something' ) >/dev/null or $ freqtrade --some-options 2 > > ( grep -v 'something' 1 > & 2 ) You can also write the copy of Freqtrade log messages to a file with the --logfile option: $ freqtrade --logfile /path/to/mylogfile.log --some-options and then grep it as: $ cat /path/to/mylogfile.log | grep 'something' or even on the fly, as the bot works and the log file grows: $ tail -f /path/to/mylogfile.log | grep 'something' from a separate terminal window. On Windows, the --logfile option is also supported by Freqtrade and you can use the findstr command to search the log for the string of interest: > type \\path\\to\\mylogfile.log | findstr \"something\" Hyperopt module \u00b6 Why does freqtrade not have GPU support? \u00b6 First of all, most indicator libraries don't have GPU support - as such, there would be little benefit for indicator calculations. The GPU improvements would only apply to pandas-native calculations - or ones written by yourself. For hyperopt, freqtrade is using scikit-optimize, which is built on top of scikit-learn. Their statement about GPU support is pretty clear . GPU's also are only good at crunching numbers (floating point operations). For hyperopt, we need both number-crunching (find next parameters) and running python code (running backtesting). As such, GPU's are not too well suited for most parts of hyperopt. The benefit of using GPU would therefore be pretty slim - and will not justify the complexity introduced by trying to add GPU support. There is however nothing preventing you from using GPU-enabled indicators within your strategy if you think you must have this - you will however probably be disappointed by the slim gain that will give you (compared to the complexity). How many epochs do I need to get a good Hyperopt result? \u00b6 Per default Hyperopt called without the -e / --epochs command line option will only run 100 epochs, means 100 evaluations of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10000 or more. But it will take an eternity to compute. Since hyperopt uses Bayesian search, running for too many epochs may not produce greater results. It's therefore recommended to run between 500-1000 epochs over and over until you hit at least 10000 epochs in total (or are satisfied with the result). You can best judge by looking at the results - if the bot keeps discovering better strategies, it's best to keep on going. freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy SampleStrategy -e 1000 Why does it take a long time to run hyperopt? \u00b6 Discovering a great strategy with Hyperopt takes time. Study www.freqtrade.io , the Freqtrade Documentation page, join the Freqtrade discord community . While you patiently wait for the most advanced, free crypto bot in the world, to hand you a possible golden strategy specially designed just for you. If you wonder why it can take from 20 minutes to days to do 1000 epochs here are some answers: This answer was written during the release 0.15.1, when we had: 8 triggers 9 guards: let's say we evaluate even 10 values from each 1 stoploss calculation: let's say we want 10 values from that too to be evaluated The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evaluations. Did you run 100 000 evaluations? Congrats, you've done roughly 1 / 100 000 th of the search space, assuming that the bot never tests the same parameters more than once. The time it takes to run 1000 hyperopt epochs depends on things like: The available cpu, hard-disk, ram, timeframe, timerange, indicator settings, indicator count, amount of coins that hyperopt test strategies on and the resulting trade count - which can be 650 trades in a year or 100000 trades depending if the strategy aims for big profits by trading rarely or for many low profit trades. Example: 4% profit 650 times vs 0,3% profit a trade 10000 times in a year. If we assume you set the --timerange to 365 days. Example: freqtrade --config config.json --strategy SampleStrategy --hyperopt SampleHyperopt -e 1000 --timerange 20190601-20200601 Edge module \u00b6 Edge implements interesting approach for controlling position size, is there any theory behind it? \u00b6 The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members. You can find further info on expectancy, win rate, risk management and position size in the following sources: https://www.tradeciety.com/ultimate-math-guide-for-traders/ http://www.vantharp.com/tharp-concepts/expectancy.asp https://samuraitradingacademy.com/trading-expectancy/ https://www.learningmarkets.com/determining-expectancy-in-your-trading/ http://www.lonestocktrader.com/make-money-trading-positive-expectancy/ https://www.babypips.com/trading/trade-expectancy-matter","title":"FAQ"},{"location":"faq/#freqtrade-faq","text":"","title":"Freqtrade FAQ"},{"location":"faq/#supported-markets","text":"Freqtrade supports spot trading only.","title":"Supported Markets"},{"location":"faq/#can-i-open-short-positions","text":"Freqtrade can open short positions in futures markets. This requires the strategy to be made for this - and \"trading_mode\": \"futures\" in the configuration. Please make sure to read the relevant documentation page first. In spot markets, you can in some cases use leveraged spot tokens, which reflect an inverted pair (eg. BTCUP/USD, BTCDOWN/USD, ETHBULL/USD, ETHBEAR/USD,...) which can be traded with Freqtrade.","title":"Can I open short positions?"},{"location":"faq/#can-i-trade-options-or-futures","text":"Futures trading is supported for selected exchanges.","title":"Can I trade options or futures?"},{"location":"faq/#beginner-tips-tricks","text":"When you work with your strategy & hyperopt file you should use a proper code editor like VSCode or PyCharm. A good code editor will provide syntax highlighting as well as line numbers, making it easy to find syntax errors (most likely pointed out by Freqtrade during startup).","title":"Beginner Tips &amp; Tricks"},{"location":"faq/#freqtrade-common-issues","text":"","title":"Freqtrade common issues"},{"location":"faq/#the-bot-does-not-start","text":"Running the bot with freqtrade trade --config config.json shows the output freqtrade: command not found . This could be caused by the following reasons: The virtual environment is not active. Run source .env/bin/activate to activate the virtual environment. The installation did not work correctly. Please check the Installation documentation .","title":"The bot does not start"},{"location":"faq/#i-have-waited-5-minutes-why-hasnt-the-bot-made-any-trades-yet","text":"Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find a good entry position for a trade. Be patient! It may be because of a configuration error. It's best to check the logs, they usually tell you if the bot is simply not getting buy signals (only heartbeat messages), or if there is something wrong (errors / exceptions in the log).","title":"I have waited 5 minutes, why hasn't the bot made any trades yet?"},{"location":"faq/#i-have-made-12-trades-already-why-is-my-total-profit-negative","text":"I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that the current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades.","title":"I have made 12 trades already, why is my total profit negative?"},{"location":"faq/#id-like-to-make-changes-to-the-config-can-i-do-that-without-having-to-kill-the-bot","text":"Yes. You can edit your config and use the /reload_config command to reload the configuration. The bot will stop, reload the configuration and strategy and will restart with the new configuration and strategy.","title":"I\u2019d like to make changes to the config. Can I do that without having to kill the bot?"},{"location":"faq/#why-does-my-bot-not-sell-everything-it-bought","text":"This is called \"coin dust\" and can happen on all exchanges. It happens because many exchanges subtract fees from the \"receiving currency\" - so you buy 100 COIN - but you only get 99.9 COIN. As COIN is trading in full lot sizes (1COIN steps), you cannot sell 0.9 COIN (or 99.9 COIN) - but you need to round down to 99 COIN. This is not a bot-problem, but will also happen while manual trading. While freqtrade can handle this (it'll sell 99 COIN), fees are often below the minimum tradable lot-size (you can only trade full COIN, not 0.9 COIN). Leaving the dust (0.9 COIN) on the exchange makes usually sense, as the next time freqtrade buys COIN, it'll eat into the remaining small balance, this time selling everything it bought, and therefore slowly declining the dust balance (although it most likely will never reach exactly 0). Where possible (e.g. on binance), the use of the exchange's dedicated fee currency will fix this. On binance, it's sufficient to have BNB in your account, and have \"Pay fees in BNB\" enabled in your profile. Your BNB balance will slowly decline (as it's used to pay fees) - but you'll no longer encounter dust (Freqtrade will include the fees in the profit calculations). Other exchanges don't offer such possibilities, where it's simply something you'll have to accept or move to a different exchange.","title":"Why does my bot not sell everything it bought?"},{"location":"faq/#i-want-to-use-incomplete-candles","text":"Freqtrade will not provide incomplete candles to strategies. Using incomplete candles will lead to repainting and consequently to strategies with \"ghost\" buys, which are impossible to both backtest, and verify after they happened. You can use \"current\" market data by using the dataprovider 's orderbook or ticker methods - which however cannot be used during backtesting.","title":"I want to use incomplete candles"},{"location":"faq/#is-there-a-setting-to-only-exit-the-trades-being-held-and-not-perform-any-new-entries","text":"You can use the /stopentry command in Telegram to prevent future trade entry, followed by /forceexit all (sell all open trades).","title":"Is there a setting to only Exit the trades being held and not perform any new Entries?"},{"location":"faq/#i-want-to-run-multiple-bots-on-the-same-machine","text":"Please look at the advanced setup documentation Page .","title":"I want to run multiple bots on the same machine"},{"location":"faq/#im-getting-missing-data-fillup-messages-in-the-log","text":"This message is just a warning that the latest candles had missing candles in them. Depending on the exchange, this can indicate that the pair didn't have a trade for the timeframe you are using - and the exchange does only return candles with volume. On low volume pairs, this is a rather common occurrence. If this happens for all pairs in the pairlist, this might indicate a recent exchange downtime. Please check your exchange's public channels for details. Irrespectively of the reason, Freqtrade will fill up these candles with \"empty\" candles, where open, high, low and close are set to the previous candle close - and volume is empty. In a chart, this will look like a _ - and is aligned with how exchanges usually represent 0 volume candles.","title":"I'm getting \"Missing data fillup\" messages in the log"},{"location":"faq/#im-getting-outdated-history-for-pair-xxx-in-the-log","text":"The bot is trying to tell you that it got an outdated last candle (not the last complete candle). As a consequence, Freqtrade will not enter a trade for this pair - as trading on old information is usually not what is desired. This warning can point to one of the below problems: Exchange downtime -> Check your exchange status page / blog / twitter feed for details. Wrong system time -> Ensure your system-time is correct. Barely traded pair -> Check the pair on the exchange webpage, look at the timeframe your strategy uses. If the pair does not have any volume in some candles (usually visualized with a \"volume 0\" bar, and a \"_\" as candle), this pair did not have any trades in this timeframe. These pairs should ideally be avoided, as they can cause problems with order-filling. API problem -> API returns wrong data (this only here for completeness, and should not happen with supported exchanges).","title":"I'm getting \"Outdated history for pair xxx\" in the log"},{"location":"faq/#im-getting-the-restricted_market-message-in-the-log","text":"Currently known to happen for US Bittrex users. Read the Bittrex section about restricted markets for more information.","title":"I'm getting the \"RESTRICTED_MARKET\" message in the log"},{"location":"faq/#im-getting-the-exchange-xxx-does-not-support-market-orders-message-and-cannot-run-my-strategy","text":"As the message says, your exchange does not support market orders and you have one of the order types set to \"market\". Your strategy was probably written with other exchanges in mind and sets \"market\" orders for \"stoploss\" orders, which is correct and preferable for most of the exchanges supporting market orders (but not for Bittrex and Gate.io). To fix this, redefine order types in the strategy to use \"limit\" instead of \"market\": order_types = { ... \"stoploss\" : \"limit\" , ... } The same fix should be applied in the configuration file, if order types are defined in your custom config rather than in the strategy.","title":"I'm getting the \"Exchange XXX does not support market orders.\" message and cannot run my strategy"},{"location":"faq/#how-do-i-search-the-bot-logs-for-something","text":"By default, the bot writes its log into stderr stream. This is implemented this way so that you can easily separate the bot's diagnostics messages from Backtesting, Edge and Hyperopt results, output from other various Freqtrade utility sub-commands, as well as from the output of your custom print() 's you may have inserted into your strategy. So if you need to search the log messages with the grep utility, you need to redirect stderr to stdout and disregard stdout. In unix shells, this normally can be done as simple as: $ freqtrade --some-options 2 > & 1 >/dev/null | grep 'something' (note, 2>&1 and >/dev/null should be written in this order) Bash interpreter also supports so called process substitution syntax, you can grep the log for a string with it as: $ freqtrade --some-options 2 > > ( grep 'something' ) >/dev/null or $ freqtrade --some-options 2 > > ( grep -v 'something' 1 > & 2 ) You can also write the copy of Freqtrade log messages to a file with the --logfile option: $ freqtrade --logfile /path/to/mylogfile.log --some-options and then grep it as: $ cat /path/to/mylogfile.log | grep 'something' or even on the fly, as the bot works and the log file grows: $ tail -f /path/to/mylogfile.log | grep 'something' from a separate terminal window. On Windows, the --logfile option is also supported by Freqtrade and you can use the findstr command to search the log for the string of interest: > type \\path\\to\\mylogfile.log | findstr \"something\"","title":"How do I search the bot logs for something?"},{"location":"faq/#hyperopt-module","text":"","title":"Hyperopt module"},{"location":"faq/#why-does-freqtrade-not-have-gpu-support","text":"First of all, most indicator libraries don't have GPU support - as such, there would be little benefit for indicator calculations. The GPU improvements would only apply to pandas-native calculations - or ones written by yourself. For hyperopt, freqtrade is using scikit-optimize, which is built on top of scikit-learn. Their statement about GPU support is pretty clear . GPU's also are only good at crunching numbers (floating point operations). For hyperopt, we need both number-crunching (find next parameters) and running python code (running backtesting). As such, GPU's are not too well suited for most parts of hyperopt. The benefit of using GPU would therefore be pretty slim - and will not justify the complexity introduced by trying to add GPU support. There is however nothing preventing you from using GPU-enabled indicators within your strategy if you think you must have this - you will however probably be disappointed by the slim gain that will give you (compared to the complexity).","title":"Why does freqtrade not have GPU support?"},{"location":"faq/#how-many-epochs-do-i-need-to-get-a-good-hyperopt-result","text":"Per default Hyperopt called without the -e / --epochs command line option will only run 100 epochs, means 100 evaluations of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10000 or more. But it will take an eternity to compute. Since hyperopt uses Bayesian search, running for too many epochs may not produce greater results. It's therefore recommended to run between 500-1000 epochs over and over until you hit at least 10000 epochs in total (or are satisfied with the result). You can best judge by looking at the results - if the bot keeps discovering better strategies, it's best to keep on going. freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy SampleStrategy -e 1000","title":"How many epochs do I need to get a good Hyperopt result?"},{"location":"faq/#why-does-it-take-a-long-time-to-run-hyperopt","text":"Discovering a great strategy with Hyperopt takes time. Study www.freqtrade.io , the Freqtrade Documentation page, join the Freqtrade discord community . While you patiently wait for the most advanced, free crypto bot in the world, to hand you a possible golden strategy specially designed just for you. If you wonder why it can take from 20 minutes to days to do 1000 epochs here are some answers: This answer was written during the release 0.15.1, when we had: 8 triggers 9 guards: let's say we evaluate even 10 values from each 1 stoploss calculation: let's say we want 10 values from that too to be evaluated The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evaluations. Did you run 100 000 evaluations? Congrats, you've done roughly 1 / 100 000 th of the search space, assuming that the bot never tests the same parameters more than once. The time it takes to run 1000 hyperopt epochs depends on things like: The available cpu, hard-disk, ram, timeframe, timerange, indicator settings, indicator count, amount of coins that hyperopt test strategies on and the resulting trade count - which can be 650 trades in a year or 100000 trades depending if the strategy aims for big profits by trading rarely or for many low profit trades. Example: 4% profit 650 times vs 0,3% profit a trade 10000 times in a year. If we assume you set the --timerange to 365 days. Example: freqtrade --config config.json --strategy SampleStrategy --hyperopt SampleHyperopt -e 1000 --timerange 20190601-20200601","title":"Why does it take a long time to run hyperopt?"},{"location":"faq/#edge-module","text":"","title":"Edge module"},{"location":"faq/#edge-implements-interesting-approach-for-controlling-position-size-is-there-any-theory-behind-it","text":"The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members. You can find further info on expectancy, win rate, risk management and position size in the following sources: https://www.tradeciety.com/ultimate-math-guide-for-traders/ http://www.vantharp.com/tharp-concepts/expectancy.asp https://samuraitradingacademy.com/trading-expectancy/ https://www.learningmarkets.com/determining-expectancy-in-your-trading/ http://www.lonestocktrader.com/make-money-trading-positive-expectancy/ https://www.babypips.com/trading/trade-expectancy-matter","title":"Edge implements interesting approach for controlling position size, is there any theory behind it?"},{"location":"freqai/","text":"FreqAI \u00b6 FreqAI is a module designed to automate a variety of tasks associated with training a predictive machine learning model to generate market forecasts given a set of input features. Features include: Self-adaptive retraining : retrain models during live deployments to self-adapt to the market in an unsupervised manner. Rapid feature engineering : create large rich feature sets (10k+ features) based on simple user-created strategies. High performance : adaptive retraining occurs on a separate thread (or on GPU if available) from inferencing and bot trade operations. Newest models and data are kept in memory for rapid inferencing. Realistic backtesting : emulate self-adaptive retraining with a backtesting module that automates past retraining. Modifiability : use the generalized and robust architecture for incorporating any machine learning library/method available in Python. Eight examples are currently available, including classifiers, regressors, and a convolutional neural network. Smart outlier removal : remove outliers from training and prediction data sets using a variety of outlier detection techniques . Crash resilience : store model to disk to make reloading from a crash fast and easy, and purge obsolete files for sustained dry/live runs. Automatic data normalization : normalize the data in a smart and statistically safe way. Automatic data download : compute the data download timerange and update historic data (in live deployments). Cleaning of incoming data : handle NaNs safely before training and prediction. Dimensionality reduction : reduce the size of the training data via Principal Component Analysis . Deploying bot fleets : set one bot to train models while a fleet of follower bots inference the models and handle trades. Quick start \u00b6 The easiest way to quickly test FreqAI is to run it in dry mode with the following command freqtrade trade --config config_examples/config_freqai.example.json --strategy FreqaiExampleStrategy --freqaimodel LightGBMRegressor --strategy-path freqtrade/templates The user will see the boot-up process of automatic data downloading, followed by simultaneous training and trading. The example strategy, example prediction model, and example config can be found in freqtrade/templates/FreqaiExampleStrategy.py , freqtrade/freqai/prediction_models/LightGBMRegressor.py , and config_examples/config_freqai.example.json , respectively. General approach \u00b6 The user provides FreqAI with a set of custom base indicators (the same way as in a typical Freqtrade strategy) as well as target values ( labels ). FreqAI trains a model to predict the target values based on the input of custom indicators, for each pair in the whitelist. These models are consistently retrained to adapt to market conditions. FreqAI offers the ability to both backtest strategies (emulating reality with periodic retraining) and deploy dry/live runs. In dry/live conditions, FreqAI can be set to constant retraining in a background thread in an effort to keep models as up to date as possible. An overview of the algorithm is shown below, explaining the data processing pipeline and the model usage. Important machine learning vocabulary \u00b6 Features - the quantities with which a model is trained. All features for a single candle is stored as a vector. In FreqAI, the user builds the feature sets from anything they can construct in the strategy. Labels - the target values that a model is trained toward. Each set of features is associated with a single label that is defined by the user within the strategy. These labels intentionally look into the future, and are not available to the model during dry/live/backtesting. Training - the process of feeding individual feature sets, composed of historic data, with associated labels into the model with the goal of matching input feature sets to associated labels. Train data - a subset of the historic data that is fed to the model during training. This data directly influences weight connections in the model. Test data - a subset of the historic data that is used to evaluate the performance of the model after training. This data does not influence nodal weights within the model. Install prerequisites \u00b6 The normal Freqtrade install process will ask the user if they wish to install FreqAI dependencies. The user should reply \"yes\" to this question if they wish to use FreqAI. If the user did not reply yes, they can manually install these dependencies after the install with: pip install -r requirements-freqai.txt Note Catboost will not be installed on arm devices (raspberry, Mac M1, ARM based VPS, ...), since Catboost does not provide wheels for this platform. Usage with docker \u00b6 For docker users, a dedicated tag with freqAI dependencies is available as :freqai . As such - you can replace the image line in your docker-compose file with image: freqtradeorg/freqtrade:develop_freqai . This image contains the regular freqAI dependencies. Similar to native installs, Catboost will not be available on ARM based devices. Setting up FreqAI \u00b6 Parameter table \u00b6 The table below will list all configuration parameters available for FreqAI, presented in the same order as config_examples/config_freqai.example.json . Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description General configuration parameters freqai Required. The parent dictionary containing all the parameters for controlling FreqAI. Datatype: Dictionary. startup_candles Number of candles needed for backtesting only to ensure all indicators are non NaNs at the start of the first train period. Datatype: Positive integer. purge_old_models Delete obsolete models (otherwise, all historic models will remain on disk). Datatype: Boolean. Default: False . train_period_days Required. Number of days to use for the training data (width of the sliding window). Datatype: Positive integer. backtest_period_days Required. Number of days to inference from the trained model before sliding the window defined above, and retraining the model. This can be fractional days, but beware that the user-provided timerange will be divided by this number to yield the number of trainings necessary to complete the backtest. Datatype: Float. identifier Required. A unique name for the current model. This can be reused to reload pre-trained models/data. Datatype: String. live_retrain_hours Frequency of retraining during dry/live runs. Default set to 0, which means the model will retrain as often as possible. Datatype: Float > 0. expiration_hours Avoid making predictions if a model is more than expiration_hours old. Defaults set to 0, which means models never expire. Datatype: Positive integer. fit_live_predictions_candles Number of historical candles to use for computing target (label) statistics from prediction data, instead of from the training data set. Datatype: Positive integer. follow_mode If true, this instance of FreqAI will look for models associated with identifier and load those for inferencing. A follower will not train new models. Datatype: Boolean. Default: False . Feature parameters feature_parameters A dictionary containing the parameters used to engineer the feature set. Details and examples are shown here . Datatype: Dictionary. include_timeframes A list of timeframes that all indicators in populate_any_indicators will be created for. The list is added as features to the base asset feature set. Datatype: List of timeframes (strings). include_corr_pairlist A list of correlated coins that FreqAI will add as additional features to all pair_whitelist coins. All indicators set in populate_any_indicators during feature engineering (see details here ) will be created for each coin in this list, and that set of features is added to the base asset feature set. Datatype: List of assets (strings). label_period_candles Number of candles into the future that the labels are created for. This is used in populate_any_indicators (see templates/FreqaiExampleStrategy.py for detailed usage). The user can create custom labels, making use of this parameter or not. Datatype: Positive integer. include_shifted_candles Add features from previous candles to subsequent candles to add historical information. FreqAI takes all features from the include_shifted_candles previous candles, duplicates and shifts them so that the information is available for the subsequent candle. Datatype: Positive integer. weight_factor Used to set weights for training data points according to their recency. See details about how it works here . Datatype: Positive float (typically < 1). indicator_max_period_candles The maximum period used in populate_any_indicators() for indicator creation. FreqAI uses this information in combination with the maximum timeframe to calculate how many data points that should be downloaded so that the first data point does not have a NaN. Datatype: Positive integer. indicator_periods_candles Calculate indicators for indicator_periods_candles time periods and add them to the feature set. Datatype: List of positive integers. stratify_training_data This value is used to indicate the grouping of the data. For example, 2 would set every 2 nd data point into a separate dataset to be pulled from during training/testing. See details about how it works here Datatype: Positive integer. principal_component_analysis Automatically reduce the dimensionality of the data set using Principal Component Analysis. See details about how it works here Datatype: Boolean. DI_threshold Activates the Dissimilarity Index for outlier detection when > 0. See details about how it works here . Datatype: Positive float (typically < 1). use_SVM_to_remove_outliers Train a support vector machine to detect and remove outliers from the training data set, as well as from incoming data points. See details about how it works here . Datatype: Boolean. svm_params All parameters available in Sklearn's SGDOneClassSVM() . See details about some select parameters here . Datatype: Dictionary. use_DBSCAN_to_remove_outliers Cluster data using DBSCAN to identify and remove outliers from training and prediction data. See details about how it works here . Datatype: Boolean. outlier_protection_percentage If more than outlier_protection_percentage fraction of points are removed as outliers, FreqAI will log a warning message and ignore outlier detection while keeping the original dataset intact. Datatype: float. Default: 30 Data split parameters data_split_parameters Include any additional parameters available from Scikit-learn test_train_split() , which are shown here (external website). Datatype: Dictionary. test_size Fraction of data that should be used for testing instead of training. Datatype: Positive float < 1. shuffle Shuffle the training data points during training. Typically, for time-series forecasting, this is set to False . Model training parameters model_training_parameters A flexible dictionary that includes all parameters available by the user selected model library. For example, if the user uses LightGBMRegressor , this dictionary can contain any parameter available by the LightGBMRegressor here (external website). If the user selects a different model, this dictionary can contain any parameter from that model. Datatype: Dictionary. Datatype: Boolean. n_estimators The number of boosted trees to fit in regression. Datatype: Integer. learning_rate Boosting learning rate during regression. Datatype: Float. n_jobs , thread_count , task_type Set the number of threads for parallel processing and the task_type ( gpu or cpu ). Different model libraries use different parameter names. Datatype: Float. Extraneous parameters keras If your model makes use of Keras (typical for Tensorflow-based prediction models), activate this flag so that the model save/loading follows Keras standards. Datatype: Boolean. Default: False . conv_width The width of a convolutional neural network input tensor. This replaces the need for shifting candles ( include_shifted_candles ) by feeding in historical data points as the second dimension of the tensor. Technically, this parameter can also be used for regressors, but it only adds computational overhead and does not change the model training/prediction. Datatype: Integer. Default: 2. Important dataframe key patterns \u00b6 Below are the values the user can expect to include/use inside a typical strategy dataframe ( df[] ): DataFrame Key Description df['&*'] Any dataframe column prepended with & in populate_any_indicators() is treated as a training target (label) inside FreqAI (typically following the naming convention &-s* ). The names of these dataframe columns are fed back to the user as the predictions. For example, if the user wishes to predict the price change in the next 40 candles (similar to templates/FreqaiExampleStrategy.py ), they set df['&-s_close'] . FreqAI makes the predictions and gives them back under the same key ( df['&-s_close'] ) to be used in populate_entry/exit_trend() . Datatype: Depends on the output of the model. df['&*_std/mean'] Standard deviation and mean values of the user-defined labels during training (or live tracking with fit_live_predictions_candles ). Commonly used to understand the rarity of a prediction (use the z-score as shown in templates/FreqaiExampleStrategy.py to evaluate how often a particular prediction was observed during training or historically with fit_live_predictions_candles ). Datatype: Float. df['do_predict'] Indication of an outlier data point. The return value is integer between -1 and 2, which lets the user know if the prediction is trustworthy or not. do_predict==1 means the prediction is trustworthy. If the Dissimilarity Index (DI, see details here ) of the input data point is above the user-defined threshold, FreqAI will subtract 1 from do_predict , resulting in do_predict==0 . If use_SVM_to_remove_outliers() is active, the Support Vector Machine (SVM) may also detect outliers in training and prediction data. In this case, the SVM will also subtract 1 from do_predict . If the input data point was considered an outlier by the SVM but not by the DI, the result will be do_predict==0 . If both the DI and the SVM considers the input data point to be an outlier, the result will be do_predict==-1 . A particular case is when do_predict == 2 , which means that the model has expired due to exceeding expired_hours . Datatype: Integer between -1 and 2. df['DI_values'] Dissimilarity Index values are proxies to the level of confidence FreqAI has in the prediction. A lower DI means the prediction is close to the training data, i.e., higher prediction confidence. Datatype: Float. df['%*'] Any dataframe column prepended with % in populate_any_indicators() is treated as a training feature. For example, the user can include the RSI in the training feature set (similar to in templates/FreqaiExampleStrategy.py ) by setting df['%-rsi'] . See more details on how this is done here . Note : Since the number of features prepended with % can multiply very quickly (10s of thousands of features is easily engineered using the multiplictative functionality described in the feature_parameters table shown above), these features are removed from the dataframe upon return from FreqAI. If the user wishes to keep a particular type of feature for plotting purposes, they can prepend it with %% . Datatype: Depends on the output of the model. File structure \u00b6 user_data_dir/models/ contains all the data associated with the trainings and backtests. This file structure is heavily controlled and inferenced by the FreqaiDataKitchen() and should therefore not be modified. Example config file \u00b6 The user interface is isolated to the typical Freqtrade config file. A FreqAI config should include: \"freqai\" : { \"enabled\" : true , \"startup_candles\" : 10000 , \"purge_old_models\" : true , \"train_period_days\" : 30 , \"backtest_period_days\" : 7 , \"identifier\" : \"unique-id\" , \"feature_parameters\" : { \"include_timeframes\" : [ \"5m\" , \"15m\" , \"4h\" ], \"include_corr_pairlist\" : [ \"ETH/USD\" , \"LINK/USD\" , \"BNB/USD\" ], \"label_period_candles\" : 24 , \"include_shifted_candles\" : 2 , \"indicator_max_period_candles\" : 20 , \"indicator_periods_candles\" : [ 10 , 20 ] }, \"data_split_parameters\" : { \"test_size\" : 0.25 }, \"model_training_parameters\" : { \"n_estimators\" : 100 }, } Building a FreqAI strategy \u00b6 The FreqAI strategy requires the user to include the following lines of code in the standard Freqtrade strategy: def informative_pairs ( self ): whitelist_pairs = self . dp . current_whitelist () corr_pairs = self . config [ \"freqai\" ][ \"feature_parameters\" ][ \"include_corr_pairlist\" ] informative_pairs = [] for tf in self . config [ \"freqai\" ][ \"feature_parameters\" ][ \"include_timeframes\" ]: for pair in whitelist_pairs : informative_pairs . append (( pair , tf )) for pair in corr_pairs : if pair in whitelist_pairs : continue # avoid duplication informative_pairs . append (( pair , tf )) return informative_pairs def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # the model will return all labels created by user in `populate_any_indicators` # (& appended targets), an indication of whether or not the prediction should be accepted, # the target mean/std values for each of the labels created by user in # `populate_any_indicators()` for each training period. dataframe = self . freqai . start ( dataframe , metadata , self ) return dataframe def populate_any_indicators ( self , pair , df , tf , informative = None , set_generalized_indicators = False ): \"\"\" Function designed to automatically generate, name and merge features from user indicated timeframes in the configuration file. User controls the indicators passed to the training/prediction by prepending indicators with `'%-' + coin ` (see convention below). I.e. user should not prepend any supporting metrics (e.g. bb_lowerband below) with % unless they explicitly want to pass that metric to the model. :param pair: pair to be used as informative :param df: strategy dataframe which will receive merges from informatives :param tf: timeframe of the dataframe which will modify the feature names :param informative: the dataframe associated with the informative pair :param coin: the name of the coin which will modify the feature names. \"\"\" coin = pair . split ( '/' )[ 0 ] if informative is None : informative = self . dp . get_pair_dataframe ( pair , tf ) # first loop is automatically duplicating indicators for time periods for t in self . freqai_info [ \"feature_parameters\" ][ \"indicator_periods_candles\" ]: t = int ( t ) informative [ f \"%- { coin } rsi-period_ { t } \" ] = ta . RSI ( informative , timeperiod = t ) informative [ f \"%- { coin } mfi-period_ { t } \" ] = ta . MFI ( informative , timeperiod = t ) informative [ f \"%- { coin } adx-period_ { t } \" ] = ta . ADX ( informative , window = t ) indicators = [ col for col in informative if col . startswith ( \"%\" )] # This loop duplicates and shifts all indicators to add a sense of recency to data for n in range ( self . freqai_info [ \"feature_parameters\" ][ \"include_shifted_candles\" ] + 1 ): if n == 0 : continue informative_shift = informative [ indicators ] . shift ( n ) informative_shift = informative_shift . add_suffix ( \"_shift-\" + str ( n )) informative = pd . concat (( informative , informative_shift ), axis = 1 ) df = merge_informative_pair ( df , informative , self . config [ \"timeframe\" ], tf , ffill = True ) skip_columns = [ ( s + \"_\" + tf ) for s in [ \"date\" , \"open\" , \"high\" , \"low\" , \"close\" , \"volume\" ] ] df = df . drop ( columns = skip_columns ) # Add generalized indicators here (because in live, it will call this # function to populate indicators during training). Notice how we ensure not to # add them multiple times if set_generalized_indicators : # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) return df Notice how the populate_any_indicators() is where the user adds their own features ( more information ) and labels ( more information ). See a full example at templates/FreqaiExampleStrategy.py . Creating a dynamic target \u00b6 The &*_std/mean return values describe the statistical fit of the user defined label during the most recent training . This value allows the user to know the rarity of a given prediction. For example, templates/FreqaiExampleStrategy.py , creates a target_roi which is based on filtering out predictions that are below a given z-score of 1.25. dataframe [ \"target_roi\" ] = dataframe [ \"&-s_close_mean\" ] + dataframe [ \"&-s_close_std\" ] * 1.25 dataframe [ \"sell_roi\" ] = dataframe [ \"&-s_close_mean\" ] - dataframe [ \"&-s_close_std\" ] * 1.25 If the user wishes to consider the population of historical predictions for creating the dynamic target instead of the trained labels, (as discussed above) the user can do so by setting fit_live_prediction_candles in the config to the number of historical prediction candles the user wishes to use to generate target statistics. \"freqai\" : { \"fit_live_prediction_candles\" : 300 , } If the user sets this value, FreqAI will initially use the predictions from the training data and subsequently begin introducing real prediction data as it is generated. FreqAI will save this historical data to be reloaded if the user stops and restarts a model with the same identifier . Building a custom prediction model \u00b6 FreqAI has multiple example prediction model libraries, such as Catboost regression ( freqai/prediction_models/CatboostRegressor.py ) and LightGBM regression. However, the user can customize and create their own prediction models using the IFreqaiModel class. The user is encouraged to inherit train() and predict() to let them customize various aspects of their training procedures. Feature engineering \u00b6 Features are added by the user inside the populate_any_indicators() method of the strategy by prepending indicators with % , and labels with & . There are some important components/structures that the user must include when building their feature set; the use of these is shown below: def populate_any_indicators ( self , pair , df , tf , informative = None , set_generalized_indicators = False ): \"\"\" Function designed to automatically generate, name, and merge features from user-indicated timeframes in the configuration file. The user controls the indicators passed to the training/prediction by prepending indicators with `'%-' + coin ` (see convention below). I.e., the user should not prepend any supporting metrics (e.g., bb_lowerband below) with % unless they explicitly want to pass that metric to the model. :param pair: pair to be used as informative :param df: strategy dataframe which will receive merges from informatives :param tf: timeframe of the dataframe which will modify the feature names :param informative: the dataframe associated with the informative pair :param coin: the name of the coin which will modify the feature names. \"\"\" coin = pair . split ( '/' )[ 0 ] if informative is None : informative = self . dp . get_pair_dataframe ( pair , tf ) # first loop is automatically duplicating indicators for time periods for t in self . freqai_info [ \"feature_parameters\" ][ \"indicator_periods_candles\" ]: t = int ( t ) informative [ f \"%- { coin } rsi-period_ { t } \" ] = ta . RSI ( informative , timeperiod = t ) informative [ f \"%- { coin } mfi-period_ { t } \" ] = ta . MFI ( informative , timeperiod = t ) informative [ f \"%- { coin } adx-period_ { t } \" ] = ta . ADX ( informative , window = t ) bollinger = qtpylib . bollinger_bands ( qtpylib . typical_price ( informative ), window = t , stds = 2.2 ) informative [ f \" { coin } bb_lowerband-period_ { t } \" ] = bollinger [ \"lower\" ] informative [ f \" { coin } bb_middleband-period_ { t } \" ] = bollinger [ \"mid\" ] informative [ f \" { coin } bb_upperband-period_ { t } \" ] = bollinger [ \"upper\" ] informative [ f \"%- { coin } bb_width-period_ { t } \" ] = ( informative [ f \" { coin } bb_upperband-period_ { t } \" ] - informative [ f \" { coin } bb_lowerband-period_ { t } \" ] ) / informative [ f \" { coin } bb_middleband-period_ { t } \" ] informative [ f \"%- { coin } close-bb_lower-period_ { t } \" ] = ( informative [ \"close\" ] / informative [ f \" { coin } bb_lowerband-period_ { t } \" ] ) informative [ f \"%- { coin } relative_volume-period_ { t } \" ] = ( informative [ \"volume\" ] / informative [ \"volume\" ] . rolling ( t ) . mean () ) indicators = [ col for col in informative if col . startswith ( \"%\" )] # This loop duplicates and shifts all indicators to add a sense of recency to data for n in range ( self . freqai_info [ \"feature_parameters\" ][ \"include_shifted_candles\" ] + 1 ): if n == 0 : continue informative_shift = informative [ indicators ] . shift ( n ) informative_shift = informative_shift . add_suffix ( \"_shift-\" + str ( n )) informative = pd . concat (( informative , informative_shift ), axis = 1 ) df = merge_informative_pair ( df , informative , self . config [ \"timeframe\" ], tf , ffill = True ) skip_columns = [ ( s + \"_\" + tf ) for s in [ \"date\" , \"open\" , \"high\" , \"low\" , \"close\" , \"volume\" ] ] df = df . drop ( columns = skip_columns ) # Add generalized indicators here (because in live, it will call this # function to populate indicators during training). Notice how we ensure not to # add them multiple times if set_generalized_indicators : df [ \" %-d ay_of_week\" ] = ( df [ \"date\" ] . dt . dayofweek + 1 ) / 7 df [ \" %-ho ur_of_day\" ] = ( df [ \"date\" ] . dt . hour + 1 ) / 25 # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) return df In the presented example strategy, the user does not wish to pass the bb_lowerband as a feature to the model, and has therefore not prepended it with % . The user does, however, wish to pass bb_width to the model for training/prediction and has therefore prepended it with % . The include_timeframes in the example config above are the timeframes ( tf ) of each call to populate_any_indicators() in the strategy. In the present case, the user is asking for the 5m , 15m , and 4h timeframes of the rsi , mfi , roc , and bb_width to be included in the feature set. The user can ask for each of the defined features to be included also from informative pairs using the include_corr_pairlist . This means that the feature set will include all the features from populate_any_indicators on all the include_timeframes for each of the correlated pairs defined in the config ( ETH/USD , LINK/USD , and BNB/USD ). include_shifted_candles indicates the number of previous candles to include in the feature set. For example, include_shifted_candles: 2 tells FreqAI to include the past 2 candles for each of the features in the feature set. In total, the number of features the user of the presented example strat has created is: length of include_timeframes * no. features in populate_any_indicators() * length of include_corr_pairlist * no. include_shifted_candles * length of indicator_periods_candles \\(= 3 * 3 * 3 * 2 * 2 = 108\\) . Another structure to consider is the location of the labels at the bottom of the example function (below if set_generalized_indicators: ). This is where the user will add single features and labels to their feature set to avoid duplication of them from various configuration parameters that multiply the feature set, such as include_timeframes . Note Features must be defined in populate_any_indicators() . Definining FreqAI features in populate_indicators() will cause the algorithm to fail in live/dry mode. If the user wishes to add generalized features that are not associated with a specific pair or timeframe, they should use the following structure inside populate_any_indicators() (as exemplified in freqtrade/templates/FreqaiExampleStrategy.py ): def populate_any_indicators ( self , metadata , pair , df , tf , informative = None , coin = \"\" , set_generalized_indicators = False ): ... # Add generalized indicators here (because in live, it will call only this function to populate # indicators for retraining). Notice how we ensure not to add them multiple times by associating # these generalized indicators to the basepair/timeframe if set_generalized_indicators : df [ ' %-d ay_of_week' ] = ( df [ \"date\" ] . dt . dayofweek + 1 ) / 7 df [ ' %-ho ur_of_day' ] = ( df [ 'date' ] . dt . hour + 1 ) / 25 # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) (Please see the example script located in freqtrade/templates/FreqaiExampleStrategy.py for a full example of populate_any_indicators() .) Setting classifier targets \u00b6 FreqAI includes the CatboostClassifier via the flag --freqaimodel CatboostClassifier . The user should take care to set the classes using strings: df [ '&s-up_or_down' ] = np . where ( df [ \"close\" ] . shift ( - 100 ) > df [ \"close\" ], 'up' , 'down' ) Additionally, the example classifier models do not accommodate multiple labels, but they do allow multi-class classification within a single label column. Running FreqAI \u00b6 There are two ways to train and deploy an adaptive machine learning model. FreqAI enables live deployment as well as backtesting analyses. In both cases, a model is trained periodically, as shown in the following figure. Running the model live \u00b6 FreqAI can be run dry/live using the following command: freqtrade trade --strategy FreqaiExampleStrategy --config config_freqai.example.json --freqaimodel LightGBMRegressor By default, FreqAI will not find any existing models and will start by training a new one based on the user's configuration settings. Following training, the model will be used to make predictions on incoming candles until a new model is available. New models are typically generated as often as possible, with FreqAI managing an internal queue of the coin pairs to try to keep all models equally up to date. FreqAI will always use the most recently trained model to make predictions on incoming live data. If the user does not want FreqAI to retrain new models as often as possible, they can set live_retrain_hours to tell FreqAI to wait at least that number of hours before training a new model. Additionally, the user can set expired_hours to tell FreqAI to avoid making predictions on models that are older than that number of hours. If the user wishes to start a dry/live run from a saved backtest model (or from a previously crashed dry/live session), the user only needs to reuse the same identifier parameter: \"freqai\" : { \"identifier\" : \"example\" , \"live_retrain_hours\" : 0.5 } In this case, although FreqAI will initiate with a pre-trained model, it will still check to see how much time has elapsed since the model was trained, and if a full live_retrain_hours has elapsed since the end of the loaded model, FreqAI will retrain. Backtesting \u00b6 The FreqAI backtesting module can be executed with the following command: freqtrade backtesting --strategy FreqaiExampleStrategy --config config_freqai.example.json --freqaimodel LightGBMRegressor --timerange 20210501 -20210701 Backtesting mode requires the user to have the data pre-downloaded (unlike in dry/live mode where FreqAI automatically downloads the necessary data). The user should be careful to consider that the time range of the downloaded data is more than the backtesting time range. This is because FreqAI needs data prior to the desired backtesting time range in order to train a model to be ready to make predictions on the first candle of the user-set backtesting time range. More details on how to calculate the data to download can be found here . If this command has never been executed with the existing config file, it will train a new model for each pair, for each backtesting window within the expanded --timerange . Model reuse Once the training is completed, the user can execute the backtesting again with the same config file and FreqAI will find the trained models and load them instead of spending time training. This is useful if the user wants to tweak (or even hyperopt) buy and sell criteria inside the strategy. If the user wants to retrain a new model with the same config file, then they should simply change the identifier . This way, the user can return to using any model they wish by simply specifying the identifier . Deciding the size of the sliding training window and backtesting duration \u00b6 The user defines the backtesting timerange with the typical --timerange parameter in the configuration file. The duration of the sliding training window is set by train_period_days , whilst backtest_period_days is the sliding backtesting window, both in number of days ( backtest_period_days can be a float to indicate sub-daily retraining in live/dry mode). In the presented example config, the user is asking FreqAI to use a training period of 30 days and backtest on the subsequent 7 days. This means that if the user sets --timerange 20210501-20210701 , FreqAI will train have trained 8 separate models at the end of --timerange (because the full range comprises 8 weeks). After the training of the model, FreqAI will backtest the subsequent 7 days. The \"sliding window\" then moves one week forward (emulating FreqAI retraining once per week in live mode) and the new model uses the previous 30 days (including the 7 days used for backtesting by the previous model) to train. This is repeated until the end of --timerange . In live mode, the required training data is automatically computed and downloaded. However, in backtesting mode, the user must manually enter the required number of startup_candles in the config. This value is used to increase the data to FreqAI, which should be sufficient to enable all indicators to be NaN free at the beginning of the first training. This is done by identifying the longest timeframe ( 4h in presented example config) and the longest indicator period ( 20 days in presented example config) and adding this to the train_period_days . The units need to be in the base candle time frame: startup_candles = ( 4 hours * 20 max period * 60 minutes/hour + 30 day train_period_days * 1440 minutes per day ) / 5 min (base time frame) = 9360. Note In dry/live mode, this is all precomputed and handled automatically. Thus, startup_candle has no influence on dry/live mode. Note Although fractional backtest_period_days is allowed, the user should be aware that the --timerange is divided by this value to determine the number of models that FreqAI will need to train in order to backtest the full range. For example, if the user wants to set a --timerange of 10 days, and asks for a backtest_period_days of 0.1, FreqAI will need to train 100 models per pair to complete the full backtest. Because of this, a true backtest of FreqAI adaptive training would take a very long time. The best way to fully test a model is to run it dry and let it constantly train. In this case, backtesting would take the exact same amount of time as a dry run. Defining model expirations \u00b6 During dry/live mode, FreqAI trains each coin pair sequentially (on separate threads/GPU from the main Freqtrade bot). This means that there is always an age discrepancy between models. If a user is training on 50 pairs, and each pair requires 5 minutes to train, the oldest model will be over 4 hours old. This may be undesirable if the characteristic time scale (the trade duration target) for a strategy is less than 4 hours. The user can decide to only make trade entries if the model is less than a certain number of hours old by setting the expiration_hours in the config file: \"freqai\" : { \"expiration_hours\" : 0.5 , } In the presented example config, the user will only allow predictions on models that are less than \u00bd hours old. Purging old model data \u00b6 FreqAI stores new model files each time it retrains. These files become obsolete as new models are trained and FreqAI adapts to new market conditions. Users planning to leave FreqAI running for extended periods of time with high frequency retraining should enable purge_old_models in their config: \"freqai\" : { \"purge_old_models\" : true , } This will automatically purge all models older than the two most recently trained ones. Returning additional info from training \u00b6 The user may find that there are some important metrics that they'd like to return to the strategy at the end of each model training. The user can include these metrics by assigning them to dk.data['extra_returns_per_train']['my_new_value'] = XYZ inside their custom prediction model class. FreqAI takes the my_new_value assigned in this dictionary and expands it to fit the return dataframe to the strategy. The user can then use the value in the strategy with dataframe['my_new_value'] . An example of how this is already used in FreqAI is the &*_mean and &*_std values, which indicate the mean and standard deviation of the particular target (label) during the most recent training. An example, where the user wants to use live metrics from the trade database, is shown below: \"freqai\" : { \"extra_returns_per_train\" : { \"total_profit\" : 4 } } The user needs to set the standard dictionary in the config so that FreqAI can return proper dataframe shapes. These values will likely be overridden by the prediction model, but in the case where the model has yet to set them, or needs a default initial value, this is the value that will be returned. Setting up a follower \u00b6 The user can define: \"freqai\" : { \"follow_mode\" : true , \"identifier\" : \"example\" } to indicate to the bot that it should not train models, but instead should look for models trained by a leader with the same identifier . In this example, the user has a leader bot with the identifier: \"example\" . The leader bot is already running or launching simultaneously as the follower. The follower will load models created by the leader and inference them to obtain predictions. Data manipulation techniques \u00b6 Feature normalization \u00b6 The feature set created by the user is automatically normalized to the training data. This includes all test data and unseen prediction data (dry/live/backtest). Reducing data dimensionality with Principal Component Analysis \u00b6 Users can reduce the dimensionality of their features by activating the principal_component_analysis in the config: \"freqai\" : { \"feature_parameters\" : { \"principal_component_analysis\" : true } } This will perform PCA on the features and reduce the dimensionality of the data so that the explained variance of the data set is >= 0.999. Stratifying the data for training and testing the model \u00b6 The user can stratify (group) the training/testing data using: \"freqai\" : { \"feature_parameters\" : { \"stratify_training_data\" : 3 } } This will split the data chronologically so that every Xth data point is used to test the model after training. In the example above, the user is asking for every third data point in the dataframe to be used for testing; the other points are used for training. The test data is used to evaluate the performance of the model after training. If the test score is high, the model is able to capture the behavior of the data well. If the test score is low, either the model either does not capture the complexity of the data, the test data is significantly different from the train data, or a different model should be used. Controlling the model learning process \u00b6 Model training parameters are unique to the machine learning library selected by the user. FreqAI allows the user to set any parameter for any library using the model_training_parameters dictionary in the user configuration file. The example configuration file (found in config_examples/config_freqai.example.json ) show some of the example parameters associated with Catboost and LightGBM , but the user can add any parameters available in those libraries. Data split parameters are defined in data_split_parameters which can be any parameters associated with Sklearn 's train_test_split() function. FreqAI includes some additional parameters such as weight_factor , which allows the user to weight more recent data more strongly than past data via an exponential function: \\[ W_i = \\exp(\\frac{-i}{\\alpha*n}) \\] where \\(W_i\\) is the weight of data point \\(i\\) in a total set of \\(n\\) data points. Below is a figure showing the effect of different weight factors on the data points (candles) in a feature set. train_test_split() has a parameters called shuffle that allows the user to keep the data unshuffled. This is particularly useful to avoid biasing training with temporally auto-correlated data. Finally, label_period_candles defines the offset (number of candles into the future) used for the labels . In the presented example config, the user is asking for labels that are 24 candles in the future. Outlier removal \u00b6 Removing outliers with the Dissimilarity Index \u00b6 The user can tell FreqAI to remove outlier data points from the training/test data sets using a Dissimilarity Index by including the following statement in the config: \"freqai\" : { \"feature_parameters\" : { \"DI_threshold\" : 1 } } Equity and crypto markets suffer from a high level of non-patterned noise in the form of outlier data points. The Dissimilarity Index (DI) aims to quantify the uncertainty associated with each prediction made by the model. The DI allows predictions which are outliers (not existent in the model feature space) to be thrown out due to low levels of certainty. To do so, FreqAI measures the distance between each training data point (feature vector), \\(X_{a}\\) , and all other training data points: \\[ d_{ab} = \\sqrt{\\sum_{j=1}^p(X_{a,j}-X_{b,j})^2} \\] where \\(d_{ab}\\) is the distance between the normalized points \\(a\\) and \\(b\\) . \\(p\\) is the number of features, i.e., the length of the vector \\(X\\) . The characteristic distance, \\(\\overline{d}\\) for a set of training data points is simply the mean of the average distances: \\[ \\overline{d} = \\sum_{a=1}^n(\\sum_{b=1}^n(d_{ab}/n)/n) \\] \\(\\overline{d}\\) quantifies the spread of the training data, which is compared to the distance between a new prediction feature vectors, \\(X_k\\) and all the training data: \\[ d_k = \\arg \\min d_{k,i} \\] which enables the estimation of the Dissimilarity Index as: \\[ DI_k = d_k/\\overline{d} \\] The user can tweak the DI through the DI_threshold to increase or decrease the extrapolation of the trained model. Below is a figure that describes the DI for a 3D data set. Removing outliers using a Support Vector Machine (SVM) \u00b6 The user can tell FreqAI to remove outlier data points from the training/test data sets using a SVM by setting: \"freqai\" : { \"feature_parameters\" : { \"use_SVM_to_remove_outliers\" : true } } FreqAI will train an SVM on the training data (or components of it if the user activated principal_component_analysis ) and remove any data point that the SVM deems to be beyond the feature space. The parameter shuffle is by default set to False to ensure consistent results. If it is set to True , running the SVM multiple times on the same data set might result in different outcomes due to max_iter being to low for the algorithm to reach the demanded tol . Increasing max_iter solves this issue but causes the procedure to take longer time. The parameter nu , very broadly, is the amount of data points that should be considered outliers. Removing outliers with DBSCAN \u00b6 The user can configure FreqAI to use DBSCAN to cluster and remove outliers from the training/test data set or incoming outliers from predictions, by activating use_DBSCAN_to_remove_outliers in the config: \"freqai\" : { \"feature_parameters\" : { \"use_DBSCAN_to_remove_outliers\" : true } } DBSCAN is an unsupervised machine learning algorithm that clusters data without needing to know how many clusters there should be. Given a number of data points \\(N\\) , and a distance \\(\\varepsilon\\) , DBSCAN clusters the data set by setting all data points that have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) as core points . A data point that is within a distance of \\(\\varepsilon\\) from a core point but that does not have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) from itself is considered an edge point . A cluster is then the collection of core points and edge points . Data points that have no other data points at a distance \\(<\\varepsilon\\) are considered outliers. The figure below shows a cluster with \\(N = 3\\) . FreqAI uses sklearn.cluster.DBSCAN (details are available on scikit-learn's webpage here ) with min_samples ( \\(N\\) ) taken as double the no. of user-defined features, and eps ( \\(\\varepsilon\\) ) taken as the longest distance in the k-distance graph computed from the nearest neighbors in the pairwise distances of all data points in the feature set. Additional information \u00b6 Common pitfalls \u00b6 FreqAI cannot be combined with dynamic VolumePairlists (or any pairlist filter that adds and removes pairs dynamically). This is for performance reasons - FreqAI relies on making quick predictions/retrains. To do this effectively, it needs to download all the training data at the beginning of a dry/live instance. FreqAI stores and appends new candles automatically for future retrains. This means that if new pairs arrive later in the dry run due to a volume pairlist, it will not have the data ready. However, FreqAI does work with the ShufflePairlist or a VolumePairlist which keeps the total pairlist constant (but reorders the pairs according to volume). Credits \u00b6 FreqAI was developed by a group of individuals who all contributed specific skillsets to the project. Conception and software development: Robert Caulk @robcaulk Theoretical brainstorming, data analysis: Elin T\u00f6rnquist @th0rntwig Code review, software architecture brainstorming: @xmatthias Beta testing and bug reporting: @bloodhunter4rc, Salah Lamkadem @ikonx, @ken11o2, @longyu, @paranoidandy, @smidelis, @smarm Juha Nyk\u00e4nen @suikula, Wagner Costa @wagnercosta","title":"FreqAI"},{"location":"freqai/#freqai","text":"FreqAI is a module designed to automate a variety of tasks associated with training a predictive machine learning model to generate market forecasts given a set of input features. Features include: Self-adaptive retraining : retrain models during live deployments to self-adapt to the market in an unsupervised manner. Rapid feature engineering : create large rich feature sets (10k+ features) based on simple user-created strategies. High performance : adaptive retraining occurs on a separate thread (or on GPU if available) from inferencing and bot trade operations. Newest models and data are kept in memory for rapid inferencing. Realistic backtesting : emulate self-adaptive retraining with a backtesting module that automates past retraining. Modifiability : use the generalized and robust architecture for incorporating any machine learning library/method available in Python. Eight examples are currently available, including classifiers, regressors, and a convolutional neural network. Smart outlier removal : remove outliers from training and prediction data sets using a variety of outlier detection techniques . Crash resilience : store model to disk to make reloading from a crash fast and easy, and purge obsolete files for sustained dry/live runs. Automatic data normalization : normalize the data in a smart and statistically safe way. Automatic data download : compute the data download timerange and update historic data (in live deployments). Cleaning of incoming data : handle NaNs safely before training and prediction. Dimensionality reduction : reduce the size of the training data via Principal Component Analysis . Deploying bot fleets : set one bot to train models while a fleet of follower bots inference the models and handle trades.","title":"FreqAI"},{"location":"freqai/#quick-start","text":"The easiest way to quickly test FreqAI is to run it in dry mode with the following command freqtrade trade --config config_examples/config_freqai.example.json --strategy FreqaiExampleStrategy --freqaimodel LightGBMRegressor --strategy-path freqtrade/templates The user will see the boot-up process of automatic data downloading, followed by simultaneous training and trading. The example strategy, example prediction model, and example config can be found in freqtrade/templates/FreqaiExampleStrategy.py , freqtrade/freqai/prediction_models/LightGBMRegressor.py , and config_examples/config_freqai.example.json , respectively.","title":"Quick start"},{"location":"freqai/#general-approach","text":"The user provides FreqAI with a set of custom base indicators (the same way as in a typical Freqtrade strategy) as well as target values ( labels ). FreqAI trains a model to predict the target values based on the input of custom indicators, for each pair in the whitelist. These models are consistently retrained to adapt to market conditions. FreqAI offers the ability to both backtest strategies (emulating reality with periodic retraining) and deploy dry/live runs. In dry/live conditions, FreqAI can be set to constant retraining in a background thread in an effort to keep models as up to date as possible. An overview of the algorithm is shown below, explaining the data processing pipeline and the model usage.","title":"General approach"},{"location":"freqai/#important-machine-learning-vocabulary","text":"Features - the quantities with which a model is trained. All features for a single candle is stored as a vector. In FreqAI, the user builds the feature sets from anything they can construct in the strategy. Labels - the target values that a model is trained toward. Each set of features is associated with a single label that is defined by the user within the strategy. These labels intentionally look into the future, and are not available to the model during dry/live/backtesting. Training - the process of feeding individual feature sets, composed of historic data, with associated labels into the model with the goal of matching input feature sets to associated labels. Train data - a subset of the historic data that is fed to the model during training. This data directly influences weight connections in the model. Test data - a subset of the historic data that is used to evaluate the performance of the model after training. This data does not influence nodal weights within the model.","title":"Important machine learning vocabulary"},{"location":"freqai/#install-prerequisites","text":"The normal Freqtrade install process will ask the user if they wish to install FreqAI dependencies. The user should reply \"yes\" to this question if they wish to use FreqAI. If the user did not reply yes, they can manually install these dependencies after the install with: pip install -r requirements-freqai.txt Note Catboost will not be installed on arm devices (raspberry, Mac M1, ARM based VPS, ...), since Catboost does not provide wheels for this platform.","title":"Install prerequisites"},{"location":"freqai/#usage-with-docker","text":"For docker users, a dedicated tag with freqAI dependencies is available as :freqai . As such - you can replace the image line in your docker-compose file with image: freqtradeorg/freqtrade:develop_freqai . This image contains the regular freqAI dependencies. Similar to native installs, Catboost will not be available on ARM based devices.","title":"Usage with docker"},{"location":"freqai/#setting-up-freqai","text":"","title":"Setting up FreqAI"},{"location":"freqai/#parameter-table","text":"The table below will list all configuration parameters available for FreqAI, presented in the same order as config_examples/config_freqai.example.json . Mandatory parameters are marked as Required , which means that they are required to be set in one of the possible ways. Parameter Description General configuration parameters freqai Required. The parent dictionary containing all the parameters for controlling FreqAI. Datatype: Dictionary. startup_candles Number of candles needed for backtesting only to ensure all indicators are non NaNs at the start of the first train period. Datatype: Positive integer. purge_old_models Delete obsolete models (otherwise, all historic models will remain on disk). Datatype: Boolean. Default: False . train_period_days Required. Number of days to use for the training data (width of the sliding window). Datatype: Positive integer. backtest_period_days Required. Number of days to inference from the trained model before sliding the window defined above, and retraining the model. This can be fractional days, but beware that the user-provided timerange will be divided by this number to yield the number of trainings necessary to complete the backtest. Datatype: Float. identifier Required. A unique name for the current model. This can be reused to reload pre-trained models/data. Datatype: String. live_retrain_hours Frequency of retraining during dry/live runs. Default set to 0, which means the model will retrain as often as possible. Datatype: Float > 0. expiration_hours Avoid making predictions if a model is more than expiration_hours old. Defaults set to 0, which means models never expire. Datatype: Positive integer. fit_live_predictions_candles Number of historical candles to use for computing target (label) statistics from prediction data, instead of from the training data set. Datatype: Positive integer. follow_mode If true, this instance of FreqAI will look for models associated with identifier and load those for inferencing. A follower will not train new models. Datatype: Boolean. Default: False . Feature parameters feature_parameters A dictionary containing the parameters used to engineer the feature set. Details and examples are shown here . Datatype: Dictionary. include_timeframes A list of timeframes that all indicators in populate_any_indicators will be created for. The list is added as features to the base asset feature set. Datatype: List of timeframes (strings). include_corr_pairlist A list of correlated coins that FreqAI will add as additional features to all pair_whitelist coins. All indicators set in populate_any_indicators during feature engineering (see details here ) will be created for each coin in this list, and that set of features is added to the base asset feature set. Datatype: List of assets (strings). label_period_candles Number of candles into the future that the labels are created for. This is used in populate_any_indicators (see templates/FreqaiExampleStrategy.py for detailed usage). The user can create custom labels, making use of this parameter or not. Datatype: Positive integer. include_shifted_candles Add features from previous candles to subsequent candles to add historical information. FreqAI takes all features from the include_shifted_candles previous candles, duplicates and shifts them so that the information is available for the subsequent candle. Datatype: Positive integer. weight_factor Used to set weights for training data points according to their recency. See details about how it works here . Datatype: Positive float (typically < 1). indicator_max_period_candles The maximum period used in populate_any_indicators() for indicator creation. FreqAI uses this information in combination with the maximum timeframe to calculate how many data points that should be downloaded so that the first data point does not have a NaN. Datatype: Positive integer. indicator_periods_candles Calculate indicators for indicator_periods_candles time periods and add them to the feature set. Datatype: List of positive integers. stratify_training_data This value is used to indicate the grouping of the data. For example, 2 would set every 2 nd data point into a separate dataset to be pulled from during training/testing. See details about how it works here Datatype: Positive integer. principal_component_analysis Automatically reduce the dimensionality of the data set using Principal Component Analysis. See details about how it works here Datatype: Boolean. DI_threshold Activates the Dissimilarity Index for outlier detection when > 0. See details about how it works here . Datatype: Positive float (typically < 1). use_SVM_to_remove_outliers Train a support vector machine to detect and remove outliers from the training data set, as well as from incoming data points. See details about how it works here . Datatype: Boolean. svm_params All parameters available in Sklearn's SGDOneClassSVM() . See details about some select parameters here . Datatype: Dictionary. use_DBSCAN_to_remove_outliers Cluster data using DBSCAN to identify and remove outliers from training and prediction data. See details about how it works here . Datatype: Boolean. outlier_protection_percentage If more than outlier_protection_percentage fraction of points are removed as outliers, FreqAI will log a warning message and ignore outlier detection while keeping the original dataset intact. Datatype: float. Default: 30 Data split parameters data_split_parameters Include any additional parameters available from Scikit-learn test_train_split() , which are shown here (external website). Datatype: Dictionary. test_size Fraction of data that should be used for testing instead of training. Datatype: Positive float < 1. shuffle Shuffle the training data points during training. Typically, for time-series forecasting, this is set to False . Model training parameters model_training_parameters A flexible dictionary that includes all parameters available by the user selected model library. For example, if the user uses LightGBMRegressor , this dictionary can contain any parameter available by the LightGBMRegressor here (external website). If the user selects a different model, this dictionary can contain any parameter from that model. Datatype: Dictionary. Datatype: Boolean. n_estimators The number of boosted trees to fit in regression. Datatype: Integer. learning_rate Boosting learning rate during regression. Datatype: Float. n_jobs , thread_count , task_type Set the number of threads for parallel processing and the task_type ( gpu or cpu ). Different model libraries use different parameter names. Datatype: Float. Extraneous parameters keras If your model makes use of Keras (typical for Tensorflow-based prediction models), activate this flag so that the model save/loading follows Keras standards. Datatype: Boolean. Default: False . conv_width The width of a convolutional neural network input tensor. This replaces the need for shifting candles ( include_shifted_candles ) by feeding in historical data points as the second dimension of the tensor. Technically, this parameter can also be used for regressors, but it only adds computational overhead and does not change the model training/prediction. Datatype: Integer. Default: 2.","title":"Parameter table"},{"location":"freqai/#important-dataframe-key-patterns","text":"Below are the values the user can expect to include/use inside a typical strategy dataframe ( df[] ): DataFrame Key Description df['&*'] Any dataframe column prepended with & in populate_any_indicators() is treated as a training target (label) inside FreqAI (typically following the naming convention &-s* ). The names of these dataframe columns are fed back to the user as the predictions. For example, if the user wishes to predict the price change in the next 40 candles (similar to templates/FreqaiExampleStrategy.py ), they set df['&-s_close'] . FreqAI makes the predictions and gives them back under the same key ( df['&-s_close'] ) to be used in populate_entry/exit_trend() . Datatype: Depends on the output of the model. df['&*_std/mean'] Standard deviation and mean values of the user-defined labels during training (or live tracking with fit_live_predictions_candles ). Commonly used to understand the rarity of a prediction (use the z-score as shown in templates/FreqaiExampleStrategy.py to evaluate how often a particular prediction was observed during training or historically with fit_live_predictions_candles ). Datatype: Float. df['do_predict'] Indication of an outlier data point. The return value is integer between -1 and 2, which lets the user know if the prediction is trustworthy or not. do_predict==1 means the prediction is trustworthy. If the Dissimilarity Index (DI, see details here ) of the input data point is above the user-defined threshold, FreqAI will subtract 1 from do_predict , resulting in do_predict==0 . If use_SVM_to_remove_outliers() is active, the Support Vector Machine (SVM) may also detect outliers in training and prediction data. In this case, the SVM will also subtract 1 from do_predict . If the input data point was considered an outlier by the SVM but not by the DI, the result will be do_predict==0 . If both the DI and the SVM considers the input data point to be an outlier, the result will be do_predict==-1 . A particular case is when do_predict == 2 , which means that the model has expired due to exceeding expired_hours . Datatype: Integer between -1 and 2. df['DI_values'] Dissimilarity Index values are proxies to the level of confidence FreqAI has in the prediction. A lower DI means the prediction is close to the training data, i.e., higher prediction confidence. Datatype: Float. df['%*'] Any dataframe column prepended with % in populate_any_indicators() is treated as a training feature. For example, the user can include the RSI in the training feature set (similar to in templates/FreqaiExampleStrategy.py ) by setting df['%-rsi'] . See more details on how this is done here . Note : Since the number of features prepended with % can multiply very quickly (10s of thousands of features is easily engineered using the multiplictative functionality described in the feature_parameters table shown above), these features are removed from the dataframe upon return from FreqAI. If the user wishes to keep a particular type of feature for plotting purposes, they can prepend it with %% . Datatype: Depends on the output of the model.","title":"Important dataframe key patterns"},{"location":"freqai/#file-structure","text":"user_data_dir/models/ contains all the data associated with the trainings and backtests. This file structure is heavily controlled and inferenced by the FreqaiDataKitchen() and should therefore not be modified.","title":"File structure"},{"location":"freqai/#example-config-file","text":"The user interface is isolated to the typical Freqtrade config file. A FreqAI config should include: \"freqai\" : { \"enabled\" : true , \"startup_candles\" : 10000 , \"purge_old_models\" : true , \"train_period_days\" : 30 , \"backtest_period_days\" : 7 , \"identifier\" : \"unique-id\" , \"feature_parameters\" : { \"include_timeframes\" : [ \"5m\" , \"15m\" , \"4h\" ], \"include_corr_pairlist\" : [ \"ETH/USD\" , \"LINK/USD\" , \"BNB/USD\" ], \"label_period_candles\" : 24 , \"include_shifted_candles\" : 2 , \"indicator_max_period_candles\" : 20 , \"indicator_periods_candles\" : [ 10 , 20 ] }, \"data_split_parameters\" : { \"test_size\" : 0.25 }, \"model_training_parameters\" : { \"n_estimators\" : 100 }, }","title":"Example config file"},{"location":"freqai/#building-a-freqai-strategy","text":"The FreqAI strategy requires the user to include the following lines of code in the standard Freqtrade strategy: def informative_pairs ( self ): whitelist_pairs = self . dp . current_whitelist () corr_pairs = self . config [ \"freqai\" ][ \"feature_parameters\" ][ \"include_corr_pairlist\" ] informative_pairs = [] for tf in self . config [ \"freqai\" ][ \"feature_parameters\" ][ \"include_timeframes\" ]: for pair in whitelist_pairs : informative_pairs . append (( pair , tf )) for pair in corr_pairs : if pair in whitelist_pairs : continue # avoid duplication informative_pairs . append (( pair , tf )) return informative_pairs def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # the model will return all labels created by user in `populate_any_indicators` # (& appended targets), an indication of whether or not the prediction should be accepted, # the target mean/std values for each of the labels created by user in # `populate_any_indicators()` for each training period. dataframe = self . freqai . start ( dataframe , metadata , self ) return dataframe def populate_any_indicators ( self , pair , df , tf , informative = None , set_generalized_indicators = False ): \"\"\" Function designed to automatically generate, name and merge features from user indicated timeframes in the configuration file. User controls the indicators passed to the training/prediction by prepending indicators with `'%-' + coin ` (see convention below). I.e. user should not prepend any supporting metrics (e.g. bb_lowerband below) with % unless they explicitly want to pass that metric to the model. :param pair: pair to be used as informative :param df: strategy dataframe which will receive merges from informatives :param tf: timeframe of the dataframe which will modify the feature names :param informative: the dataframe associated with the informative pair :param coin: the name of the coin which will modify the feature names. \"\"\" coin = pair . split ( '/' )[ 0 ] if informative is None : informative = self . dp . get_pair_dataframe ( pair , tf ) # first loop is automatically duplicating indicators for time periods for t in self . freqai_info [ \"feature_parameters\" ][ \"indicator_periods_candles\" ]: t = int ( t ) informative [ f \"%- { coin } rsi-period_ { t } \" ] = ta . RSI ( informative , timeperiod = t ) informative [ f \"%- { coin } mfi-period_ { t } \" ] = ta . MFI ( informative , timeperiod = t ) informative [ f \"%- { coin } adx-period_ { t } \" ] = ta . ADX ( informative , window = t ) indicators = [ col for col in informative if col . startswith ( \"%\" )] # This loop duplicates and shifts all indicators to add a sense of recency to data for n in range ( self . freqai_info [ \"feature_parameters\" ][ \"include_shifted_candles\" ] + 1 ): if n == 0 : continue informative_shift = informative [ indicators ] . shift ( n ) informative_shift = informative_shift . add_suffix ( \"_shift-\" + str ( n )) informative = pd . concat (( informative , informative_shift ), axis = 1 ) df = merge_informative_pair ( df , informative , self . config [ \"timeframe\" ], tf , ffill = True ) skip_columns = [ ( s + \"_\" + tf ) for s in [ \"date\" , \"open\" , \"high\" , \"low\" , \"close\" , \"volume\" ] ] df = df . drop ( columns = skip_columns ) # Add generalized indicators here (because in live, it will call this # function to populate indicators during training). Notice how we ensure not to # add them multiple times if set_generalized_indicators : # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) return df Notice how the populate_any_indicators() is where the user adds their own features ( more information ) and labels ( more information ). See a full example at templates/FreqaiExampleStrategy.py .","title":"Building a FreqAI strategy"},{"location":"freqai/#creating-a-dynamic-target","text":"The &*_std/mean return values describe the statistical fit of the user defined label during the most recent training . This value allows the user to know the rarity of a given prediction. For example, templates/FreqaiExampleStrategy.py , creates a target_roi which is based on filtering out predictions that are below a given z-score of 1.25. dataframe [ \"target_roi\" ] = dataframe [ \"&-s_close_mean\" ] + dataframe [ \"&-s_close_std\" ] * 1.25 dataframe [ \"sell_roi\" ] = dataframe [ \"&-s_close_mean\" ] - dataframe [ \"&-s_close_std\" ] * 1.25 If the user wishes to consider the population of historical predictions for creating the dynamic target instead of the trained labels, (as discussed above) the user can do so by setting fit_live_prediction_candles in the config to the number of historical prediction candles the user wishes to use to generate target statistics. \"freqai\" : { \"fit_live_prediction_candles\" : 300 , } If the user sets this value, FreqAI will initially use the predictions from the training data and subsequently begin introducing real prediction data as it is generated. FreqAI will save this historical data to be reloaded if the user stops and restarts a model with the same identifier .","title":"Creating a dynamic target"},{"location":"freqai/#building-a-custom-prediction-model","text":"FreqAI has multiple example prediction model libraries, such as Catboost regression ( freqai/prediction_models/CatboostRegressor.py ) and LightGBM regression. However, the user can customize and create their own prediction models using the IFreqaiModel class. The user is encouraged to inherit train() and predict() to let them customize various aspects of their training procedures.","title":"Building a custom prediction model"},{"location":"freqai/#feature-engineering","text":"Features are added by the user inside the populate_any_indicators() method of the strategy by prepending indicators with % , and labels with & . There are some important components/structures that the user must include when building their feature set; the use of these is shown below: def populate_any_indicators ( self , pair , df , tf , informative = None , set_generalized_indicators = False ): \"\"\" Function designed to automatically generate, name, and merge features from user-indicated timeframes in the configuration file. The user controls the indicators passed to the training/prediction by prepending indicators with `'%-' + coin ` (see convention below). I.e., the user should not prepend any supporting metrics (e.g., bb_lowerband below) with % unless they explicitly want to pass that metric to the model. :param pair: pair to be used as informative :param df: strategy dataframe which will receive merges from informatives :param tf: timeframe of the dataframe which will modify the feature names :param informative: the dataframe associated with the informative pair :param coin: the name of the coin which will modify the feature names. \"\"\" coin = pair . split ( '/' )[ 0 ] if informative is None : informative = self . dp . get_pair_dataframe ( pair , tf ) # first loop is automatically duplicating indicators for time periods for t in self . freqai_info [ \"feature_parameters\" ][ \"indicator_periods_candles\" ]: t = int ( t ) informative [ f \"%- { coin } rsi-period_ { t } \" ] = ta . RSI ( informative , timeperiod = t ) informative [ f \"%- { coin } mfi-period_ { t } \" ] = ta . MFI ( informative , timeperiod = t ) informative [ f \"%- { coin } adx-period_ { t } \" ] = ta . ADX ( informative , window = t ) bollinger = qtpylib . bollinger_bands ( qtpylib . typical_price ( informative ), window = t , stds = 2.2 ) informative [ f \" { coin } bb_lowerband-period_ { t } \" ] = bollinger [ \"lower\" ] informative [ f \" { coin } bb_middleband-period_ { t } \" ] = bollinger [ \"mid\" ] informative [ f \" { coin } bb_upperband-period_ { t } \" ] = bollinger [ \"upper\" ] informative [ f \"%- { coin } bb_width-period_ { t } \" ] = ( informative [ f \" { coin } bb_upperband-period_ { t } \" ] - informative [ f \" { coin } bb_lowerband-period_ { t } \" ] ) / informative [ f \" { coin } bb_middleband-period_ { t } \" ] informative [ f \"%- { coin } close-bb_lower-period_ { t } \" ] = ( informative [ \"close\" ] / informative [ f \" { coin } bb_lowerband-period_ { t } \" ] ) informative [ f \"%- { coin } relative_volume-period_ { t } \" ] = ( informative [ \"volume\" ] / informative [ \"volume\" ] . rolling ( t ) . mean () ) indicators = [ col for col in informative if col . startswith ( \"%\" )] # This loop duplicates and shifts all indicators to add a sense of recency to data for n in range ( self . freqai_info [ \"feature_parameters\" ][ \"include_shifted_candles\" ] + 1 ): if n == 0 : continue informative_shift = informative [ indicators ] . shift ( n ) informative_shift = informative_shift . add_suffix ( \"_shift-\" + str ( n )) informative = pd . concat (( informative , informative_shift ), axis = 1 ) df = merge_informative_pair ( df , informative , self . config [ \"timeframe\" ], tf , ffill = True ) skip_columns = [ ( s + \"_\" + tf ) for s in [ \"date\" , \"open\" , \"high\" , \"low\" , \"close\" , \"volume\" ] ] df = df . drop ( columns = skip_columns ) # Add generalized indicators here (because in live, it will call this # function to populate indicators during training). Notice how we ensure not to # add them multiple times if set_generalized_indicators : df [ \" %-d ay_of_week\" ] = ( df [ \"date\" ] . dt . dayofweek + 1 ) / 7 df [ \" %-ho ur_of_day\" ] = ( df [ \"date\" ] . dt . hour + 1 ) / 25 # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) return df In the presented example strategy, the user does not wish to pass the bb_lowerband as a feature to the model, and has therefore not prepended it with % . The user does, however, wish to pass bb_width to the model for training/prediction and has therefore prepended it with % . The include_timeframes in the example config above are the timeframes ( tf ) of each call to populate_any_indicators() in the strategy. In the present case, the user is asking for the 5m , 15m , and 4h timeframes of the rsi , mfi , roc , and bb_width to be included in the feature set. The user can ask for each of the defined features to be included also from informative pairs using the include_corr_pairlist . This means that the feature set will include all the features from populate_any_indicators on all the include_timeframes for each of the correlated pairs defined in the config ( ETH/USD , LINK/USD , and BNB/USD ). include_shifted_candles indicates the number of previous candles to include in the feature set. For example, include_shifted_candles: 2 tells FreqAI to include the past 2 candles for each of the features in the feature set. In total, the number of features the user of the presented example strat has created is: length of include_timeframes * no. features in populate_any_indicators() * length of include_corr_pairlist * no. include_shifted_candles * length of indicator_periods_candles \\(= 3 * 3 * 3 * 2 * 2 = 108\\) . Another structure to consider is the location of the labels at the bottom of the example function (below if set_generalized_indicators: ). This is where the user will add single features and labels to their feature set to avoid duplication of them from various configuration parameters that multiply the feature set, such as include_timeframes . Note Features must be defined in populate_any_indicators() . Definining FreqAI features in populate_indicators() will cause the algorithm to fail in live/dry mode. If the user wishes to add generalized features that are not associated with a specific pair or timeframe, they should use the following structure inside populate_any_indicators() (as exemplified in freqtrade/templates/FreqaiExampleStrategy.py ): def populate_any_indicators ( self , metadata , pair , df , tf , informative = None , coin = \"\" , set_generalized_indicators = False ): ... # Add generalized indicators here (because in live, it will call only this function to populate # indicators for retraining). Notice how we ensure not to add them multiple times by associating # these generalized indicators to the basepair/timeframe if set_generalized_indicators : df [ ' %-d ay_of_week' ] = ( df [ \"date\" ] . dt . dayofweek + 1 ) / 7 df [ ' %-ho ur_of_day' ] = ( df [ 'date' ] . dt . hour + 1 ) / 25 # user adds targets here by prepending them with &- (see convention below) # If user wishes to use multiple targets, a multioutput prediction model # needs to be used such as templates/CatboostPredictionMultiModel.py df [ \"&-s_close\" ] = ( df [ \"close\" ] . shift ( - self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . rolling ( self . freqai_info [ \"feature_parameters\" ][ \"label_period_candles\" ]) . mean () / df [ \"close\" ] - 1 ) (Please see the example script located in freqtrade/templates/FreqaiExampleStrategy.py for a full example of populate_any_indicators() .)","title":"Feature engineering"},{"location":"freqai/#setting-classifier-targets","text":"FreqAI includes the CatboostClassifier via the flag --freqaimodel CatboostClassifier . The user should take care to set the classes using strings: df [ '&s-up_or_down' ] = np . where ( df [ \"close\" ] . shift ( - 100 ) > df [ \"close\" ], 'up' , 'down' ) Additionally, the example classifier models do not accommodate multiple labels, but they do allow multi-class classification within a single label column.","title":"Setting classifier targets"},{"location":"freqai/#running-freqai","text":"There are two ways to train and deploy an adaptive machine learning model. FreqAI enables live deployment as well as backtesting analyses. In both cases, a model is trained periodically, as shown in the following figure.","title":"Running FreqAI"},{"location":"freqai/#running-the-model-live","text":"FreqAI can be run dry/live using the following command: freqtrade trade --strategy FreqaiExampleStrategy --config config_freqai.example.json --freqaimodel LightGBMRegressor By default, FreqAI will not find any existing models and will start by training a new one based on the user's configuration settings. Following training, the model will be used to make predictions on incoming candles until a new model is available. New models are typically generated as often as possible, with FreqAI managing an internal queue of the coin pairs to try to keep all models equally up to date. FreqAI will always use the most recently trained model to make predictions on incoming live data. If the user does not want FreqAI to retrain new models as often as possible, they can set live_retrain_hours to tell FreqAI to wait at least that number of hours before training a new model. Additionally, the user can set expired_hours to tell FreqAI to avoid making predictions on models that are older than that number of hours. If the user wishes to start a dry/live run from a saved backtest model (or from a previously crashed dry/live session), the user only needs to reuse the same identifier parameter: \"freqai\" : { \"identifier\" : \"example\" , \"live_retrain_hours\" : 0.5 } In this case, although FreqAI will initiate with a pre-trained model, it will still check to see how much time has elapsed since the model was trained, and if a full live_retrain_hours has elapsed since the end of the loaded model, FreqAI will retrain.","title":"Running the model live"},{"location":"freqai/#backtesting","text":"The FreqAI backtesting module can be executed with the following command: freqtrade backtesting --strategy FreqaiExampleStrategy --config config_freqai.example.json --freqaimodel LightGBMRegressor --timerange 20210501 -20210701 Backtesting mode requires the user to have the data pre-downloaded (unlike in dry/live mode where FreqAI automatically downloads the necessary data). The user should be careful to consider that the time range of the downloaded data is more than the backtesting time range. This is because FreqAI needs data prior to the desired backtesting time range in order to train a model to be ready to make predictions on the first candle of the user-set backtesting time range. More details on how to calculate the data to download can be found here . If this command has never been executed with the existing config file, it will train a new model for each pair, for each backtesting window within the expanded --timerange . Model reuse Once the training is completed, the user can execute the backtesting again with the same config file and FreqAI will find the trained models and load them instead of spending time training. This is useful if the user wants to tweak (or even hyperopt) buy and sell criteria inside the strategy. If the user wants to retrain a new model with the same config file, then they should simply change the identifier . This way, the user can return to using any model they wish by simply specifying the identifier .","title":"Backtesting"},{"location":"freqai/#deciding-the-size-of-the-sliding-training-window-and-backtesting-duration","text":"The user defines the backtesting timerange with the typical --timerange parameter in the configuration file. The duration of the sliding training window is set by train_period_days , whilst backtest_period_days is the sliding backtesting window, both in number of days ( backtest_period_days can be a float to indicate sub-daily retraining in live/dry mode). In the presented example config, the user is asking FreqAI to use a training period of 30 days and backtest on the subsequent 7 days. This means that if the user sets --timerange 20210501-20210701 , FreqAI will train have trained 8 separate models at the end of --timerange (because the full range comprises 8 weeks). After the training of the model, FreqAI will backtest the subsequent 7 days. The \"sliding window\" then moves one week forward (emulating FreqAI retraining once per week in live mode) and the new model uses the previous 30 days (including the 7 days used for backtesting by the previous model) to train. This is repeated until the end of --timerange . In live mode, the required training data is automatically computed and downloaded. However, in backtesting mode, the user must manually enter the required number of startup_candles in the config. This value is used to increase the data to FreqAI, which should be sufficient to enable all indicators to be NaN free at the beginning of the first training. This is done by identifying the longest timeframe ( 4h in presented example config) and the longest indicator period ( 20 days in presented example config) and adding this to the train_period_days . The units need to be in the base candle time frame: startup_candles = ( 4 hours * 20 max period * 60 minutes/hour + 30 day train_period_days * 1440 minutes per day ) / 5 min (base time frame) = 9360. Note In dry/live mode, this is all precomputed and handled automatically. Thus, startup_candle has no influence on dry/live mode. Note Although fractional backtest_period_days is allowed, the user should be aware that the --timerange is divided by this value to determine the number of models that FreqAI will need to train in order to backtest the full range. For example, if the user wants to set a --timerange of 10 days, and asks for a backtest_period_days of 0.1, FreqAI will need to train 100 models per pair to complete the full backtest. Because of this, a true backtest of FreqAI adaptive training would take a very long time. The best way to fully test a model is to run it dry and let it constantly train. In this case, backtesting would take the exact same amount of time as a dry run.","title":"Deciding the size of the sliding training window and backtesting duration"},{"location":"freqai/#defining-model-expirations","text":"During dry/live mode, FreqAI trains each coin pair sequentially (on separate threads/GPU from the main Freqtrade bot). This means that there is always an age discrepancy between models. If a user is training on 50 pairs, and each pair requires 5 minutes to train, the oldest model will be over 4 hours old. This may be undesirable if the characteristic time scale (the trade duration target) for a strategy is less than 4 hours. The user can decide to only make trade entries if the model is less than a certain number of hours old by setting the expiration_hours in the config file: \"freqai\" : { \"expiration_hours\" : 0.5 , } In the presented example config, the user will only allow predictions on models that are less than \u00bd hours old.","title":"Defining model expirations"},{"location":"freqai/#purging-old-model-data","text":"FreqAI stores new model files each time it retrains. These files become obsolete as new models are trained and FreqAI adapts to new market conditions. Users planning to leave FreqAI running for extended periods of time with high frequency retraining should enable purge_old_models in their config: \"freqai\" : { \"purge_old_models\" : true , } This will automatically purge all models older than the two most recently trained ones.","title":"Purging old model data"},{"location":"freqai/#returning-additional-info-from-training","text":"The user may find that there are some important metrics that they'd like to return to the strategy at the end of each model training. The user can include these metrics by assigning them to dk.data['extra_returns_per_train']['my_new_value'] = XYZ inside their custom prediction model class. FreqAI takes the my_new_value assigned in this dictionary and expands it to fit the return dataframe to the strategy. The user can then use the value in the strategy with dataframe['my_new_value'] . An example of how this is already used in FreqAI is the &*_mean and &*_std values, which indicate the mean and standard deviation of the particular target (label) during the most recent training. An example, where the user wants to use live metrics from the trade database, is shown below: \"freqai\" : { \"extra_returns_per_train\" : { \"total_profit\" : 4 } } The user needs to set the standard dictionary in the config so that FreqAI can return proper dataframe shapes. These values will likely be overridden by the prediction model, but in the case where the model has yet to set them, or needs a default initial value, this is the value that will be returned.","title":"Returning additional info from training"},{"location":"freqai/#setting-up-a-follower","text":"The user can define: \"freqai\" : { \"follow_mode\" : true , \"identifier\" : \"example\" } to indicate to the bot that it should not train models, but instead should look for models trained by a leader with the same identifier . In this example, the user has a leader bot with the identifier: \"example\" . The leader bot is already running or launching simultaneously as the follower. The follower will load models created by the leader and inference them to obtain predictions.","title":"Setting up a follower"},{"location":"freqai/#data-manipulation-techniques","text":"","title":"Data manipulation techniques"},{"location":"freqai/#feature-normalization","text":"The feature set created by the user is automatically normalized to the training data. This includes all test data and unseen prediction data (dry/live/backtest).","title":"Feature normalization"},{"location":"freqai/#reducing-data-dimensionality-with-principal-component-analysis","text":"Users can reduce the dimensionality of their features by activating the principal_component_analysis in the config: \"freqai\" : { \"feature_parameters\" : { \"principal_component_analysis\" : true } } This will perform PCA on the features and reduce the dimensionality of the data so that the explained variance of the data set is >= 0.999.","title":"Reducing data dimensionality with Principal Component Analysis"},{"location":"freqai/#stratifying-the-data-for-training-and-testing-the-model","text":"The user can stratify (group) the training/testing data using: \"freqai\" : { \"feature_parameters\" : { \"stratify_training_data\" : 3 } } This will split the data chronologically so that every Xth data point is used to test the model after training. In the example above, the user is asking for every third data point in the dataframe to be used for testing; the other points are used for training. The test data is used to evaluate the performance of the model after training. If the test score is high, the model is able to capture the behavior of the data well. If the test score is low, either the model either does not capture the complexity of the data, the test data is significantly different from the train data, or a different model should be used.","title":"Stratifying the data for training and testing the model"},{"location":"freqai/#controlling-the-model-learning-process","text":"Model training parameters are unique to the machine learning library selected by the user. FreqAI allows the user to set any parameter for any library using the model_training_parameters dictionary in the user configuration file. The example configuration file (found in config_examples/config_freqai.example.json ) show some of the example parameters associated with Catboost and LightGBM , but the user can add any parameters available in those libraries. Data split parameters are defined in data_split_parameters which can be any parameters associated with Sklearn 's train_test_split() function. FreqAI includes some additional parameters such as weight_factor , which allows the user to weight more recent data more strongly than past data via an exponential function: \\[ W_i = \\exp(\\frac{-i}{\\alpha*n}) \\] where \\(W_i\\) is the weight of data point \\(i\\) in a total set of \\(n\\) data points. Below is a figure showing the effect of different weight factors on the data points (candles) in a feature set. train_test_split() has a parameters called shuffle that allows the user to keep the data unshuffled. This is particularly useful to avoid biasing training with temporally auto-correlated data. Finally, label_period_candles defines the offset (number of candles into the future) used for the labels . In the presented example config, the user is asking for labels that are 24 candles in the future.","title":"Controlling the model learning process"},{"location":"freqai/#outlier-removal","text":"","title":"Outlier removal"},{"location":"freqai/#removing-outliers-with-the-dissimilarity-index","text":"The user can tell FreqAI to remove outlier data points from the training/test data sets using a Dissimilarity Index by including the following statement in the config: \"freqai\" : { \"feature_parameters\" : { \"DI_threshold\" : 1 } } Equity and crypto markets suffer from a high level of non-patterned noise in the form of outlier data points. The Dissimilarity Index (DI) aims to quantify the uncertainty associated with each prediction made by the model. The DI allows predictions which are outliers (not existent in the model feature space) to be thrown out due to low levels of certainty. To do so, FreqAI measures the distance between each training data point (feature vector), \\(X_{a}\\) , and all other training data points: \\[ d_{ab} = \\sqrt{\\sum_{j=1}^p(X_{a,j}-X_{b,j})^2} \\] where \\(d_{ab}\\) is the distance between the normalized points \\(a\\) and \\(b\\) . \\(p\\) is the number of features, i.e., the length of the vector \\(X\\) . The characteristic distance, \\(\\overline{d}\\) for a set of training data points is simply the mean of the average distances: \\[ \\overline{d} = \\sum_{a=1}^n(\\sum_{b=1}^n(d_{ab}/n)/n) \\] \\(\\overline{d}\\) quantifies the spread of the training data, which is compared to the distance between a new prediction feature vectors, \\(X_k\\) and all the training data: \\[ d_k = \\arg \\min d_{k,i} \\] which enables the estimation of the Dissimilarity Index as: \\[ DI_k = d_k/\\overline{d} \\] The user can tweak the DI through the DI_threshold to increase or decrease the extrapolation of the trained model. Below is a figure that describes the DI for a 3D data set.","title":"Removing outliers with the Dissimilarity Index"},{"location":"freqai/#removing-outliers-using-a-support-vector-machine-svm","text":"The user can tell FreqAI to remove outlier data points from the training/test data sets using a SVM by setting: \"freqai\" : { \"feature_parameters\" : { \"use_SVM_to_remove_outliers\" : true } } FreqAI will train an SVM on the training data (or components of it if the user activated principal_component_analysis ) and remove any data point that the SVM deems to be beyond the feature space. The parameter shuffle is by default set to False to ensure consistent results. If it is set to True , running the SVM multiple times on the same data set might result in different outcomes due to max_iter being to low for the algorithm to reach the demanded tol . Increasing max_iter solves this issue but causes the procedure to take longer time. The parameter nu , very broadly, is the amount of data points that should be considered outliers.","title":"Removing outliers using a Support Vector Machine (SVM)"},{"location":"freqai/#removing-outliers-with-dbscan","text":"The user can configure FreqAI to use DBSCAN to cluster and remove outliers from the training/test data set or incoming outliers from predictions, by activating use_DBSCAN_to_remove_outliers in the config: \"freqai\" : { \"feature_parameters\" : { \"use_DBSCAN_to_remove_outliers\" : true } } DBSCAN is an unsupervised machine learning algorithm that clusters data without needing to know how many clusters there should be. Given a number of data points \\(N\\) , and a distance \\(\\varepsilon\\) , DBSCAN clusters the data set by setting all data points that have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) as core points . A data point that is within a distance of \\(\\varepsilon\\) from a core point but that does not have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) from itself is considered an edge point . A cluster is then the collection of core points and edge points . Data points that have no other data points at a distance \\(<\\varepsilon\\) are considered outliers. The figure below shows a cluster with \\(N = 3\\) . FreqAI uses sklearn.cluster.DBSCAN (details are available on scikit-learn's webpage here ) with min_samples ( \\(N\\) ) taken as double the no. of user-defined features, and eps ( \\(\\varepsilon\\) ) taken as the longest distance in the k-distance graph computed from the nearest neighbors in the pairwise distances of all data points in the feature set.","title":"Removing outliers with DBSCAN"},{"location":"freqai/#additional-information","text":"","title":"Additional information"},{"location":"freqai/#common-pitfalls","text":"FreqAI cannot be combined with dynamic VolumePairlists (or any pairlist filter that adds and removes pairs dynamically). This is for performance reasons - FreqAI relies on making quick predictions/retrains. To do this effectively, it needs to download all the training data at the beginning of a dry/live instance. FreqAI stores and appends new candles automatically for future retrains. This means that if new pairs arrive later in the dry run due to a volume pairlist, it will not have the data ready. However, FreqAI does work with the ShufflePairlist or a VolumePairlist which keeps the total pairlist constant (but reorders the pairs according to volume).","title":"Common pitfalls"},{"location":"freqai/#credits","text":"FreqAI was developed by a group of individuals who all contributed specific skillsets to the project. Conception and software development: Robert Caulk @robcaulk Theoretical brainstorming, data analysis: Elin T\u00f6rnquist @th0rntwig Code review, software architecture brainstorming: @xmatthias Beta testing and bug reporting: @bloodhunter4rc, Salah Lamkadem @ikonx, @ken11o2, @longyu, @paranoidandy, @smidelis, @smarm Juha Nyk\u00e4nen @suikula, Wagner Costa @wagnercosta","title":"Credits"},{"location":"hyperopt/","text":"Hyperopt \u00b6 This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses algorithms included in the scikit-optimize package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time. In general, the search for best parameters starts with a few random combinations (see below for more details) and then uses Bayesian search with a ML regressor algorithm (currently ExtraTreesRegressor) to quickly find a combination of parameters in the search hyperspace that minimizes the value of the loss function . Hyperopt requires historic data to be available, just as backtesting does (hyperopt runs backtesting many times with different parameters). To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Bug Hyperopt can crash when used with only 1 CPU Core as found out in Issue #1133 Note Since 2021.4 release you no longer have to write a separate hyperopt class, but can configure the parameters directly in the strategy. The legacy method is still supported, but it is no longer the recommended way of setting up hyperopt. The legacy documentation is available at Legacy Hyperopt . Install hyperopt dependencies \u00b6 Since Hyperopt dependencies are not needed to run the bot itself, are heavy, can not be easily built on some platforms (like Raspberry PI), they are not installed by default. Before you run Hyperopt, you need to install the corresponding dependencies, as described in this section below. Note Since Hyperopt is a resource intensive process, running it on a Raspberry Pi is not recommended nor supported. Docker \u00b6 The docker-image includes hyperopt dependencies, no further action needed. Easy installation script (setup.sh) / Manual installation \u00b6 source .env/bin/activate pip install -r requirements-hyperopt.txt Hyperopt command reference \u00b6 usage: freqtrade hyperopt [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--recursive-strategy-search] [--freqaimodel NAME] [--freqaimodel-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--hyperopt-path PATH] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [-e INT] [--spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...]] [--print-all] [--no-color] [--print-json] [-j JOBS] [--random-state INT] [--min-trades INT] [--hyperopt-loss NAME] [--disable-param-export] [--ignore-missing-spaces] [--analyze-per-epoch] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --hyperopt-path PATH Specify additional lookup path for Hyperopt Loss functions. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying `max_open_trades` during backtest (same as setting `max_open_trades` to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting (`1m`, `5m`, `30m`, `1h`, `1d`). -e INT, --epochs INT Specify number of epochs (default: 100). --spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...] Specify which parameters to hyperopt. Space-separated list. --print-all Print all results, not only the best ones. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. -j JOBS, --job-workers JOBS The number of concurrently running jobs for hyperoptimization (hyperopt worker processes). If -1 (default), all CPUs are used, for -2, all CPUs but one are used, etc. If 1 is given, no parallel computing code is used at all. --random-state INT Set random state to some positive integer for reproducible hyperopt results. --min-trades INT Set minimal desired number of trades for evaluations in the hyperopt optimization path (default: 1). --hyperopt-loss NAME, --hyperoptloss NAME Specify the class name of the hyperopt loss function class (IHyperOptLoss). Different functions can generate completely different results, since the target for optimization is different. Built-in Hyperopt-loss-functions are: ShortTradeDurHyperOptLoss, OnlyProfitHyperOptLoss, SharpeHyperOptLoss, SharpeHyperOptLossDaily, SortinoHyperOptLoss, SortinoHyperOptLossDaily, CalmarHyperOptLoss, MaxDrawDownHyperOptLoss, MaxDrawDownRelativeHyperOptLoss, ProfitDrawDownHyperOptLoss --disable-param-export Disable automatic hyperopt parameter export. --ignore-missing-spaces, --ignore-unparameterized-spaces Suppress errors for any requested Hyperopt spaces that do not contain any parameters. --analyze-per-epoch Run populate_indicators once per epoch. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. --recursive-strategy-search Recursively search for a strategy in the strategies folder. --freqaimodel NAME Specify a custom freqaimodels. --freqaimodel-path PATH Specify additional lookup path for freqaimodels. Hyperopt checklist \u00b6 Checklist on all tasks / possibilities in hyperopt Depending on the space you want to optimize, only some of the below are required: define parameters with space='buy' - for entry signal optimization define parameters with space='sell' - for exit signal optimization Note populate_indicators needs to create all indicators any of the spaces may use, otherwise hyperopt will not work. Rarely you may also need to create a nested class named HyperOpt and implement roi_space - for custom ROI optimization (if you need the ranges for the ROI parameters in the optimization hyperspace that differ from default) generate_roi_table - for custom ROI optimization (if you need the ranges for the values in the ROI table that differ from default or the number of entries (steps) in the ROI table which differs from the default 4 steps) stoploss_space - for custom stoploss optimization (if you need the range for the stoploss parameter in the optimization hyperspace that differs from default) trailing_space - for custom trailing stop optimization (if you need the ranges for the trailing stop parameters in the optimization hyperspace that differ from default) Quickly optimize ROI, stoploss and trailing stoploss You can quickly optimize the spaces roi , stoploss and trailing without changing anything in your strategy. # Have a working strategy at hand. freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --spaces roi stoploss trailing --strategy MyWorkingStrategy --config config.json -e 100 Hyperopt execution logic \u00b6 Hyperopt will first load your data into memory and will then run populate_indicators() once per Pair to generate all indicators, unless --analyze-per-epoch is specified. Hyperopt will then spawn into different processes (number of processors, or -j <n> ), and run backtesting over and over again, changing the parameters that are part of the --spaces defined. For every new set of parameters, freqtrade will run first populate_entry_trend() followed by populate_exit_trend() , and then run the regular backtesting process to simulate trades. After backtesting, the results are passed into the loss function , which will evaluate if this result was better or worse than previous results. Based on the loss function result, hyperopt will determine the next set of parameters to try in the next round of backtesting. Configure your Guards and Triggers \u00b6 There are two places you need to change in your strategy file to add a new buy hyperopt for testing: Define the parameters at the class level hyperopt shall be optimizing. Within populate_entry_trend() - use defined parameter values instead of raw constants. There you have two different types of indicators: 1. guards and 2. triggers . Guards are conditions like \"never buy if ADX < 10\", or never buy if current price is over EMA10. Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower Bollinger band\". Guards and Triggers Technically, there is no difference between Guards and Triggers. However, this guide will make this distinction to make it clear that signals should not be \"sticking\". Sticking signals are signals that are active for multiple candles. This can lead into entering a signal late (right before the signal disappears - which means that the chance of success is a lot lower than right at the beginning). Hyper-optimization will, for each epoch round, pick one trigger and possibly multiple guards. Exit signal optimization \u00b6 Similar to the entry-signal above, exit-signals can also be optimized. Place the corresponding settings into the following methods Define the parameters at the class level hyperopt shall be optimizing, either naming them sell_* , or by explicitly defining space='sell' . Within populate_exit_trend() - use defined parameter values instead of raw constants. The configuration and rules are the same than for buy signals. Solving a Mystery \u00b6 Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your long entries. And you also wonder should you use RSI or ADX to help with those decisions. If you decide to use RSI or ADX, which values should I use for them? So let's use hyperparameter optimization to solve this mystery. Defining indicators to be used \u00b6 We start by calculating the indicators our strategy is going to use. class MyAwesomeStrategy ( IStrategy ): def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Generate all indicators used by the strategy \"\"\" dataframe [ 'adx' ] = ta . ADX ( dataframe ) dataframe [ 'rsi' ] = ta . RSI ( dataframe ) macd = ta . MACD ( dataframe ) dataframe [ 'macd' ] = macd [ 'macd' ] dataframe [ 'macdsignal' ] = macd [ 'macdsignal' ] dataframe [ 'macdhist' ] = macd [ 'macdhist' ] bollinger = ta . BBANDS ( dataframe , timeperiod = 20 , nbdevup = 2.0 , nbdevdn = 2.0 ) dataframe [ 'bb_lowerband' ] = bollinger [ 'lowerband' ] dataframe [ 'bb_middleband' ] = bollinger [ 'middleband' ] dataframe [ 'bb_upperband' ] = bollinger [ 'upperband' ] return dataframe Hyperoptable parameters \u00b6 We continue to define hyperoptable parameters: class MyAwesomeStrategy ( IStrategy ): buy_adx = DecimalParameter ( 20 , 40 , decimals = 1 , default = 30.1 , space = \"buy\" ) buy_rsi = IntParameter ( 20 , 40 , default = 30 , space = \"buy\" ) buy_adx_enabled = BooleanParameter ( default = True , space = \"buy\" ) buy_rsi_enabled = CategoricalParameter ([ True , False ], default = False , space = \"buy\" ) buy_trigger = CategoricalParameter ([ \"bb_lower\" , \"macd_cross_signal\" ], default = \"bb_lower\" , space = \"buy\" ) The above definition says: I have five parameters I want to randomly combine to find the best combination. buy_rsi is an integer parameter, which will be tested between 20 and 40. This space has a size of 20. buy_adx is a decimal parameter, which will be evaluated between 20 and 40 with 1 decimal place (so values are 20.1, 20.2, ...). This space has a size of 200. Then we have three category variables. First two are either True or False . We use these to either enable or disable the ADX and RSI guards. The last one we call trigger and use it to decide which buy trigger we want to use. Parameter space assignment Parameters must either be assigned to a variable named buy_* or sell_* - or contain space='buy' | space='sell' to be assigned to a space correctly. If no parameter is available for a space, you'll receive the error that no space was found when running hyperopt. Parameters with unclear space (e.g. adx_period = IntParameter(4, 24, default=14) - no explicit nor implicit space) will not be detected and will therefore be ignored. So let's write the buy strategy using these values: def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] # GUARDS AND TRENDS if self . buy_adx_enabled . value : conditions . append ( dataframe [ 'adx' ] > self . buy_adx . value ) if self . buy_rsi_enabled . value : conditions . append ( dataframe [ 'rsi' ] < self . buy_rsi . value ) # TRIGGERS if self . buy_trigger . value == 'bb_lower' : conditions . append ( dataframe [ 'close' ] < dataframe [ 'bb_lowerband' ]) if self . buy_trigger . value == 'macd_cross_signal' : conditions . append ( qtpylib . crossed_above ( dataframe [ 'macd' ], dataframe [ 'macdsignal' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'enter_long' ] = 1 return dataframe Hyperopt will now call populate_entry_trend() many times ( epochs ) with different value combinations. It will use the given historical data and simulate buys based on the buy signals generated with the above function. Based on the results, hyperopt will tell you which parameter combination produced the best results (based on the configured loss function ). Note The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the populate_indicators() method in your strategy or hyperopt file. Parameter types \u00b6 There are four parameter types each suited for different purposes. IntParameter - defines an integral parameter with upper and lower boundaries of search space. DecimalParameter - defines a floating point parameter with a limited number of decimals (default 3). Should be preferred instead of RealParameter in most cases. RealParameter - defines a floating point parameter with upper and lower boundaries and no precision limit. Rarely used as it creates a space with a near infinite number of possibilities. CategoricalParameter - defines a parameter with a predetermined number of choices. BooleanParameter - Shorthand for CategoricalParameter([True, False]) - great for \"enable\" parameters. Disabling parameter optimization Each parameter takes two boolean parameters: * load - when set to False it will not load values configured in buy_params and sell_params . * optimize - when set to False parameter will not be included in optimization process. Use these parameters to quickly prototype various ideas. Warning Hyperoptable parameters cannot be used in populate_indicators - as hyperopt does not recalculate indicators for each epoch, so the starting value would be used in this case. Optimizing an indicator parameter \u00b6 Assuming you have a simple strategy in mind - a EMA cross strategy (2 Moving averages crossing) - and you'd like to find the ideal parameters for this strategy. By default, we assume a stoploss of 5% - and a take-profit ( minimal_roi ) of 10% - which means freqtrade will sell the trade once 10% profit has been reached. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' minimal_roi = { \"0\" : 0.10 }, # Define the parameter spaces buy_ema_short = IntParameter ( 3 , 50 , default = 5 ) buy_ema_long = IntParameter ( 15 , 200 , default = 50 ) def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\"Generate all indicators used by the strategy\"\"\" # Calculate all ema_short values for val in self . buy_ema_short . range : dataframe [ f 'ema_short_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) # Calculate all ema_long values for val in self . buy_ema_long . range : dataframe [ f 'ema_long_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) return dataframe def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] conditions . append ( qtpylib . crossed_above ( dataframe [ f 'ema_short_ { self . buy_ema_short . value } ' ], dataframe [ f 'ema_long_ { self . buy_ema_long . value } ' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'enter_long' ] = 1 return dataframe def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] conditions . append ( qtpylib . crossed_above ( dataframe [ f 'ema_long_ { self . buy_ema_long . value } ' ], dataframe [ f 'ema_short_ { self . buy_ema_short . value } ' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'exit_long' ] = 1 return dataframe Breaking it down: Using self.buy_ema_short.range will return a range object containing all entries between the Parameters low and high value. In this case ( IntParameter(3, 50, default=5) ), the loop would run for all numbers between 3 and 50 ( [3, 4, 5, ... 49, 50] ). By using this in a loop, hyperopt will generate 48 new columns ( ['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50'] ). Hyperopt itself will then use the selected value to create the buy and sell signals. While this strategy is most likely too simple to provide consistent profit, it should serve as an example how optimize indicator parameters. Note self.buy_ema_short.range will act differently between hyperopt and other modes. For hyperopt, the above example may generate 48 new columns, however for all other modes (backtesting, dry/live), it will only generate the column for the selected value. You should therefore avoid using the resulting column with explicit values (values other than self.buy_ema_short.value ). Note range property may also be used with DecimalParameter and CategoricalParameter . RealParameter does not provide this property due to infinite search space. Performance tip During normal hyperopting, indicators are calculated once and supplied to each epoch, linearly increasing RAM usage as a factor of increasing cores. As this also has performance implications, hyperopt provides --analyze-per-epoch which will move the execution of populate_indicators() to the epoch process, calculating a single value per parameter per epoch instead of using the .range functionality. In this case, .range functionality will only return the actually used value. This will reduce RAM usage, but increase CPU usage. However, your hyperopting run will be less likely to fail due to Out Of Memory (OOM) issues. In either case, you should try to use space ranges as small as possible this will improve CPU/RAM usage in both scenarios. Optimizing protections \u00b6 Freqtrade can also optimize protections. How you optimize protections is up to you, and the following should be considered as example only. The strategy will simply need to define the \"protections\" entry as property returning a list of protection configurations. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' # Define the parameter spaces cooldown_lookback = IntParameter ( 2 , 48 , default = 5 , space = \"protection\" , optimize = True ) stop_duration = IntParameter ( 12 , 200 , default = 5 , space = \"protection\" , optimize = True ) use_stop_protection = BooleanParameter ( default = True , space = \"protection\" , optimize = True ) @property def protections ( self ): prot = [] prot . append ({ \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : self . cooldown_lookback . value }) if self . use_stop_protection . value : prot . append ({ \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 * 3 , \"trade_limit\" : 4 , \"stop_duration_candles\" : self . stop_duration . value , \"only_per_pair\" : False }) return prot def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # ... You can then run hyperopt as follows: freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection Note The protection space is not part of the default space, and is only available with the Parameters Hyperopt interface, not with the legacy hyperopt interface (which required separate hyperopt files). Freqtrade will also automatically change the \"--enable-protections\" flag if the protection space is selected. Warning If protections are defined as property, entries from the configuration will be ignored. It is therefore recommended to not define protections in the configuration. Migrating from previous property setups \u00b6 A migration from a previous setup is pretty simple, and can be accomplished by converting the protections entry to a property. In simple terms, the following configuration will be converted to the below. class MyAwesomeStrategy ( IStrategy ): protections = [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 4 } ] Result class MyAwesomeStrategy ( IStrategy ): @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 4 } ] You will then obviously also change potential interesting entries to parameters to allow hyper-optimization. Optimizing max_entry_position_adjustment \u00b6 While max_entry_position_adjustment is not a separate space, it can still be used in hyperopt by using the property approach shown above. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' # Define the parameter spaces max_epa = CategoricalParameter ([ - 1 , 0 , 1 , 3 , 5 , 10 ], default = 1 , space = \"buy\" , optimize = True ) @property def max_entry_position_adjustment ( self ): return self . max_epa . value def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # ... Using IntParameter You can also use the IntParameter for this optimization, but you must explicitly return an integer: max_epa = IntParameter ( - 1 , 10 , default = 1 , space = \"buy\" , optimize = True ) @property def max_entry_position_adjustment ( self ): return int ( self . max_epa . value ) Loss-functions \u00b6 Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results. A loss function must be specified via the --hyperopt-loss <Class-name> argument (or optionally via the configuration under the \"hyperopt_loss\" key). This class should be in its own file within the user_data/hyperopts/ directory. Currently, the following loss functions are builtin: ShortTradeDurHyperOptLoss - (default legacy Freqtrade hyperoptimization loss function) - Mostly for short trade duration and avoiding losses. OnlyProfitHyperOptLoss - takes only amount of profit into consideration. SharpeHyperOptLoss - optimizes Sharpe Ratio calculated on trade returns relative to standard deviation. SharpeHyperOptLossDaily - optimizes Sharpe Ratio calculated on daily trade returns relative to standard deviation. SortinoHyperOptLoss - optimizes Sortino Ratio calculated on trade returns relative to downside standard deviation. SortinoHyperOptLossDaily - optimizes Sortino Ratio calculated on daily trade returns relative to downside standard deviation. MaxDrawDownHyperOptLoss - Optimizes Maximum absolute drawdown. MaxDrawDownRelativeHyperOptLoss - Optimizes both maximum absolute drawdown while also adjusting for maximum relative drawdown. CalmarHyperOptLoss - Optimizes Calmar Ratio calculated on trade returns relative to max drawdown. ProfitDrawDownHyperOptLoss - Optimizes by max Profit & min Drawdown objective. DRAWDOWN_MULT variable within the hyperoptloss file can be adjusted to be stricter or more flexible on drawdown purposes. Creation of a custom loss function is covered in the Advanced Hyperopt part of the documentation. Execute Hyperopt \u00b6 Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result. We strongly recommend to use screen or tmux to prevent any connection loss. freqtrade hyperopt --config config.json --hyperopt-loss <hyperoptlossname> --strategy <strategyname> -e 500 --spaces all The -e option will set how many evaluations hyperopt will do. Since hyperopt uses Bayesian search, running too many epochs at once may not produce greater results. Experience has shown that best results are usually not improving much after 500-1000 epochs. Doing multiple runs (executions) with a few 1000 epochs and different random state will most likely produce different results. The --spaces all option determines that all possible parameters should be optimized. Possibilities are listed below. Note Hyperopt will store hyperopt results with the timestamp of the hyperopt start time. Reading commands ( hyperopt-list , hyperopt-show ) can use --hyperopt-filename <filename> to read and display older hyperopt results. You can find a list of filenames with ls -l user_data/hyperopt_results/ . Execute Hyperopt with different historical data source \u00b6 If you would like to hyperopt parameters using an alternate historical data set that you have on-disk, use the --datadir PATH option. By default, hyperopt uses data from directory user_data/data . Running Hyperopt with a smaller test-set \u00b6 Use the --timerange argument to change how much of the test-set you want to use. For example, to use one month of data, pass --timerange 20210101-20210201 (from january 2021 - february 2021) to the hyperopt call. Full command: freqtrade hyperopt --strategy <strategyname> --timerange 20210101 -20210201 Running Hyperopt with Smaller Search Space \u00b6 Use the --spaces option to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have. Legal values are: all : optimize everything buy : just search for a new buy strategy sell : just search for a new sell strategy roi : just optimize the minimal profit table for your strategy stoploss : search for the best stoploss value trailing : search for the best trailing stop values protection : search for the best protection parameters (read the protections section on how to properly define these) default : all except trailing and protection space-separated list of any of the above values for example --spaces roi stoploss The default Hyperopt Search Space, used when no --space command line option is specified, does not include the trailing hyperspace. We recommend you to run optimization for the trailing hyperspace separately, when the best parameters for other hyperspaces were found, validated and pasted into your custom strategy. Understand the Hyperopt Result \u00b6 Once Hyperopt is completed you can use the result to update your strategy. Given the following result from hyperopt: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } You should understand this result like: The buy trigger that worked best was bb_lower . You should not use ADX because 'buy_adx_enabled': False . You should consider using the RSI indicator ( 'buy_rsi_enabled': True ) and the best value is 29.0 ( 'buy_rsi': 29.0 ) Automatic parameter application to the strategy \u00b6 When using Hyperoptable parameters, the result of your hyperopt-run will be written to a json file next to your strategy (so for MyAwesomeStrategy.py , the file would be MyAwesomeStrategy.json ). This file is also updated when using the hyperopt-show sub-command, unless --disable-param-export is provided to either of the 2 commands. Your strategy class can also contain these results explicitly. Simply copy hyperopt results block and paste them at class level, replacing old parameters (if any). New parameters will automatically be loaded next time strategy is executed. Transferring your whole hyperopt result to your strategy would then look like: class MyAwesomeStrategy ( IStrategy ): # Buy hyperspace params: buy_params = { 'buy_adx' : 44 , 'buy_rsi' : 29 , 'buy_adx_enabled' : False , 'buy_rsi_enabled' : True , 'buy_trigger' : 'bb_lower' } Note Values in the configuration file will overwrite Parameter-file level parameters - and both will overwrite parameters within the strategy. The prevalence is therefore: config > parameter file > strategy *_params > parameter default Understand Hyperopt ROI results \u00b6 If you are optimizing ROI (i.e. if optimization search-space contains 'all', 'default' or 'roi'), your result will look as follows and include a ROI table: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # ROI table: minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } In order to use this best ROI table found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the minimal_roi attribute of your custom strategy: # Minimal ROI designed for the strategy. # This attribute will be overridden if the config file contains \"minimal_roi\" minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } As stated in the comment, you can also use it as the value of the minimal_roi setting in the configuration file. Default ROI Search Space \u00b6 If you are optimizing ROI, Freqtrade creates the 'roi' optimization hyperspace for you -- it's the hyperspace of components for the ROI tables. By default, each ROI table generated by the Freqtrade consists of 4 rows (steps). Hyperopt implements adaptive ranges for ROI tables with ranges for values in the ROI steps that depend on the timeframe used. By default the values vary in the following ranges (for some of the most used timeframes, values are rounded to 3 digits after the decimal point): # step 1m 5m 1h 1d 1 0 0.011...0.119 0 0.03...0.31 0 0.068...0.711 0 0.121...1.258 2 2...8 0.007...0.042 10...40 0.02...0.11 120...480 0.045...0.252 2880...11520 0.081...0.446 3 4...20 0.003...0.015 20...100 0.01...0.04 240...1200 0.022...0.091 5760...28800 0.040...0.162 4 6...44 0.0 30...220 0.0 360...2640 0.0 8640...63360 0.0 These ranges should be sufficient in most cases. The minutes in the steps (ROI dict keys) are scaled linearly depending on the timeframe used. The ROI values in the steps (ROI dict values) are scaled logarithmically depending on the timeframe used. If you have the generate_roi_table() and roi_space() methods in your custom hyperopt, remove them in order to utilize these adaptive ROI tables and the ROI hyperoptimization space generated by Freqtrade by default. Override the roi_space() method if you need components of the ROI tables to vary in other ranges. Override the generate_roi_table() and roi_space() methods and implement your own custom approach for generation of the ROI tables during hyperoptimization if you need a different structure of the ROI tables or other amount of rows (steps). A sample for these methods can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Understand Hyperopt Stoploss results \u00b6 If you are optimizing stoploss values (i.e. if optimization search-space contains 'all', 'default' or 'stoploss'), your result will look as follows and include stoploss: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } stoploss: -0.27996 In order to use this best stoploss value found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the stoploss attribute of your custom strategy: # Optimal stoploss designed for the strategy # This attribute will be overridden if the config file contains \"stoploss\" stoploss = - 0.27996 As stated in the comment, you can also use it as the value of the stoploss setting in the configuration file. Default Stoploss Search Space \u00b6 If you are optimizing stoploss values, Freqtrade creates the 'stoploss' optimization hyperspace for you. By default, the stoploss values in that hyperspace vary in the range -0.35...-0.02, which is sufficient in most cases. If you have the stoploss_space() method in your custom hyperopt file, remove it in order to utilize Stoploss hyperoptimization space generated by Freqtrade by default. Override the stoploss_space() method and define the desired range in it if you need stoploss values to vary in other range during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Understand Hyperopt Trailing Stop results \u00b6 If you are optimizing trailing stop values (i.e. if optimization search-space contains 'all' or 'trailing'), your result will look as follows and include trailing stop parameters: Best result: 45/100: 606 trades. Avg profit 1.04%. Total profit 0.31555614 BTC ( 630.48%). Avg duration 150.3 mins. Objective: -1.10161 # Trailing stop: trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True In order to use these best trailing stop parameters found by Hyperopt in backtesting and for live trades/dry-run, copy-paste them as the values of the corresponding attributes of your custom strategy: # Trailing stop # These attributes will be overridden if the config file contains corresponding values. trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True As stated in the comment, you can also use it as the values of the corresponding settings in the configuration file. Default Trailing Stop Search Space \u00b6 If you are optimizing trailing stop values, Freqtrade creates the 'trailing' optimization hyperspace for you. By default, the trailing_stop parameter is always set to True in that hyperspace, the value of the trailing_only_offset_is_reached vary between True and False, the values of the trailing_stop_positive and trailing_stop_positive_offset parameters vary in the ranges 0.02...0.35 and 0.01...0.1 correspondingly, which is sufficient in most cases. Override the trailing_space() method and define the desired range in it if you need values of the trailing stop parameters to vary in other ranges during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs. Reproducible results \u00b6 The search for optimal parameters starts with a few (currently 30) random combinations in the hyperspace of parameters, random Hyperopt epochs. These random epochs are marked with an asterisk character ( * ) in the first column in the Hyperopt output. The initial state for generation of these random values (random state) is controlled by the value of the --random-state command line option. You can set it to some arbitrary value of your choice to obtain reproducible results. If you have not set this value explicitly in the command line options, Hyperopt seeds the random state with some random value for you. The random state value for each Hyperopt run is shown in the log, so you can copy and paste it into the --random-state command line option to repeat the set of the initial random epochs used. If you have not changed anything in the command line options, configuration, timerange, Strategy and Hyperopt classes, historical data and the Loss Function -- you should obtain same hyper-optimization results with same random state value used. Output formatting \u00b6 By default, hyperopt prints colorized results -- epochs with positive profit are printed in the green color. This highlighting helps you find epochs that can be interesting for later analysis. Epochs with zero total profit or with negative profits (losses) are printed in the normal color. If you do not need colorization of results (for instance, when you are redirecting hyperopt output to a file) you can switch colorization off by specifying the --no-color option in the command line. You can use the --print-all command line option if you would like to see all results in the hyperopt output, not only the best ones. When --print-all is used, current best results are also colorized by default -- they are printed in bold (bright) style. This can also be switched off with the --no-color command line option. Windows and color output Windows does not support color-output natively, therefore it is automatically disabled. To have color-output for hyperopt running under windows, please consider using WSL. Position stacking and disabling max market positions \u00b6 In some situations, you may need to run Hyperopt (and Backtesting) with the --eps / --enable-position-staking and --dmmp / --disable-max-market-positions arguments. By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs is also limited by the max_open_trades setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previously open trades. The --eps / --enable-position-stacking argument allows emulation of buying the same pair multiple times, while --dmmp / --disable-max-market-positions disables applying max_open_trades during Hyperopt/Backtesting (which is equal to setting max_open_trades to a very high number). Note Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality. You can also enable position stacking in the configuration file by explicitly setting \"position_stacking\"=true . Out of Memory errors \u00b6 As hyperopt consumes a lot of memory (the complete data needs to be in memory once per parallel backtesting process), it's likely that you run into \"out of memory\" errors. To combat these, you have multiple options: Reduce the amount of pairs. Reduce the timerange used ( --timerange <timerange> ). Avoid using --timeframe-detail (this loads a lot of additional data into memory). Reduce the number of parallel processes ( -j <n> ). Increase the memory of your machine. Use --analyze-per-epoch if you're using a lot of parameters with .range functionality. The objective has been evaluated at this point before. \u00b6 If you see The objective has been evaluated at this point before. - then this is a sign that your space has been exhausted, or is close to that. Basically all points in your space have been hit (or a local minima has been hit) - and hyperopt does no longer find points in the multi-dimensional space it did not try yet. Freqtrade tries to counter the \"local minima\" problem by using new, randomized points in this case. Example: buy_ema_short = IntParameter ( 5 , 20 , default = 10 , space = \"buy\" , optimize = True ) # This is the only parameter in the buy space The buy_ema_short space has 15 possible values ( 5, 6, ... 19, 20 ). If you now run hyperopt for the buy space, hyperopt will only have 15 values to try before running out of options. Your epochs should therefore be aligned to the possible values - or you should be ready to interrupt a run if you norice a lot of The objective has been evaluated at this point before. warnings. Show details of Hyperopt results \u00b6 After you run Hyperopt for the desired amount of epochs, you can later list all results for analysis, select only best or profitable once, and show the details for any of the epochs previously evaluated. This can be done with the hyperopt-list and hyperopt-show sub-commands. The usage of these sub-commands is described in the Utils chapter. Validate backtesting results \u00b6 Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected. To achieve same the results (number of trades, their durations, profit, etc.) as during Hyperopt, please use the same configuration and parameters (timerange, timeframe, ...) used for hyperopt --dmmp / --disable-max-market-positions and --eps / --enable-position-stacking for Backtesting. Should results not match, please double-check to make sure you transferred all conditions correctly. Pay special care to the stoploss (and trailing stoploss) parameters, as these are often set in configuration files, which override changes to the strategy. You should also carefully review the log of your backtest to ensure that there were no parameters inadvertently set by the configuration (like stoploss or trailing_stop ).","title":"Hyperopt"},{"location":"hyperopt/#hyperopt","text":"This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses algorithms included in the scikit-optimize package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time. In general, the search for best parameters starts with a few random combinations (see below for more details) and then uses Bayesian search with a ML regressor algorithm (currently ExtraTreesRegressor) to quickly find a combination of parameters in the search hyperspace that minimizes the value of the loss function . Hyperopt requires historic data to be available, just as backtesting does (hyperopt runs backtesting many times with different parameters). To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation. Bug Hyperopt can crash when used with only 1 CPU Core as found out in Issue #1133 Note Since 2021.4 release you no longer have to write a separate hyperopt class, but can configure the parameters directly in the strategy. The legacy method is still supported, but it is no longer the recommended way of setting up hyperopt. The legacy documentation is available at Legacy Hyperopt .","title":"Hyperopt"},{"location":"hyperopt/#install-hyperopt-dependencies","text":"Since Hyperopt dependencies are not needed to run the bot itself, are heavy, can not be easily built on some platforms (like Raspberry PI), they are not installed by default. Before you run Hyperopt, you need to install the corresponding dependencies, as described in this section below. Note Since Hyperopt is a resource intensive process, running it on a Raspberry Pi is not recommended nor supported.","title":"Install hyperopt dependencies"},{"location":"hyperopt/#docker","text":"The docker-image includes hyperopt dependencies, no further action needed.","title":"Docker"},{"location":"hyperopt/#easy-installation-script-setupsh-manual-installation","text":"source .env/bin/activate pip install -r requirements-hyperopt.txt","title":"Easy installation script (setup.sh) / Manual installation"},{"location":"hyperopt/#hyperopt-command-reference","text":"usage: freqtrade hyperopt [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [--recursive-strategy-search] [--freqaimodel NAME] [--freqaimodel-path PATH] [-i TIMEFRAME] [--timerange TIMERANGE] [--data-format-ohlcv {json,jsongz,hdf5}] [--max-open-trades INT] [--stake-amount STAKE_AMOUNT] [--fee FLOAT] [-p PAIRS [PAIRS ...]] [--hyperopt-path PATH] [--eps] [--dmmp] [--enable-protections] [--dry-run-wallet DRY_RUN_WALLET] [--timeframe-detail TIMEFRAME_DETAIL] [-e INT] [--spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...]] [--print-all] [--no-color] [--print-json] [-j JOBS] [--random-state INT] [--min-trades INT] [--hyperopt-loss NAME] [--disable-param-export] [--ignore-missing-spaces] [--analyze-per-epoch] optional arguments: -h, --help show this help message and exit -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --timerange TIMERANGE Specify what timerange of data to use. --data-format-ohlcv {json,jsongz,hdf5} Storage format for downloaded candle (OHLCV) data. (default: `json`). --max-open-trades INT Override the value of the `max_open_trades` configuration setting. --stake-amount STAKE_AMOUNT Override the value of the `stake_amount` configuration setting. --fee FLOAT Specify fee ratio. Will be applied twice (on trade entry and exit). -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --hyperopt-path PATH Specify additional lookup path for Hyperopt Loss functions. --eps, --enable-position-stacking Allow buying the same pair multiple times (position stacking). --dmmp, --disable-max-market-positions Disable applying `max_open_trades` during backtest (same as setting `max_open_trades` to a very high number). --enable-protections, --enableprotections Enable protections for backtesting.Will slow backtesting down by a considerable amount, but will include configured protections --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET Starting balance, used for backtesting / hyperopt and dry-runs. --timeframe-detail TIMEFRAME_DETAIL Specify detail timeframe for backtesting (`1m`, `5m`, `30m`, `1h`, `1d`). -e INT, --epochs INT Specify number of epochs (default: 100). --spaces {all,buy,sell,roi,stoploss,trailing,protection,default} [{all,buy,sell,roi,stoploss,trailing,protection,default} ...] Specify which parameters to hyperopt. Space-separated list. --print-all Print all results, not only the best ones. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. -j JOBS, --job-workers JOBS The number of concurrently running jobs for hyperoptimization (hyperopt worker processes). If -1 (default), all CPUs are used, for -2, all CPUs but one are used, etc. If 1 is given, no parallel computing code is used at all. --random-state INT Set random state to some positive integer for reproducible hyperopt results. --min-trades INT Set minimal desired number of trades for evaluations in the hyperopt optimization path (default: 1). --hyperopt-loss NAME, --hyperoptloss NAME Specify the class name of the hyperopt loss function class (IHyperOptLoss). Different functions can generate completely different results, since the target for optimization is different. Built-in Hyperopt-loss-functions are: ShortTradeDurHyperOptLoss, OnlyProfitHyperOptLoss, SharpeHyperOptLoss, SharpeHyperOptLossDaily, SortinoHyperOptLoss, SortinoHyperOptLossDaily, CalmarHyperOptLoss, MaxDrawDownHyperOptLoss, MaxDrawDownRelativeHyperOptLoss, ProfitDrawDownHyperOptLoss --disable-param-export Disable automatic hyperopt parameter export. --ignore-missing-spaces, --ignore-unparameterized-spaces Suppress errors for any requested Hyperopt spaces that do not contain any parameters. --analyze-per-epoch Run populate_indicators once per epoch. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. --recursive-strategy-search Recursively search for a strategy in the strategies folder. --freqaimodel NAME Specify a custom freqaimodels. --freqaimodel-path PATH Specify additional lookup path for freqaimodels.","title":"Hyperopt command reference"},{"location":"hyperopt/#hyperopt-checklist","text":"Checklist on all tasks / possibilities in hyperopt Depending on the space you want to optimize, only some of the below are required: define parameters with space='buy' - for entry signal optimization define parameters with space='sell' - for exit signal optimization Note populate_indicators needs to create all indicators any of the spaces may use, otherwise hyperopt will not work. Rarely you may also need to create a nested class named HyperOpt and implement roi_space - for custom ROI optimization (if you need the ranges for the ROI parameters in the optimization hyperspace that differ from default) generate_roi_table - for custom ROI optimization (if you need the ranges for the values in the ROI table that differ from default or the number of entries (steps) in the ROI table which differs from the default 4 steps) stoploss_space - for custom stoploss optimization (if you need the range for the stoploss parameter in the optimization hyperspace that differs from default) trailing_space - for custom trailing stop optimization (if you need the ranges for the trailing stop parameters in the optimization hyperspace that differ from default) Quickly optimize ROI, stoploss and trailing stoploss You can quickly optimize the spaces roi , stoploss and trailing without changing anything in your strategy. # Have a working strategy at hand. freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --spaces roi stoploss trailing --strategy MyWorkingStrategy --config config.json -e 100","title":"Hyperopt checklist"},{"location":"hyperopt/#hyperopt-execution-logic","text":"Hyperopt will first load your data into memory and will then run populate_indicators() once per Pair to generate all indicators, unless --analyze-per-epoch is specified. Hyperopt will then spawn into different processes (number of processors, or -j <n> ), and run backtesting over and over again, changing the parameters that are part of the --spaces defined. For every new set of parameters, freqtrade will run first populate_entry_trend() followed by populate_exit_trend() , and then run the regular backtesting process to simulate trades. After backtesting, the results are passed into the loss function , which will evaluate if this result was better or worse than previous results. Based on the loss function result, hyperopt will determine the next set of parameters to try in the next round of backtesting.","title":"Hyperopt execution logic"},{"location":"hyperopt/#configure-your-guards-and-triggers","text":"There are two places you need to change in your strategy file to add a new buy hyperopt for testing: Define the parameters at the class level hyperopt shall be optimizing. Within populate_entry_trend() - use defined parameter values instead of raw constants. There you have two different types of indicators: 1. guards and 2. triggers . Guards are conditions like \"never buy if ADX < 10\", or never buy if current price is over EMA10. Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower Bollinger band\". Guards and Triggers Technically, there is no difference between Guards and Triggers. However, this guide will make this distinction to make it clear that signals should not be \"sticking\". Sticking signals are signals that are active for multiple candles. This can lead into entering a signal late (right before the signal disappears - which means that the chance of success is a lot lower than right at the beginning). Hyper-optimization will, for each epoch round, pick one trigger and possibly multiple guards.","title":"Configure your Guards and Triggers"},{"location":"hyperopt/#exit-signal-optimization","text":"Similar to the entry-signal above, exit-signals can also be optimized. Place the corresponding settings into the following methods Define the parameters at the class level hyperopt shall be optimizing, either naming them sell_* , or by explicitly defining space='sell' . Within populate_exit_trend() - use defined parameter values instead of raw constants. The configuration and rules are the same than for buy signals.","title":"Exit signal optimization"},{"location":"hyperopt/#solving-a-mystery","text":"Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your long entries. And you also wonder should you use RSI or ADX to help with those decisions. If you decide to use RSI or ADX, which values should I use for them? So let's use hyperparameter optimization to solve this mystery.","title":"Solving a Mystery"},{"location":"hyperopt/#defining-indicators-to-be-used","text":"We start by calculating the indicators our strategy is going to use. class MyAwesomeStrategy ( IStrategy ): def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Generate all indicators used by the strategy \"\"\" dataframe [ 'adx' ] = ta . ADX ( dataframe ) dataframe [ 'rsi' ] = ta . RSI ( dataframe ) macd = ta . MACD ( dataframe ) dataframe [ 'macd' ] = macd [ 'macd' ] dataframe [ 'macdsignal' ] = macd [ 'macdsignal' ] dataframe [ 'macdhist' ] = macd [ 'macdhist' ] bollinger = ta . BBANDS ( dataframe , timeperiod = 20 , nbdevup = 2.0 , nbdevdn = 2.0 ) dataframe [ 'bb_lowerband' ] = bollinger [ 'lowerband' ] dataframe [ 'bb_middleband' ] = bollinger [ 'middleband' ] dataframe [ 'bb_upperband' ] = bollinger [ 'upperband' ] return dataframe","title":"Defining indicators to be used"},{"location":"hyperopt/#hyperoptable-parameters","text":"We continue to define hyperoptable parameters: class MyAwesomeStrategy ( IStrategy ): buy_adx = DecimalParameter ( 20 , 40 , decimals = 1 , default = 30.1 , space = \"buy\" ) buy_rsi = IntParameter ( 20 , 40 , default = 30 , space = \"buy\" ) buy_adx_enabled = BooleanParameter ( default = True , space = \"buy\" ) buy_rsi_enabled = CategoricalParameter ([ True , False ], default = False , space = \"buy\" ) buy_trigger = CategoricalParameter ([ \"bb_lower\" , \"macd_cross_signal\" ], default = \"bb_lower\" , space = \"buy\" ) The above definition says: I have five parameters I want to randomly combine to find the best combination. buy_rsi is an integer parameter, which will be tested between 20 and 40. This space has a size of 20. buy_adx is a decimal parameter, which will be evaluated between 20 and 40 with 1 decimal place (so values are 20.1, 20.2, ...). This space has a size of 200. Then we have three category variables. First two are either True or False . We use these to either enable or disable the ADX and RSI guards. The last one we call trigger and use it to decide which buy trigger we want to use. Parameter space assignment Parameters must either be assigned to a variable named buy_* or sell_* - or contain space='buy' | space='sell' to be assigned to a space correctly. If no parameter is available for a space, you'll receive the error that no space was found when running hyperopt. Parameters with unclear space (e.g. adx_period = IntParameter(4, 24, default=14) - no explicit nor implicit space) will not be detected and will therefore be ignored. So let's write the buy strategy using these values: def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] # GUARDS AND TRENDS if self . buy_adx_enabled . value : conditions . append ( dataframe [ 'adx' ] > self . buy_adx . value ) if self . buy_rsi_enabled . value : conditions . append ( dataframe [ 'rsi' ] < self . buy_rsi . value ) # TRIGGERS if self . buy_trigger . value == 'bb_lower' : conditions . append ( dataframe [ 'close' ] < dataframe [ 'bb_lowerband' ]) if self . buy_trigger . value == 'macd_cross_signal' : conditions . append ( qtpylib . crossed_above ( dataframe [ 'macd' ], dataframe [ 'macdsignal' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'enter_long' ] = 1 return dataframe Hyperopt will now call populate_entry_trend() many times ( epochs ) with different value combinations. It will use the given historical data and simulate buys based on the buy signals generated with the above function. Based on the results, hyperopt will tell you which parameter combination produced the best results (based on the configured loss function ). Note The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the populate_indicators() method in your strategy or hyperopt file.","title":"Hyperoptable parameters"},{"location":"hyperopt/#parameter-types","text":"There are four parameter types each suited for different purposes. IntParameter - defines an integral parameter with upper and lower boundaries of search space. DecimalParameter - defines a floating point parameter with a limited number of decimals (default 3). Should be preferred instead of RealParameter in most cases. RealParameter - defines a floating point parameter with upper and lower boundaries and no precision limit. Rarely used as it creates a space with a near infinite number of possibilities. CategoricalParameter - defines a parameter with a predetermined number of choices. BooleanParameter - Shorthand for CategoricalParameter([True, False]) - great for \"enable\" parameters. Disabling parameter optimization Each parameter takes two boolean parameters: * load - when set to False it will not load values configured in buy_params and sell_params . * optimize - when set to False parameter will not be included in optimization process. Use these parameters to quickly prototype various ideas. Warning Hyperoptable parameters cannot be used in populate_indicators - as hyperopt does not recalculate indicators for each epoch, so the starting value would be used in this case.","title":"Parameter types"},{"location":"hyperopt/#optimizing-an-indicator-parameter","text":"Assuming you have a simple strategy in mind - a EMA cross strategy (2 Moving averages crossing) - and you'd like to find the ideal parameters for this strategy. By default, we assume a stoploss of 5% - and a take-profit ( minimal_roi ) of 10% - which means freqtrade will sell the trade once 10% profit has been reached. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' minimal_roi = { \"0\" : 0.10 }, # Define the parameter spaces buy_ema_short = IntParameter ( 3 , 50 , default = 5 ) buy_ema_long = IntParameter ( 15 , 200 , default = 50 ) def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\"Generate all indicators used by the strategy\"\"\" # Calculate all ema_short values for val in self . buy_ema_short . range : dataframe [ f 'ema_short_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) # Calculate all ema_long values for val in self . buy_ema_long . range : dataframe [ f 'ema_long_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) return dataframe def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] conditions . append ( qtpylib . crossed_above ( dataframe [ f 'ema_short_ { self . buy_ema_short . value } ' ], dataframe [ f 'ema_long_ { self . buy_ema_long . value } ' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'enter_long' ] = 1 return dataframe def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : conditions = [] conditions . append ( qtpylib . crossed_above ( dataframe [ f 'ema_long_ { self . buy_ema_long . value } ' ], dataframe [ f 'ema_short_ { self . buy_ema_short . value } ' ] )) # Check that volume is not 0 conditions . append ( dataframe [ 'volume' ] > 0 ) if conditions : dataframe . loc [ reduce ( lambda x , y : x & y , conditions ), 'exit_long' ] = 1 return dataframe Breaking it down: Using self.buy_ema_short.range will return a range object containing all entries between the Parameters low and high value. In this case ( IntParameter(3, 50, default=5) ), the loop would run for all numbers between 3 and 50 ( [3, 4, 5, ... 49, 50] ). By using this in a loop, hyperopt will generate 48 new columns ( ['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50'] ). Hyperopt itself will then use the selected value to create the buy and sell signals. While this strategy is most likely too simple to provide consistent profit, it should serve as an example how optimize indicator parameters. Note self.buy_ema_short.range will act differently between hyperopt and other modes. For hyperopt, the above example may generate 48 new columns, however for all other modes (backtesting, dry/live), it will only generate the column for the selected value. You should therefore avoid using the resulting column with explicit values (values other than self.buy_ema_short.value ). Note range property may also be used with DecimalParameter and CategoricalParameter . RealParameter does not provide this property due to infinite search space. Performance tip During normal hyperopting, indicators are calculated once and supplied to each epoch, linearly increasing RAM usage as a factor of increasing cores. As this also has performance implications, hyperopt provides --analyze-per-epoch which will move the execution of populate_indicators() to the epoch process, calculating a single value per parameter per epoch instead of using the .range functionality. In this case, .range functionality will only return the actually used value. This will reduce RAM usage, but increase CPU usage. However, your hyperopting run will be less likely to fail due to Out Of Memory (OOM) issues. In either case, you should try to use space ranges as small as possible this will improve CPU/RAM usage in both scenarios.","title":"Optimizing an indicator parameter"},{"location":"hyperopt/#optimizing-protections","text":"Freqtrade can also optimize protections. How you optimize protections is up to you, and the following should be considered as example only. The strategy will simply need to define the \"protections\" entry as property returning a list of protection configurations. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' # Define the parameter spaces cooldown_lookback = IntParameter ( 2 , 48 , default = 5 , space = \"protection\" , optimize = True ) stop_duration = IntParameter ( 12 , 200 , default = 5 , space = \"protection\" , optimize = True ) use_stop_protection = BooleanParameter ( default = True , space = \"protection\" , optimize = True ) @property def protections ( self ): prot = [] prot . append ({ \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : self . cooldown_lookback . value }) if self . use_stop_protection . value : prot . append ({ \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 * 3 , \"trade_limit\" : 4 , \"stop_duration_candles\" : self . stop_duration . value , \"only_per_pair\" : False }) return prot def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # ... You can then run hyperopt as follows: freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection Note The protection space is not part of the default space, and is only available with the Parameters Hyperopt interface, not with the legacy hyperopt interface (which required separate hyperopt files). Freqtrade will also automatically change the \"--enable-protections\" flag if the protection space is selected. Warning If protections are defined as property, entries from the configuration will be ignored. It is therefore recommended to not define protections in the configuration.","title":"Optimizing protections"},{"location":"hyperopt/#migrating-from-previous-property-setups","text":"A migration from a previous setup is pretty simple, and can be accomplished by converting the protections entry to a property. In simple terms, the following configuration will be converted to the below. class MyAwesomeStrategy ( IStrategy ): protections = [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 4 } ] Result class MyAwesomeStrategy ( IStrategy ): @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 4 } ] You will then obviously also change potential interesting entries to parameters to allow hyper-optimization.","title":"Migrating from previous property setups"},{"location":"hyperopt/#optimizing-max_entry_position_adjustment","text":"While max_entry_position_adjustment is not a separate space, it can still be used in hyperopt by using the property approach shown above. from pandas import DataFrame from functools import reduce import talib.abstract as ta from freqtrade.strategy import ( BooleanParameter , CategoricalParameter , DecimalParameter , IStrategy , IntParameter ) import freqtrade.vendor.qtpylib.indicators as qtpylib class MyAwesomeStrategy ( IStrategy ): stoploss = - 0.05 timeframe = '15m' # Define the parameter spaces max_epa = CategoricalParameter ([ - 1 , 0 , 1 , 3 , 5 , 10 ], default = 1 , space = \"buy\" , optimize = True ) @property def max_entry_position_adjustment ( self ): return self . max_epa . value def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # ... Using IntParameter You can also use the IntParameter for this optimization, but you must explicitly return an integer: max_epa = IntParameter ( - 1 , 10 , default = 1 , space = \"buy\" , optimize = True ) @property def max_entry_position_adjustment ( self ): return int ( self . max_epa . value )","title":"Optimizing max_entry_position_adjustment"},{"location":"hyperopt/#loss-functions","text":"Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results. A loss function must be specified via the --hyperopt-loss <Class-name> argument (or optionally via the configuration under the \"hyperopt_loss\" key). This class should be in its own file within the user_data/hyperopts/ directory. Currently, the following loss functions are builtin: ShortTradeDurHyperOptLoss - (default legacy Freqtrade hyperoptimization loss function) - Mostly for short trade duration and avoiding losses. OnlyProfitHyperOptLoss - takes only amount of profit into consideration. SharpeHyperOptLoss - optimizes Sharpe Ratio calculated on trade returns relative to standard deviation. SharpeHyperOptLossDaily - optimizes Sharpe Ratio calculated on daily trade returns relative to standard deviation. SortinoHyperOptLoss - optimizes Sortino Ratio calculated on trade returns relative to downside standard deviation. SortinoHyperOptLossDaily - optimizes Sortino Ratio calculated on daily trade returns relative to downside standard deviation. MaxDrawDownHyperOptLoss - Optimizes Maximum absolute drawdown. MaxDrawDownRelativeHyperOptLoss - Optimizes both maximum absolute drawdown while also adjusting for maximum relative drawdown. CalmarHyperOptLoss - Optimizes Calmar Ratio calculated on trade returns relative to max drawdown. ProfitDrawDownHyperOptLoss - Optimizes by max Profit & min Drawdown objective. DRAWDOWN_MULT variable within the hyperoptloss file can be adjusted to be stricter or more flexible on drawdown purposes. Creation of a custom loss function is covered in the Advanced Hyperopt part of the documentation.","title":"Loss-functions"},{"location":"hyperopt/#execute-hyperopt","text":"Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result. We strongly recommend to use screen or tmux to prevent any connection loss. freqtrade hyperopt --config config.json --hyperopt-loss <hyperoptlossname> --strategy <strategyname> -e 500 --spaces all The -e option will set how many evaluations hyperopt will do. Since hyperopt uses Bayesian search, running too many epochs at once may not produce greater results. Experience has shown that best results are usually not improving much after 500-1000 epochs. Doing multiple runs (executions) with a few 1000 epochs and different random state will most likely produce different results. The --spaces all option determines that all possible parameters should be optimized. Possibilities are listed below. Note Hyperopt will store hyperopt results with the timestamp of the hyperopt start time. Reading commands ( hyperopt-list , hyperopt-show ) can use --hyperopt-filename <filename> to read and display older hyperopt results. You can find a list of filenames with ls -l user_data/hyperopt_results/ .","title":"Execute Hyperopt"},{"location":"hyperopt/#execute-hyperopt-with-different-historical-data-source","text":"If you would like to hyperopt parameters using an alternate historical data set that you have on-disk, use the --datadir PATH option. By default, hyperopt uses data from directory user_data/data .","title":"Execute Hyperopt with different historical data source"},{"location":"hyperopt/#running-hyperopt-with-a-smaller-test-set","text":"Use the --timerange argument to change how much of the test-set you want to use. For example, to use one month of data, pass --timerange 20210101-20210201 (from january 2021 - february 2021) to the hyperopt call. Full command: freqtrade hyperopt --strategy <strategyname> --timerange 20210101 -20210201","title":"Running Hyperopt with a smaller test-set"},{"location":"hyperopt/#running-hyperopt-with-smaller-search-space","text":"Use the --spaces option to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have. Legal values are: all : optimize everything buy : just search for a new buy strategy sell : just search for a new sell strategy roi : just optimize the minimal profit table for your strategy stoploss : search for the best stoploss value trailing : search for the best trailing stop values protection : search for the best protection parameters (read the protections section on how to properly define these) default : all except trailing and protection space-separated list of any of the above values for example --spaces roi stoploss The default Hyperopt Search Space, used when no --space command line option is specified, does not include the trailing hyperspace. We recommend you to run optimization for the trailing hyperspace separately, when the best parameters for other hyperspaces were found, validated and pasted into your custom strategy.","title":"Running Hyperopt with Smaller Search Space"},{"location":"hyperopt/#understand-the-hyperopt-result","text":"Once Hyperopt is completed you can use the result to update your strategy. Given the following result from hyperopt: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } You should understand this result like: The buy trigger that worked best was bb_lower . You should not use ADX because 'buy_adx_enabled': False . You should consider using the RSI indicator ( 'buy_rsi_enabled': True ) and the best value is 29.0 ( 'buy_rsi': 29.0 )","title":"Understand the Hyperopt Result"},{"location":"hyperopt/#automatic-parameter-application-to-the-strategy","text":"When using Hyperoptable parameters, the result of your hyperopt-run will be written to a json file next to your strategy (so for MyAwesomeStrategy.py , the file would be MyAwesomeStrategy.json ). This file is also updated when using the hyperopt-show sub-command, unless --disable-param-export is provided to either of the 2 commands. Your strategy class can also contain these results explicitly. Simply copy hyperopt results block and paste them at class level, replacing old parameters (if any). New parameters will automatically be loaded next time strategy is executed. Transferring your whole hyperopt result to your strategy would then look like: class MyAwesomeStrategy ( IStrategy ): # Buy hyperspace params: buy_params = { 'buy_adx' : 44 , 'buy_rsi' : 29 , 'buy_adx_enabled' : False , 'buy_rsi_enabled' : True , 'buy_trigger' : 'bb_lower' } Note Values in the configuration file will overwrite Parameter-file level parameters - and both will overwrite parameters within the strategy. The prevalence is therefore: config > parameter file > strategy *_params > parameter default","title":"Automatic parameter application to the strategy"},{"location":"hyperopt/#understand-hyperopt-roi-results","text":"If you are optimizing ROI (i.e. if optimization search-space contains 'all', 'default' or 'roi'), your result will look as follows and include a ROI table: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # ROI table: minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } In order to use this best ROI table found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the minimal_roi attribute of your custom strategy: # Minimal ROI designed for the strategy. # This attribute will be overridden if the config file contains \"minimal_roi\" minimal_roi = { 0: 0.10674, 21: 0.09158, 78: 0.03634, 118: 0 } As stated in the comment, you can also use it as the value of the minimal_roi setting in the configuration file.","title":"Understand Hyperopt ROI results"},{"location":"hyperopt/#default-roi-search-space","text":"If you are optimizing ROI, Freqtrade creates the 'roi' optimization hyperspace for you -- it's the hyperspace of components for the ROI tables. By default, each ROI table generated by the Freqtrade consists of 4 rows (steps). Hyperopt implements adaptive ranges for ROI tables with ranges for values in the ROI steps that depend on the timeframe used. By default the values vary in the following ranges (for some of the most used timeframes, values are rounded to 3 digits after the decimal point): # step 1m 5m 1h 1d 1 0 0.011...0.119 0 0.03...0.31 0 0.068...0.711 0 0.121...1.258 2 2...8 0.007...0.042 10...40 0.02...0.11 120...480 0.045...0.252 2880...11520 0.081...0.446 3 4...20 0.003...0.015 20...100 0.01...0.04 240...1200 0.022...0.091 5760...28800 0.040...0.162 4 6...44 0.0 30...220 0.0 360...2640 0.0 8640...63360 0.0 These ranges should be sufficient in most cases. The minutes in the steps (ROI dict keys) are scaled linearly depending on the timeframe used. The ROI values in the steps (ROI dict values) are scaled logarithmically depending on the timeframe used. If you have the generate_roi_table() and roi_space() methods in your custom hyperopt, remove them in order to utilize these adaptive ROI tables and the ROI hyperoptimization space generated by Freqtrade by default. Override the roi_space() method if you need components of the ROI tables to vary in other ranges. Override the generate_roi_table() and roi_space() methods and implement your own custom approach for generation of the ROI tables during hyperoptimization if you need a different structure of the ROI tables or other amount of rows (steps). A sample for these methods can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default ROI Search Space"},{"location":"hyperopt/#understand-hyperopt-stoploss-results","text":"If you are optimizing stoploss values (i.e. if optimization search-space contains 'all', 'default' or 'stoploss'), your result will look as follows and include stoploss: Best result: 44/100: 135 trades. Avg profit 0.57%. Total profit 0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367 # Buy hyperspace params: buy_params = { 'buy_adx': 44, 'buy_rsi': 29, 'buy_adx_enabled': False, 'buy_rsi_enabled': True, 'buy_trigger': 'bb_lower' } stoploss: -0.27996 In order to use this best stoploss value found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the stoploss attribute of your custom strategy: # Optimal stoploss designed for the strategy # This attribute will be overridden if the config file contains \"stoploss\" stoploss = - 0.27996 As stated in the comment, you can also use it as the value of the stoploss setting in the configuration file.","title":"Understand Hyperopt Stoploss results"},{"location":"hyperopt/#default-stoploss-search-space","text":"If you are optimizing stoploss values, Freqtrade creates the 'stoploss' optimization hyperspace for you. By default, the stoploss values in that hyperspace vary in the range -0.35...-0.02, which is sufficient in most cases. If you have the stoploss_space() method in your custom hyperopt file, remove it in order to utilize Stoploss hyperoptimization space generated by Freqtrade by default. Override the stoploss_space() method and define the desired range in it if you need stoploss values to vary in other range during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default Stoploss Search Space"},{"location":"hyperopt/#understand-hyperopt-trailing-stop-results","text":"If you are optimizing trailing stop values (i.e. if optimization search-space contains 'all' or 'trailing'), your result will look as follows and include trailing stop parameters: Best result: 45/100: 606 trades. Avg profit 1.04%. Total profit 0.31555614 BTC ( 630.48%). Avg duration 150.3 mins. Objective: -1.10161 # Trailing stop: trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True In order to use these best trailing stop parameters found by Hyperopt in backtesting and for live trades/dry-run, copy-paste them as the values of the corresponding attributes of your custom strategy: # Trailing stop # These attributes will be overridden if the config file contains corresponding values. trailing_stop = True trailing_stop_positive = 0.02001 trailing_stop_positive_offset = 0.06038 trailing_only_offset_is_reached = True As stated in the comment, you can also use it as the values of the corresponding settings in the configuration file.","title":"Understand Hyperopt Trailing Stop results"},{"location":"hyperopt/#default-trailing-stop-search-space","text":"If you are optimizing trailing stop values, Freqtrade creates the 'trailing' optimization hyperspace for you. By default, the trailing_stop parameter is always set to True in that hyperspace, the value of the trailing_only_offset_is_reached vary between True and False, the values of the trailing_stop_positive and trailing_stop_positive_offset parameters vary in the ranges 0.02...0.35 and 0.01...0.1 correspondingly, which is sufficient in most cases. Override the trailing_space() method and define the desired range in it if you need values of the trailing stop parameters to vary in other ranges during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section . Reduced search space To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.","title":"Default Trailing Stop Search Space"},{"location":"hyperopt/#reproducible-results","text":"The search for optimal parameters starts with a few (currently 30) random combinations in the hyperspace of parameters, random Hyperopt epochs. These random epochs are marked with an asterisk character ( * ) in the first column in the Hyperopt output. The initial state for generation of these random values (random state) is controlled by the value of the --random-state command line option. You can set it to some arbitrary value of your choice to obtain reproducible results. If you have not set this value explicitly in the command line options, Hyperopt seeds the random state with some random value for you. The random state value for each Hyperopt run is shown in the log, so you can copy and paste it into the --random-state command line option to repeat the set of the initial random epochs used. If you have not changed anything in the command line options, configuration, timerange, Strategy and Hyperopt classes, historical data and the Loss Function -- you should obtain same hyper-optimization results with same random state value used.","title":"Reproducible results"},{"location":"hyperopt/#output-formatting","text":"By default, hyperopt prints colorized results -- epochs with positive profit are printed in the green color. This highlighting helps you find epochs that can be interesting for later analysis. Epochs with zero total profit or with negative profits (losses) are printed in the normal color. If you do not need colorization of results (for instance, when you are redirecting hyperopt output to a file) you can switch colorization off by specifying the --no-color option in the command line. You can use the --print-all command line option if you would like to see all results in the hyperopt output, not only the best ones. When --print-all is used, current best results are also colorized by default -- they are printed in bold (bright) style. This can also be switched off with the --no-color command line option. Windows and color output Windows does not support color-output natively, therefore it is automatically disabled. To have color-output for hyperopt running under windows, please consider using WSL.","title":"Output formatting"},{"location":"hyperopt/#position-stacking-and-disabling-max-market-positions","text":"In some situations, you may need to run Hyperopt (and Backtesting) with the --eps / --enable-position-staking and --dmmp / --disable-max-market-positions arguments. By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs is also limited by the max_open_trades setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previously open trades. The --eps / --enable-position-stacking argument allows emulation of buying the same pair multiple times, while --dmmp / --disable-max-market-positions disables applying max_open_trades during Hyperopt/Backtesting (which is equal to setting max_open_trades to a very high number). Note Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality. You can also enable position stacking in the configuration file by explicitly setting \"position_stacking\"=true .","title":"Position stacking and disabling max market positions"},{"location":"hyperopt/#out-of-memory-errors","text":"As hyperopt consumes a lot of memory (the complete data needs to be in memory once per parallel backtesting process), it's likely that you run into \"out of memory\" errors. To combat these, you have multiple options: Reduce the amount of pairs. Reduce the timerange used ( --timerange <timerange> ). Avoid using --timeframe-detail (this loads a lot of additional data into memory). Reduce the number of parallel processes ( -j <n> ). Increase the memory of your machine. Use --analyze-per-epoch if you're using a lot of parameters with .range functionality.","title":"Out of Memory errors"},{"location":"hyperopt/#the-objective-has-been-evaluated-at-this-point-before","text":"If you see The objective has been evaluated at this point before. - then this is a sign that your space has been exhausted, or is close to that. Basically all points in your space have been hit (or a local minima has been hit) - and hyperopt does no longer find points in the multi-dimensional space it did not try yet. Freqtrade tries to counter the \"local minima\" problem by using new, randomized points in this case. Example: buy_ema_short = IntParameter ( 5 , 20 , default = 10 , space = \"buy\" , optimize = True ) # This is the only parameter in the buy space The buy_ema_short space has 15 possible values ( 5, 6, ... 19, 20 ). If you now run hyperopt for the buy space, hyperopt will only have 15 values to try before running out of options. Your epochs should therefore be aligned to the possible values - or you should be ready to interrupt a run if you norice a lot of The objective has been evaluated at this point before. warnings.","title":"The objective has been evaluated at this point before."},{"location":"hyperopt/#show-details-of-hyperopt-results","text":"After you run Hyperopt for the desired amount of epochs, you can later list all results for analysis, select only best or profitable once, and show the details for any of the epochs previously evaluated. This can be done with the hyperopt-list and hyperopt-show sub-commands. The usage of these sub-commands is described in the Utils chapter.","title":"Show details of Hyperopt results"},{"location":"hyperopt/#validate-backtesting-results","text":"Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected. To achieve same the results (number of trades, their durations, profit, etc.) as during Hyperopt, please use the same configuration and parameters (timerange, timeframe, ...) used for hyperopt --dmmp / --disable-max-market-positions and --eps / --enable-position-stacking for Backtesting. Should results not match, please double-check to make sure you transferred all conditions correctly. Pay special care to the stoploss (and trailing stoploss) parameters, as these are often set in configuration files, which override changes to the strategy. You should also carefully review the log of your backtest to ensure that there were no parameters inadvertently set by the configuration (like stoploss or trailing_stop ).","title":"Validate backtesting results"},{"location":"installation/","text":"Installation \u00b6 This page explains how to prepare your environment for running the bot. The freqtrade documentation describes various ways to install freqtrade Docker images (separate page) Script Installation Manual Installation Installation with Conda Please consider using the prebuilt docker images to get started quickly while evaluating how freqtrade works. Information \u00b6 For Windows installation, please use the windows installation guide . The easiest way to install and run Freqtrade is to clone the bot Github repository and then run the ./setup.sh script, if it's available for your platform. Version considerations When cloning the repository the default working branch has the name develop . This branch contains all last features (can be considered as relatively stable, thanks to automated tests). The stable branch contains the code of the last release (done usually once per month on an approximately one week old snapshot of the develop branch to prevent packaging bugs, so potentially it's more stable). Note Python3.8 or higher and the corresponding pip are assumed to be available. The install-script will warn you and stop if that's not the case. git is also needed to clone the Freqtrade repository. Also, python headers ( python<yourversion>-dev / python<yourversion>-devel ) must be available for the installation to complete successfully. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges. Requirements \u00b6 These requirements apply to both Script Installation and Manual Installation . ARM64 systems If you are running an ARM64 system (like a MacOS M1 or an Oracle VM), please use docker to run freqtrade. While native installation is possible with some manual effort, this is not supported at the moment. Install guide \u00b6 Python >= 3.8.x pip git virtualenv (Recommended) TA-Lib (install instructions below ) Install code \u00b6 We've included/collected install instructions for Ubuntu, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the Common section below is necessary for all systems. Note Python3.8 or higher and the corresponding pip are assumed to be available. Debian/Ubuntu RaspberryPi/Raspbian Install necessary dependencies \u00b6 # update repository sudo apt-get update # install packages sudo apt install -y python3-pip python3-venv python3-dev python3-pandas git curl The following assumes the latest Raspbian Buster lite image . This image comes with python3.9 preinstalled, making it easy to get freqtrade up and running. Tested using a Raspberry Pi 3 with the Raspbian Buster lite image, all updates applied. sudo apt-get install python3-venv libatlas-base-dev cmake curl # Use pywheels.org to speed up installation sudo echo \"[global]\\nextra-index-url=https://www.piwheels.org/simple\" > tee /etc/pip.conf git clone https://github.com/freqtrade/freqtrade.git cd freqtrade bash setup.sh -i Installation duration Depending on your internet speed and the Raspberry Pi version, installation can take multiple hours to complete. Due to this, we recommend to use the pre-build docker-image for Raspberry, by following the Docker quickstart documentation Note The above does not install hyperopt dependencies. To install these, please use python3 -m pip install -e .[hyperopt] . We do not advise to run hyperopt on a Raspberry Pi, since this is a very resource-heavy operation, which should be done on powerful machine. Freqtrade repository \u00b6 Freqtrade is an open source crypto-currency trading bot, whose code is hosted on github.com # Download `develop` branch of freqtrade repository git clone https://github.com/freqtrade/freqtrade.git # Enter downloaded directory cd freqtrade # your choice (1): novice user git checkout stable # your choice (2): advanced user git checkout develop (1) This command switches the cloned repository to the use of the stable branch. It's not needed, if you wish to stay on the (2) develop branch. You may later switch between branches at any time with the git checkout stable / git checkout develop commands. Install from pypi An alternative way to install Freqtrade is from pypi . The downside is that this method requires ta-lib to be correctly installed beforehand, and is therefore currently not the recommended way to install Freqtrade. pip install freqtrade Script Installation \u00b6 First of the ways to install Freqtrade, is to use provided the Linux/MacOS ./setup.sh script, which install all dependencies and help you configure the bot. Make sure you fulfill the Requirements and have downloaded the Freqtrade repository . Use /setup.sh -install (Linux/MacOS) \u00b6 If you are on Debian, Ubuntu or MacOS, freqtrade provides the script to install freqtrade. # --install, Install freqtrade from scratch ./setup.sh -i Activate your virtual environment \u00b6 Each time you open a new terminal, you must run source .env/bin/activate to activate your virtual environment. # then activate your .env source ./.env/bin/activate Congratulations \u00b6 You are ready , and run the bot Other options of /setup.sh script \u00b6 You can as well update, configure and reset the codebase of your bot with ./script.sh # --update, Command git pull to update. ./setup.sh -u # --reset, Hard reset your develop/stable branch. ./setup.sh -r ** --install ** With this option, the script will install the bot and most dependencies: You will need to have git and python3.8+ installed beforehand for this to work. * Mandatory software as: `ta-lib` * Setup your virtualenv under `.env/` This option is a combination of installation tasks and `--reset` ** --update ** This option will pull the last version of your current branch and update your virtualenv. Run the script with this option periodically to update your bot. ** --reset ** This option will hard reset your branch (only if you are on either `stable` or `develop`) and recreate your virtualenv. Manual Installation \u00b6 Make sure you fulfill the Requirements and have downloaded the Freqtrade repository . Install TA-Lib \u00b6 TA-Lib script installation \u00b6 sudo ./build_helpers/install_ta-lib.sh Note This will use the ta-lib tar.gz included in this repository. TA-Lib manual installation \u00b6 Official webpage: https://mrjbq7.github.io/ta-lib/install.html wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz tar xvzf ta-lib-0.4.0-src.tar.gz cd ta-lib sed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h ./configure --prefix = /usr/local make sudo make install # On debian based systems (debian, ubuntu, ...) - updating ldconfig might be necessary. sudo ldconfig cd .. rm -rf ./ta-lib* Setup Python virtual environment (virtualenv) \u00b6 You will run freqtrade in separated virtual environment # create virtualenv in directory /freqtrade/.env python3 -m venv .env # run virtualenv source .env/bin/activate Install python dependencies \u00b6 python3 -m pip install --upgrade pip python3 -m pip install -e . Congratulations \u00b6 You are ready , and run the bot (Optional) Post-installation Tasks \u00b6 Note If you run the bot on a server, you should consider using Docker or a terminal multiplexer like screen or tmux to avoid that the bot is stopped on logout. On Linux with software suite systemd , as an optional post-installation task, you may wish to setup the bot to run as a systemd service or configure it to send the log messages to the syslog / rsyslog or journald daemons. See Advanced Logging for details. Installation with Conda \u00b6 Freqtrade can also be installed with Miniconda or Anaconda. We recommend using Miniconda as it's installation footprint is smaller. Conda will automatically prepare and manage the extensive library-dependencies of the Freqtrade program. What is Conda? \u00b6 Conda is a package, dependency and environment manager for multiple programming languages: conda docs Installation with conda \u00b6 Install Conda \u00b6 Installing on linux Installing on windows Answer all questions. After installation, it is mandatory to turn your terminal OFF and ON again. Freqtrade download \u00b6 Download and install freqtrade. # download freqtrade git clone https://github.com/freqtrade/freqtrade.git # enter downloaded directory 'freqtrade' cd freqtrade Freqtrade install: Conda Environment \u00b6 Prepare conda-freqtrade environment, using file environment.yml , which exist in main freqtrade directory conda env create -n freqtrade-conda -f environment.yml Creating Conda Environment The conda command create -n automatically installs all nested dependencies for the selected libraries, general structure of installation command is: # choose your own packages conda env create -n [ name of the environment ] [ python version ] [ packages ] # point to file with packages conda env create -n [ name of the environment ] -f [ file ] Enter/exit freqtrade-conda environment \u00b6 To check available environments, type conda env list Enter installed environment # enter conda environment conda activate freqtrade-conda # exit conda environment - don't do it now conda deactivate Install last python dependencies with pip python3 -m pip install --upgrade pip python3 -m pip install -e . Patch conda libta-lib (Linux only) # Ensure that the environment is active! conda activate freqtrade-conda cd build_helpers bash install_ta-lib.sh ${ CONDA_PREFIX } nosudo Congratulations \u00b6 You are ready , and run the bot Important shortcuts \u00b6 # list installed conda environments conda env list # activate base environment conda activate # activate freqtrade-conda environment conda activate freqtrade-conda #deactivate any conda environments conda deactivate Further info on anaconda \u00b6 New heavy packages It may happen that creating a new Conda environment, populated with selected packages at the moment of creation takes less time than installing a large, heavy library or application, into previously set environment. pip install within conda The documentation of conda says that pip should NOT be used within conda, because internal problems can occur. However, they are rare. Anaconda Blogpost Nevertheless, that is why, the conda-forge channel is preferred: more libraries are available (less need for pip ) conda-forge works better with pip the libraries are newer Happy trading! You are ready \u00b6 You've made it this far, so you have successfully installed freqtrade. Initialize the configuration \u00b6 # Step 1 - Initialize user folder freqtrade create-userdir --userdir user_data # Step 2 - Create a new configuration file freqtrade new-config --config config.json You are ready to run, read Bot Configuration , remember to start with dry_run: True and verify that everything is working. To learn how to setup your configuration, please refer to the Bot Configuration documentation page. Start the Bot \u00b6 freqtrade trade --config config.json --strategy SampleStrategy Warning You should read through the rest of the documentation, backtest the strategy you're going to use, and use dry-run before enabling trading with real money. Troubleshooting \u00b6 Common problem: \"command not found\" \u00b6 If you used (1) Script or (2) Manual installation, you need to run the bot in virtual environment. If you get error as below, make sure venv is active. # if: bash: freqtrade: command not found # then activate your .env source ./.env/bin/activate MacOS installation error \u00b6 Newer versions of MacOS may have installation failed with errors like error: command 'g++' failed with exit status 1 . This error will require explicit installation of the SDK Headers, which are not installed by default in this version of MacOS. For MacOS 10.14, this can be accomplished with the below command. open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg If this file is inexistent, then you're probably on a different version of MacOS, so you may need to consult the internet for specific resolution details.","title":"Linux/MacOS/Raspberry"},{"location":"installation/#installation","text":"This page explains how to prepare your environment for running the bot. The freqtrade documentation describes various ways to install freqtrade Docker images (separate page) Script Installation Manual Installation Installation with Conda Please consider using the prebuilt docker images to get started quickly while evaluating how freqtrade works.","title":"Installation"},{"location":"installation/#information","text":"For Windows installation, please use the windows installation guide . The easiest way to install and run Freqtrade is to clone the bot Github repository and then run the ./setup.sh script, if it's available for your platform. Version considerations When cloning the repository the default working branch has the name develop . This branch contains all last features (can be considered as relatively stable, thanks to automated tests). The stable branch contains the code of the last release (done usually once per month on an approximately one week old snapshot of the develop branch to prevent packaging bugs, so potentially it's more stable). Note Python3.8 or higher and the corresponding pip are assumed to be available. The install-script will warn you and stop if that's not the case. git is also needed to clone the Freqtrade repository. Also, python headers ( python<yourversion>-dev / python<yourversion>-devel ) must be available for the installation to complete successfully. Up-to-date clock The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.","title":"Information"},{"location":"installation/#requirements","text":"These requirements apply to both Script Installation and Manual Installation . ARM64 systems If you are running an ARM64 system (like a MacOS M1 or an Oracle VM), please use docker to run freqtrade. While native installation is possible with some manual effort, this is not supported at the moment.","title":"Requirements"},{"location":"installation/#install-guide","text":"Python >= 3.8.x pip git virtualenv (Recommended) TA-Lib (install instructions below )","title":"Install guide"},{"location":"installation/#install-code","text":"We've included/collected install instructions for Ubuntu, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the Common section below is necessary for all systems. Note Python3.8 or higher and the corresponding pip are assumed to be available. Debian/Ubuntu RaspberryPi/Raspbian","title":"Install code"},{"location":"installation/#install-necessary-dependencies","text":"# update repository sudo apt-get update # install packages sudo apt install -y python3-pip python3-venv python3-dev python3-pandas git curl The following assumes the latest Raspbian Buster lite image . This image comes with python3.9 preinstalled, making it easy to get freqtrade up and running. Tested using a Raspberry Pi 3 with the Raspbian Buster lite image, all updates applied. sudo apt-get install python3-venv libatlas-base-dev cmake curl # Use pywheels.org to speed up installation sudo echo \"[global]\\nextra-index-url=https://www.piwheels.org/simple\" > tee /etc/pip.conf git clone https://github.com/freqtrade/freqtrade.git cd freqtrade bash setup.sh -i Installation duration Depending on your internet speed and the Raspberry Pi version, installation can take multiple hours to complete. Due to this, we recommend to use the pre-build docker-image for Raspberry, by following the Docker quickstart documentation Note The above does not install hyperopt dependencies. To install these, please use python3 -m pip install -e .[hyperopt] . We do not advise to run hyperopt on a Raspberry Pi, since this is a very resource-heavy operation, which should be done on powerful machine.","title":"Install necessary dependencies"},{"location":"installation/#freqtrade-repository","text":"Freqtrade is an open source crypto-currency trading bot, whose code is hosted on github.com # Download `develop` branch of freqtrade repository git clone https://github.com/freqtrade/freqtrade.git # Enter downloaded directory cd freqtrade # your choice (1): novice user git checkout stable # your choice (2): advanced user git checkout develop (1) This command switches the cloned repository to the use of the stable branch. It's not needed, if you wish to stay on the (2) develop branch. You may later switch between branches at any time with the git checkout stable / git checkout develop commands. Install from pypi An alternative way to install Freqtrade is from pypi . The downside is that this method requires ta-lib to be correctly installed beforehand, and is therefore currently not the recommended way to install Freqtrade. pip install freqtrade","title":"Freqtrade repository"},{"location":"installation/#script-installation","text":"First of the ways to install Freqtrade, is to use provided the Linux/MacOS ./setup.sh script, which install all dependencies and help you configure the bot. Make sure you fulfill the Requirements and have downloaded the Freqtrade repository .","title":"Script Installation"},{"location":"installation/#use-setupsh-install-linuxmacos","text":"If you are on Debian, Ubuntu or MacOS, freqtrade provides the script to install freqtrade. # --install, Install freqtrade from scratch ./setup.sh -i","title":"Use /setup.sh -install (Linux/MacOS)"},{"location":"installation/#activate-your-virtual-environment","text":"Each time you open a new terminal, you must run source .env/bin/activate to activate your virtual environment. # then activate your .env source ./.env/bin/activate","title":"Activate your virtual environment"},{"location":"installation/#congratulations","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#other-options-of-setupsh-script","text":"You can as well update, configure and reset the codebase of your bot with ./script.sh # --update, Command git pull to update. ./setup.sh -u # --reset, Hard reset your develop/stable branch. ./setup.sh -r ** --install ** With this option, the script will install the bot and most dependencies: You will need to have git and python3.8+ installed beforehand for this to work. * Mandatory software as: `ta-lib` * Setup your virtualenv under `.env/` This option is a combination of installation tasks and `--reset` ** --update ** This option will pull the last version of your current branch and update your virtualenv. Run the script with this option periodically to update your bot. ** --reset ** This option will hard reset your branch (only if you are on either `stable` or `develop`) and recreate your virtualenv.","title":"Other options of /setup.sh script"},{"location":"installation/#manual-installation","text":"Make sure you fulfill the Requirements and have downloaded the Freqtrade repository .","title":"Manual Installation"},{"location":"installation/#install-ta-lib","text":"","title":"Install TA-Lib"},{"location":"installation/#ta-lib-script-installation","text":"sudo ./build_helpers/install_ta-lib.sh Note This will use the ta-lib tar.gz included in this repository.","title":"TA-Lib script installation"},{"location":"installation/#ta-lib-manual-installation","text":"Official webpage: https://mrjbq7.github.io/ta-lib/install.html wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz tar xvzf ta-lib-0.4.0-src.tar.gz cd ta-lib sed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h ./configure --prefix = /usr/local make sudo make install # On debian based systems (debian, ubuntu, ...) - updating ldconfig might be necessary. sudo ldconfig cd .. rm -rf ./ta-lib*","title":"TA-Lib manual installation"},{"location":"installation/#setup-python-virtual-environment-virtualenv","text":"You will run freqtrade in separated virtual environment # create virtualenv in directory /freqtrade/.env python3 -m venv .env # run virtualenv source .env/bin/activate","title":"Setup Python virtual environment (virtualenv)"},{"location":"installation/#install-python-dependencies","text":"python3 -m pip install --upgrade pip python3 -m pip install -e .","title":"Install python dependencies"},{"location":"installation/#congratulations_1","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#optional-post-installation-tasks","text":"Note If you run the bot on a server, you should consider using Docker or a terminal multiplexer like screen or tmux to avoid that the bot is stopped on logout. On Linux with software suite systemd , as an optional post-installation task, you may wish to setup the bot to run as a systemd service or configure it to send the log messages to the syslog / rsyslog or journald daemons. See Advanced Logging for details.","title":"(Optional) Post-installation Tasks"},{"location":"installation/#installation-with-conda","text":"Freqtrade can also be installed with Miniconda or Anaconda. We recommend using Miniconda as it's installation footprint is smaller. Conda will automatically prepare and manage the extensive library-dependencies of the Freqtrade program.","title":"Installation with Conda"},{"location":"installation/#what-is-conda","text":"Conda is a package, dependency and environment manager for multiple programming languages: conda docs","title":"What is Conda?"},{"location":"installation/#installation-with-conda_1","text":"","title":"Installation with conda"},{"location":"installation/#install-conda","text":"Installing on linux Installing on windows Answer all questions. After installation, it is mandatory to turn your terminal OFF and ON again.","title":"Install Conda"},{"location":"installation/#freqtrade-download","text":"Download and install freqtrade. # download freqtrade git clone https://github.com/freqtrade/freqtrade.git # enter downloaded directory 'freqtrade' cd freqtrade","title":"Freqtrade download"},{"location":"installation/#freqtrade-install-conda-environment","text":"Prepare conda-freqtrade environment, using file environment.yml , which exist in main freqtrade directory conda env create -n freqtrade-conda -f environment.yml Creating Conda Environment The conda command create -n automatically installs all nested dependencies for the selected libraries, general structure of installation command is: # choose your own packages conda env create -n [ name of the environment ] [ python version ] [ packages ] # point to file with packages conda env create -n [ name of the environment ] -f [ file ]","title":"Freqtrade install: Conda Environment"},{"location":"installation/#enterexit-freqtrade-conda-environment","text":"To check available environments, type conda env list Enter installed environment # enter conda environment conda activate freqtrade-conda # exit conda environment - don't do it now conda deactivate Install last python dependencies with pip python3 -m pip install --upgrade pip python3 -m pip install -e . Patch conda libta-lib (Linux only) # Ensure that the environment is active! conda activate freqtrade-conda cd build_helpers bash install_ta-lib.sh ${ CONDA_PREFIX } nosudo","title":"Enter/exit freqtrade-conda environment"},{"location":"installation/#congratulations_2","text":"You are ready , and run the bot","title":"Congratulations"},{"location":"installation/#important-shortcuts","text":"# list installed conda environments conda env list # activate base environment conda activate # activate freqtrade-conda environment conda activate freqtrade-conda #deactivate any conda environments conda deactivate","title":"Important shortcuts"},{"location":"installation/#further-info-on-anaconda","text":"New heavy packages It may happen that creating a new Conda environment, populated with selected packages at the moment of creation takes less time than installing a large, heavy library or application, into previously set environment. pip install within conda The documentation of conda says that pip should NOT be used within conda, because internal problems can occur. However, they are rare. Anaconda Blogpost Nevertheless, that is why, the conda-forge channel is preferred: more libraries are available (less need for pip ) conda-forge works better with pip the libraries are newer Happy trading!","title":"Further info on anaconda"},{"location":"installation/#you-are-ready","text":"You've made it this far, so you have successfully installed freqtrade.","title":"You are ready"},{"location":"installation/#initialize-the-configuration","text":"# Step 1 - Initialize user folder freqtrade create-userdir --userdir user_data # Step 2 - Create a new configuration file freqtrade new-config --config config.json You are ready to run, read Bot Configuration , remember to start with dry_run: True and verify that everything is working. To learn how to setup your configuration, please refer to the Bot Configuration documentation page.","title":"Initialize the configuration"},{"location":"installation/#start-the-bot","text":"freqtrade trade --config config.json --strategy SampleStrategy Warning You should read through the rest of the documentation, backtest the strategy you're going to use, and use dry-run before enabling trading with real money.","title":"Start the Bot"},{"location":"installation/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"installation/#common-problem-command-not-found","text":"If you used (1) Script or (2) Manual installation, you need to run the bot in virtual environment. If you get error as below, make sure venv is active. # if: bash: freqtrade: command not found # then activate your .env source ./.env/bin/activate","title":"Common problem: \"command not found\""},{"location":"installation/#macos-installation-error","text":"Newer versions of MacOS may have installation failed with errors like error: command 'g++' failed with exit status 1 . This error will require explicit installation of the SDK Headers, which are not installed by default in this version of MacOS. For MacOS 10.14, this can be accomplished with the below command. open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg If this file is inexistent, then you're probably on a different version of MacOS, so you may need to consult the internet for specific resolution details.","title":"MacOS installation error"},{"location":"leverage/","text":"Trading with Leverage \u00b6 Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Multiple bots on one account You can't run 2 bots on the same account with leverage. For leveraged / margin trading, freqtrade assumes it's the only user of the account, and all liquidation levels are calculated based on this assumption. Trading with leverage is very risky Do not trade with a leverage > 1 using a strategy that hasn't shown positive results in a live run using the spot market. Check the stoploss of your strategy. With a leverage of 2, a stoploss of 0.5 (50%) would be too low, and these trades would be liquidated before reaching that stoploss. We do not assume any responsibility for eventual losses that occur from using this software or this mode. Please only use advanced trading modes when you know how freqtrade (and your strategy) works. Also, never risk more than what you can afford to lose. Please read the strategy migration guide to migrate your strategy from a freqtrade v2 strategy, to v3 strategy that can short and trade futures. Shorting \u00b6 Shorting is not possible when trading with trading_mode set to spot . To short trade, trading_mode must be set to margin (currently unavailable) or futures , with margin_mode set to cross (currently unavailable) or isolated For a strategy to short, the strategy class must set the class variable can_short = True Please read strategy customization for instructions on how to set signals to enter and exit short trades. Understand trading_mode \u00b6 The possible values are: spot (default), margin ( Currently unavailable ) or futures . Spot \u00b6 Regular trading mode (low risk) Long trades only (No short trades). No leverage. No Liquidation. Profits gained/lost are equal to the change in value of the assets (minus trading fees). Leverage trading modes \u00b6 With leverage, a trader borrows capital from the exchange. The capital must be re-payed fully to the exchange (potentially with interest), and the trader keeps any profits, or pays any losses, from any trades made using the borrowed capital. Because the capital must always be re-payed, exchanges will liquidate (forcefully sell the traders assets) a trade made using borrowed capital when the total value of assets in the leverage account drops to a certain point (a point where the total value of losses is less than the value of the collateral that the trader actually owns in the leverage account), in order to ensure that the trader has enough capital to pay the borrowed assets back to the exchange. The exchange will also charge a liquidation fee , adding to the traders losses. For this reason, DO NOT TRADE WITH LEVERAGE IF YOU DON'T KNOW EXACTLY WHAT YOUR DOING. LEVERAGE TRADING IS HIGH RISK, AND CAN RESULT IN THE VALUE OF YOUR ASSETS DROPPING TO 0 VERY QUICKLY, WITH NO CHANCE OF INCREASING IN VALUE AGAIN. Margin (currently unavailable) \u00b6 Trading occurs on the spot market, but the exchange lends currency to you in an amount equal to the chosen leverage. You pay the amount lent to you back to the exchange with interest, and your profits/losses are multiplied by the leverage specified. Futures \u00b6 Perpetual swaps (also known as Perpetual Futures) are contracts traded at a price that is closely tied to the underlying asset they are based off of (ex.). You are not trading the actual asset but instead are trading a derivative contract. Perpetual swap contracts can last indefinitely, in contrast to futures or option contracts. In addition to the gains/losses from the change in price of the futures contract, traders also exchange funding fees , which are gains/losses worth an amount that is derived from the difference in price between the futures contract and the underlying asset. The difference in price between a futures contract and the underlying asset varies between exchanges. To trade in futures markets, you'll have to set trading_mode to \"futures\". You will also have to pick a \"margin mode\" (explanation below) - with freqtrade currently only supporting isolated margin. \"trading_mode\" : \"futures\" , \"margin_mode\" : \"isolated\" Margin mode \u00b6 On top of trading_mode - you will also have to configure your margin_mode . While freqtrade currently only supports one margin mode, this will change, and by configuring it now you're all set for future updates. The possible values are: isolated , or cross ( currently unavailable ). Isolated margin mode \u00b6 Each market(trading pair), keeps collateral in a separate account \"margin_mode\" : \"isolated\" Cross margin mode (currently unavailable) \u00b6 One account is used to share collateral between markets (trading pairs). Margin is taken from total account balance to avoid liquidation when needed. \"margin_mode\" : \"cross\" Set leverage to use \u00b6 Different strategies and risk profiles will require different levels of leverage. While you could configure one static leverage value - freqtrade offers you the flexibility to adjust this via strategy leverage callback - which allows you to use different leverages by pair, or based on some other factor benefitting your strategy result. If not implemented, leverage defaults to 1x (no leverage). Warning Higher leverage also equals higher risk - be sure you fully understand the implications of using leverage! Understand liquidation_buffer \u00b6 Defaults to 0.05 A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price. This artificial liquidation price is calculated as: freqtrade_liquidation_price = liquidation_price \u00b1 (abs(open_rate - liquidation_price) * liquidation_buffer) \u00b1 = + for long trades \u00b1 = - for short trades Possible values are any floats between 0.0 and 0.99 ex: If a trade is entered at a price of 10 coin/USDT, and the liquidation price of this trade is 8 coin/USDT, then with liquidation_buffer set to 0.05 the minimum stoploss for this trade would be \\(8 + ((10 - 8) * 0.05) = 8 + 0.1 = 8.1\\) A liquidation_buffer of 0.0, or a low liquidation_buffer is likely to result in liquidations, and liquidation fees Currently Freqtrade is able to calculate liquidation prices, but does not calculate liquidation fees. Setting your liquidation_buffer to 0.0, or using a low liquidation_buffer could result in your positions being liquidated. Freqtrade does not track liquidation fees, so liquidations will result in inaccurate profit/loss results for your bot. If you use a low liquidation_buffer , it is recommended to use stoploss_on_exchange if your exchange supports this. Unavailable funding rates \u00b6 For futures data, exchanges commonly provide the futures candles, the marks, and the funding rates. However, it is common that whilst candles and marks might be available, the funding rates are not. This can affect backtesting timeranges, i.e. you may only be able to test recent timeranges and not earlier, experiencing the No data found. Terminating. error. To get around this, add the futures_funding_rate config option as listed in configuration.md , and it is recommended that you set this to 0 , unless you know a given specific funding rate for your pair, exchange and timerange. Setting this to anything other than 0 can have drastic effects on your profit calculations within strategy, e.g. within the custom_exit , custom_stoploss , etc functions. This will mean your backtests are inaccurate. This will not overwrite funding rates that are available from the exchange, but bear in mind that setting a false funding rate will mean backtesting results will be inaccurate for historical timeranges where funding rates are not available. Developer \u00b6 Margin mode \u00b6 For shorts, the currency which pays the interest fee for the borrowed currency is purchased at the same time of the closing trade (This means that the amount purchased in short closing trades is greater than the amount sold in short opening trades). For longs, the currency which pays the interest fee for the borrowed will already be owned by the user and does not need to be purchased. The interest is subtracted from the close_value of the trade. All Fees are included in current_profit calculations during the trade. Futures mode \u00b6 Funding fees are either added or subtracted from the total amount of a trade","title":"Short / Leverage"},{"location":"leverage/#trading-with-leverage","text":"Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Multiple bots on one account You can't run 2 bots on the same account with leverage. For leveraged / margin trading, freqtrade assumes it's the only user of the account, and all liquidation levels are calculated based on this assumption. Trading with leverage is very risky Do not trade with a leverage > 1 using a strategy that hasn't shown positive results in a live run using the spot market. Check the stoploss of your strategy. With a leverage of 2, a stoploss of 0.5 (50%) would be too low, and these trades would be liquidated before reaching that stoploss. We do not assume any responsibility for eventual losses that occur from using this software or this mode. Please only use advanced trading modes when you know how freqtrade (and your strategy) works. Also, never risk more than what you can afford to lose. Please read the strategy migration guide to migrate your strategy from a freqtrade v2 strategy, to v3 strategy that can short and trade futures.","title":"Trading with Leverage"},{"location":"leverage/#shorting","text":"Shorting is not possible when trading with trading_mode set to spot . To short trade, trading_mode must be set to margin (currently unavailable) or futures , with margin_mode set to cross (currently unavailable) or isolated For a strategy to short, the strategy class must set the class variable can_short = True Please read strategy customization for instructions on how to set signals to enter and exit short trades.","title":"Shorting"},{"location":"leverage/#understand-trading_mode","text":"The possible values are: spot (default), margin ( Currently unavailable ) or futures .","title":"Understand trading_mode"},{"location":"leverage/#spot","text":"Regular trading mode (low risk) Long trades only (No short trades). No leverage. No Liquidation. Profits gained/lost are equal to the change in value of the assets (minus trading fees).","title":"Spot"},{"location":"leverage/#leverage-trading-modes","text":"With leverage, a trader borrows capital from the exchange. The capital must be re-payed fully to the exchange (potentially with interest), and the trader keeps any profits, or pays any losses, from any trades made using the borrowed capital. Because the capital must always be re-payed, exchanges will liquidate (forcefully sell the traders assets) a trade made using borrowed capital when the total value of assets in the leverage account drops to a certain point (a point where the total value of losses is less than the value of the collateral that the trader actually owns in the leverage account), in order to ensure that the trader has enough capital to pay the borrowed assets back to the exchange. The exchange will also charge a liquidation fee , adding to the traders losses. For this reason, DO NOT TRADE WITH LEVERAGE IF YOU DON'T KNOW EXACTLY WHAT YOUR DOING. LEVERAGE TRADING IS HIGH RISK, AND CAN RESULT IN THE VALUE OF YOUR ASSETS DROPPING TO 0 VERY QUICKLY, WITH NO CHANCE OF INCREASING IN VALUE AGAIN.","title":"Leverage trading modes"},{"location":"leverage/#margin-currently-unavailable","text":"Trading occurs on the spot market, but the exchange lends currency to you in an amount equal to the chosen leverage. You pay the amount lent to you back to the exchange with interest, and your profits/losses are multiplied by the leverage specified.","title":"Margin (currently unavailable)"},{"location":"leverage/#futures","text":"Perpetual swaps (also known as Perpetual Futures) are contracts traded at a price that is closely tied to the underlying asset they are based off of (ex.). You are not trading the actual asset but instead are trading a derivative contract. Perpetual swap contracts can last indefinitely, in contrast to futures or option contracts. In addition to the gains/losses from the change in price of the futures contract, traders also exchange funding fees , which are gains/losses worth an amount that is derived from the difference in price between the futures contract and the underlying asset. The difference in price between a futures contract and the underlying asset varies between exchanges. To trade in futures markets, you'll have to set trading_mode to \"futures\". You will also have to pick a \"margin mode\" (explanation below) - with freqtrade currently only supporting isolated margin. \"trading_mode\" : \"futures\" , \"margin_mode\" : \"isolated\"","title":"Futures"},{"location":"leverage/#margin-mode","text":"On top of trading_mode - you will also have to configure your margin_mode . While freqtrade currently only supports one margin mode, this will change, and by configuring it now you're all set for future updates. The possible values are: isolated , or cross ( currently unavailable ).","title":"Margin mode"},{"location":"leverage/#isolated-margin-mode","text":"Each market(trading pair), keeps collateral in a separate account \"margin_mode\" : \"isolated\"","title":"Isolated margin mode"},{"location":"leverage/#cross-margin-mode-currently-unavailable","text":"One account is used to share collateral between markets (trading pairs). Margin is taken from total account balance to avoid liquidation when needed. \"margin_mode\" : \"cross\"","title":"Cross margin mode (currently unavailable)"},{"location":"leverage/#set-leverage-to-use","text":"Different strategies and risk profiles will require different levels of leverage. While you could configure one static leverage value - freqtrade offers you the flexibility to adjust this via strategy leverage callback - which allows you to use different leverages by pair, or based on some other factor benefitting your strategy result. If not implemented, leverage defaults to 1x (no leverage). Warning Higher leverage also equals higher risk - be sure you fully understand the implications of using leverage!","title":"Set leverage to use"},{"location":"leverage/#understand-liquidation_buffer","text":"Defaults to 0.05 A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price. This artificial liquidation price is calculated as: freqtrade_liquidation_price = liquidation_price \u00b1 (abs(open_rate - liquidation_price) * liquidation_buffer) \u00b1 = + for long trades \u00b1 = - for short trades Possible values are any floats between 0.0 and 0.99 ex: If a trade is entered at a price of 10 coin/USDT, and the liquidation price of this trade is 8 coin/USDT, then with liquidation_buffer set to 0.05 the minimum stoploss for this trade would be \\(8 + ((10 - 8) * 0.05) = 8 + 0.1 = 8.1\\) A liquidation_buffer of 0.0, or a low liquidation_buffer is likely to result in liquidations, and liquidation fees Currently Freqtrade is able to calculate liquidation prices, but does not calculate liquidation fees. Setting your liquidation_buffer to 0.0, or using a low liquidation_buffer could result in your positions being liquidated. Freqtrade does not track liquidation fees, so liquidations will result in inaccurate profit/loss results for your bot. If you use a low liquidation_buffer , it is recommended to use stoploss_on_exchange if your exchange supports this.","title":"Understand liquidation_buffer"},{"location":"leverage/#unavailable-funding-rates","text":"For futures data, exchanges commonly provide the futures candles, the marks, and the funding rates. However, it is common that whilst candles and marks might be available, the funding rates are not. This can affect backtesting timeranges, i.e. you may only be able to test recent timeranges and not earlier, experiencing the No data found. Terminating. error. To get around this, add the futures_funding_rate config option as listed in configuration.md , and it is recommended that you set this to 0 , unless you know a given specific funding rate for your pair, exchange and timerange. Setting this to anything other than 0 can have drastic effects on your profit calculations within strategy, e.g. within the custom_exit , custom_stoploss , etc functions. This will mean your backtests are inaccurate. This will not overwrite funding rates that are available from the exchange, but bear in mind that setting a false funding rate will mean backtesting results will be inaccurate for historical timeranges where funding rates are not available.","title":"Unavailable funding rates"},{"location":"leverage/#developer","text":"","title":"Developer"},{"location":"leverage/#margin-mode_1","text":"For shorts, the currency which pays the interest fee for the borrowed currency is purchased at the same time of the closing trade (This means that the amount purchased in short closing trades is greater than the amount sold in short opening trades). For longs, the currency which pays the interest fee for the borrowed will already be owned by the user and does not need to be purchased. The interest is subtracted from the close_value of the trade. All Fees are included in current_profit calculations during the trade.","title":"Margin mode"},{"location":"leverage/#futures-mode","text":"Funding fees are either added or subtracted from the total amount of a trade","title":"Futures mode"},{"location":"plotting/","text":"Plotting \u00b6 This page explains how to plot prices, indicators and profits. Installation / Setup \u00b6 Plotting modules use the Plotly library. You can install / upgrade this by running the following command: pip install -U -r requirements-plot.txt Plot price and indicators \u00b6 The freqtrade plot-dataframe subcommand shows an interactive graph with three subplots: Main plot with candlesticks and indicators following price (sma/ema) Volume bars Additional indicators as specified by --indicators2 Possible arguments: usage: freqtrade plot-dataframe [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--indicators1 INDICATORS1 [INDICATORS1 ...]] [--indicators2 INDICATORS2 [INDICATORS2 ...]] [--plot-limit INT] [--db-url PATH] [--trade-source {DB,file}] [--export EXPORT] [--export-filename PATH] [--timerange TIMERANGE] [-i TIMEFRAME] [--no-trades] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --indicators1 INDICATORS1 [INDICATORS1 ...] Set indicators from your strategy you want in the first row of the graph. Space-separated list. Example: `ema3 ema5`. Default: `['sma', 'ema3', 'ema5']`. --indicators2 INDICATORS2 [INDICATORS2 ...] Set indicators from your strategy you want in the third row of the graph. Space-separated list. Example: `fastd fastk`. Default: `['macd', 'macdsignal']`. --plot-limit INT Specify tick limit for plotting. Notice: too high values cause huge files. Default: 750. --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file --export EXPORT Export backtest results, argument are: trades. Example: `--export=trades` --export-filename PATH Save backtest results to the file with this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --timerange TIMERANGE Specify what timerange of data to use. -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --no-trades Skip using trades from backtesting file and DB. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. Example: freqtrade plot-dataframe -p BTC/ETH --strategy AwesomeStrategy The -p/--pairs argument can be used to specify pairs you would like to plot. Note The freqtrade plot-dataframe subcommand generates one plot-file per pair. Specify custom indicators. Use --indicators1 for the main plot and --indicators2 for the subplot below (if values are in a different range than prices). freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --indicators1 sma ema --indicators2 macd Further usage examples \u00b6 To plot multiple pairs, separate them with a space: freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH XRP/ETH To plot a timerange (to zoom in) freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange = 20180801 -20180805 To plot trades stored in a database use --db-url in combination with --trade-source DB : freqtrade plot-dataframe --strategy AwesomeStrategy --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB To plot trades from a backtesting result, use --export-filename <filename> freqtrade plot-dataframe --strategy AwesomeStrategy --export-filename user_data/backtest_results/backtest-result.json -p BTC/ETH Plot dataframe basics \u00b6 The plot-dataframe subcommand requires backtesting data, a strategy and either a backtesting-results file or a database, containing trades corresponding to the strategy. The resulting plot will have the following elements: Green triangles: Buy signals from the strategy. (Note: not every buy signal generates a trade, compare to cyan circles.) Red triangles: Sell signals from the strategy. (Also, not every sell signal terminates a trade, compare to red and green squares.) Cyan circles: Trade entry points. Red squares: Trade exit points for trades with loss or 0% profit. Green squares: Trade exit points for profitable trades. Indicators with values corresponding to the candle scale (e.g. SMA/EMA), as specified with --indicators1 . Volume (bar chart at the bottom of the main chart). Indicators with values in different scales (e.g. MACD, RSI) below the volume bars, as specified with --indicators2 . Bollinger Bands Bollinger bands are automatically added to the plot if the columns bb_lowerband and bb_upperband exist, and are painted as a light blue area spanning from the lower band to the upper band. Advanced plot configuration \u00b6 An advanced plot configuration can be specified in the strategy in the plot_config parameter. Additional features when using plot_config include: Specify colors per indicator Specify additional subplots Specify indicator pairs to fill area in between The sample plot configuration below specifies fixed colors for the indicators. Otherwise, consecutive plots may produce different color schemes each time, making comparisons difficult. It also allows multiple subplots to display both MACD and RSI at the same time. Plot type can be configured using type key. Possible types are: scatter corresponding to plotly.graph_objects.Scatter class (default). bar corresponding to plotly.graph_objects.Bar class. Extra parameters to plotly.graph_objects.* constructor can be specified in plotly dict. Sample configuration with inline comments explaining the process: @property def plot_config ( self ): \"\"\" There are a lot of solutions how to build the return dictionary. The only important point is the return value. Example: plot_config = {'main_plot': {}, 'subplots': {}} \"\"\" plot_config = {} plot_config [ 'main_plot' ] = { # Configuration for main plot indicators. # Assumes 2 parameters, emashort and emalong to be specified. f 'ema_ { self . emashort . value } ' : { 'color' : 'red' }, f 'ema_ { self . emalong . value } ' : { 'color' : '#CCCCCC' }, # By omitting color, a random color is selected. 'sar' : {}, # fill area between senkou_a and senkou_b 'senkou_a' : { 'color' : 'green' , #optional 'fill_to' : 'senkou_b' , 'fill_label' : 'Ichimoku Cloud' , #optional 'fill_color' : 'rgba(255,76,46,0.2)' , #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b' : {} } plot_config [ 'subplots' ] = { # Create subplot MACD \"MACD\" : { 'macd' : { 'color' : 'blue' , 'fill_to' : 'macdhist' }, 'macdsignal' : { 'color' : 'orange' }, 'macdhist' : { 'type' : 'bar' , 'plotly' : { 'opacity' : 0.9 }} }, # Additional subplot RSI \"RSI\" : { 'rsi' : { 'color' : 'red' } } } return plot_config As attribute (former method) Assigning plot_config is also possible as Attribute (this used to be the default way). This has the disadvantage that strategy parameters are not available, preventing certain configurations from working. plot_config = { 'main_plot' : { # Configuration for main plot indicators. # Specifies `ema10` to be red, and `ema50` to be a shade of gray 'ema10' : { 'color' : 'red' }, 'ema50' : { 'color' : '#CCCCCC' }, # By omitting color, a random color is selected. 'sar' : {}, # fill area between senkou_a and senkou_b 'senkou_a' : { 'color' : 'green' , #optional 'fill_to' : 'senkou_b' , 'fill_label' : 'Ichimoku Cloud' , #optional 'fill_color' : 'rgba(255,76,46,0.2)' , #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b' : {} }, 'subplots' : { # Create subplot MACD \"MACD\" : { 'macd' : { 'color' : 'blue' , 'fill_to' : 'macdhist' }, 'macdsignal' : { 'color' : 'orange' }, 'macdhist' : { 'type' : 'bar' , 'plotly' : { 'opacity' : 0.9 }} }, # Additional subplot RSI \"RSI\" : { 'rsi' : { 'color' : 'red' } } } } Note The above configuration assumes that ema10 , ema50 , senkou_a , senkou_b , macd , macdsignal , macdhist and rsi are columns in the DataFrame created by the strategy. Warning plotly arguments are only supported with plotly library and will not work with freq-ui. Trade position adjustments If position_adjustment_enable / adjust_trade_position() is used, the trade initial buy price is averaged over multiple orders and the trade start price will most likely appear outside the candle range. Plot profit \u00b6 The plot-profit subcommand shows an interactive graph with three plots: Average closing price for all pairs. The summarized profit made by backtesting. Note that this is not the real-world profit, but more of an estimate. Profit for each individual pair. Parallelism of trades. Underwater (Periods of drawdown). The first graph is good to get a grip of how the overall market progresses. The second graph will show if your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less often, but makes big swings. This graph will also highlight the start (and end) of the Max drawdown period. The third graph can be useful to spot outliers, events in pairs that cause profit spikes. The forth graph can help you analyze trade parallelism, showing how often max_open_trades have been maxed out. Possible options for the freqtrade plot-profit subcommand: usage: freqtrade plot-profit [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--timerange TIMERANGE] [--export EXPORT] [--export-filename PATH] [--db-url PATH] [--trade-source {DB,file}] [-i TIMEFRAME] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --timerange TIMERANGE Specify what timerange of data to use. --export EXPORT Export backtest results, argument are: trades. Example: `--export=trades` --export-filename PATH, --backtest-filename PATH Use backtest results from this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --auto-open Automatically open generated plot. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. The -p/--pairs argument, can be used to limit the pairs that are considered for this calculation. Examples: Use custom backtest-export file freqtrade plot-profit -p LTC/BTC --export-filename user_data/backtest_results/backtest-result.json Use custom database freqtrade plot-profit -p LTC/BTC --db-url sqlite:///tradesv3.sqlite --trade-source DB freqtrade --datadir user_data/data/binance_save/ plot-profit -p LTC/BTC","title":"Plotting"},{"location":"plotting/#plotting","text":"This page explains how to plot prices, indicators and profits.","title":"Plotting"},{"location":"plotting/#installation-setup","text":"Plotting modules use the Plotly library. You can install / upgrade this by running the following command: pip install -U -r requirements-plot.txt","title":"Installation / Setup"},{"location":"plotting/#plot-price-and-indicators","text":"The freqtrade plot-dataframe subcommand shows an interactive graph with three subplots: Main plot with candlesticks and indicators following price (sma/ema) Volume bars Additional indicators as specified by --indicators2 Possible arguments: usage: freqtrade plot-dataframe [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--indicators1 INDICATORS1 [INDICATORS1 ...]] [--indicators2 INDICATORS2 [INDICATORS2 ...]] [--plot-limit INT] [--db-url PATH] [--trade-source {DB,file}] [--export EXPORT] [--export-filename PATH] [--timerange TIMERANGE] [-i TIMEFRAME] [--no-trades] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --indicators1 INDICATORS1 [INDICATORS1 ...] Set indicators from your strategy you want in the first row of the graph. Space-separated list. Example: `ema3 ema5`. Default: `['sma', 'ema3', 'ema5']`. --indicators2 INDICATORS2 [INDICATORS2 ...] Set indicators from your strategy you want in the third row of the graph. Space-separated list. Example: `fastd fastk`. Default: `['macd', 'macdsignal']`. --plot-limit INT Specify tick limit for plotting. Notice: too high values cause huge files. Default: 750. --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file --export EXPORT Export backtest results, argument are: trades. Example: `--export=trades` --export-filename PATH Save backtest results to the file with this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --timerange TIMERANGE Specify what timerange of data to use. -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --no-trades Skip using trades from backtesting file and DB. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. Example: freqtrade plot-dataframe -p BTC/ETH --strategy AwesomeStrategy The -p/--pairs argument can be used to specify pairs you would like to plot. Note The freqtrade plot-dataframe subcommand generates one plot-file per pair. Specify custom indicators. Use --indicators1 for the main plot and --indicators2 for the subplot below (if values are in a different range than prices). freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --indicators1 sma ema --indicators2 macd","title":"Plot price and indicators"},{"location":"plotting/#further-usage-examples","text":"To plot multiple pairs, separate them with a space: freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH XRP/ETH To plot a timerange (to zoom in) freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange = 20180801 -20180805 To plot trades stored in a database use --db-url in combination with --trade-source DB : freqtrade plot-dataframe --strategy AwesomeStrategy --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB To plot trades from a backtesting result, use --export-filename <filename> freqtrade plot-dataframe --strategy AwesomeStrategy --export-filename user_data/backtest_results/backtest-result.json -p BTC/ETH","title":"Further usage examples"},{"location":"plotting/#plot-dataframe-basics","text":"The plot-dataframe subcommand requires backtesting data, a strategy and either a backtesting-results file or a database, containing trades corresponding to the strategy. The resulting plot will have the following elements: Green triangles: Buy signals from the strategy. (Note: not every buy signal generates a trade, compare to cyan circles.) Red triangles: Sell signals from the strategy. (Also, not every sell signal terminates a trade, compare to red and green squares.) Cyan circles: Trade entry points. Red squares: Trade exit points for trades with loss or 0% profit. Green squares: Trade exit points for profitable trades. Indicators with values corresponding to the candle scale (e.g. SMA/EMA), as specified with --indicators1 . Volume (bar chart at the bottom of the main chart). Indicators with values in different scales (e.g. MACD, RSI) below the volume bars, as specified with --indicators2 . Bollinger Bands Bollinger bands are automatically added to the plot if the columns bb_lowerband and bb_upperband exist, and are painted as a light blue area spanning from the lower band to the upper band.","title":"Plot dataframe basics"},{"location":"plotting/#advanced-plot-configuration","text":"An advanced plot configuration can be specified in the strategy in the plot_config parameter. Additional features when using plot_config include: Specify colors per indicator Specify additional subplots Specify indicator pairs to fill area in between The sample plot configuration below specifies fixed colors for the indicators. Otherwise, consecutive plots may produce different color schemes each time, making comparisons difficult. It also allows multiple subplots to display both MACD and RSI at the same time. Plot type can be configured using type key. Possible types are: scatter corresponding to plotly.graph_objects.Scatter class (default). bar corresponding to plotly.graph_objects.Bar class. Extra parameters to plotly.graph_objects.* constructor can be specified in plotly dict. Sample configuration with inline comments explaining the process: @property def plot_config ( self ): \"\"\" There are a lot of solutions how to build the return dictionary. The only important point is the return value. Example: plot_config = {'main_plot': {}, 'subplots': {}} \"\"\" plot_config = {} plot_config [ 'main_plot' ] = { # Configuration for main plot indicators. # Assumes 2 parameters, emashort and emalong to be specified. f 'ema_ { self . emashort . value } ' : { 'color' : 'red' }, f 'ema_ { self . emalong . value } ' : { 'color' : '#CCCCCC' }, # By omitting color, a random color is selected. 'sar' : {}, # fill area between senkou_a and senkou_b 'senkou_a' : { 'color' : 'green' , #optional 'fill_to' : 'senkou_b' , 'fill_label' : 'Ichimoku Cloud' , #optional 'fill_color' : 'rgba(255,76,46,0.2)' , #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b' : {} } plot_config [ 'subplots' ] = { # Create subplot MACD \"MACD\" : { 'macd' : { 'color' : 'blue' , 'fill_to' : 'macdhist' }, 'macdsignal' : { 'color' : 'orange' }, 'macdhist' : { 'type' : 'bar' , 'plotly' : { 'opacity' : 0.9 }} }, # Additional subplot RSI \"RSI\" : { 'rsi' : { 'color' : 'red' } } } return plot_config As attribute (former method) Assigning plot_config is also possible as Attribute (this used to be the default way). This has the disadvantage that strategy parameters are not available, preventing certain configurations from working. plot_config = { 'main_plot' : { # Configuration for main plot indicators. # Specifies `ema10` to be red, and `ema50` to be a shade of gray 'ema10' : { 'color' : 'red' }, 'ema50' : { 'color' : '#CCCCCC' }, # By omitting color, a random color is selected. 'sar' : {}, # fill area between senkou_a and senkou_b 'senkou_a' : { 'color' : 'green' , #optional 'fill_to' : 'senkou_b' , 'fill_label' : 'Ichimoku Cloud' , #optional 'fill_color' : 'rgba(255,76,46,0.2)' , #optional }, # plot senkou_b, too. Not only the area to it. 'senkou_b' : {} }, 'subplots' : { # Create subplot MACD \"MACD\" : { 'macd' : { 'color' : 'blue' , 'fill_to' : 'macdhist' }, 'macdsignal' : { 'color' : 'orange' }, 'macdhist' : { 'type' : 'bar' , 'plotly' : { 'opacity' : 0.9 }} }, # Additional subplot RSI \"RSI\" : { 'rsi' : { 'color' : 'red' } } } } Note The above configuration assumes that ema10 , ema50 , senkou_a , senkou_b , macd , macdsignal , macdhist and rsi are columns in the DataFrame created by the strategy. Warning plotly arguments are only supported with plotly library and will not work with freq-ui. Trade position adjustments If position_adjustment_enable / adjust_trade_position() is used, the trade initial buy price is averaged over multiple orders and the trade start price will most likely appear outside the candle range.","title":"Advanced plot configuration"},{"location":"plotting/#plot-profit","text":"The plot-profit subcommand shows an interactive graph with three plots: Average closing price for all pairs. The summarized profit made by backtesting. Note that this is not the real-world profit, but more of an estimate. Profit for each individual pair. Parallelism of trades. Underwater (Periods of drawdown). The first graph is good to get a grip of how the overall market progresses. The second graph will show if your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less often, but makes big swings. This graph will also highlight the start (and end) of the Max drawdown period. The third graph can be useful to spot outliers, events in pairs that cause profit spikes. The forth graph can help you analyze trade parallelism, showing how often max_open_trades have been maxed out. Possible options for the freqtrade plot-profit subcommand: usage: freqtrade plot-profit [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [-s NAME] [--strategy-path PATH] [-p PAIRS [PAIRS ...]] [--timerange TIMERANGE] [--export EXPORT] [--export-filename PATH] [--db-url PATH] [--trade-source {DB,file}] [-i TIMEFRAME] optional arguments: -h, --help show this help message and exit -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...] Limit command to these pairs. Pairs are space- separated. --timerange TIMERANGE Specify what timerange of data to use. --export EXPORT Export backtest results, argument are: trades. Example: `--export=trades` --export-filename PATH, --backtest-filename PATH Use backtest results from this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-source {DB,file} Specify the source for trades (Can be DB or file (backtest file)) Default: file -i TIMEFRAME, --timeframe TIMEFRAME Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`). --auto-open Automatically open generated plot. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Strategy arguments: -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --strategy-path PATH Specify additional strategy lookup path. The -p/--pairs argument, can be used to limit the pairs that are considered for this calculation. Examples: Use custom backtest-export file freqtrade plot-profit -p LTC/BTC --export-filename user_data/backtest_results/backtest-result.json Use custom database freqtrade plot-profit -p LTC/BTC --db-url sqlite:///tradesv3.sqlite --trade-source DB freqtrade --datadir user_data/data/binance_save/ plot-profit -p LTC/BTC","title":"Plot profit"},{"location":"plugins/","text":"Plugins \u00b6 Pairlists and Pairlist Handlers \u00b6 Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist. Pair blacklist \u00b6 The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!) Available Pairlist Handlers \u00b6 StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly. Static Pair List \u00b6 By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . \"pairlists\" : [ { \"method\" : \"StaticPairList\" } ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist. Volume Pair List \u00b6 VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange. VolumePairList Advanced mode \u00b6 VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 3600 , \"lookback_timeframe\" : \"1h\" , \"lookback_period\" : 72 } ], Note VolumePairList does not support backtesting mode. AgeFilter \u00b6 Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed . OffsetFilter \u00b6 Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list): \"pairlists\" : [ // ... { \"method\" : \"OffsetFilter\" , \"offset\" : 10 , \"number_assets\" : 20 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger than the total length of the incoming pairlist will result in an empty pairlist. PerformanceFilter \u00b6 Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. \"pairlists\" : [ // ... { \"method\" : \"PerformanceFilter\" , \"minutes\" : 1440 , // rolling 24h \"min_profit\" : 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode. PrecisionFilter \u00b6 Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies. PriceFilter \u00b6 The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding. ShuffleFilter \u00b6 Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set. SpreadFilter \u00b6 Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out. RangeStabilityFilter \u00b6 Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. \"pairlists\" : [ { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"max_rate_of_change\" : 0.99 , \"refresh_period\" : 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time. VolatilityFilter \u00b6 Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. \"pairlists\" : [ { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 } ] Full example of Pairlist Handlers \u00b6 The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. \"exchange\" : { \"pair_whitelist\" : [], \"pair_blacklist\" : [ \"BNB/BTC\" ] }, \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" }, { \"method\" : \"AgeFilter\" , \"min_days_listed\" : 10 }, { \"method\" : \"PrecisionFilter\" }, { \"method\" : \"PriceFilter\" , \"low_price_ratio\" : 0.01 }, { \"method\" : \"SpreadFilter\" , \"max_spread_ratio\" : 0.005 }, { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"refresh_period\" : 1440 }, { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 }, { \"method\" : \"ShuffleFilter\" , \"seed\" : 42 } ], Protections \u00b6 Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property . Available Protections \u00b6 StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade. Common settings to all Protections \u00b6 Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition. Stoploss Guard \u00b6 StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. Similarly, this protection will by default look at all trades (long and short). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses. required_profit will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. @property def protections ( self ): return [ { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 4 , \"required_profit\" : 0.0 , \"only_per_pair\" : False , \"only_per_side\" : False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy. MaxDrawdown \u00b6 MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. @property def protections ( self ): return [ { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 12 , \"max_allowed_drawdown\" : 0.2 }, ] Low Profit Pairs \u00b6 LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses. The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. @property def protections ( self ): return [ { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration\" : 60 , \"required_profit\" : 0.02 , \"only_per_pair\" : False , } ] Cooldown Period \u00b6 CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade. Full example of Protections \u00b6 All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. from freqtrade.strategy import IStrategy class AwesomeStrategy ( IStrategy ) timeframe = '1h' @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 5 }, { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 4 , \"max_allowed_drawdown\" : 0.2 }, { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"only_per_pair\" : False }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration_candles\" : 60 , \"required_profit\" : 0.02 }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"required_profit\" : 0.01 } ] # ...","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"plugins/#pairlists-and-pairlist-handlers","text":"Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist.","title":"Pairlists and Pairlist Handlers"},{"location":"plugins/#pair-blacklist","text":"The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!)","title":"Pair blacklist"},{"location":"plugins/#available-pairlist-handlers","text":"StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly.","title":"Available Pairlist Handlers"},{"location":"plugins/#static-pair-list","text":"By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . \"pairlists\" : [ { \"method\" : \"StaticPairList\" } ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist.","title":"Static Pair List"},{"location":"plugins/#volume-pair-list","text":"VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange.","title":"Volume Pair List"},{"location":"plugins/#volumepairlist-advanced-mode","text":"VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 3600 , \"lookback_timeframe\" : \"1h\" , \"lookback_period\" : 72 } ], Note VolumePairList does not support backtesting mode.","title":"VolumePairList Advanced mode"},{"location":"plugins/#agefilter","text":"Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed .","title":"AgeFilter"},{"location":"plugins/#offsetfilter","text":"Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list): \"pairlists\" : [ // ... { \"method\" : \"OffsetFilter\" , \"offset\" : 10 , \"number_assets\" : 20 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger than the total length of the incoming pairlist will result in an empty pairlist.","title":"OffsetFilter"},{"location":"plugins/#performancefilter","text":"Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. \"pairlists\" : [ // ... { \"method\" : \"PerformanceFilter\" , \"minutes\" : 1440 , // rolling 24h \"min_profit\" : 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode.","title":"PerformanceFilter"},{"location":"plugins/#precisionfilter","text":"Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies.","title":"PrecisionFilter"},{"location":"plugins/#pricefilter","text":"The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.","title":"PriceFilter"},{"location":"plugins/#shufflefilter","text":"Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set.","title":"ShuffleFilter"},{"location":"plugins/#spreadfilter","text":"Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out.","title":"SpreadFilter"},{"location":"plugins/#rangestabilityfilter","text":"Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. \"pairlists\" : [ { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"max_rate_of_change\" : 0.99 , \"refresh_period\" : 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.","title":"RangeStabilityFilter"},{"location":"plugins/#volatilityfilter","text":"Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. \"pairlists\" : [ { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 } ]","title":"VolatilityFilter"},{"location":"plugins/#full-example-of-pairlist-handlers","text":"The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. \"exchange\" : { \"pair_whitelist\" : [], \"pair_blacklist\" : [ \"BNB/BTC\" ] }, \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" }, { \"method\" : \"AgeFilter\" , \"min_days_listed\" : 10 }, { \"method\" : \"PrecisionFilter\" }, { \"method\" : \"PriceFilter\" , \"low_price_ratio\" : 0.01 }, { \"method\" : \"SpreadFilter\" , \"max_spread_ratio\" : 0.005 }, { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"refresh_period\" : 1440 }, { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 }, { \"method\" : \"ShuffleFilter\" , \"seed\" : 42 } ],","title":"Full example of Pairlist Handlers"},{"location":"plugins/#protections","text":"Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property .","title":"Protections"},{"location":"plugins/#available-protections","text":"StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade.","title":"Available Protections"},{"location":"plugins/#common-settings-to-all-protections","text":"Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.","title":"Common settings to all Protections"},{"location":"plugins/#stoploss-guard","text":"StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. Similarly, this protection will by default look at all trades (long and short). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses. required_profit will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. @property def protections ( self ): return [ { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 4 , \"required_profit\" : 0.0 , \"only_per_pair\" : False , \"only_per_side\" : False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy.","title":"Stoploss Guard"},{"location":"plugins/#maxdrawdown","text":"MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. @property def protections ( self ): return [ { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 12 , \"max_allowed_drawdown\" : 0.2 }, ]","title":"MaxDrawdown"},{"location":"plugins/#low-profit-pairs","text":"LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses. The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. @property def protections ( self ): return [ { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration\" : 60 , \"required_profit\" : 0.02 , \"only_per_pair\" : False , } ]","title":"Low Profit Pairs"},{"location":"plugins/#cooldown-period","text":"CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade.","title":"Cooldown Period"},{"location":"plugins/#full-example-of-protections","text":"All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. from freqtrade.strategy import IStrategy class AwesomeStrategy ( IStrategy ) timeframe = '1h' @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 5 }, { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 4 , \"max_allowed_drawdown\" : 0.2 }, { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"only_per_pair\" : False }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration_candles\" : 60 , \"required_profit\" : 0.02 }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"required_profit\" : 0.01 } ] # ...","title":"Full example of Protections"},{"location":"rest-api/","text":"REST API & FreqUI \u00b6 FreqUI \u00b6 Freqtrade provides a builtin webserver, which can serve FreqUI , the freqtrade UI. By default, the UI is not included in the installation (except for docker images), and must be installed explicitly with freqtrade install-ui . This same command can also be used to update freqUI, should there be a new release. Once the bot is started in trade / dry-run mode (with freqtrade trade ) - the UI will be available under the configured port below (usually http://127.0.0.1:8080 ). Alpha release FreqUI is still considered an alpha release - if you encounter bugs or inconsistencies please open a FreqUI issue . developers Developers should not use this method, but instead use the method described in the freqUI repository to get the source-code of freqUI. Configuration \u00b6 Enable the rest API by adding the api_server section to your configuration and setting api_server.enabled to true . Sample configuration: \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"127.0.0.1\" , \"listen_port\" : 8080 , \"verbosity\" : \"error\" , \"enable_openapi\" : false , \"jwt_secret_key\" : \"somethingrandom\" , \"CORS_origins\" : [], \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" }, Security warning By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot. API/UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. You can then access the API by going to http://127.0.0.1:8080/api/v1/ping in a browser to check if the API is running correctly. This should return the response: {\"status\":\"pong\"} All other endpoints return sensitive info and require authentication and are therefore not available through a web browser. Security \u00b6 To generate a secure password, best use a password manager, or use the below code. import secrets secrets . token_hex () JWT token Use the same method to also generate a JWT secret key ( jwt_secret_key ). Password selection Please make sure to select a very strong, unique password to protect your bot from unauthorized access. Also change jwt_secret_key to something random (no need to remember this, but it'll be used to encrypt your session, so it better be something unique!). Configuration with docker \u00b6 If you run your bot using docker, you'll need to have the bot listen to incoming connections. The security is then handled by docker. \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"0.0.0.0\" , \"listen_port\" : 8080 , \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" , //... }, Make sure that the following 2 lines are available in your docker-compose file: ports: - \"127.0.0.1:8080:8080\" Security warning By using 8080:8080 in the docker port mapping, the API will be available to everyone connecting to the server under the correct port, so others may be able to control your bot. Rest API \u00b6 Consuming the API \u00b6 You can consume the API by using the script scripts/rest_client.py . The client script only requires the requests module, so Freqtrade does not need to be installed on the system. python3 scripts/rest_client.py <command> [ optional parameters ] By default, the script assumes 127.0.0.1 (localhost) and port 8080 to be used, however you can specify a configuration file to override this behaviour. Minimalistic client config \u00b6 { \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"0.0.0.0\" , \"listen_port\" : 8080 , \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" , //... } } python3 scripts/rest_client.py --config rest_config.json <command> [ optional parameters ] Available endpoints \u00b6 Command Description ping Simple command testing the API Readiness - requires no authentication. start Starts the trader. stop Stops the trader. stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. reload_config Reloads the configuration file. trades List last trades. Limited to 500 trades per call. trade/<tradeid> Get specific trade. delete_trade <trade_id> Remove trade from the database. Tries to close open orders. Requires manual handling of this trade on the exchange. show_config Shows part of the current configuration with relevant settings to operation. logs Shows last log messages. status Lists all open trades. count Displays number of trades used and available. locks Displays currently locked pairs. delete_lock <lock_id> Deletes (disables) the lock by id. profit Display a summary of your profit/loss from close trades and some stats about your performance. forceexit <trade_id> Instantly exits the given trade (Ignoring minimum_roi ). forceexit all Instantly exits all open trades (Ignoring minimum_roi ). forceenter <pair> [rate] Instantly enters the given pair. Rate is optional. ( force_entry_enable must be set to True) forceenter <pair> <side> [rate] Instantly longs or shorts the given pair. Rate is optional. ( force_entry_enable must be set to True) performance Show performance of each finished trade grouped by pair. balance Show account balance per currency. daily <n> Shows profit or loss per day, over the last n days (n defaults to 7). stats Display a summary of profit / loss reasons as well as average holding times. whitelist Show the current whitelist. blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. edge Show validated pairs by Edge if it is enabled. pair_candles Returns dataframe for a pair / timeframe combination while the bot is running. Alpha pair_history Returns an analyzed dataframe for a given timerange, analyzed by a given strategy. Alpha plot_config Get plot config from the strategy (or nothing if not configured). Alpha strategies List strategies in strategy directory. Alpha strategy <strategy> Get specific Strategy content. Alpha available_pairs List available backtest data. Alpha version Show version. sysinfo Show informations about the system load. health Show bot health (last bot loop). Alpha status Endpoints labeled with Alpha status above may change at any time without notice. Possible commands can be listed from the rest-client script using the help command. python3 scripts/rest_client.py help Possible commands: available_pairs Return available pair (backtest data) based on timeframe / stake_currency selection :param timeframe: Only pairs with this timeframe available. :param stake_currency: Only pairs that include this timeframe balance Get the account balance. blacklist Show the current blacklist. :param add: List of coins to add (example: \"BNB/BTC\") count Return the amount of open trades. daily Return the profits for each day, and amount of trades. delete_lock Delete (disable) lock from the database. :param lock_id: ID for the lock to delete delete_trade Delete trade from the database. Tries to close open orders. Requires manual handling of this asset on the exchange. :param trade_id: Deletes the trade with this ID from the database. edge Return information about edge. forcebuy Buy an asset. :param pair: Pair to buy (ETH/BTC) :param price: Optional - price to buy forceenter Force entering a trade :param pair: Pair to buy (ETH/BTC) :param side: 'long' or 'short' :param price: Optional - price to buy forceexit Force-exit a trade. :param tradeid: Id of the trade (can be received via status command) :param ordertype: Order type to use (must be market or limit) :param amount: Amount to sell. Full sell if not given health Provides a quick health check of the running bot. locks Return current locks logs Show latest logs. :param limit: Limits log messages to the last <limit> logs. No limit to get the entire log. pair_candles Return live dataframe for <pair><timeframe>. :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param limit: Limit result to the last n candles. pair_history Return historic, analyzed dataframe :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param strategy: Strategy to analyze and get values for :param timerange: Timerange to get data for (same format than --timerange endpoints) performance Return the performance of the different coins. ping simple ping plot_config Return plot configuration if the strategy defines one. profit Return the profit summary. reload_config Reload configuration. show_config Returns part of the configuration, relevant for trading operations. start Start the bot if it's in the stopped state. stats Return the stats report (durations, sell-reasons). status Get the status of open trades. stop Stop the bot. Use `start` to restart. stopbuy Stop buying (but handle sells gracefully). Use `reload_config` to reset. strategies Lists available strategies strategy Get strategy details :param strategy: Strategy class name sysinfo Provides system information (CPU, RAM usage) trade Return specific trade :param trade_id: Specify which trade to get. trades Return trades history, sorted by id :param limit: Limits trades to the X last trades. Max 500 trades. :param offset: Offset by this amount of trades. version Return the version of the bot. whitelist Show the current whitelist. OpenAPI interface \u00b6 To enable the builtin openAPI interface (Swagger UI), specify \"enable_openapi\": true in the api_server configuration. This will enable the Swagger UI at the /docs endpoint. By default, that's running at http://localhost:8080/docs - but it'll depend on your settings. Advanced API usage using JWT tokens \u00b6 Note The below should be done in an application (a Freqtrade REST API client, which fetches info via API), and is not intended to be used on a regular basis. Freqtrade's REST API also offers JWT (JSON Web Tokens). You can login using the following command, and subsequently use the resulting access_token. > curl -X POST --user Freqtrader http://localhost:8080/api/v1/token/login { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\" , \"refresh_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiZWQ1ZWI3YjAtYjMwMy00YzAyLTg2N2MtNWViMjIxNWQ2YTMxIiwiZXhwIjoxNTkxNzExNjgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJ0eXBlIjoicmVmcmVzaCJ9.d1AT_jYICyTAjD0fiQAr52rkRqtxCjUGEMwlNuuzgNQ\" } > access_token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\" # Use access_token for authentication > curl -X GET --header \"Authorization: Bearer ${ access_token } \" http://localhost:8080/api/v1/count Since the access token has a short timeout (15 min) - the token/refresh request should be used periodically to get a fresh access token: > curl -X POST --header \"Authorization: Bearer ${ refresh_token } \" http://localhost:8080/api/v1/token/refresh { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk5NzQsIm5iZiI6MTU4OTExOTk3NCwianRpIjoiMDBjNTlhMWUtMjBmYS00ZTk0LTliZjAtNWQwNTg2MTdiZDIyIiwiZXhwIjoxNTg5MTIwODc0LCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.1seHlII3WprjjclY6DpRhen0rqdF4j6jbvxIhUFaSbs\" } CORS \u00b6 This whole section is only necessary in cross-origin cases (where you multiple bot API's running on localhost:8081 , localhost:8082 , ...), and want to combine them into one FreqUI instance. Technical explanation All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows * CORS policies for requests with credentials, so this setting must be set appropriately. Users can allow access from different origin URL's to the bot API via the CORS_origins configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API. Assuming your application is deployed as https://frequi.freqtrade.io/home/ - this would mean that the following configuration becomes necessary: { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"https://frequi.freqtrade.io\"], //... } In the following (pretty common) case, FreqUI is accessible on http://localhost:8080/trade (this is what you see in your navbar when navigating to freqUI). The correct configuration for this case is http://localhost:8080 - the main part of the URL including the port. { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"http://localhost:8080\"], //... } Note We strongly recommend to also set jwt_secret_key to something random and known only to yourself to avoid unauthorized access to your bot.","title":"REST API & FreqUI"},{"location":"rest-api/#rest-api-frequi","text":"","title":"REST API &amp; FreqUI"},{"location":"rest-api/#frequi","text":"Freqtrade provides a builtin webserver, which can serve FreqUI , the freqtrade UI. By default, the UI is not included in the installation (except for docker images), and must be installed explicitly with freqtrade install-ui . This same command can also be used to update freqUI, should there be a new release. Once the bot is started in trade / dry-run mode (with freqtrade trade ) - the UI will be available under the configured port below (usually http://127.0.0.1:8080 ). Alpha release FreqUI is still considered an alpha release - if you encounter bugs or inconsistencies please open a FreqUI issue . developers Developers should not use this method, but instead use the method described in the freqUI repository to get the source-code of freqUI.","title":"FreqUI"},{"location":"rest-api/#configuration","text":"Enable the rest API by adding the api_server section to your configuration and setting api_server.enabled to true . Sample configuration: \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"127.0.0.1\" , \"listen_port\" : 8080 , \"verbosity\" : \"error\" , \"enable_openapi\" : false , \"jwt_secret_key\" : \"somethingrandom\" , \"CORS_origins\" : [], \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" }, Security warning By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot. API/UI Access on a remote servers If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. You can then access the API by going to http://127.0.0.1:8080/api/v1/ping in a browser to check if the API is running correctly. This should return the response: {\"status\":\"pong\"} All other endpoints return sensitive info and require authentication and are therefore not available through a web browser.","title":"Configuration"},{"location":"rest-api/#security","text":"To generate a secure password, best use a password manager, or use the below code. import secrets secrets . token_hex () JWT token Use the same method to also generate a JWT secret key ( jwt_secret_key ). Password selection Please make sure to select a very strong, unique password to protect your bot from unauthorized access. Also change jwt_secret_key to something random (no need to remember this, but it'll be used to encrypt your session, so it better be something unique!).","title":"Security"},{"location":"rest-api/#configuration-with-docker","text":"If you run your bot using docker, you'll need to have the bot listen to incoming connections. The security is then handled by docker. \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"0.0.0.0\" , \"listen_port\" : 8080 , \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" , //... }, Make sure that the following 2 lines are available in your docker-compose file: ports: - \"127.0.0.1:8080:8080\" Security warning By using 8080:8080 in the docker port mapping, the API will be available to everyone connecting to the server under the correct port, so others may be able to control your bot.","title":"Configuration with docker"},{"location":"rest-api/#rest-api","text":"","title":"Rest API"},{"location":"rest-api/#consuming-the-api","text":"You can consume the API by using the script scripts/rest_client.py . The client script only requires the requests module, so Freqtrade does not need to be installed on the system. python3 scripts/rest_client.py <command> [ optional parameters ] By default, the script assumes 127.0.0.1 (localhost) and port 8080 to be used, however you can specify a configuration file to override this behaviour.","title":"Consuming the API"},{"location":"rest-api/#minimalistic-client-config","text":"{ \"api_server\" : { \"enabled\" : true , \"listen_ip_address\" : \"0.0.0.0\" , \"listen_port\" : 8080 , \"username\" : \"Freqtrader\" , \"password\" : \"SuperSecret1!\" , //... } } python3 scripts/rest_client.py --config rest_config.json <command> [ optional parameters ]","title":"Minimalistic client config"},{"location":"rest-api/#available-endpoints","text":"Command Description ping Simple command testing the API Readiness - requires no authentication. start Starts the trader. stop Stops the trader. stopbuy Stops the trader from opening new trades. Gracefully closes open trades according to their rules. reload_config Reloads the configuration file. trades List last trades. Limited to 500 trades per call. trade/<tradeid> Get specific trade. delete_trade <trade_id> Remove trade from the database. Tries to close open orders. Requires manual handling of this trade on the exchange. show_config Shows part of the current configuration with relevant settings to operation. logs Shows last log messages. status Lists all open trades. count Displays number of trades used and available. locks Displays currently locked pairs. delete_lock <lock_id> Deletes (disables) the lock by id. profit Display a summary of your profit/loss from close trades and some stats about your performance. forceexit <trade_id> Instantly exits the given trade (Ignoring minimum_roi ). forceexit all Instantly exits all open trades (Ignoring minimum_roi ). forceenter <pair> [rate] Instantly enters the given pair. Rate is optional. ( force_entry_enable must be set to True) forceenter <pair> <side> [rate] Instantly longs or shorts the given pair. Rate is optional. ( force_entry_enable must be set to True) performance Show performance of each finished trade grouped by pair. balance Show account balance per currency. daily <n> Shows profit or loss per day, over the last n days (n defaults to 7). stats Display a summary of profit / loss reasons as well as average holding times. whitelist Show the current whitelist. blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. edge Show validated pairs by Edge if it is enabled. pair_candles Returns dataframe for a pair / timeframe combination while the bot is running. Alpha pair_history Returns an analyzed dataframe for a given timerange, analyzed by a given strategy. Alpha plot_config Get plot config from the strategy (or nothing if not configured). Alpha strategies List strategies in strategy directory. Alpha strategy <strategy> Get specific Strategy content. Alpha available_pairs List available backtest data. Alpha version Show version. sysinfo Show informations about the system load. health Show bot health (last bot loop). Alpha status Endpoints labeled with Alpha status above may change at any time without notice. Possible commands can be listed from the rest-client script using the help command. python3 scripts/rest_client.py help Possible commands: available_pairs Return available pair (backtest data) based on timeframe / stake_currency selection :param timeframe: Only pairs with this timeframe available. :param stake_currency: Only pairs that include this timeframe balance Get the account balance. blacklist Show the current blacklist. :param add: List of coins to add (example: \"BNB/BTC\") count Return the amount of open trades. daily Return the profits for each day, and amount of trades. delete_lock Delete (disable) lock from the database. :param lock_id: ID for the lock to delete delete_trade Delete trade from the database. Tries to close open orders. Requires manual handling of this asset on the exchange. :param trade_id: Deletes the trade with this ID from the database. edge Return information about edge. forcebuy Buy an asset. :param pair: Pair to buy (ETH/BTC) :param price: Optional - price to buy forceenter Force entering a trade :param pair: Pair to buy (ETH/BTC) :param side: 'long' or 'short' :param price: Optional - price to buy forceexit Force-exit a trade. :param tradeid: Id of the trade (can be received via status command) :param ordertype: Order type to use (must be market or limit) :param amount: Amount to sell. Full sell if not given health Provides a quick health check of the running bot. locks Return current locks logs Show latest logs. :param limit: Limits log messages to the last <limit> logs. No limit to get the entire log. pair_candles Return live dataframe for <pair><timeframe>. :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param limit: Limit result to the last n candles. pair_history Return historic, analyzed dataframe :param pair: Pair to get data for :param timeframe: Only pairs with this timeframe available. :param strategy: Strategy to analyze and get values for :param timerange: Timerange to get data for (same format than --timerange endpoints) performance Return the performance of the different coins. ping simple ping plot_config Return plot configuration if the strategy defines one. profit Return the profit summary. reload_config Reload configuration. show_config Returns part of the configuration, relevant for trading operations. start Start the bot if it's in the stopped state. stats Return the stats report (durations, sell-reasons). status Get the status of open trades. stop Stop the bot. Use `start` to restart. stopbuy Stop buying (but handle sells gracefully). Use `reload_config` to reset. strategies Lists available strategies strategy Get strategy details :param strategy: Strategy class name sysinfo Provides system information (CPU, RAM usage) trade Return specific trade :param trade_id: Specify which trade to get. trades Return trades history, sorted by id :param limit: Limits trades to the X last trades. Max 500 trades. :param offset: Offset by this amount of trades. version Return the version of the bot. whitelist Show the current whitelist.","title":"Available endpoints"},{"location":"rest-api/#openapi-interface","text":"To enable the builtin openAPI interface (Swagger UI), specify \"enable_openapi\": true in the api_server configuration. This will enable the Swagger UI at the /docs endpoint. By default, that's running at http://localhost:8080/docs - but it'll depend on your settings.","title":"OpenAPI interface"},{"location":"rest-api/#advanced-api-usage-using-jwt-tokens","text":"Note The below should be done in an application (a Freqtrade REST API client, which fetches info via API), and is not intended to be used on a regular basis. Freqtrade's REST API also offers JWT (JSON Web Tokens). You can login using the following command, and subsequently use the resulting access_token. > curl -X POST --user Freqtrader http://localhost:8080/api/v1/token/login { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\" , \"refresh_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiZWQ1ZWI3YjAtYjMwMy00YzAyLTg2N2MtNWViMjIxNWQ2YTMxIiwiZXhwIjoxNTkxNzExNjgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJ0eXBlIjoicmVmcmVzaCJ9.d1AT_jYICyTAjD0fiQAr52rkRqtxCjUGEMwlNuuzgNQ\" } > access_token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\" # Use access_token for authentication > curl -X GET --header \"Authorization: Bearer ${ access_token } \" http://localhost:8080/api/v1/count Since the access token has a short timeout (15 min) - the token/refresh request should be used periodically to get a fresh access token: > curl -X POST --header \"Authorization: Bearer ${ refresh_token } \" http://localhost:8080/api/v1/token/refresh { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk5NzQsIm5iZiI6MTU4OTExOTk3NCwianRpIjoiMDBjNTlhMWUtMjBmYS00ZTk0LTliZjAtNWQwNTg2MTdiZDIyIiwiZXhwIjoxNTg5MTIwODc0LCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.1seHlII3WprjjclY6DpRhen0rqdF4j6jbvxIhUFaSbs\" }","title":"Advanced API usage using JWT tokens"},{"location":"rest-api/#cors","text":"This whole section is only necessary in cross-origin cases (where you multiple bot API's running on localhost:8081 , localhost:8082 , ...), and want to combine them into one FreqUI instance. Technical explanation All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows * CORS policies for requests with credentials, so this setting must be set appropriately. Users can allow access from different origin URL's to the bot API via the CORS_origins configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API. Assuming your application is deployed as https://frequi.freqtrade.io/home/ - this would mean that the following configuration becomes necessary: { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"https://frequi.freqtrade.io\"], //... } In the following (pretty common) case, FreqUI is accessible on http://localhost:8080/trade (this is what you see in your navbar when navigating to freqUI). The correct configuration for this case is http://localhost:8080 - the main part of the URL including the port. { //... \"jwt_secret_key\": \"somethingrandom\", \"CORS_origins\": [\"http://localhost:8080\"], //... } Note We strongly recommend to also set jwt_secret_key to something random and known only to yourself to avoid unauthorized access to your bot.","title":"CORS"},{"location":"sandbox-testing/","text":"Sandbox API testing \u00b6 Some exchanges provide sandboxes or testbeds for risk-free testing, while running the bot against a real exchange. With some configuration, freqtrade (in combination with ccxt) provides access to these. This document is an overview to configure Freqtrade to be used with sandboxes. This can be useful to developers and trader alike. Warning Sandboxes usually have very low volume, and either a very wide spread, or no orders available at all. Therefore, sandboxes will usually not do a good job of showing you how a strategy would work in real trading. Exchanges known to have a sandbox / testnet \u00b6 binance coinbasepro gemini huobipro kucoin phemex Note We did not test correct functioning of all of the above testnets. Please report your experiences with each sandbox. Configure a Sandbox account \u00b6 When testing your API connectivity, make sure to use the appropriate sandbox / testnet URL. In general, you should follow these steps to enable an exchange's sandbox: Figure out if an exchange has a sandbox (most likely by using google or the exchange's support documents) Create a sandbox account (often the sandbox-account requires separate registration) Add some test assets to account Create API keys Add test funds \u00b6 Usually, sandbox exchanges allow depositing funds directly via web-interface. You should make sure to have a realistic amount of funds available to your test-account, so results are representable of your real account funds. Warning Test exchanges will NEVER require your real credit card or banking details! Configure freqtrade to use a exchange's sandbox \u00b6 Sandbox URLs \u00b6 Freqtrade makes use of CCXT which in turn provides a list of URLs to Freqtrade. These include ['test'] and ['api'] . [Test] if available will point to an Exchanges sandbox. [Api] normally used, and resolves to live API target on the exchange. To make use of sandbox / test add \"sandbox\": true, to your config.json \"exchange\" : { \"name\" : \"coinbasepro\" , \"sandbox\" : true , \"key\" : \"5wowfxemogxeowo;heiohgmd\" , \"secret\" : \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\" , \"password\" : \"1bkjfkhfhfu6sr\" , \"outdated_offset\" : 5 \"pair_whitelist\" : [ \"BTC/USD\" ] }, \"datadir\" : \"user_data/data/coinbasepro_sandbox\" Also the following information: api-key (created for the sandbox webpage) api-secret (noted earlier) password (the passphrase - noted earlier) Different data directory We also recommend to set datadir to something identifying downloaded data as sandbox data, to avoid having sandbox data mixed with data from the real exchange. This can be done by adding the \"datadir\" key to the configuration. Now, whenever you use this configuration, your data directory will be set to this directory. You should now be ready to test your sandbox \u00b6 Ensure Freqtrade logs show the sandbox URL, and trades made are shown in sandbox. Also make sure to select a pair which shows at least some decent value (which very often is BTC/ ). Common problems with sandbox exchanges \u00b6 Sandbox exchange instances often have very low volume, which can cause some problems which usually are not seen on a real exchange instance. Old Candles problem \u00b6 Since Sandboxes often have low volume, candles can be quite old and show no volume. To disable the error \"Outdated history for pair ...\", best increase the parameter \"outdated_offset\" to a number that seems realistic for the sandbox you're using. Unfilled orders \u00b6 Sandboxes often have very low volumes - which means that many trades can go unfilled, or can go unfilled for a very long time. To mitigate this, you can try to match the first order on the opposite orderbook side using the following configuration: jsonc \"order_types\": { \"entry\": \"limit\", \"exit\": \"limit\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, The configuration is similar to the suggested configuration for market orders - however by using limit-orders you can avoid moving the price too much, and you can set the worst price you might get.","title":"Sandbox Testing"},{"location":"sandbox-testing/#sandbox-api-testing","text":"Some exchanges provide sandboxes or testbeds for risk-free testing, while running the bot against a real exchange. With some configuration, freqtrade (in combination with ccxt) provides access to these. This document is an overview to configure Freqtrade to be used with sandboxes. This can be useful to developers and trader alike. Warning Sandboxes usually have very low volume, and either a very wide spread, or no orders available at all. Therefore, sandboxes will usually not do a good job of showing you how a strategy would work in real trading.","title":"Sandbox API testing"},{"location":"sandbox-testing/#exchanges-known-to-have-a-sandbox-testnet","text":"binance coinbasepro gemini huobipro kucoin phemex Note We did not test correct functioning of all of the above testnets. Please report your experiences with each sandbox.","title":"Exchanges known to have a sandbox / testnet"},{"location":"sandbox-testing/#configure-a-sandbox-account","text":"When testing your API connectivity, make sure to use the appropriate sandbox / testnet URL. In general, you should follow these steps to enable an exchange's sandbox: Figure out if an exchange has a sandbox (most likely by using google or the exchange's support documents) Create a sandbox account (often the sandbox-account requires separate registration) Add some test assets to account Create API keys","title":"Configure a Sandbox account"},{"location":"sandbox-testing/#add-test-funds","text":"Usually, sandbox exchanges allow depositing funds directly via web-interface. You should make sure to have a realistic amount of funds available to your test-account, so results are representable of your real account funds. Warning Test exchanges will NEVER require your real credit card or banking details!","title":"Add test funds"},{"location":"sandbox-testing/#configure-freqtrade-to-use-a-exchanges-sandbox","text":"","title":"Configure freqtrade to use a exchange's sandbox"},{"location":"sandbox-testing/#sandbox-urls","text":"Freqtrade makes use of CCXT which in turn provides a list of URLs to Freqtrade. These include ['test'] and ['api'] . [Test] if available will point to an Exchanges sandbox. [Api] normally used, and resolves to live API target on the exchange. To make use of sandbox / test add \"sandbox\": true, to your config.json \"exchange\" : { \"name\" : \"coinbasepro\" , \"sandbox\" : true , \"key\" : \"5wowfxemogxeowo;heiohgmd\" , \"secret\" : \"/ZMH1P62rCVmwefewrgcewX8nh4gob+lywxfwfxwwfxwfNsH1ySgvWCUR/w==\" , \"password\" : \"1bkjfkhfhfu6sr\" , \"outdated_offset\" : 5 \"pair_whitelist\" : [ \"BTC/USD\" ] }, \"datadir\" : \"user_data/data/coinbasepro_sandbox\" Also the following information: api-key (created for the sandbox webpage) api-secret (noted earlier) password (the passphrase - noted earlier) Different data directory We also recommend to set datadir to something identifying downloaded data as sandbox data, to avoid having sandbox data mixed with data from the real exchange. This can be done by adding the \"datadir\" key to the configuration. Now, whenever you use this configuration, your data directory will be set to this directory.","title":"Sandbox URLs"},{"location":"sandbox-testing/#you-should-now-be-ready-to-test-your-sandbox","text":"Ensure Freqtrade logs show the sandbox URL, and trades made are shown in sandbox. Also make sure to select a pair which shows at least some decent value (which very often is BTC/ ).","title":"You should now be ready to test your sandbox"},{"location":"sandbox-testing/#common-problems-with-sandbox-exchanges","text":"Sandbox exchange instances often have very low volume, which can cause some problems which usually are not seen on a real exchange instance.","title":"Common problems with sandbox exchanges"},{"location":"sandbox-testing/#old-candles-problem","text":"Since Sandboxes often have low volume, candles can be quite old and show no volume. To disable the error \"Outdated history for pair ...\", best increase the parameter \"outdated_offset\" to a number that seems realistic for the sandbox you're using.","title":"Old Candles problem"},{"location":"sandbox-testing/#unfilled-orders","text":"Sandboxes often have very low volumes - which means that many trades can go unfilled, or can go unfilled for a very long time. To mitigate this, you can try to match the first order on the opposite orderbook side using the following configuration: jsonc \"order_types\": { \"entry\": \"limit\", \"exit\": \"limit\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, The configuration is similar to the suggested configuration for market orders - however by using limit-orders you can avoid moving the price too much, and you can set the worst price you might get.","title":"Unfilled orders"},{"location":"sql_cheatsheet/","text":"SQL Helper \u00b6 This page contains some help if you want to edit your sqlite db. Install sqlite3 \u00b6 Sqlite3 is a terminal based sqlite application. Feel free to use a visual Database editor like SqliteBrowser if you feel more comfortable with that. Ubuntu/Debian installation \u00b6 sudo apt-get install sqlite3 Using sqlite3 via docker-compose \u00b6 The freqtrade docker image does contain sqlite3, so you can edit the database without having to install anything on the host system. docker-compose exec freqtrade /bin/bash sqlite3 <database-file>.sqlite Open the DB \u00b6 sqlite3 .open <filepath> Table structure \u00b6 List tables \u00b6 .tables Display table structure \u00b6 .schema <table_name> Get all trades in the table \u00b6 SELECT * FROM trades ; Fix trade still open after a manual exit on the exchange \u00b6 Warning Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, /forceexit should be used to accomplish the same thing. It is strongly advised to backup your database file before making any manual changes. Note This should not be necessary after /forceexit, as force_exit orders are closed automatically by the bot on the next iteration. UPDATE trades SET is_open = 0 , close_date =< close_date > , close_rate =< close_rate > , close_profit = close_rate / open_rate - 1 , close_profit_abs = ( amount * < close_rate > * ( 1 - fee_close ) - ( amount * ( open_rate * ( 1 - fee_open )))), exit_reason =< exit_reason > WHERE id =< trade_ID_to_update > ; Example \u00b6 UPDATE trades SET is_open = 0 , close_date = '2020-06-20 03:08:45.103418' , close_rate = 0 . 19638016 , close_profit = 0 . 0496 , close_profit_abs = ( amount * 0 . 19638016 * ( 1 - fee_close ) - ( amount * ( open_rate * ( 1 - fee_open )))), exit_reason = 'force_exit' WHERE id = 31 ; Remove trade from the database \u00b6 Use RPC Methods to delete trades Consider using /delete <tradeid> via telegram or rest API. That's the recommended way to deleting trades. If you'd still like to remove a trade from the database directly, you can use the below query. Danger Some systems (Ubuntu) disable foreign keys in their sqlite3 packaging. When using sqlite - please ensure that foreign keys are on by running PRAGMA foreign_keys = ON before the above query. DELETE FROM trades WHERE id = < tradeid > ; DELETE FROM trades WHERE id = 31 ; Warning This will remove this trade from the database. Please make sure you got the correct id and NEVER run this query without the where clause. Use a different database system \u00b6 Freqtrade is using SQLAlchemy, which supports multiple different database systems. As such, a multitude of database systems should be supported. Freqtrade does not depend or install any additional database driver. Please refer to the SQLAlchemy docs on installation instructions for the respective database systems. The following systems have been tested and are known to work with freqtrade: sqlite (default) PostgreSQL) MariaDB Warning By using one of the below database systems, you acknowledge that you know how to manage such a system. The freqtrade team will not provide any support with setup or maintenance (or backups) of the below database systems. PostgreSQL \u00b6 Installation: pip install psycopg2-binary Usage: ... --db-url postgresql+psycopg2://<username>:<password>@localhost:5432/<database> Freqtrade will automatically create the tables necessary upon startup. If you're running different instances of Freqtrade, you must either setup one database per Instance or use different users / schemas for your connections. MariaDB / MySQL \u00b6 Freqtrade supports MariaDB by using SQLAlchemy, which supports multiple different database systems. Installation: pip install pymysql Usage: ... --db-url mysql+pymysql://<username>:<password>@localhost:3306/<database>","title":"SQL Cheat-sheet"},{"location":"sql_cheatsheet/#sql-helper","text":"This page contains some help if you want to edit your sqlite db.","title":"SQL Helper"},{"location":"sql_cheatsheet/#install-sqlite3","text":"Sqlite3 is a terminal based sqlite application. Feel free to use a visual Database editor like SqliteBrowser if you feel more comfortable with that.","title":"Install sqlite3"},{"location":"sql_cheatsheet/#ubuntudebian-installation","text":"sudo apt-get install sqlite3","title":"Ubuntu/Debian installation"},{"location":"sql_cheatsheet/#using-sqlite3-via-docker-compose","text":"The freqtrade docker image does contain sqlite3, so you can edit the database without having to install anything on the host system. docker-compose exec freqtrade /bin/bash sqlite3 <database-file>.sqlite","title":"Using sqlite3 via docker-compose"},{"location":"sql_cheatsheet/#open-the-db","text":"sqlite3 .open <filepath>","title":"Open the DB"},{"location":"sql_cheatsheet/#table-structure","text":"","title":"Table structure"},{"location":"sql_cheatsheet/#list-tables","text":".tables","title":"List tables"},{"location":"sql_cheatsheet/#display-table-structure","text":".schema <table_name>","title":"Display table structure"},{"location":"sql_cheatsheet/#get-all-trades-in-the-table","text":"SELECT * FROM trades ;","title":"Get all trades in the table"},{"location":"sql_cheatsheet/#fix-trade-still-open-after-a-manual-exit-on-the-exchange","text":"Warning Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, /forceexit should be used to accomplish the same thing. It is strongly advised to backup your database file before making any manual changes. Note This should not be necessary after /forceexit, as force_exit orders are closed automatically by the bot on the next iteration. UPDATE trades SET is_open = 0 , close_date =< close_date > , close_rate =< close_rate > , close_profit = close_rate / open_rate - 1 , close_profit_abs = ( amount * < close_rate > * ( 1 - fee_close ) - ( amount * ( open_rate * ( 1 - fee_open )))), exit_reason =< exit_reason > WHERE id =< trade_ID_to_update > ;","title":"Fix trade still open after a manual exit on the exchange"},{"location":"sql_cheatsheet/#example","text":"UPDATE trades SET is_open = 0 , close_date = '2020-06-20 03:08:45.103418' , close_rate = 0 . 19638016 , close_profit = 0 . 0496 , close_profit_abs = ( amount * 0 . 19638016 * ( 1 - fee_close ) - ( amount * ( open_rate * ( 1 - fee_open )))), exit_reason = 'force_exit' WHERE id = 31 ;","title":"Example"},{"location":"sql_cheatsheet/#remove-trade-from-the-database","text":"Use RPC Methods to delete trades Consider using /delete <tradeid> via telegram or rest API. That's the recommended way to deleting trades. If you'd still like to remove a trade from the database directly, you can use the below query. Danger Some systems (Ubuntu) disable foreign keys in their sqlite3 packaging. When using sqlite - please ensure that foreign keys are on by running PRAGMA foreign_keys = ON before the above query. DELETE FROM trades WHERE id = < tradeid > ; DELETE FROM trades WHERE id = 31 ; Warning This will remove this trade from the database. Please make sure you got the correct id and NEVER run this query without the where clause.","title":"Remove trade from the database"},{"location":"sql_cheatsheet/#use-a-different-database-system","text":"Freqtrade is using SQLAlchemy, which supports multiple different database systems. As such, a multitude of database systems should be supported. Freqtrade does not depend or install any additional database driver. Please refer to the SQLAlchemy docs on installation instructions for the respective database systems. The following systems have been tested and are known to work with freqtrade: sqlite (default) PostgreSQL) MariaDB Warning By using one of the below database systems, you acknowledge that you know how to manage such a system. The freqtrade team will not provide any support with setup or maintenance (or backups) of the below database systems.","title":"Use a different database system"},{"location":"sql_cheatsheet/#postgresql","text":"Installation: pip install psycopg2-binary Usage: ... --db-url postgresql+psycopg2://<username>:<password>@localhost:5432/<database> Freqtrade will automatically create the tables necessary upon startup. If you're running different instances of Freqtrade, you must either setup one database per Instance or use different users / schemas for your connections.","title":"PostgreSQL"},{"location":"sql_cheatsheet/#mariadb-mysql","text":"Freqtrade supports MariaDB by using SQLAlchemy, which supports multiple different database systems. Installation: pip install pymysql Usage: ... --db-url mysql+pymysql://<username>:<password>@localhost:3306/<database>","title":"MariaDB / MySQL"},{"location":"stoploss/","text":"Stop Loss \u00b6 The stoploss configuration parameter is loss as ratio that should trigger a sale. For example, value -0.10 will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional. Stoploss calculations do include fees, so a stoploss of -10% is placed exactly 10% below the entry point. Most of the strategy files already include the optimal stoploss value. Info All stoploss properties mentioned in this file can be set in the Strategy, or in the configuration. Configuration values will override the strategy values. Stop Loss On-Exchange/Freqtrade \u00b6 Those stoploss modes can be on exchange or off exchange . These modes can be configured with these values: 'emergency_exit' : 'market' , 'stoploss_on_exchange' : False 'stoploss_on_exchange_interval' : 60 , 'stoploss_on_exchange_limit_ratio' : 0.99 Note Stoploss on exchange is only supported for Binance (stop-loss-limit), Huobi (stop-limit), Kraken (stop-loss-market, stop-loss-limit), FTX (stop limit and stop-market) Gateio (stop-limit), and Kucoin (stop-limit and stop-market) as of now. Do not set too low/tight stoploss value if using stop loss on exchange! If set to low/tight then you have greater risk of missing fill on the order and stoploss will not work. stoploss_on_exchange and stoploss_on_exchange_limit_ratio \u00b6 Enable or Disable stop loss on exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order fills. This will protect you against sudden crashes in market, as the order execution happens purely within the exchange, and has no potential network overhead. If stoploss_on_exchange uses limit orders, the exchange needs 2 prices, the stoploss_price and the Limit price. stoploss defines the stop-price where the limit order is placed - and limit should be slightly below this. If an exchange supports both limit and market stoploss orders, then the value of stoploss will be used to determine the stoploss type. Calculation example: we bought the asset at 100$. Stop-price is 95$, then limit would be 95 * 0.99 = 94.05$ - so the limit order fill can happen between 95$ and 94.05$. For example, assuming the stoploss is on exchange, and trailing stoploss is enabled, and the market is going up, then the bot automatically cancels the previous stoploss order and puts a new one with a stop value higher than the previous stoploss order. Note If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order. stoploss_on_exchange_interval \u00b6 In case of stoploss on exchange there is another parameter called stoploss_on_exchange_interval . This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. The bot cannot do these every 5 seconds (at each iteration), otherwise it would get banned by the exchange. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute). This same logic will reapply a stoploss order on the exchange should you cancel it accidentally. force_exit \u00b6 force_exit is an optional value, which defaults to the same value as exit and is used when sending a /forceexit command from Telegram or from the Rest API. force_entry \u00b6 force_entry is an optional value, which defaults to the same value as entry and is used when sending a /forceentry command from Telegram or from the Rest API. emergency_exit \u00b6 emergency_exit is an optional value, which defaults to market and is used when creating stop loss on exchange orders fails. The below is the default which is used if not changed in strategy or configuration file. Example from strategy file: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : True , \"stoploss_on_exchange_interval\" : 60 , \"stoploss_on_exchange_limit_ratio\" : 0.99 } Stop Loss Types \u00b6 At this stage the bot contains the following stoploss support modes: Static stop loss. Trailing stop loss. Trailing stop loss, custom positive loss. Trailing stop loss only once the trade has reached a certain offset. Custom stoploss function Static Stop Loss \u00b6 This is very simple, you define a stop loss of x (as a ratio of price, i.e. x * 100% of price). This will try to sell the asset once the loss exceeds the defined loss. Example of stop loss: stoploss = - 0.10 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ Trailing Stop Loss \u00b6 The initial value for this is stoploss , just as you would define your static Stop loss. To enable trailing stoploss: stoploss = - 0.10 trailing_stop = True This will now activate an algorithm, which automatically moves the stop loss up every time the price of your asset increases. For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -10% of 102$ = 91.8$ now the asset drops in value to 101$, the stop loss will still be 91.8$ and would trigger at 91.8$. In summary: The stoploss will be adjusted to be always be -10% of the highest observed price. Trailing stop loss, custom positive loss \u00b6 You could also have a default stop loss when you are in the red with your buy (buy - fee), but once you hit a positive result (or an offset you define) the system will utilize a new stop loss, which can have a different value. For example, your default stop loss is -10%, but once you have more than 0% profit (example 0.1%) a different trailing stoploss will be used. Note If you want the stoploss to only be changed when you break even of making a profit (what most users want) please refer to next section with offset enabled . Both values require trailing_stop to be set to true and trailing_stop_positive with a value. stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.0 trailing_only_offset_is_reached = False # Default - not necessary for this example For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -2% of 102$ = 99.96$ (99.96$ stop loss will be locked in and will follow asset price increments with -2%) now the asset drops in value to 101$, the stop loss will still be 99.96$ and would trigger at 99.96$ The 0.02 would translate to a -2% stop loss. Before this, stoploss is used for the trailing stoploss. Use an offset to change your stoploss Use trailing_stop_positive_offset to ensure that your new trailing stoploss will be in profit by setting trailing_stop_positive_offset higher than trailing_stop_positive . Your first new stoploss value will then already have locked in profits. Example with simplified math: stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 the bot buys an asset at a price of 100$ the stop loss is defined at -10%, so the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stoploss will now be at 91.8$ - 10% below the highest observed rate assuming the asset now increases to 103.5$ (above the offset configured) the stop loss will now be -2% of 103.5$ = 101.43$ now the asset drops in value to 102$, the stop loss will still be 101.43$ and would trigger once price breaks below 101.43$ Trailing stop loss only once the trade has reached a certain offset \u00b6 You can also keep a static stoploss until the offset is reached, and then trail the trade to take profits once the market turns. If trailing_only_offset_is_reached = True then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured stoploss . This option can be used with or without trailing_stop_positive , but uses trailing_stop_positive_offset as offset. trailing_stop_positive_offset = 0.011 trailing_only_offset_is_reached = True Configuration (offset is buy-price + 3%): stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 trailing_only_offset_is_reached = True For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ stoploss will remain at 90$ unless asset increases to or above the configured offset assuming the asset now increases to 103$ (where we have the offset configured) the stop loss will now be -2% of 103$ = 100.94$ now the asset drops in value to 101$, the stop loss will still be 100.94$ and would trigger at 100.94$ Tip Make sure to have this value ( trailing_stop_positive_offset ) lower than minimal ROI, otherwise minimal ROI will apply first and sell the trade. Stoploss and Leverage \u00b6 Stoploss should be thought of as \"risk on this trade\" - so a stoploss of 10% on a 100$ trade means you are willing to lose 10$ (10%) on this trade - which would trigger if the price moves 10% to the downside. When using leverage, the same principle is applied - with stoploss defining the risk on the trade (the amount you are willing to lose). Therefore, a stoploss of 10% on a 10x trade would trigger on a 1% price move. If your stake amount (own capital) was 100$ - this trade would be 1000$ at 10x (after leverage). If price moves 1% - you've lost 10$ of your own capital - therfore stoploss will trigger in this case. Make sure to be aware of this, and avoid using too tight stoploss (at 10x leverage, 10% risk may be too little to allow the trade to \"breath\" a little). Changing stoploss on open trades \u00b6 A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the /reload_config command (alternatively, completely stopping and restarting the bot also works). The new stoploss value will be applied to open trades (and corresponding log-messages will be generated). Limitations \u00b6 Stoploss values cannot be changed if trailing_stop is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).","title":"Stoploss"},{"location":"stoploss/#stop-loss","text":"The stoploss configuration parameter is loss as ratio that should trigger a sale. For example, value -0.10 will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional. Stoploss calculations do include fees, so a stoploss of -10% is placed exactly 10% below the entry point. Most of the strategy files already include the optimal stoploss value. Info All stoploss properties mentioned in this file can be set in the Strategy, or in the configuration. Configuration values will override the strategy values.","title":"Stop Loss"},{"location":"stoploss/#stop-loss-on-exchangefreqtrade","text":"Those stoploss modes can be on exchange or off exchange . These modes can be configured with these values: 'emergency_exit' : 'market' , 'stoploss_on_exchange' : False 'stoploss_on_exchange_interval' : 60 , 'stoploss_on_exchange_limit_ratio' : 0.99 Note Stoploss on exchange is only supported for Binance (stop-loss-limit), Huobi (stop-limit), Kraken (stop-loss-market, stop-loss-limit), FTX (stop limit and stop-market) Gateio (stop-limit), and Kucoin (stop-limit and stop-market) as of now. Do not set too low/tight stoploss value if using stop loss on exchange! If set to low/tight then you have greater risk of missing fill on the order and stoploss will not work.","title":"Stop Loss On-Exchange/Freqtrade"},{"location":"stoploss/#stoploss_on_exchange-and-stoploss_on_exchange_limit_ratio","text":"Enable or Disable stop loss on exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order fills. This will protect you against sudden crashes in market, as the order execution happens purely within the exchange, and has no potential network overhead. If stoploss_on_exchange uses limit orders, the exchange needs 2 prices, the stoploss_price and the Limit price. stoploss defines the stop-price where the limit order is placed - and limit should be slightly below this. If an exchange supports both limit and market stoploss orders, then the value of stoploss will be used to determine the stoploss type. Calculation example: we bought the asset at 100$. Stop-price is 95$, then limit would be 95 * 0.99 = 94.05$ - so the limit order fill can happen between 95$ and 94.05$. For example, assuming the stoploss is on exchange, and trailing stoploss is enabled, and the market is going up, then the bot automatically cancels the previous stoploss order and puts a new one with a stop value higher than the previous stoploss order. Note If stoploss_on_exchange is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order.","title":"stoploss_on_exchange and stoploss_on_exchange_limit_ratio"},{"location":"stoploss/#stoploss_on_exchange_interval","text":"In case of stoploss on exchange there is another parameter called stoploss_on_exchange_interval . This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. The bot cannot do these every 5 seconds (at each iteration), otherwise it would get banned by the exchange. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute). This same logic will reapply a stoploss order on the exchange should you cancel it accidentally.","title":"stoploss_on_exchange_interval"},{"location":"stoploss/#force_exit","text":"force_exit is an optional value, which defaults to the same value as exit and is used when sending a /forceexit command from Telegram or from the Rest API.","title":"force_exit"},{"location":"stoploss/#force_entry","text":"force_entry is an optional value, which defaults to the same value as entry and is used when sending a /forceentry command from Telegram or from the Rest API.","title":"force_entry"},{"location":"stoploss/#emergency_exit","text":"emergency_exit is an optional value, which defaults to market and is used when creating stop loss on exchange orders fails. The below is the default which is used if not changed in strategy or configuration file. Example from strategy file: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : True , \"stoploss_on_exchange_interval\" : 60 , \"stoploss_on_exchange_limit_ratio\" : 0.99 }","title":"emergency_exit"},{"location":"stoploss/#stop-loss-types","text":"At this stage the bot contains the following stoploss support modes: Static stop loss. Trailing stop loss. Trailing stop loss, custom positive loss. Trailing stop loss only once the trade has reached a certain offset. Custom stoploss function","title":"Stop Loss Types"},{"location":"stoploss/#static-stop-loss","text":"This is very simple, you define a stop loss of x (as a ratio of price, i.e. x * 100% of price). This will try to sell the asset once the loss exceeds the defined loss. Example of stop loss: stoploss = - 0.10 For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$","title":"Static Stop Loss"},{"location":"stoploss/#trailing-stop-loss","text":"The initial value for this is stoploss , just as you would define your static Stop loss. To enable trailing stoploss: stoploss = - 0.10 trailing_stop = True This will now activate an algorithm, which automatically moves the stop loss up every time the price of your asset increases. For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -10% of 102$ = 91.8$ now the asset drops in value to 101$, the stop loss will still be 91.8$ and would trigger at 91.8$. In summary: The stoploss will be adjusted to be always be -10% of the highest observed price.","title":"Trailing Stop Loss"},{"location":"stoploss/#trailing-stop-loss-custom-positive-loss","text":"You could also have a default stop loss when you are in the red with your buy (buy - fee), but once you hit a positive result (or an offset you define) the system will utilize a new stop loss, which can have a different value. For example, your default stop loss is -10%, but once you have more than 0% profit (example 0.1%) a different trailing stoploss will be used. Note If you want the stoploss to only be changed when you break even of making a profit (what most users want) please refer to next section with offset enabled . Both values require trailing_stop to be set to true and trailing_stop_positive with a value. stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.0 trailing_only_offset_is_reached = False # Default - not necessary for this example For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stop loss will now be -2% of 102$ = 99.96$ (99.96$ stop loss will be locked in and will follow asset price increments with -2%) now the asset drops in value to 101$, the stop loss will still be 99.96$ and would trigger at 99.96$ The 0.02 would translate to a -2% stop loss. Before this, stoploss is used for the trailing stoploss. Use an offset to change your stoploss Use trailing_stop_positive_offset to ensure that your new trailing stoploss will be in profit by setting trailing_stop_positive_offset higher than trailing_stop_positive . Your first new stoploss value will then already have locked in profits. Example with simplified math: stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 the bot buys an asset at a price of 100$ the stop loss is defined at -10%, so the stop loss would get triggered once the asset drops below 90$ assuming the asset now increases to 102$ the stoploss will now be at 91.8$ - 10% below the highest observed rate assuming the asset now increases to 103.5$ (above the offset configured) the stop loss will now be -2% of 103.5$ = 101.43$ now the asset drops in value to 102$, the stop loss will still be 101.43$ and would trigger once price breaks below 101.43$","title":"Trailing stop loss, custom positive loss"},{"location":"stoploss/#trailing-stop-loss-only-once-the-trade-has-reached-a-certain-offset","text":"You can also keep a static stoploss until the offset is reached, and then trail the trade to take profits once the market turns. If trailing_only_offset_is_reached = True then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured stoploss . This option can be used with or without trailing_stop_positive , but uses trailing_stop_positive_offset as offset. trailing_stop_positive_offset = 0.011 trailing_only_offset_is_reached = True Configuration (offset is buy-price + 3%): stoploss = - 0.10 trailing_stop = True trailing_stop_positive = 0.02 trailing_stop_positive_offset = 0.03 trailing_only_offset_is_reached = True For example, simplified math: the bot buys an asset at a price of 100$ the stop loss is defined at -10% the stop loss would get triggered once the asset drops below 90$ stoploss will remain at 90$ unless asset increases to or above the configured offset assuming the asset now increases to 103$ (where we have the offset configured) the stop loss will now be -2% of 103$ = 100.94$ now the asset drops in value to 101$, the stop loss will still be 100.94$ and would trigger at 100.94$ Tip Make sure to have this value ( trailing_stop_positive_offset ) lower than minimal ROI, otherwise minimal ROI will apply first and sell the trade.","title":"Trailing stop loss only once the trade has reached a certain offset"},{"location":"stoploss/#stoploss-and-leverage","text":"Stoploss should be thought of as \"risk on this trade\" - so a stoploss of 10% on a 100$ trade means you are willing to lose 10$ (10%) on this trade - which would trigger if the price moves 10% to the downside. When using leverage, the same principle is applied - with stoploss defining the risk on the trade (the amount you are willing to lose). Therefore, a stoploss of 10% on a 10x trade would trigger on a 1% price move. If your stake amount (own capital) was 100$ - this trade would be 1000$ at 10x (after leverage). If price moves 1% - you've lost 10$ of your own capital - therfore stoploss will trigger in this case. Make sure to be aware of this, and avoid using too tight stoploss (at 10x leverage, 10% risk may be too little to allow the trade to \"breath\" a little).","title":"Stoploss and Leverage"},{"location":"stoploss/#changing-stoploss-on-open-trades","text":"A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the /reload_config command (alternatively, completely stopping and restarting the bot also works). The new stoploss value will be applied to open trades (and corresponding log-messages will be generated).","title":"Changing stoploss on open trades"},{"location":"stoploss/#limitations","text":"Stoploss values cannot be changed if trailing_stop is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).","title":"Limitations"},{"location":"strategy-advanced/","text":"Advanced Strategies \u00b6 This page explains some advanced concepts available for strategies. If you're just getting started, please be familiar with the methods described in the Strategy Customization documentation and with the Freqtrade basics first. Freqtrade basics describes in which sequence each method described below is called, which can be helpful to understand which method to use for your custom needs. Note All callback methods described below should only be implemented in a strategy if they are actually used. Tip You can get a strategy template containing all below methods by running freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced Storing information \u00b6 Storing information can be accomplished by creating a new dictionary within the strategy class. The name of the variable can be chosen at will, but should be prefixed with cust_ to avoid naming collisions with predefined strategy variables. class AwesomeStrategy ( IStrategy ): # Create custom dictionary custom_info = {} def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # Check if the entry already exists if not metadata [ \"pair\" ] in self . custom_info : # Create empty entry for this pair self . custom_info [ metadata [ \"pair\" ]] = {} if \"crosstime\" in self . custom_info [ metadata [ \"pair\" ]]: self . custom_info [ metadata [ \"pair\" ]][ \"crosstime\" ] += 1 else : self . custom_info [ metadata [ \"pair\" ]][ \"crosstime\" ] = 1 Warning The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash. Note If the data is pair-specific, make sure to use pair as one of the keys in the dictionary. Dataframe access \u00b6 You may access dataframe in various strategy functions by querying it from dataprovider. from freqtrade.exchange import timeframe_to_prev_date class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : 'Trade' , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : 'datetime' , ** kwargs ) -> bool : # Obtain pair dataframe. dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) # Obtain last available candle. Do not use current_time to look up latest candle, because # current_time points to current incomplete candle whose data is not available. last_candle = dataframe . iloc [ - 1 ] . squeeze () # <...> # In dry/live runs trade open date will not match candle open date therefore it must be # rounded. trade_date = timeframe_to_prev_date ( self . timeframe , trade . open_date_utc ) # Look up trade candle. trade_candle = dataframe . loc [ dataframe [ 'date' ] == trade_date ] # trade_candle may be empty for trades that just opened as it is still incomplete. if not trade_candle . empty : trade_candle = trade_candle . squeeze () # <...> Using .iloc[-1] You can use .iloc[-1] here because get_analyzed_dataframe() only returns candles that backtesting is allowed to see. This will not work in populate_* methods, so make sure to not use .iloc[] in that area. Also, this will only work starting with version 2021.5. Enter Tag \u00b6 When your strategy has multiple buy signals, you can name the signal that triggered. Then you can access you buy signal on custom_exit def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( dataframe [ 'rsi' ] < 35 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'buy_signal_rsi' ) return dataframe def custom_exit ( self , pair : str , trade : Trade , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () if trade . enter_tag == 'buy_signal_rsi' and last_candle [ 'rsi' ] > 80 : return 'sell_signal_rsi' return None Note enter_tag is limited to 100 characters, remaining data will be truncated. Exit tag \u00b6 Similar to Buy Tagging , you can also specify a sell tag. def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( dataframe [ 'rsi' ] > 70 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'exit_rsi' ) return dataframe The provided exit-tag is then used as sell-reason - and shown as such in backtest results. Note exit_reason is limited to 100 characters, remaining data will be truncated. Strategy version \u00b6 You can implement custom strategy versioning by using the \"version\" method, and returning the version you would like this strategy to have. def version ( self ) -> str : \"\"\" Returns version of the strategy. \"\"\" return \"1.1\" Note You should make sure to implement proper version control (like a git repository) alongside this, as freqtrade will not keep historic versions of your strategy, so it's up to the user to be able to eventually roll back to a prior version of the strategy. Derived strategies \u00b6 The strategies can be derived from other strategies. This avoids duplication of your custom strategy code. You can use this technique to override small parts of your main strategy, leaving the rest untouched: user_data/strategies/myawesomestrategy.py class MyAwesomeStrategy ( IStrategy ): ... stoploss = 0.13 trailing_stop = False # All other attributes and methods are here as they # should be in any custom strategy... ... user_data/strategies/MyAwesomeStrategy2.py from myawesomestrategy import MyAwesomeStrategy class MyAwesomeStrategy2 ( MyAwesomeStrategy ): # Override something stoploss = 0.08 trailing_stop = True Both attributes and methods may be overridden, altering behavior of the original strategy in a way you need. While keeping the subclass in the same file is technically possible, it can lead to some problems with hyperopt parameter files, we therefore recommend to use separate strategy files, and import the parent strategy as shown above. Embedding Strategies \u00b6 Freqtrade provides you with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file. Encoding a string as BASE64 \u00b6 This is a quick example, how to generate the BASE64 string in python from base64 import urlsafe_b64encode with open ( file , 'r' ) as f : content = f . read () content = urlsafe_b64encode ( content . encode ( 'utf-8' )) The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following \"strategy\" : \"NameOfStrategy:BASE64String\" Please ensure that 'NameOfStrategy' is identical to the strategy name! Performance warning \u00b6 When executing a strategy, one can sometimes be greeted by the following in the logs PerformanceWarning: DataFrame is highly fragmented. This is a warning from pandas and as the warning continues to say: use pd.concat(axis=1) . This can have slight performance implications, which are usually only visible during hyperopt (when optimizing an indicator). For example: for val in self . buy_ema_short . range : dataframe [ f 'ema_short_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) should be rewritten to frames = [ dataframe ] for val in self . buy_ema_short . range : frames . append ( DataFrame ({ f 'ema_short_ { val } ' : ta . EMA ( dataframe , timeperiod = val ) })) # Append columns to existing dataframe merged_frame = pd . concat ( frames , axis = 1 ) Freqtrade does however also counter this by running dataframe.copy() on the dataframe right after the populate_indicators() method - so performance implications of this should be low to non-existant.","title":"Advanced Strategy"},{"location":"strategy-advanced/#advanced-strategies","text":"This page explains some advanced concepts available for strategies. If you're just getting started, please be familiar with the methods described in the Strategy Customization documentation and with the Freqtrade basics first. Freqtrade basics describes in which sequence each method described below is called, which can be helpful to understand which method to use for your custom needs. Note All callback methods described below should only be implemented in a strategy if they are actually used. Tip You can get a strategy template containing all below methods by running freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced","title":"Advanced Strategies"},{"location":"strategy-advanced/#storing-information","text":"Storing information can be accomplished by creating a new dictionary within the strategy class. The name of the variable can be chosen at will, but should be prefixed with cust_ to avoid naming collisions with predefined strategy variables. class AwesomeStrategy ( IStrategy ): # Create custom dictionary custom_info = {} def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # Check if the entry already exists if not metadata [ \"pair\" ] in self . custom_info : # Create empty entry for this pair self . custom_info [ metadata [ \"pair\" ]] = {} if \"crosstime\" in self . custom_info [ metadata [ \"pair\" ]]: self . custom_info [ metadata [ \"pair\" ]][ \"crosstime\" ] += 1 else : self . custom_info [ metadata [ \"pair\" ]][ \"crosstime\" ] = 1 Warning The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash. Note If the data is pair-specific, make sure to use pair as one of the keys in the dictionary.","title":"Storing information"},{"location":"strategy-advanced/#dataframe-access","text":"You may access dataframe in various strategy functions by querying it from dataprovider. from freqtrade.exchange import timeframe_to_prev_date class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : 'Trade' , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : 'datetime' , ** kwargs ) -> bool : # Obtain pair dataframe. dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) # Obtain last available candle. Do not use current_time to look up latest candle, because # current_time points to current incomplete candle whose data is not available. last_candle = dataframe . iloc [ - 1 ] . squeeze () # <...> # In dry/live runs trade open date will not match candle open date therefore it must be # rounded. trade_date = timeframe_to_prev_date ( self . timeframe , trade . open_date_utc ) # Look up trade candle. trade_candle = dataframe . loc [ dataframe [ 'date' ] == trade_date ] # trade_candle may be empty for trades that just opened as it is still incomplete. if not trade_candle . empty : trade_candle = trade_candle . squeeze () # <...> Using .iloc[-1] You can use .iloc[-1] here because get_analyzed_dataframe() only returns candles that backtesting is allowed to see. This will not work in populate_* methods, so make sure to not use .iloc[] in that area. Also, this will only work starting with version 2021.5.","title":"Dataframe access"},{"location":"strategy-advanced/#enter-tag","text":"When your strategy has multiple buy signals, you can name the signal that triggered. Then you can access you buy signal on custom_exit def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( dataframe [ 'rsi' ] < 35 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'buy_signal_rsi' ) return dataframe def custom_exit ( self , pair : str , trade : Trade , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () if trade . enter_tag == 'buy_signal_rsi' and last_candle [ 'rsi' ] > 80 : return 'sell_signal_rsi' return None Note enter_tag is limited to 100 characters, remaining data will be truncated.","title":"Enter Tag"},{"location":"strategy-advanced/#exit-tag","text":"Similar to Buy Tagging , you can also specify a sell tag. def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( dataframe [ 'rsi' ] > 70 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'exit_rsi' ) return dataframe The provided exit-tag is then used as sell-reason - and shown as such in backtest results. Note exit_reason is limited to 100 characters, remaining data will be truncated.","title":"Exit tag"},{"location":"strategy-advanced/#strategy-version","text":"You can implement custom strategy versioning by using the \"version\" method, and returning the version you would like this strategy to have. def version ( self ) -> str : \"\"\" Returns version of the strategy. \"\"\" return \"1.1\" Note You should make sure to implement proper version control (like a git repository) alongside this, as freqtrade will not keep historic versions of your strategy, so it's up to the user to be able to eventually roll back to a prior version of the strategy.","title":"Strategy version"},{"location":"strategy-advanced/#derived-strategies","text":"The strategies can be derived from other strategies. This avoids duplication of your custom strategy code. You can use this technique to override small parts of your main strategy, leaving the rest untouched: user_data/strategies/myawesomestrategy.py class MyAwesomeStrategy ( IStrategy ): ... stoploss = 0.13 trailing_stop = False # All other attributes and methods are here as they # should be in any custom strategy... ... user_data/strategies/MyAwesomeStrategy2.py from myawesomestrategy import MyAwesomeStrategy class MyAwesomeStrategy2 ( MyAwesomeStrategy ): # Override something stoploss = 0.08 trailing_stop = True Both attributes and methods may be overridden, altering behavior of the original strategy in a way you need. While keeping the subclass in the same file is technically possible, it can lead to some problems with hyperopt parameter files, we therefore recommend to use separate strategy files, and import the parent strategy as shown above.","title":"Derived strategies"},{"location":"strategy-advanced/#embedding-strategies","text":"Freqtrade provides you with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file.","title":"Embedding Strategies"},{"location":"strategy-advanced/#encoding-a-string-as-base64","text":"This is a quick example, how to generate the BASE64 string in python from base64 import urlsafe_b64encode with open ( file , 'r' ) as f : content = f . read () content = urlsafe_b64encode ( content . encode ( 'utf-8' )) The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following \"strategy\" : \"NameOfStrategy:BASE64String\" Please ensure that 'NameOfStrategy' is identical to the strategy name!","title":"Encoding a string as BASE64"},{"location":"strategy-advanced/#performance-warning","text":"When executing a strategy, one can sometimes be greeted by the following in the logs PerformanceWarning: DataFrame is highly fragmented. This is a warning from pandas and as the warning continues to say: use pd.concat(axis=1) . This can have slight performance implications, which are usually only visible during hyperopt (when optimizing an indicator). For example: for val in self . buy_ema_short . range : dataframe [ f 'ema_short_ { val } ' ] = ta . EMA ( dataframe , timeperiod = val ) should be rewritten to frames = [ dataframe ] for val in self . buy_ema_short . range : frames . append ( DataFrame ({ f 'ema_short_ { val } ' : ta . EMA ( dataframe , timeperiod = val ) })) # Append columns to existing dataframe merged_frame = pd . concat ( frames , axis = 1 ) Freqtrade does however also counter this by running dataframe.copy() on the dataframe right after the populate_indicators() method - so performance implications of this should be low to non-existant.","title":"Performance warning"},{"location":"strategy-callbacks/","text":"Strategy Callbacks \u00b6 While the main strategy functions ( populate_indicators() , populate_entry_trend() , populate_exit_trend() ) should be used in a vectorized way, and are only called once during backtesting , callbacks are called \"whenever needed\". As such, you should avoid doing heavy calculations in callbacks to avoid delays during operations. Depending on the callback used, they may be called when entering / exiting a trade, or throughout the duration of a trade. Currently available callbacks: bot_start() bot_loop_start() custom_stake_amount() custom_exit() custom_stoploss() custom_entry_price() and custom_exit_price() check_entry_timeout() and check_exit_timeout() confirm_trade_entry() confirm_trade_exit() adjust_trade_position() adjust_entry_price() leverage() Callback calling sequence You can find the callback calling sequence in bot-basics Bot start \u00b6 A simple callback which is called once when the strategy is loaded. This can be used to perform actions that must only be performed once and runs after dataprovider and wallet are set import requests class AwesomeStrategy ( IStrategy ): # ... populate_* methods def bot_start ( self , ** kwargs ) -> None : \"\"\" Called only once after bot instantiation. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # Assign this to the class by using self.* # can then be used by populate_* methods self . cust_remote_data = requests . get ( 'https://some_remote_source.example.com' ) During hyperopt, this runs only once at startup. Bot loop start \u00b6 A simple callback which is called once at the start of every bot throttling iteration (roughly every 5 seconds, unless configured differently). This can be used to perform calculations which are pair independent (apply to all pairs), loading of external data, etc. import requests class AwesomeStrategy ( IStrategy ): # ... populate_* methods def bot_loop_start ( self , ** kwargs ) -> None : \"\"\" Called at the start of the bot iteration (one loop). Might be used to perform pair-independent tasks (e.g. gather some remote resource for comparison) :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # Assign this to the class by using self.* # can then be used by populate_* methods self . remote_data = requests . get ( 'https://some_remote_source.example.com' ) Stake size management \u00b6 Called before entering a trade, makes it possible to manage your position size when placing a new trade. class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) current_candle = dataframe . iloc [ - 1 ] . squeeze () if current_candle [ 'fastk_rsi_1h' ] > current_candle [ 'fastd_rsi_1h' ]: if self . config [ 'stake_amount' ] == 'unlimited' : # Use entire available wallet during favorable conditions when in compounding mode. return max_stake else : # Compound profits during favorable conditions instead of using a static stake. return self . wallets . get_total_stake_amount () / self . config [ 'max_open_trades' ] # Use default stake amount. return proposed_stake Freqtrade will fall back to the proposed_stake value should your code raise an exception. The exception itself will be logged. Tip You do not have to ensure that min_stake <= returned_value <= max_stake . Trades will succeed as the returned value will be clamped to supported range and this action will be logged. Tip Returning 0 or None will prevent trades from being placed. Custom exit signal \u00b6 Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. Allows to define custom exit signals, indicating that specified position should be sold. This is very useful when we need to customize exit conditions for each individual trade, or if you need trade data to make an exit decision. For example you could implement a 1:2 risk-reward ROI with custom_exit() . Using custom_exit() signals in place of stoploss though is not recommended . It is a inferior method to using custom_stoploss() in this regard - which also allows you to keep the stoploss on exchange. Note Returning a (none-empty) string or True from this method is equal to setting exit signal on a candle at specified time. This method is not called when exit signal is set already, or if exit signals are disabled ( use_exit_signal=False ). string max length is 64 characters. Exceeding this limit will cause the message to be truncated to 64 characters. custom_exit() will ignore exit_profit_only , and will always be called unless use_exit_signal=False , even if there is a new enter signal. An example of how we can use different indicators depending on the current profit and also exit trades that were open longer than one day: class AwesomeStrategy ( IStrategy ): def custom_exit ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # Above 20% profit, sell when rsi < 80 if current_profit > 0.2 : if last_candle [ 'rsi' ] < 80 : return 'rsi_below_80' # Between 2% and 10%, sell if EMA-long above EMA-short if 0.02 < current_profit < 0.1 : if last_candle [ 'emalong' ] > last_candle [ 'emashort' ]: return 'ema_long_below_80' # Sell any positions at a loss if they are held for more than one day. if current_profit < 0.0 and ( current_time - trade . open_date_utc ) . days >= 1 : return 'unclog' See Dataframe access for more information about dataframe use in strategy callbacks. Custom stoploss \u00b6 Called for open trade every iteration (roughly every 5 seconds) until a trade is closed. The usage of the custom stoploss method must be enabled by setting use_custom_stoploss=True on the strategy object. The stoploss price can only ever move upwards - if the stoploss value returned from custom_stoploss would result in a lower stoploss price than was previously set, it will be ignored. The traditional stoploss value serves as an absolute lower level and will be instated as the initial stoploss (before this method is called for the first time for a trade), and is still mandatory. The method must return a stoploss value (float / number) as a percentage of the current price. E.g. If the current_rate is 200 USD, then returning 0.02 will set the stoploss price 2% lower, at 196 USD. The absolute value of the return value is used (the sign is ignored), so returning 0.05 or -0.05 have the same result, a stoploss 5% below the current price. To simulate a regular trailing stoploss of 4% (trailing 4% behind the maximum reached price) you would use the following very simple method: # additional imports required from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : \"\"\" Custom stoploss logic, returning the new distance relative to current_rate (as ratio). e.g. returning -0.05 would create a stoploss 5% below current_rate. The custom stoploss can never be below self.stoploss, which serves as a hard maximum loss. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns the initial stoploss value Only called when use_custom_stoploss is set to True. :param pair: Pair that's currently analyzed :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in exit_pricing. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New stoploss value, relative to the current rate \"\"\" return - 0.04 Stoploss on exchange works similar to trailing_stop , and the stoploss on exchange is updated as configured in stoploss_on_exchange_interval ( More details about stoploss on exchange ). Use of dates All time-based calculations should be done based on current_time - using datetime.now() or datetime.utcnow() is discouraged, as this will break backtesting support. Trailing stoploss It's recommended to disable trailing_stop when using custom stoploss values. Both can work in tandem, but you might encounter the trailing stop to move the price higher while your custom function would not want this, causing conflicting behavior. Custom stoploss examples \u00b6 The next section will show some examples on what's possible with the custom stoploss function. Of course, many more things are possible, and all examples can be combined at will. Time based trailing stop \u00b6 Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss. from datetime import datetime , timedelta from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # Make sure you have the longest interval first - these conditions are evaluated from top to bottom. if current_time - timedelta ( minutes = 120 ) > trade . open_date_utc : return - 0.05 elif current_time - timedelta ( minutes = 60 ) > trade . open_date_utc : return - 0.10 return 1 Different stoploss per pair \u00b6 Use a different stoploss depending on the pair. In this example, we'll trail the highest price with 10% trailing stoploss for ETH/BTC and XRP/BTC , with 5% trailing stoploss for LTC/BTC and with 15% for all other pairs. from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : if pair in ( 'ETH/BTC' , 'XRP/BTC' ): return - 0.10 elif pair in ( 'LTC/BTC' ): return - 0.05 return - 0.15 Trailing stoploss with positive offset \u00b6 Use the initial stoploss until the profit is above 4%, then use a trailing stoploss of 50% of the current profit with a minimum of 2.5% and a maximum of 5%. Please note that the stoploss can only increase, values lower than the current stoploss are ignored. from datetime import datetime , timedelta from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : if current_profit < 0.04 : return - 1 # return a value bigger than the initial stoploss to keep using the initial stoploss # After reaching the desired offset, allow the stoploss to trail by half the profit desired_stoploss = current_profit / 2 # Use a minimum of 2.5% and a maximum of 5% return max ( min ( desired_stoploss , 0.05 ), 0.025 ) Stepped stoploss \u00b6 Instead of continuously trailing behind the current price, this example sets fixed stoploss price levels based on the current profit. Use the regular stoploss until 20% profit is reached Once profit is > 20% - set stoploss to 7% above open price. Once profit is > 25% - set stoploss to 15% above open price. Once profit is > 40% - set stoploss to 25% above open price. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import stoploss_from_open class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # evaluate highest to lowest, so that highest possible stop is used if current_profit > 0.40 : return stoploss_from_open ( 0.25 , current_profit , is_short = trade . is_short ) elif current_profit > 0.25 : return stoploss_from_open ( 0.15 , current_profit , is_short = trade . is_short ) elif current_profit > 0.20 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) # return maximum stoploss value, keeping current stoploss price unchanged return 1 Custom stoploss using an indicator from dataframe example \u00b6 Absolute stoploss value may be derived from indicators stored in dataframe. Example uses parabolic SAR below the price as stoploss. class AwesomeStrategy ( IStrategy ): def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # <...> dataframe [ 'sar' ] = ta . SAR ( dataframe ) use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # Use parabolic sar as absolute stoploss price stoploss_price = last_candle [ 'sar' ] # Convert absolute price to percentage relative to current_rate if stoploss_price < current_rate : return ( stoploss_price / current_rate ) - 1 # return maximum stoploss value, keeping current stoploss price unchanged return 1 See Dataframe access for more information about dataframe use in strategy callbacks. Common helpers for stoploss calculations \u00b6 Stoploss relative to open price \u00b6 Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss relative to the open price, we need to use current_profit to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_open() can be used to convert from an open price relative stop, to a current price relative stop which can be returned from custom_stoploss() . Stoploss percentage from absolute price \u00b6 Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss at specified absolute price level, we need to use stop_rate to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_absolute() can be used to convert from an absolute price, to a current price relative stop which can be returned from custom_stoploss() . Custom order price rules \u00b6 By default, freqtrade use the orderbook to automatically set an order price( Relevant documentation ), you also have the option to create custom order prices based on your strategy. You can use this feature by creating a custom_entry_price() function in your strategy file to customize entry prices and custom_exit_price() for exits. Each of these methods are called right before placing an order on the exchange. Note If your custom pricing function return None or an invalid value, price will fall back to proposed_rate , which is based on the regular pricing configuration. Custom order entry and exit price example \u00b6 from datetime import datetime , timedelta , timezone from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) new_entryprice = dataframe [ 'bollinger_10_lowerband' ] . iat [ - 1 ] return new_entryprice def custom_exit_price ( self , pair : str , trade : Trade , current_time : datetime , proposed_rate : float , current_profit : float , exit_tag : Optional [ str ], ** kwargs ) -> float : dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) new_exitprice = dataframe [ 'bollinger_10_upperband' ] . iat [ - 1 ] return new_exitprice Warning Modifying entry and exit prices will only work for limit orders. Depending on the price chosen, this can result in a lot of unfilled orders. By default the maximum allowed distance between the current price and the custom price is 2%, this value can be changed in config with the custom_price_max_distance_ratio parameter. Example : If the new_entryprice is 97, the proposed_rate is 100 and the custom_price_max_distance_ratio is set to 2%, The retained valid custom entry price will be 98, which is 2% below the current (proposed) rate. Backtesting Custom prices are supported in backtesting (starting with 2021.12), and orders will fill if the price falls within the candle's low/high range. Orders that don't fill immediately are subject to regular timeout handling, which happens once per (detail) candle. custom_exit_price() is only called for sells of type exit_signal, Custom exit and partial exits. All other exit-types will use regular backtesting prices. Custom order timeout rules \u00b6 Simple, time-based order-timeouts can be configured either via strategy or in the configuration in the unfilledtimeout section. However, freqtrade also offers a custom callback for both order types, which allows you to decide based on custom criteria if an order did time out or not. Note Backtesting fills orders if their price falls within the candle's low/high range. The below callbacks will be called once per (detail) candle for orders that don't fill immediately (which use custom pricing). Custom order timeout example \u00b6 Called for every open order until that order is either filled or cancelled. check_entry_timeout() is called for trade entries, while check_exit_timeout() is called for trade exit orders. A simple example, which applies different unfilled-timeouts depending on the price of the asset can be seen below. It applies a tight timeout for higher priced assets, while allowing more time to fill on cheap coins. The function must return either True (cancel order) or False (keep order alive). from datetime import datetime , timedelta from freqtrade.persistence import Trade , Order class AwesomeStrategy ( IStrategy ): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'entry' : 60 * 25 , 'exit' : 60 * 25 } def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : if trade . open_rate > 100 and trade . open_date_utc < current_time - timedelta ( minutes = 5 ): return True elif trade . open_rate > 10 and trade . open_date_utc < current_time - timedelta ( minutes = 3 ): return True elif trade . open_rate < 1 and trade . open_date_utc < current_time - timedelta ( hours = 24 ): return True return False def check_exit_timeout ( self , pair : str , trade : Trade , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : if trade . open_rate > 100 and trade . open_date_utc < current_time - timedelta ( minutes = 5 ): return True elif trade . open_rate > 10 and trade . open_date_utc < current_time - timedelta ( minutes = 3 ): return True elif trade . open_rate < 1 and trade . open_date_utc < current_time - timedelta ( hours = 24 ): return True return False Note For the above example, unfilledtimeout must be set to something bigger than 24h, otherwise that type of timeout will apply first. Custom order timeout example (using additional data) \u00b6 from datetime import datetime from freqtrade.persistence import Trade , Order class AwesomeStrategy ( IStrategy ): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'entry' : 60 * 25 , 'exit' : 60 * 25 } def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : ob = self . dp . orderbook ( pair , 1 ) current_price = ob [ 'bids' ][ 0 ][ 0 ] # Cancel buy order if price is more than 2% above the order. if current_price > order . price * 1.02 : return True return False def check_exit_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : ob = self . dp . orderbook ( pair , 1 ) current_price = ob [ 'asks' ][ 0 ][ 0 ] # Cancel sell order if price is more than 2% below the order. if current_price < order . price * 0.98 : return True return False Bot order confirmation \u00b6 Confirm trade entry / exits. This are the last methods that will be called before an order is placed. Trade entry (buy order) confirmation \u00b6 confirm_trade_entry() can be used to abort a trade entry at the latest second (maybe because the price is not what we expect). class AwesomeStrategy ( IStrategy ): # ... populate_* methods def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], side : str , ** kwargs ) -> bool : \"\"\" Called right before placing a entry order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be bought/shorted. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in target (base) currency that's going to be traded. :param rate: Rate that's going to be used when using limit orders or current rate for market orders. :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param current_time: datetime object, containing the current datetime :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the buy-order is placed on the exchange. False aborts the process \"\"\" return True Trade exit (sell order) confirmation \u00b6 confirm_trade_exit() can be used to abort a trade exit (sell) at the latest second (maybe because the price is not what we expect). confirm_trade_exit() may be called multiple times within one iteration for the same trade if different exit-reasons apply. The exit-reasons (if applicable) will be in the following sequence: exit_signal / custom_exit stop_loss roi trailing_stop_loss from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : datetime , ** kwargs ) -> bool : \"\"\" Called right before placing a regular exit order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair for trade that's about to be exited. :param trade: trade object. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in base currency. :param rate: Rate that's going to be used when using limit orders or current rate for market orders. :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param exit_reason: Exit reason. Can be any of ['roi', 'stop_loss', 'stoploss_on_exchange', 'trailing_stop_loss', 'exit_signal', 'force_exit', 'emergency_exit'] :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True, then the exit-order is placed on the exchange. False aborts the process \"\"\" if exit_reason == 'force_exit' and trade . calc_profit_ratio ( rate ) < 0 : # Reject force-sells with negative profit # This is just a sample, please adjust to your needs # (this does not necessarily make sense, assuming you know when you're force-selling) return False return True Warning confirm_trade_exit() can prevent stoploss exits, causing significant losses as this would ignore stoploss exits. confirm_trade_exit() will not be called for Liquidations - as liquidations are forced by the exchange, and therefore cannot be rejected. Adjust trade position \u00b6 The position_adjustment_enable strategy property enables the usage of adjust_trade_position() callback in the strategy. For performance reasons, it's disabled by default and freqtrade will show a warning message on startup if enabled. adjust_trade_position() can be used to perform additional orders, for example to manage risk with DCA (Dollar Cost Averaging) or to increase or decrease positions. max_entry_position_adjustment property is used to limit the number of additional buys per trade (on top of the first buy) that the bot can execute. By default, the value is -1 which means the bot have no limit on number of adjustment buys. The strategy is expected to return a stake_amount (in stake currency) between min_stake and max_stake if and when an additional buy order should be made (position is increased). If there are not enough funds in the wallet (the return value is above max_stake ) then the signal will be ignored. Additional orders also result in additional fees and those orders don't count towards max_open_trades . This callback is not called when there is an open order (either buy or sell) waiting for execution. adjust_trade_position() is called very frequently for the duration of a trade, so you must keep your implementation as performant as possible. Additional Buys are ignored once you have reached the maximum amount of extra buys that you have set on max_entry_position_adjustment , but the callback is called anyway looking for partial exits. Position adjustments will always be applied in the direction of the trade, so a positive value will always increase your position (negative values will decrease your position), no matter if it's a long or short trade. Modifications to leverage are not possible. About stake size Using fixed stake size means it will be the amount used for the first order, just like without position adjustment. If you wish to buy additional orders with DCA, then make sure to leave enough funds in the wallet for that. Using 'unlimited' stake amount with DCA orders requires you to also implement the custom_stake_amount() callback to avoid allocating all funds to the initial order. Warning Stoploss is still calculated from the initial opening price, not averaged price. Regular stoploss rules still apply (cannot move down). While /stopentry command stops the bot from entering new trades, the position adjustment feature will continue buying new orders on existing trades. Backtesting During backtesting this callback is called for each candle in timeframe or timeframe_detail , so run-time performance will be affected. from freqtrade.persistence import Trade class DigDeeperStrategy ( IStrategy ): position_adjustment_enable = True # Attempts to handle large drops with DCA. High stoploss is required. stoploss = - 0.30 # ... populate_* methods # Example specific variables max_entry_position_adjustment = 3 # This number is explained a bit further down max_dca_multiplier = 5.5 # This is called when placing the initial order (opening trade) def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : # We need to leave most of the funds for possible further DCA orders # This also applies to fixed stakes return proposed_stake / self . max_dca_multiplier def adjust_trade_position ( self , trade : Trade , current_time : datetime , current_rate : float , current_profit : float , min_stake : Optional [ float ], max_stake : float , current_entry_rate : float , current_exit_rate : float , current_entry_profit : float , current_exit_profit : float , ** kwargs ) -> Optional [ float ]: \"\"\" Custom trade adjustment logic, returning the stake amount that a trade should be increased or decreased. This means extra buy or sell orders with additional fees. Only called when `position_adjustment_enable` is set to True. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns None :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Current buy rate. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param min_stake: Minimal stake size allowed by exchange (for both entries and exits) :param max_stake: Maximum stake allowed (either through balance, or by exchange limits). :param current_entry_rate: Current rate using entry pricing. :param current_exit_rate: Current rate using exit pricing. :param current_entry_profit: Current profit using entry pricing. :param current_exit_profit: Current profit using exit pricing. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: Stake amount to adjust your trade, Positive values to increase position, Negative values to decrease position. Return None for no action. \"\"\" if current_profit > 0.05 and trade . nr_of_successful_exits == 0 : # Take half of the profit at +5% return - ( trade . stake_amount / 2 ) if current_profit > - 0.05 : return None # Obtain pair dataframe (just to show how to access it) dataframe , _ = self . dp . get_analyzed_dataframe ( trade . pair , self . timeframe ) # Only buy when not actively falling price. last_candle = dataframe . iloc [ - 1 ] . squeeze () previous_candle = dataframe . iloc [ - 2 ] . squeeze () if last_candle [ 'close' ] < previous_candle [ 'close' ]: return None filled_entries = trade . select_filled_orders ( trade . entry_side ) count_of_entries = trade . nr_of_successful_entries # Allow up to 3 additional increasingly larger buys (4 in total) # Initial buy is 1x # If that falls to -5% profit, we buy 1.25x more, average profit should increase to roughly -2.2% # If that falls down to -5% again, we buy 1.5x more # If that falls once again down to -5%, we buy 1.75x more # Total stake for this trade would be 1 + 1.25 + 1.5 + 1.75 = 5.5x of the initial allowed stake. # That is why max_dca_multiplier is 5.5 # Hope you have a deep wallet! try : # This returns first order stake size stake_amount = filled_entries [ 0 ] . cost # This then calculates current safety order size stake_amount = stake_amount * ( 1 + ( count_of_entries * 0.25 )) return stake_amount except Exception as exception : return None return None Position adjust calculations \u00b6 Entry rates are calculated using weighted averages. Exits will not influence the average entry rate. Partial exit relative profit is relative to the average entry price at this point. Final exit relative profit is calculated based on the total invested capital. (See example below) Calculation example This example assumes 0 fees for simplicity, and a long position on an imaginary coin. Buy 100@8$ Buy 100@9$ -> Avg price: 8.5$ Sell 100@10$ -> Avg price: 8.5$, realized profit 150$, 17.65% Buy 150@11$ -> Avg price: 10$, realized profit 150$, 17.65% Sell 100@12$ -> Avg price: 10$, total realized profit 350$, 20% Sell 150@14$ -> Avg price: 10$, total realized profit 950$, 40% The total profit for this trade was 950$ on a 3350$ investment ( 100@8$ + 100@9$ + 150@11$ ). As such - the final relative profit is 28.35% ( 950 / 3350 ). Adjust Entry Price \u00b6 The adjust_entry_price() callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles. Be aware that custom_entry_price() is still the one dictating initial entry limit order price target at the time of entry trigger. Orders can be cancelled out of this callback by returning None . Returning current_order_rate will keep the order on the exchange \"as is\". Returning any other price will cancel the existing order, and replace it with a new order. The trade open-date ( trade.open_date_utc ) will remain at the time of the very first order placed. Please make sure to be aware of this - and eventually adjust your logic in other callbacks to account for this, and use the date of the first filled order instead. Regular timeout Entry unfilledtimeout mechanism (as well as check_entry_timeout() ) takes precedence over this. Entry Orders that are cancelled via the above methods will not have this callback called. Be sure to update timeout values to match your expectations. from freqtrade.persistence import Trade from datetime import timedelta class AwesomeStrategy ( IStrategy ): # ... populate_* methods def adjust_entry_price ( self , trade : Trade , order : Optional [ Order ], pair : str , current_time : datetime , proposed_rate : float , current_order_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : \"\"\" Entry price re-adjustment logic, returning the user desired limit price. This only executes when a order was already placed, still open (unfilled fully or partially) and not timed out on subsequent candles after entry trigger. When not implemented by a strategy, returns current_order_rate as default. If current_order_rate is returned then the existing order is maintained. If None is returned then order gets canceled but not replaced by a new one. :param pair: Pair that's currently analyzed :param trade: Trade object. :param order: Order object :param current_time: datetime object, containing the current datetime :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing. :param current_order_rate: Rate of the existing order in place. :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New entry price value if provided \"\"\" # Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair. if pair == 'BTC/USDT' and entry_tag == 'long_sma200' and side == 'long' and ( current_time - timedelta ( minutes = 10 ) > trade . open_date_utc : # just cancel the order if it has been filled more than half of the amount if order . filled > order . remaining : return None else : dataframe , _ = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) current_candle = dataframe . iloc [ - 1 ] . squeeze () # desired price return current_candle [ 'sma_200' ] # default: maintain existing order return current_order_rate Leverage Callback \u00b6 When trading in markets that allow leverage, this method must return the desired Leverage (Defaults to 1 -> No leverage). Assuming a capital of 500USDT, a trade with leverage=3 would result in a position with 500 x 3 = 1500 USDT. Values that are above max_leverage will be adjusted to max_leverage . For markets / exchanges that don't support leverage, this method is ignored. class AwesomeStrategy ( IStrategy ): def leverage ( self , pair : str , current_time : datetime , current_rate : float , proposed_leverage : float , max_leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : \"\"\" Customize leverage for each new trade. This method is only called in futures mode. :param pair: Pair that's currently analyzed :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in exit_pricing. :param proposed_leverage: A leverage proposed by the bot. :param max_leverage: Max leverage allowed on this pair :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :return: A leverage amount, which is between 1.0 and max_leverage. \"\"\" return 1.0 All profit calculations include leverage. Stoploss / ROI also include leverage in their calculation. Defining a stoploss of 10% at 10x leverage would trigger the stoploss with a 1% move to the downside.","title":"Strategy Callbacks"},{"location":"strategy-callbacks/#strategy-callbacks","text":"While the main strategy functions ( populate_indicators() , populate_entry_trend() , populate_exit_trend() ) should be used in a vectorized way, and are only called once during backtesting , callbacks are called \"whenever needed\". As such, you should avoid doing heavy calculations in callbacks to avoid delays during operations. Depending on the callback used, they may be called when entering / exiting a trade, or throughout the duration of a trade. Currently available callbacks: bot_start() bot_loop_start() custom_stake_amount() custom_exit() custom_stoploss() custom_entry_price() and custom_exit_price() check_entry_timeout() and check_exit_timeout() confirm_trade_entry() confirm_trade_exit() adjust_trade_position() adjust_entry_price() leverage() Callback calling sequence You can find the callback calling sequence in bot-basics","title":"Strategy Callbacks"},{"location":"strategy-callbacks/#bot-start","text":"A simple callback which is called once when the strategy is loaded. This can be used to perform actions that must only be performed once and runs after dataprovider and wallet are set import requests class AwesomeStrategy ( IStrategy ): # ... populate_* methods def bot_start ( self , ** kwargs ) -> None : \"\"\" Called only once after bot instantiation. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # Assign this to the class by using self.* # can then be used by populate_* methods self . cust_remote_data = requests . get ( 'https://some_remote_source.example.com' ) During hyperopt, this runs only once at startup.","title":"Bot start"},{"location":"strategy-callbacks/#bot-loop-start","text":"A simple callback which is called once at the start of every bot throttling iteration (roughly every 5 seconds, unless configured differently). This can be used to perform calculations which are pair independent (apply to all pairs), loading of external data, etc. import requests class AwesomeStrategy ( IStrategy ): # ... populate_* methods def bot_loop_start ( self , ** kwargs ) -> None : \"\"\" Called at the start of the bot iteration (one loop). Might be used to perform pair-independent tasks (e.g. gather some remote resource for comparison) :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. \"\"\" if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # Assign this to the class by using self.* # can then be used by populate_* methods self . remote_data = requests . get ( 'https://some_remote_source.example.com' )","title":"Bot loop start"},{"location":"strategy-callbacks/#stake-size-management","text":"Called before entering a trade, makes it possible to manage your position size when placing a new trade. class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) current_candle = dataframe . iloc [ - 1 ] . squeeze () if current_candle [ 'fastk_rsi_1h' ] > current_candle [ 'fastd_rsi_1h' ]: if self . config [ 'stake_amount' ] == 'unlimited' : # Use entire available wallet during favorable conditions when in compounding mode. return max_stake else : # Compound profits during favorable conditions instead of using a static stake. return self . wallets . get_total_stake_amount () / self . config [ 'max_open_trades' ] # Use default stake amount. return proposed_stake Freqtrade will fall back to the proposed_stake value should your code raise an exception. The exception itself will be logged. Tip You do not have to ensure that min_stake <= returned_value <= max_stake . Trades will succeed as the returned value will be clamped to supported range and this action will be logged. Tip Returning 0 or None will prevent trades from being placed.","title":"Stake size management"},{"location":"strategy-callbacks/#custom-exit-signal","text":"Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed. Allows to define custom exit signals, indicating that specified position should be sold. This is very useful when we need to customize exit conditions for each individual trade, or if you need trade data to make an exit decision. For example you could implement a 1:2 risk-reward ROI with custom_exit() . Using custom_exit() signals in place of stoploss though is not recommended . It is a inferior method to using custom_stoploss() in this regard - which also allows you to keep the stoploss on exchange. Note Returning a (none-empty) string or True from this method is equal to setting exit signal on a candle at specified time. This method is not called when exit signal is set already, or if exit signals are disabled ( use_exit_signal=False ). string max length is 64 characters. Exceeding this limit will cause the message to be truncated to 64 characters. custom_exit() will ignore exit_profit_only , and will always be called unless use_exit_signal=False , even if there is a new enter signal. An example of how we can use different indicators depending on the current profit and also exit trades that were open longer than one day: class AwesomeStrategy ( IStrategy ): def custom_exit ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # Above 20% profit, sell when rsi < 80 if current_profit > 0.2 : if last_candle [ 'rsi' ] < 80 : return 'rsi_below_80' # Between 2% and 10%, sell if EMA-long above EMA-short if 0.02 < current_profit < 0.1 : if last_candle [ 'emalong' ] > last_candle [ 'emashort' ]: return 'ema_long_below_80' # Sell any positions at a loss if they are held for more than one day. if current_profit < 0.0 and ( current_time - trade . open_date_utc ) . days >= 1 : return 'unclog' See Dataframe access for more information about dataframe use in strategy callbacks.","title":"Custom exit signal"},{"location":"strategy-callbacks/#custom-stoploss","text":"Called for open trade every iteration (roughly every 5 seconds) until a trade is closed. The usage of the custom stoploss method must be enabled by setting use_custom_stoploss=True on the strategy object. The stoploss price can only ever move upwards - if the stoploss value returned from custom_stoploss would result in a lower stoploss price than was previously set, it will be ignored. The traditional stoploss value serves as an absolute lower level and will be instated as the initial stoploss (before this method is called for the first time for a trade), and is still mandatory. The method must return a stoploss value (float / number) as a percentage of the current price. E.g. If the current_rate is 200 USD, then returning 0.02 will set the stoploss price 2% lower, at 196 USD. The absolute value of the return value is used (the sign is ignored), so returning 0.05 or -0.05 have the same result, a stoploss 5% below the current price. To simulate a regular trailing stoploss of 4% (trailing 4% behind the maximum reached price) you would use the following very simple method: # additional imports required from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : \"\"\" Custom stoploss logic, returning the new distance relative to current_rate (as ratio). e.g. returning -0.05 would create a stoploss 5% below current_rate. The custom stoploss can never be below self.stoploss, which serves as a hard maximum loss. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns the initial stoploss value Only called when use_custom_stoploss is set to True. :param pair: Pair that's currently analyzed :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in exit_pricing. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New stoploss value, relative to the current rate \"\"\" return - 0.04 Stoploss on exchange works similar to trailing_stop , and the stoploss on exchange is updated as configured in stoploss_on_exchange_interval ( More details about stoploss on exchange ). Use of dates All time-based calculations should be done based on current_time - using datetime.now() or datetime.utcnow() is discouraged, as this will break backtesting support. Trailing stoploss It's recommended to disable trailing_stop when using custom stoploss values. Both can work in tandem, but you might encounter the trailing stop to move the price higher while your custom function would not want this, causing conflicting behavior.","title":"Custom stoploss"},{"location":"strategy-callbacks/#custom-stoploss-examples","text":"The next section will show some examples on what's possible with the custom stoploss function. Of course, many more things are possible, and all examples can be combined at will.","title":"Custom stoploss examples"},{"location":"strategy-callbacks/#time-based-trailing-stop","text":"Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss. from datetime import datetime , timedelta from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # Make sure you have the longest interval first - these conditions are evaluated from top to bottom. if current_time - timedelta ( minutes = 120 ) > trade . open_date_utc : return - 0.05 elif current_time - timedelta ( minutes = 60 ) > trade . open_date_utc : return - 0.10 return 1","title":"Time based trailing stop"},{"location":"strategy-callbacks/#different-stoploss-per-pair","text":"Use a different stoploss depending on the pair. In this example, we'll trail the highest price with 10% trailing stoploss for ETH/BTC and XRP/BTC , with 5% trailing stoploss for LTC/BTC and with 15% for all other pairs. from datetime import datetime from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : if pair in ( 'ETH/BTC' , 'XRP/BTC' ): return - 0.10 elif pair in ( 'LTC/BTC' ): return - 0.05 return - 0.15","title":"Different stoploss per pair"},{"location":"strategy-callbacks/#trailing-stoploss-with-positive-offset","text":"Use the initial stoploss until the profit is above 4%, then use a trailing stoploss of 50% of the current profit with a minimum of 2.5% and a maximum of 5%. Please note that the stoploss can only increase, values lower than the current stoploss are ignored. from datetime import datetime , timedelta from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : if current_profit < 0.04 : return - 1 # return a value bigger than the initial stoploss to keep using the initial stoploss # After reaching the desired offset, allow the stoploss to trail by half the profit desired_stoploss = current_profit / 2 # Use a minimum of 2.5% and a maximum of 5% return max ( min ( desired_stoploss , 0.05 ), 0.025 )","title":"Trailing stoploss with positive offset"},{"location":"strategy-callbacks/#stepped-stoploss","text":"Instead of continuously trailing behind the current price, this example sets fixed stoploss price levels based on the current profit. Use the regular stoploss until 20% profit is reached Once profit is > 20% - set stoploss to 7% above open price. Once profit is > 25% - set stoploss to 15% above open price. Once profit is > 40% - set stoploss to 25% above open price. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import stoploss_from_open class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # evaluate highest to lowest, so that highest possible stop is used if current_profit > 0.40 : return stoploss_from_open ( 0.25 , current_profit , is_short = trade . is_short ) elif current_profit > 0.25 : return stoploss_from_open ( 0.15 , current_profit , is_short = trade . is_short ) elif current_profit > 0.20 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) # return maximum stoploss value, keeping current stoploss price unchanged return 1","title":"Stepped stoploss"},{"location":"strategy-callbacks/#custom-stoploss-using-an-indicator-from-dataframe-example","text":"Absolute stoploss value may be derived from indicators stored in dataframe. Example uses parabolic SAR below the price as stoploss. class AwesomeStrategy ( IStrategy ): def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # <...> dataframe [ 'sar' ] = ta . SAR ( dataframe ) use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # Use parabolic sar as absolute stoploss price stoploss_price = last_candle [ 'sar' ] # Convert absolute price to percentage relative to current_rate if stoploss_price < current_rate : return ( stoploss_price / current_rate ) - 1 # return maximum stoploss value, keeping current stoploss price unchanged return 1 See Dataframe access for more information about dataframe use in strategy callbacks.","title":"Custom stoploss using an indicator from dataframe example"},{"location":"strategy-callbacks/#common-helpers-for-stoploss-calculations","text":"","title":"Common helpers for stoploss calculations"},{"location":"strategy-callbacks/#stoploss-relative-to-open-price","text":"Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss relative to the open price, we need to use current_profit to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_open() can be used to convert from an open price relative stop, to a current price relative stop which can be returned from custom_stoploss() .","title":"Stoploss relative to open price"},{"location":"strategy-callbacks/#stoploss-percentage-from-absolute-price","text":"Stoploss values returned from custom_stoploss() always specify a percentage relative to current_rate . In order to set a stoploss at specified absolute price level, we need to use stop_rate to calculate what percentage relative to the current_rate will give you the same result as if the percentage was specified from the open price. The helper function stoploss_from_absolute() can be used to convert from an absolute price, to a current price relative stop which can be returned from custom_stoploss() .","title":"Stoploss percentage from absolute price"},{"location":"strategy-callbacks/#custom-order-price-rules","text":"By default, freqtrade use the orderbook to automatically set an order price( Relevant documentation ), you also have the option to create custom order prices based on your strategy. You can use this feature by creating a custom_entry_price() function in your strategy file to customize entry prices and custom_exit_price() for exits. Each of these methods are called right before placing an order on the exchange. Note If your custom pricing function return None or an invalid value, price will fall back to proposed_rate , which is based on the regular pricing configuration.","title":"Custom order price rules"},{"location":"strategy-callbacks/#custom-order-entry-and-exit-price-example","text":"from datetime import datetime , timedelta , timezone from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) new_entryprice = dataframe [ 'bollinger_10_lowerband' ] . iat [ - 1 ] return new_entryprice def custom_exit_price ( self , pair : str , trade : Trade , current_time : datetime , proposed_rate : float , current_profit : float , exit_tag : Optional [ str ], ** kwargs ) -> float : dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) new_exitprice = dataframe [ 'bollinger_10_upperband' ] . iat [ - 1 ] return new_exitprice Warning Modifying entry and exit prices will only work for limit orders. Depending on the price chosen, this can result in a lot of unfilled orders. By default the maximum allowed distance between the current price and the custom price is 2%, this value can be changed in config with the custom_price_max_distance_ratio parameter. Example : If the new_entryprice is 97, the proposed_rate is 100 and the custom_price_max_distance_ratio is set to 2%, The retained valid custom entry price will be 98, which is 2% below the current (proposed) rate. Backtesting Custom prices are supported in backtesting (starting with 2021.12), and orders will fill if the price falls within the candle's low/high range. Orders that don't fill immediately are subject to regular timeout handling, which happens once per (detail) candle. custom_exit_price() is only called for sells of type exit_signal, Custom exit and partial exits. All other exit-types will use regular backtesting prices.","title":"Custom order entry and exit price example"},{"location":"strategy-callbacks/#custom-order-timeout-rules","text":"Simple, time-based order-timeouts can be configured either via strategy or in the configuration in the unfilledtimeout section. However, freqtrade also offers a custom callback for both order types, which allows you to decide based on custom criteria if an order did time out or not. Note Backtesting fills orders if their price falls within the candle's low/high range. The below callbacks will be called once per (detail) candle for orders that don't fill immediately (which use custom pricing).","title":"Custom order timeout rules"},{"location":"strategy-callbacks/#custom-order-timeout-example","text":"Called for every open order until that order is either filled or cancelled. check_entry_timeout() is called for trade entries, while check_exit_timeout() is called for trade exit orders. A simple example, which applies different unfilled-timeouts depending on the price of the asset can be seen below. It applies a tight timeout for higher priced assets, while allowing more time to fill on cheap coins. The function must return either True (cancel order) or False (keep order alive). from datetime import datetime , timedelta from freqtrade.persistence import Trade , Order class AwesomeStrategy ( IStrategy ): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'entry' : 60 * 25 , 'exit' : 60 * 25 } def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : if trade . open_rate > 100 and trade . open_date_utc < current_time - timedelta ( minutes = 5 ): return True elif trade . open_rate > 10 and trade . open_date_utc < current_time - timedelta ( minutes = 3 ): return True elif trade . open_rate < 1 and trade . open_date_utc < current_time - timedelta ( hours = 24 ): return True return False def check_exit_timeout ( self , pair : str , trade : Trade , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : if trade . open_rate > 100 and trade . open_date_utc < current_time - timedelta ( minutes = 5 ): return True elif trade . open_rate > 10 and trade . open_date_utc < current_time - timedelta ( minutes = 3 ): return True elif trade . open_rate < 1 and trade . open_date_utc < current_time - timedelta ( hours = 24 ): return True return False Note For the above example, unfilledtimeout must be set to something bigger than 24h, otherwise that type of timeout will apply first.","title":"Custom order timeout example"},{"location":"strategy-callbacks/#custom-order-timeout-example-using-additional-data","text":"from datetime import datetime from freqtrade.persistence import Trade , Order class AwesomeStrategy ( IStrategy ): # ... populate_* methods # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours. unfilledtimeout = { 'entry' : 60 * 25 , 'exit' : 60 * 25 } def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : ob = self . dp . orderbook ( pair , 1 ) current_price = ob [ 'bids' ][ 0 ][ 0 ] # Cancel buy order if price is more than 2% above the order. if current_price > order . price * 1.02 : return True return False def check_exit_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : ob = self . dp . orderbook ( pair , 1 ) current_price = ob [ 'asks' ][ 0 ][ 0 ] # Cancel sell order if price is more than 2% below the order. if current_price < order . price * 0.98 : return True return False","title":"Custom order timeout example (using additional data)"},{"location":"strategy-callbacks/#bot-order-confirmation","text":"Confirm trade entry / exits. This are the last methods that will be called before an order is placed.","title":"Bot order confirmation"},{"location":"strategy-callbacks/#trade-entry-buy-order-confirmation","text":"confirm_trade_entry() can be used to abort a trade entry at the latest second (maybe because the price is not what we expect). class AwesomeStrategy ( IStrategy ): # ... populate_* methods def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], side : str , ** kwargs ) -> bool : \"\"\" Called right before placing a entry order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair that's about to be bought/shorted. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in target (base) currency that's going to be traded. :param rate: Rate that's going to be used when using limit orders or current rate for market orders. :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param current_time: datetime object, containing the current datetime :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True is returned, then the buy-order is placed on the exchange. False aborts the process \"\"\" return True","title":"Trade entry (buy order) confirmation"},{"location":"strategy-callbacks/#trade-exit-sell-order-confirmation","text":"confirm_trade_exit() can be used to abort a trade exit (sell) at the latest second (maybe because the price is not what we expect). confirm_trade_exit() may be called multiple times within one iteration for the same trade if different exit-reasons apply. The exit-reasons (if applicable) will be in the following sequence: exit_signal / custom_exit stop_loss roi trailing_stop_loss from freqtrade.persistence import Trade class AwesomeStrategy ( IStrategy ): # ... populate_* methods def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : datetime , ** kwargs ) -> bool : \"\"\" Called right before placing a regular exit order. Timing for this function is critical, so avoid doing heavy computations or network requests in this method. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns True (always confirming). :param pair: Pair for trade that's about to be exited. :param trade: trade object. :param order_type: Order type (as configured in order_types). usually limit or market. :param amount: Amount in base currency. :param rate: Rate that's going to be used when using limit orders or current rate for market orders. :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled). :param exit_reason: Exit reason. Can be any of ['roi', 'stop_loss', 'stoploss_on_exchange', 'trailing_stop_loss', 'exit_signal', 'force_exit', 'emergency_exit'] :param current_time: datetime object, containing the current datetime :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return bool: When True, then the exit-order is placed on the exchange. False aborts the process \"\"\" if exit_reason == 'force_exit' and trade . calc_profit_ratio ( rate ) < 0 : # Reject force-sells with negative profit # This is just a sample, please adjust to your needs # (this does not necessarily make sense, assuming you know when you're force-selling) return False return True Warning confirm_trade_exit() can prevent stoploss exits, causing significant losses as this would ignore stoploss exits. confirm_trade_exit() will not be called for Liquidations - as liquidations are forced by the exchange, and therefore cannot be rejected.","title":"Trade exit (sell order) confirmation"},{"location":"strategy-callbacks/#adjust-trade-position","text":"The position_adjustment_enable strategy property enables the usage of adjust_trade_position() callback in the strategy. For performance reasons, it's disabled by default and freqtrade will show a warning message on startup if enabled. adjust_trade_position() can be used to perform additional orders, for example to manage risk with DCA (Dollar Cost Averaging) or to increase or decrease positions. max_entry_position_adjustment property is used to limit the number of additional buys per trade (on top of the first buy) that the bot can execute. By default, the value is -1 which means the bot have no limit on number of adjustment buys. The strategy is expected to return a stake_amount (in stake currency) between min_stake and max_stake if and when an additional buy order should be made (position is increased). If there are not enough funds in the wallet (the return value is above max_stake ) then the signal will be ignored. Additional orders also result in additional fees and those orders don't count towards max_open_trades . This callback is not called when there is an open order (either buy or sell) waiting for execution. adjust_trade_position() is called very frequently for the duration of a trade, so you must keep your implementation as performant as possible. Additional Buys are ignored once you have reached the maximum amount of extra buys that you have set on max_entry_position_adjustment , but the callback is called anyway looking for partial exits. Position adjustments will always be applied in the direction of the trade, so a positive value will always increase your position (negative values will decrease your position), no matter if it's a long or short trade. Modifications to leverage are not possible. About stake size Using fixed stake size means it will be the amount used for the first order, just like without position adjustment. If you wish to buy additional orders with DCA, then make sure to leave enough funds in the wallet for that. Using 'unlimited' stake amount with DCA orders requires you to also implement the custom_stake_amount() callback to avoid allocating all funds to the initial order. Warning Stoploss is still calculated from the initial opening price, not averaged price. Regular stoploss rules still apply (cannot move down). While /stopentry command stops the bot from entering new trades, the position adjustment feature will continue buying new orders on existing trades. Backtesting During backtesting this callback is called for each candle in timeframe or timeframe_detail , so run-time performance will be affected. from freqtrade.persistence import Trade class DigDeeperStrategy ( IStrategy ): position_adjustment_enable = True # Attempts to handle large drops with DCA. High stoploss is required. stoploss = - 0.30 # ... populate_* methods # Example specific variables max_entry_position_adjustment = 3 # This number is explained a bit further down max_dca_multiplier = 5.5 # This is called when placing the initial order (opening trade) def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : # We need to leave most of the funds for possible further DCA orders # This also applies to fixed stakes return proposed_stake / self . max_dca_multiplier def adjust_trade_position ( self , trade : Trade , current_time : datetime , current_rate : float , current_profit : float , min_stake : Optional [ float ], max_stake : float , current_entry_rate : float , current_exit_rate : float , current_entry_profit : float , current_exit_profit : float , ** kwargs ) -> Optional [ float ]: \"\"\" Custom trade adjustment logic, returning the stake amount that a trade should be increased or decreased. This means extra buy or sell orders with additional fees. Only called when `position_adjustment_enable` is set to True. For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/ When not implemented by a strategy, returns None :param trade: trade object. :param current_time: datetime object, containing the current datetime :param current_rate: Current buy rate. :param current_profit: Current profit (as ratio), calculated based on current_rate. :param min_stake: Minimal stake size allowed by exchange (for both entries and exits) :param max_stake: Maximum stake allowed (either through balance, or by exchange limits). :param current_entry_rate: Current rate using entry pricing. :param current_exit_rate: Current rate using exit pricing. :param current_entry_profit: Current profit using entry pricing. :param current_exit_profit: Current profit using exit pricing. :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: Stake amount to adjust your trade, Positive values to increase position, Negative values to decrease position. Return None for no action. \"\"\" if current_profit > 0.05 and trade . nr_of_successful_exits == 0 : # Take half of the profit at +5% return - ( trade . stake_amount / 2 ) if current_profit > - 0.05 : return None # Obtain pair dataframe (just to show how to access it) dataframe , _ = self . dp . get_analyzed_dataframe ( trade . pair , self . timeframe ) # Only buy when not actively falling price. last_candle = dataframe . iloc [ - 1 ] . squeeze () previous_candle = dataframe . iloc [ - 2 ] . squeeze () if last_candle [ 'close' ] < previous_candle [ 'close' ]: return None filled_entries = trade . select_filled_orders ( trade . entry_side ) count_of_entries = trade . nr_of_successful_entries # Allow up to 3 additional increasingly larger buys (4 in total) # Initial buy is 1x # If that falls to -5% profit, we buy 1.25x more, average profit should increase to roughly -2.2% # If that falls down to -5% again, we buy 1.5x more # If that falls once again down to -5%, we buy 1.75x more # Total stake for this trade would be 1 + 1.25 + 1.5 + 1.75 = 5.5x of the initial allowed stake. # That is why max_dca_multiplier is 5.5 # Hope you have a deep wallet! try : # This returns first order stake size stake_amount = filled_entries [ 0 ] . cost # This then calculates current safety order size stake_amount = stake_amount * ( 1 + ( count_of_entries * 0.25 )) return stake_amount except Exception as exception : return None return None","title":"Adjust trade position"},{"location":"strategy-callbacks/#position-adjust-calculations","text":"Entry rates are calculated using weighted averages. Exits will not influence the average entry rate. Partial exit relative profit is relative to the average entry price at this point. Final exit relative profit is calculated based on the total invested capital. (See example below) Calculation example This example assumes 0 fees for simplicity, and a long position on an imaginary coin. Buy 100@8$ Buy 100@9$ -> Avg price: 8.5$ Sell 100@10$ -> Avg price: 8.5$, realized profit 150$, 17.65% Buy 150@11$ -> Avg price: 10$, realized profit 150$, 17.65% Sell 100@12$ -> Avg price: 10$, total realized profit 350$, 20% Sell 150@14$ -> Avg price: 10$, total realized profit 950$, 40% The total profit for this trade was 950$ on a 3350$ investment ( 100@8$ + 100@9$ + 150@11$ ). As such - the final relative profit is 28.35% ( 950 / 3350 ).","title":"Position adjust calculations"},{"location":"strategy-callbacks/#adjust-entry-price","text":"The adjust_entry_price() callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles. Be aware that custom_entry_price() is still the one dictating initial entry limit order price target at the time of entry trigger. Orders can be cancelled out of this callback by returning None . Returning current_order_rate will keep the order on the exchange \"as is\". Returning any other price will cancel the existing order, and replace it with a new order. The trade open-date ( trade.open_date_utc ) will remain at the time of the very first order placed. Please make sure to be aware of this - and eventually adjust your logic in other callbacks to account for this, and use the date of the first filled order instead. Regular timeout Entry unfilledtimeout mechanism (as well as check_entry_timeout() ) takes precedence over this. Entry Orders that are cancelled via the above methods will not have this callback called. Be sure to update timeout values to match your expectations. from freqtrade.persistence import Trade from datetime import timedelta class AwesomeStrategy ( IStrategy ): # ... populate_* methods def adjust_entry_price ( self , trade : Trade , order : Optional [ Order ], pair : str , current_time : datetime , proposed_rate : float , current_order_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : \"\"\" Entry price re-adjustment logic, returning the user desired limit price. This only executes when a order was already placed, still open (unfilled fully or partially) and not timed out on subsequent candles after entry trigger. When not implemented by a strategy, returns current_order_rate as default. If current_order_rate is returned then the existing order is maintained. If None is returned then order gets canceled but not replaced by a new one. :param pair: Pair that's currently analyzed :param trade: Trade object. :param order: Order object :param current_time: datetime object, containing the current datetime :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing. :param current_order_rate: Rate of the existing order in place. :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :param **kwargs: Ensure to keep this here so updates to this won't break your strategy. :return float: New entry price value if provided \"\"\" # Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair. if pair == 'BTC/USDT' and entry_tag == 'long_sma200' and side == 'long' and ( current_time - timedelta ( minutes = 10 ) > trade . open_date_utc : # just cancel the order if it has been filled more than half of the amount if order . filled > order . remaining : return None else : dataframe , _ = self . dp . get_analyzed_dataframe ( pair = pair , timeframe = self . timeframe ) current_candle = dataframe . iloc [ - 1 ] . squeeze () # desired price return current_candle [ 'sma_200' ] # default: maintain existing order return current_order_rate","title":"Adjust Entry Price"},{"location":"strategy-callbacks/#leverage-callback","text":"When trading in markets that allow leverage, this method must return the desired Leverage (Defaults to 1 -> No leverage). Assuming a capital of 500USDT, a trade with leverage=3 would result in a position with 500 x 3 = 1500 USDT. Values that are above max_leverage will be adjusted to max_leverage . For markets / exchanges that don't support leverage, this method is ignored. class AwesomeStrategy ( IStrategy ): def leverage ( self , pair : str , current_time : datetime , current_rate : float , proposed_leverage : float , max_leverage : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : \"\"\" Customize leverage for each new trade. This method is only called in futures mode. :param pair: Pair that's currently analyzed :param current_time: datetime object, containing the current datetime :param current_rate: Rate, calculated based on pricing settings in exit_pricing. :param proposed_leverage: A leverage proposed by the bot. :param max_leverage: Max leverage allowed on this pair :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal. :param side: 'long' or 'short' - indicating the direction of the proposed trade :return: A leverage amount, which is between 1.0 and max_leverage. \"\"\" return 1.0 All profit calculations include leverage. Stoploss / ROI also include leverage in their calculation. Defining a stoploss of 10% at 10x leverage would trigger the stoploss with a 1% move to the downside.","title":"Leverage Callback"},{"location":"strategy-customization/","text":"Strategy Customization \u00b6 This page explains how to customize your strategies, add new indicators and set up trading rules. Please familiarize yourself with Freqtrade basics first, which provides overall info on how the bot operates. Develop your own strategy \u00b6 The bot includes a default strategy file. Also, several other strategies are available in the strategy repository . You will however most likely have your own idea for a strategy. This document intends to help you convert your strategy idea into your own strategy. To get started, use freqtrade new-strategy --strategy AwesomeStrategy (you can obviously use your own naming for your strategy). This will create a new strategy file from a template, which will be located under user_data/strategies/AwesomeStrategy.py . Note This is just a template file, which will most likely not be profitable out of the box. Different template levels freqtrade new-strategy has an additional parameter, --template , which controls the amount of pre-build information you get in the created strategy. Use --template minimal to get an empty strategy without any indicator examples, or --template advanced to get a template with most callbacks defined. Anatomy of a strategy \u00b6 A strategy file contains all the information needed to build a good strategy: Indicators Entry strategy rules Exit strategy rules Minimal ROI recommended Stoploss strongly recommended The bot also include a sample strategy called SampleStrategy you can update: user_data/strategies/sample_strategy.py . You can test it with the parameter: --strategy SampleStrategy Additionally, there is an attribute called INTERFACE_VERSION , which defines the version of the strategy interface the bot should use. The current version is 3 - which is also the default when it's not set explicitly in the strategy. Future versions will require this to be set. freqtrade trade --strategy AwesomeStrategy For the following section we will use the user_data/strategies/sample_strategy.py file as reference. Strategies and Backtesting To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time range is passed to the populate_*() methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing ( df.iloc[-1] ), but instead use df.shift() to get to the previous candle. Warning: Using future data Since backtesting passes the full time range to the populate_*() methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Some common patterns for this are listed in the Common Mistakes section of this document. Dataframe \u00b6 Freqtrade uses pandas to store/provide the candlestick (OHLCV) data. Pandas is a great library developed for processing large amounts of data. Each row in a dataframe corresponds to one candle on a chart, with the latest candle always being the last in the dataframe (sorted by date). > dataframe.head() date open high low close volume 0 2021-11-09 23:25:00+00:00 67279.67 67321.84 67255.01 67300.97 44.62253 1 2021-11-09 23:30:00+00:00 67300.97 67301.34 67183.03 67187.01 61.38076 2 2021-11-09 23:35:00+00:00 67187.02 67187.02 67031.93 67123.81 113.42728 3 2021-11-09 23:40:00+00:00 67123.80 67222.40 67080.33 67160.48 78.96008 4 2021-11-09 23:45:00+00:00 67160.48 67160.48 66901.26 66943.37 111.39292 Pandas provides fast ways to calculate metrics. To benefit from this speed, it's advised to not use loops, but use vectorized methods instead. Vectorized operations perform calculations across the whole range of data and are therefore, compared to looping through each row, a lot faster when calculating indicators. As a dataframe is a table, simple python comparisons like the following will not work if dataframe [ 'rsi' ] > 30 : dataframe [ 'enter_long' ] = 1 The above section will fail with The truth value of a Series is ambiguous. [...] . This must instead be written in a pandas-compatible way, so the operation is performed across the whole dataframe. dataframe . loc [ ( dataframe [ 'rsi' ] > 30 ) , 'enter_long' ] = 1 With this section, you have a new column in your dataframe, which has 1 assigned whenever RSI is above 30. Customize Indicators \u00b6 Buy and sell signals need indicators. You can add more indicators by extending the list contained in the method populate_indicators() from your strategy file. You should only add the indicators used in either populate_entry_trend() , populate_exit_trend() , or to populate another indicator, otherwise performance may suffer. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. Sample: def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Adds several different TA indicators to the given DataFrame Performance Note: For the best performance be frugal on the number of indicators you are using. Let uncomment only the indicator you are using in your strategies or your hyperopt configuration, otherwise you will waste your memory and CPU usage. :param dataframe: Dataframe with data from the exchange :param metadata: Additional information, like the currently traded pair :return: a Dataframe with all mandatory indicators for the strategies \"\"\" dataframe [ 'sar' ] = ta . SAR ( dataframe ) dataframe [ 'adx' ] = ta . ADX ( dataframe ) stoch = ta . STOCHF ( dataframe ) dataframe [ 'fastd' ] = stoch [ 'fastd' ] dataframe [ 'fastk' ] = stoch [ 'fastk' ] dataframe [ 'blower' ] = ta . BBANDS ( dataframe , nbdevup = 2 , nbdevdn = 2 )[ 'lowerband' ] dataframe [ 'sma' ] = ta . SMA ( dataframe , timeperiod = 40 ) dataframe [ 'tema' ] = ta . TEMA ( dataframe , timeperiod = 9 ) dataframe [ 'mfi' ] = ta . MFI ( dataframe ) dataframe [ 'rsi' ] = ta . RSI ( dataframe ) dataframe [ 'ema5' ] = ta . EMA ( dataframe , timeperiod = 5 ) dataframe [ 'ema10' ] = ta . EMA ( dataframe , timeperiod = 10 ) dataframe [ 'ema50' ] = ta . EMA ( dataframe , timeperiod = 50 ) dataframe [ 'ema100' ] = ta . EMA ( dataframe , timeperiod = 100 ) dataframe [ 'ao' ] = awesome_oscillator ( dataframe ) macd = ta . MACD ( dataframe ) dataframe [ 'macd' ] = macd [ 'macd' ] dataframe [ 'macdsignal' ] = macd [ 'macdsignal' ] dataframe [ 'macdhist' ] = macd [ 'macdhist' ] hilbert = ta . HT_SINE ( dataframe ) dataframe [ 'htsine' ] = hilbert [ 'sine' ] dataframe [ 'htleadsine' ] = hilbert [ 'leadsine' ] dataframe [ 'plus_dm' ] = ta . PLUS_DM ( dataframe ) dataframe [ 'plus_di' ] = ta . PLUS_DI ( dataframe ) dataframe [ 'minus_dm' ] = ta . MINUS_DM ( dataframe ) dataframe [ 'minus_di' ] = ta . MINUS_DI ( dataframe ) return dataframe Want more indicator examples? Look into the user_data/strategies/sample_strategy.py . Then uncomment indicators you need. Indicator libraries \u00b6 Out of the box, freqtrade installs the following technical libraries: ta-lib pandas-ta technical Additional technical libraries can be installed as necessary, or custom indicators may be written / invented by the strategy author. Strategy startup period \u00b6 Most indicators have an instable startup period, in which they are either not available (NaN), or the calculation is incorrect. This can lead to inconsistencies, since Freqtrade does not know how long this instable period should be. To account for this, the strategy can be assigned the startup_candle_count attribute. This should be set to the maximum number of candles that the strategy requires to calculate stable indicators. In this example strategy, this should be set to 100 ( startup_candle_count = 100 ), since the longest needed history is 100 candles. dataframe [ 'ema100' ] = ta . EMA ( dataframe , timeperiod = 100 ) By letting the bot know how much history is needed, backtest trades can start at the specified timerange during backtesting and hyperopt. Using x calls to get OHLCV If you receive a warning like WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy - you should consider if you really need this much historic data for your signals. Having this will cause Freqtrade to make multiple calls for the same pair, which will obviously be slower than one network request. As a consequence, Freqtrade will take longer to refresh candles - and should therefore be avoided if possible. This is capped to 5 total calls to avoid overloading the exchange, or make freqtrade too slow. Warning startup_candle_count should be below ohlcv_candle_limit * 5 (which is 500 * 5 for most exchanges) - since only this amount of candles will be available during Dry-Run/Live Trade operations. Example \u00b6 Let's try to backtest 1 month (January 2019) of 5m candles using an example strategy with EMA100, as above. freqtrade backtesting --timerange 20190101 -20190201 --timeframe 5m Assuming startup_candle_count is set to 100, backtesting knows it needs 100 candles to generate valid buy signals. It will load data from 20190101 - (100 * 5m) - which is ~2018-12-31 15:30:00. If this data is available, indicators will be calculated with this extended timerange. The instable startup period (up to 2019-01-01 00:00:00) will then be removed before starting backtesting. Note If data for the startup period is not available, then the timerange will be adjusted to account for this startup period - so Backtesting would start at 2019-01-01 08:30:00. Entry signal rules \u00b6 Edit the method populate_entry_trend() in your strategy file to update your entry strategy. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"enter_long\" ( \"enter_short\" for shorts), which needs to contain 1 for entries, and 0 for \"no action\". enter_long is a mandatory column that must be set even if the strategy is shorting only. Sample from user_data/strategies/sample_strategy.py : def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Based on TA indicators, populates the buy signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Enter short trades Short-entries can be created by setting enter_short (corresponds to enter_long for long trades). The enter_tag column remains identical. Short-trades need to be supported by your exchange and market configuration! Please make sure to set can_short appropriately on your strategy if you intend to short. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) dataframe . loc [ ( ( qtpylib . crossed_below ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses below 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_short' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Note Buying requires sellers to buy from - therefore volume needs to be > 0 ( dataframe['volume'] > 0 ) to make sure that the bot does not buy/sell in no-activity periods. Exit signal rules \u00b6 Edit the method populate_exit_trend() into your strategy file to update your exit strategy. Please note that the exit-signal is only used if use_exit_signal is set to true in the configuration. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"exit_long\" ( \"exit_short\" for shorts), which needs to contain 1 for exits, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Based on TA indicators, populates the exit signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'rsi_too_high' ) return dataframe Exit short trades Short-exits can be created by setting exit_short (corresponds to exit_long ). The exit_tag column remains identical. Short-trades need to be supported by your exchange and market configuration! def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'rsi_too_high' ) dataframe . loc [ ( ( qtpylib . crossed_below ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses below 30 ( dataframe [ 'tema' ] < dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_short' , 'exit_tag' ]] = ( 1 , 'rsi_too_low' ) return dataframe Minimal ROI \u00b6 This dict defines the minimal Return On Investment (ROI) a trade should reach before exiting, independent from the exit signal. It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage. minimal_roi = { \"40\" : 0.0 , \"30\" : 0.01 , \"20\" : 0.02 , \"0\" : 0.04 } The above configuration would therefore mean: Exit whenever 4% profit was reached Exit when 2% profit was reached (in effect after 20 minutes) Exit when 1% profit was reached (in effect after 30 minutes) Exit when trade is non-loosing (in effect after 40 minutes) The calculation does include fees. To disable ROI completely, set it to an insanely high number: minimal_roi = { \"0\" : 100 } While technically not completely disabled, this would exit once the trade reaches 10000% Profit. To use times based on candle duration (timeframe), the following snippet can be handy. This will allow you to change the timeframe for the strategy, and ROI times will still be set as candles (e.g. after 3 candles ...) from freqtrade.exchange import timeframe_to_minutes class AwesomeStrategy ( IStrategy ): timeframe = \"1d\" timeframe_mins = timeframe_to_minutes ( timeframe ) minimal_roi = { \"0\" : 0.05 , # 5% for the first 3 candles str ( timeframe_mins * 3 )): 0.02 , # 2% after 3 candles str ( timeframe_mins * 6 )): 0.01 , # 1% After 6 candles } Stoploss \u00b6 Setting a stoploss is highly recommended to protect your capital from strong moves against you. Sample of setting a 10% stoploss: stoploss = - 0.10 For the full documentation on stoploss features, look at the dedicated stoploss page . Timeframe \u00b6 This is the set of candles the bot should download and use for the analysis. Common values are \"1m\" , \"5m\" , \"15m\" , \"1h\" , however all values supported by your exchange should work. Please note that the same entry/exit signals may work well with one timeframe, but not with the others. This setting is accessible within the strategy methods as the self.timeframe attribute. Can short \u00b6 To use short signals in futures markets, you will have to let us know to do so by setting can_short=True . Strategies which enable this will fail to load on spot markets. Disabling of this will have short signals ignored (also in futures markets). Metadata dict \u00b6 The metadata-dict (available for populate_entry_trend , populate_exit_trend , populate_indicators ) contains additional information. Currently this is pair , which can be accessed using metadata['pair'] - and will return a pair in the format XRP/BTC . The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the Storing information section. Strategy file loading \u00b6 By default, freqtrade will attempt to load strategies from all .py files within user_data/strategies . Assuming your strategy is called AwesomeStrategy , stored in the file user_data/strategies/AwesomeStrategy.py , then you can start freqtrade with freqtrade trade --strategy AwesomeStrategy . Note that we're using the class-name, not the file name. You can use freqtrade list-strategies to see a list of all strategies Freqtrade is able to load (all strategies in the correct folder). It will also include a \"status\" field, highlighting potential problems. Customize strategy directory You can use a different directory by using --strategy-path user_data/otherPath . This parameter is available to all commands that require a strategy. Informative Pairs \u00b6 Get data for non-tradeable pairs \u00b6 Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. OHLCV data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via DataProvider just as other pairs (see below). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting. The pairs need to be specified as tuples in the format (\"pair\", \"timeframe\") , with pair as the first and timeframe as the second argument. Sample: def informative_pairs ( self ): return [( \"ETH/USDT\" , \"5m\" ), ( \"BTC/TUSD\" , \"15m\" ), ] A full sample can be found in the DataProvider section . Warning As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All timeframes and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer timeframes whenever possible to avoid hammering the exchange with too many requests and risk being blocked. Alternative candle types Informative_pairs can also provide a 3 rd tuple element defining the candle type explicitly. Availability of alternative candle-types will depend on the trading-mode and the exchange. Details about this can be found in the exchange documentation. def informative_pairs ( self ): return [ ( \"ETH/USDT\" , \"5m\" , \"\" ), # Uses default candletype, depends on trading_mode ( \"ETH/USDT\" , \"5m\" , \"spot\" ), # Forces usage of spot candles ( \"BTC/TUSD\" , \"15m\" , \"futures\" ), # Uses futures candles ( \"BTC/TUSD\" , \"15m\" , \"mark\" ), # Uses mark candles ] Informative pairs decorator ( @informative() ) \u00b6 In most common case it is possible to easily define informative pairs by using a decorator. All decorated populate_indicators_* methods run in isolation, not having access to data from other informative pairs, in the end all informative dataframes are merged and passed to main populate_indicators() method. When hyperopting, use of hyperoptable parameter .value attribute is not supported. Please use .range attribute. See optimizing an indicator parameter for more information. Full documentation def informative ( timeframe : str , asset : str = '' , fmt : Optional [ Union [ str , Callable [[ KwArg ( str )], str ]]] = None , * , candle_type : Optional [ CandleType ] = None , ffill : bool = True ) -> Callable [[ PopulateIndicators ], PopulateIndicators ]: \"\"\" A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to define informative indicators. Example usage: @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe. :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use current pair. :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not specified, defaults to: * {base}_{quote}_{column}_{timeframe} if asset is specified. * {column}_{timeframe} if asset is not specified. Format string supports these format variables: * {asset} - full name of the asset, for example 'BTC/USDT'. * {base} - base currency in lower case, for example 'eth'. * {BASE} - same as {base}, except in upper case. * {quote} - quote currency in lower case, for example 'usdt'. * {QUOTE} - same as {quote}, except in upper case. * {column} - name of dataframe column. * {timeframe} - timeframe of informative dataframe. :param ffill: ffill dataframe after merging informative pair. :param candle_type: '', mark, index, premiumIndex, or funding_rate \"\"\" Fast and easy way to define informative pairs Most of the time we do not need power and flexibility offered by merge_informative_pair() , therefore we can use a decorator to quickly define informative pairs. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , informative class AwesomeStrategy ( IStrategy ): # This method is not required. # def informative_pairs(self): ... # Define informative upper timeframe for each pair. Decorators can be stacked on same # method. Available in populate_indicators as 'rsi_30m' and 'rsi_1h'. @informative ( '30m' ) @informative ( '1h' ) def populate_indicators_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/STAKE informative pair. Available in populate_indicators and other methods as # 'btc_rsi_1h'. Current stake currency should be specified as {stake} format variable # instead of hard-coding actual stake currency. Available in populate_indicators and other # methods as 'btc_usdt_rsi_1h' (when stake currency is USDT). @informative ( '1h' , 'BTC/ {stake} ' ) def populate_indicators_btc_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/ETH informative pair. You must specify quote currency if it is different from # stake currency. Available in populate_indicators and other methods as 'eth_btc_rsi_1h'. @informative ( '1h' , 'ETH/BTC' ) def populate_indicators_eth_btc_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/STAKE informative pair. A custom formatter may be specified for formatting # column names. A callable `fmt(**kwargs) -> str` may be specified, to implement custom # formatting. Available in populate_indicators and other methods as 'rsi_upper'. @informative ( '1h' , 'BTC/ {stake} ' , ' {column} ' ) def populate_indicators_btc_1h_2 ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi_upper' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # Strategy timeframe indicators for current pair. dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) # Informative pairs are available in this method. dataframe [ 'rsi_less' ] = dataframe [ 'rsi' ] < dataframe [ 'rsi_1h' ] return dataframe Note Do not use @informative decorator if you need to use data of one informative pair when generating another informative pair. Instead, define informative pairs manually as described in the DataProvider section . Note Use string formatting when accessing informative dataframes of other pairs. This will allow easily changing stake currency in config without having to adjust strategy code. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : stake = self . config [ 'stake_currency' ] dataframe . loc [ ( ( dataframe [ f 'btc_ { stake } _rsi_1h' ] < 35 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'buy_signal_rsi' ) return dataframe Alternatively column renaming may be used to remove stake currency from column names: @informative('1h', 'BTC/{stake}', fmt='{base}_{column}_{timeframe}') . Duplicate method names Methods tagged with @informative() decorator must always have unique names! Re-using same name (for example when copy-pasting already defined informative method) will overwrite previously defined method and not produce any errors due to limitations of Python programming language. In such cases you will find that indicators created in earlier-defined methods are not available in the dataframe. Carefully review method names and make sure they are unique! Additional data (DataProvider) \u00b6 The strategy provides access to the DataProvider . This allows you to get additional data to use in your strategy. All methods return None in case of failure (do not raise an exception). Please always check the mode of operation to select the correct method to get data (samples see below). Hyperopt Dataprovider is available during hyperopt, however it can only be used in populate_indicators() within a strategy. It is not available in populate_buy() and populate_sell() methods, nor in populate_indicators() , if this method located in the hyperopt file. Possible options for DataProvider \u00b6 available_pairs - Property with tuples listing cached pairs with their timeframe (pair, timeframe). current_whitelist() - Returns a current list of whitelisted pairs. Useful for accessing dynamic whitelists (i.e. VolumePairlist) get_pair_dataframe(pair, timeframe) - This is a universal method, which returns either historical data (for backtesting) or cached live data (for the Dry-Run and Live-Run modes). get_analyzed_dataframe(pair, timeframe) - Returns the analyzed dataframe (after calling populate_indicators() , populate_buy() , populate_sell() ) and the time of the latest analysis. historic_ohlcv(pair, timeframe) - Returns historical data stored on disk. market(pair) - Returns market data for the pair: fees, limits, precisions, activity flag, etc. See ccxt documentation for more details on the Market data structure. ohlcv(pair, timeframe) - Currently cached candle (OHLCV) data for the pair, returns DataFrame or empty DataFrame. orderbook(pair, maximum) - Returns latest orderbook data for the pair, a dict with bids/asks with a total of maximum entries. ticker(pair) - Returns current ticker data for the pair. See ccxt documentation for more details on the Ticker data structure. runmode - Property containing the current runmode. Example Usages \u00b6 available_pairs \u00b6 for pair , timeframe in self . dp . available_pairs : print ( f \"available { pair } , { timeframe } \" ) current_whitelist() \u00b6 Imagine you've developed a strategy that trades the 5m timeframe using signals generated from a 1d timeframe on the top 10 volume pairs by volume. The strategy might look something like this: Scan through the top 10 pairs by volume using the VolumePairList every 5 minutes and use a 14 day RSI to buy and sell. Due to the limited available data, it's very difficult to resample 5m candles into daily candles for use in a 14 day RSI. Most exchanges limit us to just 500-1000 candles which effectively gives us around 1.74 daily candles. We need 14 days at least! Since we can't resample the data we will have to use an informative pair; and since the whitelist will be dynamic we don't know which pair(s) to use. This is where calling self.dp.current_whitelist() comes in handy. def informative_pairs ( self ): # get access to all pairs available in whitelist. pairs = self . dp . current_whitelist () # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [( pair , '1d' ) for pair in pairs ] return informative_pairs Plotting with current_whitelist Current whitelist is not supported for plot-dataframe , as this command is usually used by providing an explicit pairlist - and would therefore make the return values of this method misleading. get_pair_dataframe(pair, timeframe) \u00b6 # fetch live / historical candle (OHLCV) data for the first informative pair inf_pair , inf_timeframe = self . informative_pairs ()[ 0 ] informative = self . dp . get_pair_dataframe ( pair = inf_pair , timeframe = inf_timeframe ) Warning about backtesting Be careful when using dataprovider in backtesting. historic_ohlcv() (and get_pair_dataframe() for the backtesting runmode) provides the full time-range in one go, so please be aware of it and make sure to not \"look into the future\" to avoid surprises when running in dry/live mode. get_analyzed_dataframe(pair, timeframe) \u00b6 This method is used by freqtrade internally to determine the last signal. It can also be used in specific callbacks to get the signal that caused the action (see Advanced Strategy Documentation for more details on available callbacks). # fetch current dataframe if self . dp . runmode . value in ( 'live' , 'dry_run' ): dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = metadata [ 'pair' ], timeframe = self . timeframe ) No data available Returns an empty dataframe if the requested pair was not cached. This should not happen when using whitelisted pairs. orderbook(pair, maximum) \u00b6 if self . dp . runmode . value in ( 'live' , 'dry_run' ): ob = self . dp . orderbook ( metadata [ 'pair' ], 1 ) dataframe [ 'best_bid' ] = ob [ 'bids' ][ 0 ][ 0 ] dataframe [ 'best_ask' ] = ob [ 'asks' ][ 0 ][ 0 ] The orderbook structure is aligned with the order structure from ccxt , so the result will look as follows: { 'bids' : [ [ price , amount ], // [ float, float ] [ price , amount ], ... ], 'asks' : [ [ price , amount ], [ price , amount ], //... ], //... } Therefore, using ob['bids'][0][0] as demonstrated above will result in using the best bid price. ob['bids'][0][1] would look at the amount at this orderbook position. Warning about backtesting The order book is not part of the historic data which means backtesting and hyperopt will not work correctly if this method is used, as the method will return uptodate values. ticker(pair) \u00b6 if self . dp . runmode . value in ( 'live' , 'dry_run' ): ticker = self . dp . ticker ( metadata [ 'pair' ]) dataframe [ 'last_price' ] = ticker [ 'last' ] dataframe [ 'volume24h' ] = ticker [ 'quoteVolume' ] dataframe [ 'vwap' ] = ticker [ 'vwap' ] Warning Although the ticker data structure is a part of the ccxt Unified Interface, the values returned by this method can vary for different exchanges. For instance, many exchanges do not return vwap values, the FTX exchange does not always fills in the last field (so it can be None), etc. So you need to carefully verify the ticker data returned from the exchange and add appropriate error handling / defaults. Warning about backtesting This method will always return up-to-date values - so usage during backtesting / hyperopt without runmode checks will lead to wrong results. Send Notification \u00b6 The dataprovider .send_msg() function allows you to send custom notifications from your strategy. Identical notifications will only be sent once per candle, unless the 2 nd argument ( always_send ) is set to True. self . dp . send_msg ( f \" { metadata [ 'pair' ] } just got hot!\" ) # Force send this notification, avoid caching (Please read warning below!) self . dp . send_msg ( f \" { metadata [ 'pair' ] } just got hot!\" , always_send = True ) Notifications will only be sent in trading modes (Live/Dry-run) - so this method can be called without conditions for backtesting. Spamming You can spam yourself pretty good by setting always_send=True in this method. Use this with great care and only in conditions you know will not happen throughout a candle to avoid a message every 5 seconds. Complete Data-provider sample \u00b6 from freqtrade.strategy import IStrategy , merge_informative_pair from pandas import DataFrame class SampleStrategy ( IStrategy ): # strategy init stuff... timeframe = '5m' # more strategy init stuff.. def informative_pairs ( self ): # get access to all pairs available in whitelist. pairs = self . dp . current_whitelist () # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [( pair , '1d' ) for pair in pairs ] # Optionally Add additional \"static\" pairs informative_pairs += [( \"ETH/USDT\" , \"5m\" ), ( \"BTC/TUSD\" , \"15m\" ), ] return informative_pairs def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : if not self . dp : # Don't do anything if DataProvider is not available. return dataframe inf_tf = '1d' # Get the informative pair informative = self . dp . get_pair_dataframe ( pair = metadata [ 'pair' ], timeframe = inf_tf ) # Get the 14 day rsi informative [ 'rsi' ] = ta . RSI ( informative , timeperiod = 14 ) # Use the helper function merge_informative_pair to safely merge the pair # Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair # use ffill to have the 1d value available in every row throughout the day. # Without this, comparisons between columns of the original and the informative pair would only work once per day. # Full documentation of this method, see below dataframe = merge_informative_pair ( dataframe , informative , self . timeframe , inf_tf , ffill = True ) # Calculate rsi of the original dataframe (5m timeframe) dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) # Do other stuff # ... return dataframe def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'rsi_1d' ] < 30 ) & # Ensure daily RSI is < 30 ( dataframe [ 'volume' ] > 0 ) # Ensure this candle had volume (important for backtesting) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) Helper functions \u00b6 merge_informative_pair() \u00b6 This method helps you merge an informative pair to a regular dataframe without lookahead bias. It's there to help you merge the dataframe in a safe and consistent way. Options: Rename the columns for you to create unique columns Merge the dataframe without lookahead bias Forward-fill (optional) All columns of the informative dataframe will be available on the returning dataframe in a renamed fashion: Column renaming Assuming inf_tf = '1d' the resulting columns will be: 'date' , 'open' , 'high' , 'low' , 'close' , 'rsi' # from the original dataframe 'date_1d' , 'open_1d' , 'high_1d' , 'low_1d' , 'close_1d' , 'rsi_1d' # from the informative dataframe Column renaming - 1h Assuming inf_tf = '1h' the resulting columns will be: 'date' , 'open' , 'high' , 'low' , 'close' , 'rsi' # from the original dataframe 'date_1h' , 'open_1h' , 'high_1h' , 'low_1h' , 'close_1h' , 'rsi_1h' # from the informative dataframe Custom implementation A custom implementation for this is possible, and can be done as follows: # Shift date by 1 candle # This is necessary since the data is always the \"open date\" # and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00 minutes = timeframe_to_minutes ( inf_tf ) # Only do this if the timeframes are different: informative [ 'date_merge' ] = informative [ \"date\" ] + pd . to_timedelta ( minutes , 'm' ) # Rename columns to be unique informative . columns = [ f \" { col } _ { inf_tf } \" for col in informative . columns ] # Assuming inf_tf = '1d' - then the columns will now be: # date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d # Combine the 2 dataframes # all indicators on the informative sample MUST be calculated before this point dataframe = pd . merge ( dataframe , informative , left_on = 'date' , right_on = f 'date_merge_ { inf_tf } ' , how = 'left' ) # FFill to have the 1d value available in every row throughout the day. # Without this, comparisons would only work once per day. dataframe = dataframe . ffill () Informative timeframe < timeframe Using informative timeframes smaller than the dataframe timeframe is not recommended with this method, as it will not use any of the additional information this would provide. To use the more detailed information properly, more advanced methods should be applied (which are out of scope for freqtrade documentation, as it'll depend on the respective need). stoploss_from_open() \u00b6 Stoploss values returned from custom_stoploss must specify a percentage relative to current_rate , but sometimes you may want to specify a stoploss relative to the open price instead. stoploss_from_open() is a helper function to calculate a stoploss value that can be returned from custom_stoploss which will be equivalent to the desired percentage above the open price. Returning a stoploss relative to the open price from the custom stoploss function Say the open price was $100, and current_price is $121 ( current_profit will be 0.21 ). If we want a stop price at 7% above the open price we can call stoploss_from_open(0.07, current_profit, False) which will return 0.1157024793 . 11.57% below $121 is $107, which is the same as 7% above $100. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , stoploss_from_open class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) return 1 Full examples can be found in the Custom stoploss section of the Documentation. Note Providing invalid input to stoploss_from_open() may produce \"CustomStoploss function did not return valid stoploss\" warnings. This may happen if current_profit parameter is below specified open_relative_stop . Such situations may arise when closing trade is blocked by confirm_trade_exit() method. Warnings can be solved by never blocking stop loss sells by checking exit_reason in confirm_trade_exit() , or by using return stoploss_from_open(...) or 1 idiom, which will request to not change stop loss when current_profit < open_relative_stop . stoploss_from_absolute() \u00b6 In some situations it may be confusing to deal with stops relative to current rate. Instead, you may define a stoploss level using an absolute price. Returning a stoploss using absolute price from the custom stoploss function If we want to trail a stop price at 2xATR below current price we can call stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate, is_short=trade.is_short) . from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , stoploss_from_absolute class AwesomeStrategy ( IStrategy ): use_custom_stoploss = True def populate_indicators_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'atr' ] = ta . ATR ( dataframe , timeperiod = 14 ) return dataframe def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) candle = dataframe . iloc [ - 1 ] . squeeze () return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate , is_short = trade . is_short ) Additional data (Wallets) \u00b6 The strategy provides access to the Wallets object. This contains the current balances on the exchange. Note Wallets is not available during backtesting / hyperopt. Please always check if Wallets is available to avoid failures during backtesting. if self . wallets : free_eth = self . wallets . get_free ( 'ETH' ) used_eth = self . wallets . get_used ( 'ETH' ) total_eth = self . wallets . get_total ( 'ETH' ) Possible options for Wallets \u00b6 get_free(asset) - currently available balance to trade get_used(asset) - currently tied up balance (open orders) get_total(asset) - total available balance - sum of the 2 above Additional data (Trades) \u00b6 A history of Trades can be retrieved in the strategy by querying the database. At the top of the file, import Trade. from freqtrade.persistence import Trade The following example queries for the current pair and trades from today, however other filters can easily be added. if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): trades = Trade . get_trades ([ Trade . pair == metadata [ 'pair' ], Trade . open_date > datetime . utcnow () - timedelta ( days = 1 ), Trade . is_open . is_ ( False ), ]) . order_by ( Trade . close_date ) . all () # Summarize profit for this pair. curdayprofit = sum ( trade . close_profit for trade in trades ) Get amount of stake_currency currently invested in Trades: if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): total_stakes = Trade . total_open_trades_stakes () Retrieve performance per pair. Returns a List of dicts per pair. if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): performance = Trade . get_overall_performance () Sample return value: ETH/BTC had 5 trades, with a total profit of 1.5% (ratio of 0.015). { \"pair\" : \"ETH/BTC\" , \"profit\" : 0.015 , \"count\" : 5 } Warning Trade history is not available during backtesting or hyperopt. Prevent trades from happening for a specific pair \u00b6 Freqtrade locks pairs automatically for the current candle (until that candle is over) when a pair is sold, preventing an immediate re-buy of that pair. Locked pairs will show the message Pair <pair> is currently locked. . Locking pairs from within the strategy \u00b6 Sometimes it may be desired to lock a pair after certain events happen (e.g. multiple losing trades in a row). Freqtrade has an easy method to do this from within the strategy, by calling self.lock_pair(pair, until, [reason]) . until must be a datetime object in the future, after which trading will be re-enabled for that pair, while reason is an optional string detailing why the pair was locked. Locks can also be lifted manually, by calling self.unlock_pair(pair) or self.unlock_reason(<reason>) - providing reason the pair was locked with. self.unlock_reason(<reason>) will unlock all pairs currently locked with the provided reason. To verify if a pair is currently locked, use self.is_pair_locked(pair) . Note Locked pairs will always be rounded up to the next candle. So assuming a 5m timeframe, a lock with until set to 10:18 will lock the pair until the candle from 10:15-10:20 will be finished. Warning Manually locking pairs is not available during backtesting, only locks via Protections are allowed. Pair locking example \u00b6 from freqtrade.persistence import Trade from datetime import timedelta , datetime , timezone # Put the above lines a the top of the strategy file, next to all the other imports # -------- # Within populate indicators (or populate_buy): if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # fetch closed trades for the last 2 days trades = Trade . get_trades ([ Trade . pair == metadata [ 'pair' ], Trade . open_date > datetime . utcnow () - timedelta ( days = 2 ), Trade . is_open . is_ ( False ), ]) . all () # Analyze the conditions you'd like to lock the pair .... will probably be different for every strategy sumprofit = sum ( trade . close_profit for trade in trades ) if sumprofit < 0 : # Lock pair for 12 hours self . lock_pair ( metadata [ 'pair' ], until = datetime . now ( timezone . utc ) + timedelta ( hours = 12 )) Print created dataframe \u00b6 To inspect the created dataframe, you can issue a print-statement in either populate_entry_trend() or populate_exit_trend() . You may also want to print the pair so it's clear what data is currently shown. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( #>> whatever condition<<< ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'somestring' ) # Print the Analyzed pair print ( f \"result for { metadata [ 'pair' ] } \" ) # Inspect the last 5 rows print ( dataframe . tail ()) return dataframe Printing more than a few rows is also possible (simply use print(dataframe) instead of print(dataframe.tail()) ), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds). Common mistakes when developing strategies \u00b6 Peeking into the future while backtesting \u00b6 Backtesting analyzes the whole time-range at once for performance reasons. Because of this, strategy authors need to make sure that strategies do not look-ahead into the future. This is a common pain-point, which can cause huge differences between backtesting and dry/live run methods, since they all use data which is not available during dry/live runs, so these strategies will perform well during backtesting, but will fail / perform badly in real conditions. The following lists some common patterns which should be avoided to prevent frustration: don't use shift(-1) . This uses data from the future, which is not available. don't use .iloc[-1] or any other absolute position in the dataframe, this will be different between dry-run and backtesting. don't use dataframe['volume'].mean() . This uses the full DataFrame for backtesting, including data from the future. Use dataframe['volume'].rolling(<window>).mean() instead don't use .resample('1h') . This uses the left border of the interval, so moves data from an hour to the start of the hour. Use .resample('1h', label='right') instead. Colliding signals \u00b6 When conflicting signals collide (e.g. both 'enter_long' and 'exit_long' are 1), freqtrade will do nothing and ignore the entry signal. This will avoid trades that enter, and exit immediately. Obviously, this can potentially lead to missed entries. The following rules apply, and entry signals will be ignored if more than one of the 3 signals is set: enter_long -> exit_long , enter_short enter_short -> exit_short , enter_long Further strategy ideas \u00b6 To get additional Ideas for strategies, head over to the strategy repository . Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo. Next step \u00b6 Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting .","title":"Strategy Customization"},{"location":"strategy-customization/#strategy-customization","text":"This page explains how to customize your strategies, add new indicators and set up trading rules. Please familiarize yourself with Freqtrade basics first, which provides overall info on how the bot operates.","title":"Strategy Customization"},{"location":"strategy-customization/#develop-your-own-strategy","text":"The bot includes a default strategy file. Also, several other strategies are available in the strategy repository . You will however most likely have your own idea for a strategy. This document intends to help you convert your strategy idea into your own strategy. To get started, use freqtrade new-strategy --strategy AwesomeStrategy (you can obviously use your own naming for your strategy). This will create a new strategy file from a template, which will be located under user_data/strategies/AwesomeStrategy.py . Note This is just a template file, which will most likely not be profitable out of the box. Different template levels freqtrade new-strategy has an additional parameter, --template , which controls the amount of pre-build information you get in the created strategy. Use --template minimal to get an empty strategy without any indicator examples, or --template advanced to get a template with most callbacks defined.","title":"Develop your own strategy"},{"location":"strategy-customization/#anatomy-of-a-strategy","text":"A strategy file contains all the information needed to build a good strategy: Indicators Entry strategy rules Exit strategy rules Minimal ROI recommended Stoploss strongly recommended The bot also include a sample strategy called SampleStrategy you can update: user_data/strategies/sample_strategy.py . You can test it with the parameter: --strategy SampleStrategy Additionally, there is an attribute called INTERFACE_VERSION , which defines the version of the strategy interface the bot should use. The current version is 3 - which is also the default when it's not set explicitly in the strategy. Future versions will require this to be set. freqtrade trade --strategy AwesomeStrategy For the following section we will use the user_data/strategies/sample_strategy.py file as reference. Strategies and Backtesting To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time range is passed to the populate_*() methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing ( df.iloc[-1] ), but instead use df.shift() to get to the previous candle. Warning: Using future data Since backtesting passes the full time range to the populate_*() methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Some common patterns for this are listed in the Common Mistakes section of this document.","title":"Anatomy of a strategy"},{"location":"strategy-customization/#dataframe","text":"Freqtrade uses pandas to store/provide the candlestick (OHLCV) data. Pandas is a great library developed for processing large amounts of data. Each row in a dataframe corresponds to one candle on a chart, with the latest candle always being the last in the dataframe (sorted by date). > dataframe.head() date open high low close volume 0 2021-11-09 23:25:00+00:00 67279.67 67321.84 67255.01 67300.97 44.62253 1 2021-11-09 23:30:00+00:00 67300.97 67301.34 67183.03 67187.01 61.38076 2 2021-11-09 23:35:00+00:00 67187.02 67187.02 67031.93 67123.81 113.42728 3 2021-11-09 23:40:00+00:00 67123.80 67222.40 67080.33 67160.48 78.96008 4 2021-11-09 23:45:00+00:00 67160.48 67160.48 66901.26 66943.37 111.39292 Pandas provides fast ways to calculate metrics. To benefit from this speed, it's advised to not use loops, but use vectorized methods instead. Vectorized operations perform calculations across the whole range of data and are therefore, compared to looping through each row, a lot faster when calculating indicators. As a dataframe is a table, simple python comparisons like the following will not work if dataframe [ 'rsi' ] > 30 : dataframe [ 'enter_long' ] = 1 The above section will fail with The truth value of a Series is ambiguous. [...] . This must instead be written in a pandas-compatible way, so the operation is performed across the whole dataframe. dataframe . loc [ ( dataframe [ 'rsi' ] > 30 ) , 'enter_long' ] = 1 With this section, you have a new column in your dataframe, which has 1 assigned whenever RSI is above 30.","title":"Dataframe"},{"location":"strategy-customization/#customize-indicators","text":"Buy and sell signals need indicators. You can add more indicators by extending the list contained in the method populate_indicators() from your strategy file. You should only add the indicators used in either populate_entry_trend() , populate_exit_trend() , or to populate another indicator, otherwise performance may suffer. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. Sample: def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Adds several different TA indicators to the given DataFrame Performance Note: For the best performance be frugal on the number of indicators you are using. Let uncomment only the indicator you are using in your strategies or your hyperopt configuration, otherwise you will waste your memory and CPU usage. :param dataframe: Dataframe with data from the exchange :param metadata: Additional information, like the currently traded pair :return: a Dataframe with all mandatory indicators for the strategies \"\"\" dataframe [ 'sar' ] = ta . SAR ( dataframe ) dataframe [ 'adx' ] = ta . ADX ( dataframe ) stoch = ta . STOCHF ( dataframe ) dataframe [ 'fastd' ] = stoch [ 'fastd' ] dataframe [ 'fastk' ] = stoch [ 'fastk' ] dataframe [ 'blower' ] = ta . BBANDS ( dataframe , nbdevup = 2 , nbdevdn = 2 )[ 'lowerband' ] dataframe [ 'sma' ] = ta . SMA ( dataframe , timeperiod = 40 ) dataframe [ 'tema' ] = ta . TEMA ( dataframe , timeperiod = 9 ) dataframe [ 'mfi' ] = ta . MFI ( dataframe ) dataframe [ 'rsi' ] = ta . RSI ( dataframe ) dataframe [ 'ema5' ] = ta . EMA ( dataframe , timeperiod = 5 ) dataframe [ 'ema10' ] = ta . EMA ( dataframe , timeperiod = 10 ) dataframe [ 'ema50' ] = ta . EMA ( dataframe , timeperiod = 50 ) dataframe [ 'ema100' ] = ta . EMA ( dataframe , timeperiod = 100 ) dataframe [ 'ao' ] = awesome_oscillator ( dataframe ) macd = ta . MACD ( dataframe ) dataframe [ 'macd' ] = macd [ 'macd' ] dataframe [ 'macdsignal' ] = macd [ 'macdsignal' ] dataframe [ 'macdhist' ] = macd [ 'macdhist' ] hilbert = ta . HT_SINE ( dataframe ) dataframe [ 'htsine' ] = hilbert [ 'sine' ] dataframe [ 'htleadsine' ] = hilbert [ 'leadsine' ] dataframe [ 'plus_dm' ] = ta . PLUS_DM ( dataframe ) dataframe [ 'plus_di' ] = ta . PLUS_DI ( dataframe ) dataframe [ 'minus_dm' ] = ta . MINUS_DM ( dataframe ) dataframe [ 'minus_di' ] = ta . MINUS_DI ( dataframe ) return dataframe Want more indicator examples? Look into the user_data/strategies/sample_strategy.py . Then uncomment indicators you need.","title":"Customize Indicators"},{"location":"strategy-customization/#indicator-libraries","text":"Out of the box, freqtrade installs the following technical libraries: ta-lib pandas-ta technical Additional technical libraries can be installed as necessary, or custom indicators may be written / invented by the strategy author.","title":"Indicator libraries"},{"location":"strategy-customization/#strategy-startup-period","text":"Most indicators have an instable startup period, in which they are either not available (NaN), or the calculation is incorrect. This can lead to inconsistencies, since Freqtrade does not know how long this instable period should be. To account for this, the strategy can be assigned the startup_candle_count attribute. This should be set to the maximum number of candles that the strategy requires to calculate stable indicators. In this example strategy, this should be set to 100 ( startup_candle_count = 100 ), since the longest needed history is 100 candles. dataframe [ 'ema100' ] = ta . EMA ( dataframe , timeperiod = 100 ) By letting the bot know how much history is needed, backtest trades can start at the specified timerange during backtesting and hyperopt. Using x calls to get OHLCV If you receive a warning like WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy - you should consider if you really need this much historic data for your signals. Having this will cause Freqtrade to make multiple calls for the same pair, which will obviously be slower than one network request. As a consequence, Freqtrade will take longer to refresh candles - and should therefore be avoided if possible. This is capped to 5 total calls to avoid overloading the exchange, or make freqtrade too slow. Warning startup_candle_count should be below ohlcv_candle_limit * 5 (which is 500 * 5 for most exchanges) - since only this amount of candles will be available during Dry-Run/Live Trade operations.","title":"Strategy startup period"},{"location":"strategy-customization/#example","text":"Let's try to backtest 1 month (January 2019) of 5m candles using an example strategy with EMA100, as above. freqtrade backtesting --timerange 20190101 -20190201 --timeframe 5m Assuming startup_candle_count is set to 100, backtesting knows it needs 100 candles to generate valid buy signals. It will load data from 20190101 - (100 * 5m) - which is ~2018-12-31 15:30:00. If this data is available, indicators will be calculated with this extended timerange. The instable startup period (up to 2019-01-01 00:00:00) will then be removed before starting backtesting. Note If data for the startup period is not available, then the timerange will be adjusted to account for this startup period - so Backtesting would start at 2019-01-01 08:30:00.","title":"Example"},{"location":"strategy-customization/#entry-signal-rules","text":"Edit the method populate_entry_trend() in your strategy file to update your entry strategy. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"enter_long\" ( \"enter_short\" for shorts), which needs to contain 1 for entries, and 0 for \"no action\". enter_long is a mandatory column that must be set even if the strategy is shorting only. Sample from user_data/strategies/sample_strategy.py : def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Based on TA indicators, populates the buy signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Enter short trades Short-entries can be created by setting enter_short (corresponds to enter_long for long trades). The enter_tag column remains identical. Short-trades need to be supported by your exchange and market configuration! Please make sure to set can_short appropriately on your strategy if you intend to short. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) dataframe . loc [ ( ( qtpylib . crossed_below ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses below 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_short' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Note Buying requires sellers to buy from - therefore volume needs to be > 0 ( dataframe['volume'] > 0 ) to make sure that the bot does not buy/sell in no-activity periods.","title":"Entry signal rules"},{"location":"strategy-customization/#exit-signal-rules","text":"Edit the method populate_exit_trend() into your strategy file to update your exit strategy. Please note that the exit-signal is only used if use_exit_signal is set to true in the configuration. It's important to always return the dataframe without removing/modifying the columns \"open\", \"high\", \"low\", \"close\", \"volume\" , otherwise these fields would contain something unexpected. This method will also define a new column, \"exit_long\" ( \"exit_short\" for shorts), which needs to contain 1 for exits, and 0 for \"no action\". Sample from user_data/strategies/sample_strategy.py : def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : \"\"\" Based on TA indicators, populates the exit signal for the given dataframe :param dataframe: DataFrame populated with indicators :param metadata: Additional information, like the currently traded pair :return: DataFrame with buy column \"\"\" dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'rsi_too_high' ) return dataframe Exit short trades Short-exits can be created by setting exit_short (corresponds to exit_long ). The exit_tag column remains identical. Short-trades need to be supported by your exchange and market configuration! def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'rsi_too_high' ) dataframe . loc [ ( ( qtpylib . crossed_below ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses below 30 ( dataframe [ 'tema' ] < dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_short' , 'exit_tag' ]] = ( 1 , 'rsi_too_low' ) return dataframe","title":"Exit signal rules"},{"location":"strategy-customization/#minimal-roi","text":"This dict defines the minimal Return On Investment (ROI) a trade should reach before exiting, independent from the exit signal. It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage. minimal_roi = { \"40\" : 0.0 , \"30\" : 0.01 , \"20\" : 0.02 , \"0\" : 0.04 } The above configuration would therefore mean: Exit whenever 4% profit was reached Exit when 2% profit was reached (in effect after 20 minutes) Exit when 1% profit was reached (in effect after 30 minutes) Exit when trade is non-loosing (in effect after 40 minutes) The calculation does include fees. To disable ROI completely, set it to an insanely high number: minimal_roi = { \"0\" : 100 } While technically not completely disabled, this would exit once the trade reaches 10000% Profit. To use times based on candle duration (timeframe), the following snippet can be handy. This will allow you to change the timeframe for the strategy, and ROI times will still be set as candles (e.g. after 3 candles ...) from freqtrade.exchange import timeframe_to_minutes class AwesomeStrategy ( IStrategy ): timeframe = \"1d\" timeframe_mins = timeframe_to_minutes ( timeframe ) minimal_roi = { \"0\" : 0.05 , # 5% for the first 3 candles str ( timeframe_mins * 3 )): 0.02 , # 2% after 3 candles str ( timeframe_mins * 6 )): 0.01 , # 1% After 6 candles }","title":"Minimal ROI"},{"location":"strategy-customization/#stoploss","text":"Setting a stoploss is highly recommended to protect your capital from strong moves against you. Sample of setting a 10% stoploss: stoploss = - 0.10 For the full documentation on stoploss features, look at the dedicated stoploss page .","title":"Stoploss"},{"location":"strategy-customization/#timeframe","text":"This is the set of candles the bot should download and use for the analysis. Common values are \"1m\" , \"5m\" , \"15m\" , \"1h\" , however all values supported by your exchange should work. Please note that the same entry/exit signals may work well with one timeframe, but not with the others. This setting is accessible within the strategy methods as the self.timeframe attribute.","title":"Timeframe"},{"location":"strategy-customization/#can-short","text":"To use short signals in futures markets, you will have to let us know to do so by setting can_short=True . Strategies which enable this will fail to load on spot markets. Disabling of this will have short signals ignored (also in futures markets).","title":"Can short"},{"location":"strategy-customization/#metadata-dict","text":"The metadata-dict (available for populate_entry_trend , populate_exit_trend , populate_indicators ) contains additional information. Currently this is pair , which can be accessed using metadata['pair'] - and will return a pair in the format XRP/BTC . The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the Storing information section.","title":"Metadata dict"},{"location":"strategy-customization/#strategy-file-loading","text":"By default, freqtrade will attempt to load strategies from all .py files within user_data/strategies . Assuming your strategy is called AwesomeStrategy , stored in the file user_data/strategies/AwesomeStrategy.py , then you can start freqtrade with freqtrade trade --strategy AwesomeStrategy . Note that we're using the class-name, not the file name. You can use freqtrade list-strategies to see a list of all strategies Freqtrade is able to load (all strategies in the correct folder). It will also include a \"status\" field, highlighting potential problems. Customize strategy directory You can use a different directory by using --strategy-path user_data/otherPath . This parameter is available to all commands that require a strategy.","title":"Strategy file loading"},{"location":"strategy-customization/#informative-pairs","text":"","title":"Informative Pairs"},{"location":"strategy-customization/#get-data-for-non-tradeable-pairs","text":"Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. OHLCV data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via DataProvider just as other pairs (see below). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting. The pairs need to be specified as tuples in the format (\"pair\", \"timeframe\") , with pair as the first and timeframe as the second argument. Sample: def informative_pairs ( self ): return [( \"ETH/USDT\" , \"5m\" ), ( \"BTC/TUSD\" , \"15m\" ), ] A full sample can be found in the DataProvider section . Warning As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All timeframes and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer timeframes whenever possible to avoid hammering the exchange with too many requests and risk being blocked. Alternative candle types Informative_pairs can also provide a 3 rd tuple element defining the candle type explicitly. Availability of alternative candle-types will depend on the trading-mode and the exchange. Details about this can be found in the exchange documentation. def informative_pairs ( self ): return [ ( \"ETH/USDT\" , \"5m\" , \"\" ), # Uses default candletype, depends on trading_mode ( \"ETH/USDT\" , \"5m\" , \"spot\" ), # Forces usage of spot candles ( \"BTC/TUSD\" , \"15m\" , \"futures\" ), # Uses futures candles ( \"BTC/TUSD\" , \"15m\" , \"mark\" ), # Uses mark candles ]","title":"Get data for non-tradeable pairs"},{"location":"strategy-customization/#informative-pairs-decorator-informative","text":"In most common case it is possible to easily define informative pairs by using a decorator. All decorated populate_indicators_* methods run in isolation, not having access to data from other informative pairs, in the end all informative dataframes are merged and passed to main populate_indicators() method. When hyperopting, use of hyperoptable parameter .value attribute is not supported. Please use .range attribute. See optimizing an indicator parameter for more information. Full documentation def informative ( timeframe : str , asset : str = '' , fmt : Optional [ Union [ str , Callable [[ KwArg ( str )], str ]]] = None , * , candle_type : Optional [ CandleType ] = None , ffill : bool = True ) -> Callable [[ PopulateIndicators ], PopulateIndicators ]: \"\"\" A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to define informative indicators. Example usage: @informative('1h') def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -> DataFrame: dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14) return dataframe :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe. :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use current pair. :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not specified, defaults to: * {base}_{quote}_{column}_{timeframe} if asset is specified. * {column}_{timeframe} if asset is not specified. Format string supports these format variables: * {asset} - full name of the asset, for example 'BTC/USDT'. * {base} - base currency in lower case, for example 'eth'. * {BASE} - same as {base}, except in upper case. * {quote} - quote currency in lower case, for example 'usdt'. * {QUOTE} - same as {quote}, except in upper case. * {column} - name of dataframe column. * {timeframe} - timeframe of informative dataframe. :param ffill: ffill dataframe after merging informative pair. :param candle_type: '', mark, index, premiumIndex, or funding_rate \"\"\" Fast and easy way to define informative pairs Most of the time we do not need power and flexibility offered by merge_informative_pair() , therefore we can use a decorator to quickly define informative pairs. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , informative class AwesomeStrategy ( IStrategy ): # This method is not required. # def informative_pairs(self): ... # Define informative upper timeframe for each pair. Decorators can be stacked on same # method. Available in populate_indicators as 'rsi_30m' and 'rsi_1h'. @informative ( '30m' ) @informative ( '1h' ) def populate_indicators_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/STAKE informative pair. Available in populate_indicators and other methods as # 'btc_rsi_1h'. Current stake currency should be specified as {stake} format variable # instead of hard-coding actual stake currency. Available in populate_indicators and other # methods as 'btc_usdt_rsi_1h' (when stake currency is USDT). @informative ( '1h' , 'BTC/ {stake} ' ) def populate_indicators_btc_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/ETH informative pair. You must specify quote currency if it is different from # stake currency. Available in populate_indicators and other methods as 'eth_btc_rsi_1h'. @informative ( '1h' , 'ETH/BTC' ) def populate_indicators_eth_btc_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe # Define BTC/STAKE informative pair. A custom formatter may be specified for formatting # column names. A callable `fmt(**kwargs) -> str` may be specified, to implement custom # formatting. Available in populate_indicators and other methods as 'rsi_upper'. @informative ( '1h' , 'BTC/ {stake} ' , ' {column} ' ) def populate_indicators_btc_1h_2 ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'rsi_upper' ] = ta . RSI ( dataframe , timeperiod = 14 ) return dataframe def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : # Strategy timeframe indicators for current pair. dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) # Informative pairs are available in this method. dataframe [ 'rsi_less' ] = dataframe [ 'rsi' ] < dataframe [ 'rsi_1h' ] return dataframe Note Do not use @informative decorator if you need to use data of one informative pair when generating another informative pair. Instead, define informative pairs manually as described in the DataProvider section . Note Use string formatting when accessing informative dataframes of other pairs. This will allow easily changing stake currency in config without having to adjust strategy code. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : stake = self . config [ 'stake_currency' ] dataframe . loc [ ( ( dataframe [ f 'btc_ { stake } _rsi_1h' ] < 35 ) & ( dataframe [ 'volume' ] > 0 ) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'buy_signal_rsi' ) return dataframe Alternatively column renaming may be used to remove stake currency from column names: @informative('1h', 'BTC/{stake}', fmt='{base}_{column}_{timeframe}') . Duplicate method names Methods tagged with @informative() decorator must always have unique names! Re-using same name (for example when copy-pasting already defined informative method) will overwrite previously defined method and not produce any errors due to limitations of Python programming language. In such cases you will find that indicators created in earlier-defined methods are not available in the dataframe. Carefully review method names and make sure they are unique!","title":"Informative pairs decorator (@informative())"},{"location":"strategy-customization/#additional-data-dataprovider","text":"The strategy provides access to the DataProvider . This allows you to get additional data to use in your strategy. All methods return None in case of failure (do not raise an exception). Please always check the mode of operation to select the correct method to get data (samples see below). Hyperopt Dataprovider is available during hyperopt, however it can only be used in populate_indicators() within a strategy. It is not available in populate_buy() and populate_sell() methods, nor in populate_indicators() , if this method located in the hyperopt file.","title":"Additional data (DataProvider)"},{"location":"strategy-customization/#possible-options-for-dataprovider","text":"available_pairs - Property with tuples listing cached pairs with their timeframe (pair, timeframe). current_whitelist() - Returns a current list of whitelisted pairs. Useful for accessing dynamic whitelists (i.e. VolumePairlist) get_pair_dataframe(pair, timeframe) - This is a universal method, which returns either historical data (for backtesting) or cached live data (for the Dry-Run and Live-Run modes). get_analyzed_dataframe(pair, timeframe) - Returns the analyzed dataframe (after calling populate_indicators() , populate_buy() , populate_sell() ) and the time of the latest analysis. historic_ohlcv(pair, timeframe) - Returns historical data stored on disk. market(pair) - Returns market data for the pair: fees, limits, precisions, activity flag, etc. See ccxt documentation for more details on the Market data structure. ohlcv(pair, timeframe) - Currently cached candle (OHLCV) data for the pair, returns DataFrame or empty DataFrame. orderbook(pair, maximum) - Returns latest orderbook data for the pair, a dict with bids/asks with a total of maximum entries. ticker(pair) - Returns current ticker data for the pair. See ccxt documentation for more details on the Ticker data structure. runmode - Property containing the current runmode.","title":"Possible options for DataProvider"},{"location":"strategy-customization/#example-usages","text":"","title":"Example Usages"},{"location":"strategy-customization/#available_pairs","text":"for pair , timeframe in self . dp . available_pairs : print ( f \"available { pair } , { timeframe } \" )","title":"available_pairs"},{"location":"strategy-customization/#current_whitelist","text":"Imagine you've developed a strategy that trades the 5m timeframe using signals generated from a 1d timeframe on the top 10 volume pairs by volume. The strategy might look something like this: Scan through the top 10 pairs by volume using the VolumePairList every 5 minutes and use a 14 day RSI to buy and sell. Due to the limited available data, it's very difficult to resample 5m candles into daily candles for use in a 14 day RSI. Most exchanges limit us to just 500-1000 candles which effectively gives us around 1.74 daily candles. We need 14 days at least! Since we can't resample the data we will have to use an informative pair; and since the whitelist will be dynamic we don't know which pair(s) to use. This is where calling self.dp.current_whitelist() comes in handy. def informative_pairs ( self ): # get access to all pairs available in whitelist. pairs = self . dp . current_whitelist () # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [( pair , '1d' ) for pair in pairs ] return informative_pairs Plotting with current_whitelist Current whitelist is not supported for plot-dataframe , as this command is usually used by providing an explicit pairlist - and would therefore make the return values of this method misleading.","title":"current_whitelist()"},{"location":"strategy-customization/#get_pair_dataframepair-timeframe","text":"# fetch live / historical candle (OHLCV) data for the first informative pair inf_pair , inf_timeframe = self . informative_pairs ()[ 0 ] informative = self . dp . get_pair_dataframe ( pair = inf_pair , timeframe = inf_timeframe ) Warning about backtesting Be careful when using dataprovider in backtesting. historic_ohlcv() (and get_pair_dataframe() for the backtesting runmode) provides the full time-range in one go, so please be aware of it and make sure to not \"look into the future\" to avoid surprises when running in dry/live mode.","title":"get_pair_dataframe(pair, timeframe)"},{"location":"strategy-customization/#get_analyzed_dataframepair-timeframe","text":"This method is used by freqtrade internally to determine the last signal. It can also be used in specific callbacks to get the signal that caused the action (see Advanced Strategy Documentation for more details on available callbacks). # fetch current dataframe if self . dp . runmode . value in ( 'live' , 'dry_run' ): dataframe , last_updated = self . dp . get_analyzed_dataframe ( pair = metadata [ 'pair' ], timeframe = self . timeframe ) No data available Returns an empty dataframe if the requested pair was not cached. This should not happen when using whitelisted pairs.","title":"get_analyzed_dataframe(pair, timeframe)"},{"location":"strategy-customization/#orderbookpair-maximum","text":"if self . dp . runmode . value in ( 'live' , 'dry_run' ): ob = self . dp . orderbook ( metadata [ 'pair' ], 1 ) dataframe [ 'best_bid' ] = ob [ 'bids' ][ 0 ][ 0 ] dataframe [ 'best_ask' ] = ob [ 'asks' ][ 0 ][ 0 ] The orderbook structure is aligned with the order structure from ccxt , so the result will look as follows: { 'bids' : [ [ price , amount ], // [ float, float ] [ price , amount ], ... ], 'asks' : [ [ price , amount ], [ price , amount ], //... ], //... } Therefore, using ob['bids'][0][0] as demonstrated above will result in using the best bid price. ob['bids'][0][1] would look at the amount at this orderbook position. Warning about backtesting The order book is not part of the historic data which means backtesting and hyperopt will not work correctly if this method is used, as the method will return uptodate values.","title":"orderbook(pair, maximum)"},{"location":"strategy-customization/#tickerpair","text":"if self . dp . runmode . value in ( 'live' , 'dry_run' ): ticker = self . dp . ticker ( metadata [ 'pair' ]) dataframe [ 'last_price' ] = ticker [ 'last' ] dataframe [ 'volume24h' ] = ticker [ 'quoteVolume' ] dataframe [ 'vwap' ] = ticker [ 'vwap' ] Warning Although the ticker data structure is a part of the ccxt Unified Interface, the values returned by this method can vary for different exchanges. For instance, many exchanges do not return vwap values, the FTX exchange does not always fills in the last field (so it can be None), etc. So you need to carefully verify the ticker data returned from the exchange and add appropriate error handling / defaults. Warning about backtesting This method will always return up-to-date values - so usage during backtesting / hyperopt without runmode checks will lead to wrong results.","title":"ticker(pair)"},{"location":"strategy-customization/#send-notification","text":"The dataprovider .send_msg() function allows you to send custom notifications from your strategy. Identical notifications will only be sent once per candle, unless the 2 nd argument ( always_send ) is set to True. self . dp . send_msg ( f \" { metadata [ 'pair' ] } just got hot!\" ) # Force send this notification, avoid caching (Please read warning below!) self . dp . send_msg ( f \" { metadata [ 'pair' ] } just got hot!\" , always_send = True ) Notifications will only be sent in trading modes (Live/Dry-run) - so this method can be called without conditions for backtesting. Spamming You can spam yourself pretty good by setting always_send=True in this method. Use this with great care and only in conditions you know will not happen throughout a candle to avoid a message every 5 seconds.","title":"Send Notification"},{"location":"strategy-customization/#complete-data-provider-sample","text":"from freqtrade.strategy import IStrategy , merge_informative_pair from pandas import DataFrame class SampleStrategy ( IStrategy ): # strategy init stuff... timeframe = '5m' # more strategy init stuff.. def informative_pairs ( self ): # get access to all pairs available in whitelist. pairs = self . dp . current_whitelist () # Assign tf to each pair so they can be downloaded and cached for strategy. informative_pairs = [( pair , '1d' ) for pair in pairs ] # Optionally Add additional \"static\" pairs informative_pairs += [( \"ETH/USDT\" , \"5m\" ), ( \"BTC/TUSD\" , \"15m\" ), ] return informative_pairs def populate_indicators ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : if not self . dp : # Don't do anything if DataProvider is not available. return dataframe inf_tf = '1d' # Get the informative pair informative = self . dp . get_pair_dataframe ( pair = metadata [ 'pair' ], timeframe = inf_tf ) # Get the 14 day rsi informative [ 'rsi' ] = ta . RSI ( informative , timeperiod = 14 ) # Use the helper function merge_informative_pair to safely merge the pair # Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair # use ffill to have the 1d value available in every row throughout the day. # Without this, comparisons between columns of the original and the informative pair would only work once per day. # Full documentation of this method, see below dataframe = merge_informative_pair ( dataframe , informative , self . timeframe , inf_tf , ffill = True ) # Calculate rsi of the original dataframe (5m timeframe) dataframe [ 'rsi' ] = ta . RSI ( dataframe , timeperiod = 14 ) # Do other stuff # ... return dataframe def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'rsi_1d' ] < 30 ) & # Ensure daily RSI is < 30 ( dataframe [ 'volume' ] > 0 ) # Ensure this candle had volume (important for backtesting) ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' )","title":"Complete Data-provider sample"},{"location":"strategy-customization/#helper-functions","text":"","title":"Helper functions"},{"location":"strategy-customization/#merge_informative_pair","text":"This method helps you merge an informative pair to a regular dataframe without lookahead bias. It's there to help you merge the dataframe in a safe and consistent way. Options: Rename the columns for you to create unique columns Merge the dataframe without lookahead bias Forward-fill (optional) All columns of the informative dataframe will be available on the returning dataframe in a renamed fashion: Column renaming Assuming inf_tf = '1d' the resulting columns will be: 'date' , 'open' , 'high' , 'low' , 'close' , 'rsi' # from the original dataframe 'date_1d' , 'open_1d' , 'high_1d' , 'low_1d' , 'close_1d' , 'rsi_1d' # from the informative dataframe Column renaming - 1h Assuming inf_tf = '1h' the resulting columns will be: 'date' , 'open' , 'high' , 'low' , 'close' , 'rsi' # from the original dataframe 'date_1h' , 'open_1h' , 'high_1h' , 'low_1h' , 'close_1h' , 'rsi_1h' # from the informative dataframe Custom implementation A custom implementation for this is possible, and can be done as follows: # Shift date by 1 candle # This is necessary since the data is always the \"open date\" # and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00 minutes = timeframe_to_minutes ( inf_tf ) # Only do this if the timeframes are different: informative [ 'date_merge' ] = informative [ \"date\" ] + pd . to_timedelta ( minutes , 'm' ) # Rename columns to be unique informative . columns = [ f \" { col } _ { inf_tf } \" for col in informative . columns ] # Assuming inf_tf = '1d' - then the columns will now be: # date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d # Combine the 2 dataframes # all indicators on the informative sample MUST be calculated before this point dataframe = pd . merge ( dataframe , informative , left_on = 'date' , right_on = f 'date_merge_ { inf_tf } ' , how = 'left' ) # FFill to have the 1d value available in every row throughout the day. # Without this, comparisons would only work once per day. dataframe = dataframe . ffill () Informative timeframe < timeframe Using informative timeframes smaller than the dataframe timeframe is not recommended with this method, as it will not use any of the additional information this would provide. To use the more detailed information properly, more advanced methods should be applied (which are out of scope for freqtrade documentation, as it'll depend on the respective need).","title":"merge_informative_pair()"},{"location":"strategy-customization/#stoploss_from_open","text":"Stoploss values returned from custom_stoploss must specify a percentage relative to current_rate , but sometimes you may want to specify a stoploss relative to the open price instead. stoploss_from_open() is a helper function to calculate a stoploss value that can be returned from custom_stoploss which will be equivalent to the desired percentage above the open price. Returning a stoploss relative to the open price from the custom stoploss function Say the open price was $100, and current_price is $121 ( current_profit will be 0.21 ). If we want a stop price at 7% above the open price we can call stoploss_from_open(0.07, current_profit, False) which will return 0.1157024793 . 11.57% below $121 is $107, which is the same as 7% above $100. from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , stoploss_from_open class AwesomeStrategy ( IStrategy ): # ... populate_* methods use_custom_stoploss = True def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) return 1 Full examples can be found in the Custom stoploss section of the Documentation. Note Providing invalid input to stoploss_from_open() may produce \"CustomStoploss function did not return valid stoploss\" warnings. This may happen if current_profit parameter is below specified open_relative_stop . Such situations may arise when closing trade is blocked by confirm_trade_exit() method. Warnings can be solved by never blocking stop loss sells by checking exit_reason in confirm_trade_exit() , or by using return stoploss_from_open(...) or 1 idiom, which will request to not change stop loss when current_profit < open_relative_stop .","title":"stoploss_from_open()"},{"location":"strategy-customization/#stoploss_from_absolute","text":"In some situations it may be confusing to deal with stops relative to current rate. Instead, you may define a stoploss level using an absolute price. Returning a stoploss using absolute price from the custom stoploss function If we want to trail a stop price at 2xATR below current price we can call stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate, is_short=trade.is_short) . from datetime import datetime from freqtrade.persistence import Trade from freqtrade.strategy import IStrategy , stoploss_from_absolute class AwesomeStrategy ( IStrategy ): use_custom_stoploss = True def populate_indicators_1h ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe [ 'atr' ] = ta . ATR ( dataframe , timeperiod = 14 ) return dataframe def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) candle = dataframe . iloc [ - 1 ] . squeeze () return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate , is_short = trade . is_short )","title":"stoploss_from_absolute()"},{"location":"strategy-customization/#additional-data-wallets","text":"The strategy provides access to the Wallets object. This contains the current balances on the exchange. Note Wallets is not available during backtesting / hyperopt. Please always check if Wallets is available to avoid failures during backtesting. if self . wallets : free_eth = self . wallets . get_free ( 'ETH' ) used_eth = self . wallets . get_used ( 'ETH' ) total_eth = self . wallets . get_total ( 'ETH' )","title":"Additional data (Wallets)"},{"location":"strategy-customization/#possible-options-for-wallets","text":"get_free(asset) - currently available balance to trade get_used(asset) - currently tied up balance (open orders) get_total(asset) - total available balance - sum of the 2 above","title":"Possible options for Wallets"},{"location":"strategy-customization/#additional-data-trades","text":"A history of Trades can be retrieved in the strategy by querying the database. At the top of the file, import Trade. from freqtrade.persistence import Trade The following example queries for the current pair and trades from today, however other filters can easily be added. if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): trades = Trade . get_trades ([ Trade . pair == metadata [ 'pair' ], Trade . open_date > datetime . utcnow () - timedelta ( days = 1 ), Trade . is_open . is_ ( False ), ]) . order_by ( Trade . close_date ) . all () # Summarize profit for this pair. curdayprofit = sum ( trade . close_profit for trade in trades ) Get amount of stake_currency currently invested in Trades: if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): total_stakes = Trade . total_open_trades_stakes () Retrieve performance per pair. Returns a List of dicts per pair. if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): performance = Trade . get_overall_performance () Sample return value: ETH/BTC had 5 trades, with a total profit of 1.5% (ratio of 0.015). { \"pair\" : \"ETH/BTC\" , \"profit\" : 0.015 , \"count\" : 5 } Warning Trade history is not available during backtesting or hyperopt.","title":"Additional data (Trades)"},{"location":"strategy-customization/#prevent-trades-from-happening-for-a-specific-pair","text":"Freqtrade locks pairs automatically for the current candle (until that candle is over) when a pair is sold, preventing an immediate re-buy of that pair. Locked pairs will show the message Pair <pair> is currently locked. .","title":"Prevent trades from happening for a specific pair"},{"location":"strategy-customization/#locking-pairs-from-within-the-strategy","text":"Sometimes it may be desired to lock a pair after certain events happen (e.g. multiple losing trades in a row). Freqtrade has an easy method to do this from within the strategy, by calling self.lock_pair(pair, until, [reason]) . until must be a datetime object in the future, after which trading will be re-enabled for that pair, while reason is an optional string detailing why the pair was locked. Locks can also be lifted manually, by calling self.unlock_pair(pair) or self.unlock_reason(<reason>) - providing reason the pair was locked with. self.unlock_reason(<reason>) will unlock all pairs currently locked with the provided reason. To verify if a pair is currently locked, use self.is_pair_locked(pair) . Note Locked pairs will always be rounded up to the next candle. So assuming a 5m timeframe, a lock with until set to 10:18 will lock the pair until the candle from 10:15-10:20 will be finished. Warning Manually locking pairs is not available during backtesting, only locks via Protections are allowed.","title":"Locking pairs from within the strategy"},{"location":"strategy-customization/#pair-locking-example","text":"from freqtrade.persistence import Trade from datetime import timedelta , datetime , timezone # Put the above lines a the top of the strategy file, next to all the other imports # -------- # Within populate indicators (or populate_buy): if self . config [ 'runmode' ] . value in ( 'live' , 'dry_run' ): # fetch closed trades for the last 2 days trades = Trade . get_trades ([ Trade . pair == metadata [ 'pair' ], Trade . open_date > datetime . utcnow () - timedelta ( days = 2 ), Trade . is_open . is_ ( False ), ]) . all () # Analyze the conditions you'd like to lock the pair .... will probably be different for every strategy sumprofit = sum ( trade . close_profit for trade in trades ) if sumprofit < 0 : # Lock pair for 12 hours self . lock_pair ( metadata [ 'pair' ], until = datetime . now ( timezone . utc ) + timedelta ( hours = 12 ))","title":"Pair locking example"},{"location":"strategy-customization/#print-created-dataframe","text":"To inspect the created dataframe, you can issue a print-statement in either populate_entry_trend() or populate_exit_trend() . You may also want to print the pair so it's clear what data is currently shown. def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( #>> whatever condition<<< ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'somestring' ) # Print the Analyzed pair print ( f \"result for { metadata [ 'pair' ] } \" ) # Inspect the last 5 rows print ( dataframe . tail ()) return dataframe Printing more than a few rows is also possible (simply use print(dataframe) instead of print(dataframe.tail()) ), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds).","title":"Print created dataframe"},{"location":"strategy-customization/#common-mistakes-when-developing-strategies","text":"","title":"Common mistakes when developing strategies"},{"location":"strategy-customization/#peeking-into-the-future-while-backtesting","text":"Backtesting analyzes the whole time-range at once for performance reasons. Because of this, strategy authors need to make sure that strategies do not look-ahead into the future. This is a common pain-point, which can cause huge differences between backtesting and dry/live run methods, since they all use data which is not available during dry/live runs, so these strategies will perform well during backtesting, but will fail / perform badly in real conditions. The following lists some common patterns which should be avoided to prevent frustration: don't use shift(-1) . This uses data from the future, which is not available. don't use .iloc[-1] or any other absolute position in the dataframe, this will be different between dry-run and backtesting. don't use dataframe['volume'].mean() . This uses the full DataFrame for backtesting, including data from the future. Use dataframe['volume'].rolling(<window>).mean() instead don't use .resample('1h') . This uses the left border of the interval, so moves data from an hour to the start of the hour. Use .resample('1h', label='right') instead.","title":"Peeking into the future while backtesting"},{"location":"strategy-customization/#colliding-signals","text":"When conflicting signals collide (e.g. both 'enter_long' and 'exit_long' are 1), freqtrade will do nothing and ignore the entry signal. This will avoid trades that enter, and exit immediately. Obviously, this can potentially lead to missed entries. The following rules apply, and entry signals will be ignored if more than one of the 3 signals is set: enter_long -> exit_long , enter_short enter_short -> exit_short , enter_long","title":"Colliding signals"},{"location":"strategy-customization/#further-strategy-ideas","text":"To get additional Ideas for strategies, head over to the strategy repository . Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo.","title":"Further strategy ideas"},{"location":"strategy-customization/#next-step","text":"Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting .","title":"Next step"},{"location":"strategy_analysis_example/","text":"Strategy analysis example \u00b6 Debugging a strategy can be time-consuming. Freqtrade offers helper functions to visualize raw data. The following assumes you work with SampleStrategy, data for 5m timeframe from Binance and have downloaded them into the data directory in the default location. Setup \u00b6 from pathlib import Path from freqtrade.configuration import Configuration # Customize these according to your needs. # Initialize empty configuration object config = Configuration . from_files ([]) # Optionally (recommended), use existing configuration file # config = Configuration.from_files([\"config.json\"]) # Define some constants config [ \"timeframe\" ] = \"5m\" # Name of the strategy class config [ \"strategy\" ] = \"SampleStrategy\" # Location of the data data_location = config [ 'datadir' ] # Pair to analyze - Only use one pair here pair = \"BTC/USDT\" # Load data using values set above from freqtrade.data.history import load_pair_history from freqtrade.enums import CandleType candles = load_pair_history ( datadir = data_location , timeframe = config [ \"timeframe\" ], pair = pair , data_format = \"hdf5\" , candle_type = CandleType . SPOT , ) # Confirm success print ( \"Loaded \" + str ( len ( candles )) + f \" rows of data for { pair } from { data_location } \" ) candles . head () Load and run strategy \u00b6 Rerun each time the strategy file is changed # Load strategy using values set above from freqtrade.resolvers import StrategyResolver from freqtrade.data.dataprovider import DataProvider strategy = StrategyResolver . load_strategy ( config ) strategy . dp = DataProvider ( config , None , None ) # Generate buy/sell signals using strategy df = strategy . analyze_ticker ( candles , { 'pair' : pair }) df . tail () Display the trade details \u00b6 Note that using data.head() would also work, however most indicators have some \"startup\" data at the top of the dataframe. Some possible problems * Columns with NaN values at the end of the dataframe * Columns used in crossed*() functions with completely different units Comparison with full backtest * having 200 buy signals as output for one pair from analyze_ticker() does not necessarily mean that 200 trades will be made during backtesting. * Assuming you use only one condition such as, df['rsi'] < 30 as buy condition, this will generate multiple \"buy\" signals for each pair in sequence (until rsi returns > 29). The bot will only buy on the first of these signals (and also only if a trade-slot (\"max_open_trades\") is still available), or on one of the middle signals, as soon as a \"slot\" becomes available. # Report results print ( f \"Generated { df [ 'enter_long' ] . sum () } entry signals\" ) data = df . set_index ( 'date' , drop = False ) data . tail () Load existing objects into a Jupyter notebook \u00b6 The following cells assume that you have already generated data using the cli. They will allow you to drill deeper into your results, and perform analysis which otherwise would make the output very difficult to digest due to information overload. Load backtest results to pandas dataframe \u00b6 Analyze a trades dataframe (also used below for plotting) from freqtrade.data.btanalysis import load_backtest_data , load_backtest_stats # if backtest_dir points to a directory, it'll automatically load the last backtest file. backtest_dir = config [ \"user_data_dir\" ] / \"backtest_results\" # backtest_dir can also point to a specific file # backtest_dir = config[\"user_data_dir\"] / \"backtest_results/backtest-result-2020-07-01_20-04-22.json\" # You can get the full backtest statistics by using the following command. # This contains all information used to generate the backtest result. stats = load_backtest_stats ( backtest_dir ) strategy = 'SampleStrategy' # All statistics are available per strategy, so if `--strategy-list` was used during backtest, this will be reflected here as well. # Example usages: print ( stats [ 'strategy' ][ strategy ][ 'results_per_pair' ]) # Get pairlist used for this backtest print ( stats [ 'strategy' ][ strategy ][ 'pairlist' ]) # Get market change (average change of all pairs from start to end of the backtest period) print ( stats [ 'strategy' ][ strategy ][ 'market_change' ]) # Maximum drawdown () print ( stats [ 'strategy' ][ strategy ][ 'max_drawdown' ]) # Maximum drawdown start and end print ( stats [ 'strategy' ][ strategy ][ 'drawdown_start' ]) print ( stats [ 'strategy' ][ strategy ][ 'drawdown_end' ]) # Get strategy comparison (only relevant if multiple strategies were compared) print ( stats [ 'strategy_comparison' ]) # Load backtested trades as dataframe trades = load_backtest_data ( backtest_dir ) # Show value-counts per pair trades . groupby ( \"pair\" )[ \"exit_reason\" ] . value_counts () Plotting daily profit / equity line \u00b6 # Plotting equity line (starting with 0 on day 1 and adding daily profit for each backtested day) from freqtrade.configuration import Configuration from freqtrade.data.btanalysis import load_backtest_data , load_backtest_stats import plotly.express as px import pandas as pd # strategy = 'SampleStrategy' # config = Configuration.from_files([\"user_data/config.json\"]) # backtest_dir = config[\"user_data_dir\"] / \"backtest_results\" stats = load_backtest_stats ( backtest_dir ) strategy_stats = stats [ 'strategy' ][ strategy ] dates = [] profits = [] for date_profit in strategy_stats [ 'daily_profit' ]: dates . append ( date_profit [ 0 ]) profits . append ( date_profit [ 1 ]) equity = 0 equity_daily = [] for daily_profit in profits : equity_daily . append ( equity ) equity += float ( daily_profit ) df = pd . DataFrame ({ 'dates' : dates , 'equity_daily' : equity_daily }) fig = px . line ( df , x = \"dates\" , y = \"equity_daily\" ) fig . show () Load live trading results into a pandas dataframe \u00b6 In case you did already some trading and want to analyze your performance from freqtrade.data.btanalysis import load_trades_from_db # Fetch trades from database trades = load_trades_from_db ( \"sqlite:///tradesv3.sqlite\" ) # Display results trades . groupby ( \"pair\" )[ \"exit_reason\" ] . value_counts () Analyze the loaded trades for trade parallelism \u00b6 This can be useful to find the best max_open_trades parameter, when used with backtesting in conjunction with --disable-max-market-positions . analyze_trade_parallelism() returns a timeseries dataframe with an \"open_trades\" column, specifying the number of open trades for each candle. from freqtrade.data.btanalysis import analyze_trade_parallelism # Analyze the above parallel_trades = analyze_trade_parallelism ( trades , '5m' ) parallel_trades . plot () Plot results \u00b6 Freqtrade offers interactive plotting capabilities based on plotly. from freqtrade.plot.plotting import generate_candlestick_graph # Limit graph period to keep plotly quick and reactive # Filter trades to one pair trades_red = trades . loc [ trades [ 'pair' ] == pair ] data_red = data [ '2019-06-01' : '2019-06-10' ] # Generate candlestick graph graph = generate_candlestick_graph ( pair = pair , data = data_red , trades = trades_red , indicators1 = [ 'sma20' , 'ema50' , 'ema55' ], indicators2 = [ 'rsi' , 'macd' , 'macdsignal' , 'macdhist' ] ) # Show graph inline # graph.show() # Render graph in a seperate window graph . show ( renderer = \"browser\" ) Plot average profit per trade as distribution graph \u00b6 import plotly.figure_factory as ff hist_data = [ trades . profit_ratio ] group_labels = [ 'profit_ratio' ] # name of the dataset fig = ff . create_distplot ( hist_data , group_labels , bin_size = 0.01 ) fig . show () Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Strategy analysis"},{"location":"strategy_analysis_example/#strategy-analysis-example","text":"Debugging a strategy can be time-consuming. Freqtrade offers helper functions to visualize raw data. The following assumes you work with SampleStrategy, data for 5m timeframe from Binance and have downloaded them into the data directory in the default location.","title":"Strategy analysis example"},{"location":"strategy_analysis_example/#setup","text":"from pathlib import Path from freqtrade.configuration import Configuration # Customize these according to your needs. # Initialize empty configuration object config = Configuration . from_files ([]) # Optionally (recommended), use existing configuration file # config = Configuration.from_files([\"config.json\"]) # Define some constants config [ \"timeframe\" ] = \"5m\" # Name of the strategy class config [ \"strategy\" ] = \"SampleStrategy\" # Location of the data data_location = config [ 'datadir' ] # Pair to analyze - Only use one pair here pair = \"BTC/USDT\" # Load data using values set above from freqtrade.data.history import load_pair_history from freqtrade.enums import CandleType candles = load_pair_history ( datadir = data_location , timeframe = config [ \"timeframe\" ], pair = pair , data_format = \"hdf5\" , candle_type = CandleType . SPOT , ) # Confirm success print ( \"Loaded \" + str ( len ( candles )) + f \" rows of data for { pair } from { data_location } \" ) candles . head ()","title":"Setup"},{"location":"strategy_analysis_example/#load-and-run-strategy","text":"Rerun each time the strategy file is changed # Load strategy using values set above from freqtrade.resolvers import StrategyResolver from freqtrade.data.dataprovider import DataProvider strategy = StrategyResolver . load_strategy ( config ) strategy . dp = DataProvider ( config , None , None ) # Generate buy/sell signals using strategy df = strategy . analyze_ticker ( candles , { 'pair' : pair }) df . tail ()","title":"Load and run strategy"},{"location":"strategy_analysis_example/#display-the-trade-details","text":"Note that using data.head() would also work, however most indicators have some \"startup\" data at the top of the dataframe. Some possible problems * Columns with NaN values at the end of the dataframe * Columns used in crossed*() functions with completely different units Comparison with full backtest * having 200 buy signals as output for one pair from analyze_ticker() does not necessarily mean that 200 trades will be made during backtesting. * Assuming you use only one condition such as, df['rsi'] < 30 as buy condition, this will generate multiple \"buy\" signals for each pair in sequence (until rsi returns > 29). The bot will only buy on the first of these signals (and also only if a trade-slot (\"max_open_trades\") is still available), or on one of the middle signals, as soon as a \"slot\" becomes available. # Report results print ( f \"Generated { df [ 'enter_long' ] . sum () } entry signals\" ) data = df . set_index ( 'date' , drop = False ) data . tail ()","title":"Display the trade details"},{"location":"strategy_analysis_example/#load-existing-objects-into-a-jupyter-notebook","text":"The following cells assume that you have already generated data using the cli. They will allow you to drill deeper into your results, and perform analysis which otherwise would make the output very difficult to digest due to information overload.","title":"Load existing objects into a Jupyter notebook"},{"location":"strategy_analysis_example/#load-backtest-results-to-pandas-dataframe","text":"Analyze a trades dataframe (also used below for plotting) from freqtrade.data.btanalysis import load_backtest_data , load_backtest_stats # if backtest_dir points to a directory, it'll automatically load the last backtest file. backtest_dir = config [ \"user_data_dir\" ] / \"backtest_results\" # backtest_dir can also point to a specific file # backtest_dir = config[\"user_data_dir\"] / \"backtest_results/backtest-result-2020-07-01_20-04-22.json\" # You can get the full backtest statistics by using the following command. # This contains all information used to generate the backtest result. stats = load_backtest_stats ( backtest_dir ) strategy = 'SampleStrategy' # All statistics are available per strategy, so if `--strategy-list` was used during backtest, this will be reflected here as well. # Example usages: print ( stats [ 'strategy' ][ strategy ][ 'results_per_pair' ]) # Get pairlist used for this backtest print ( stats [ 'strategy' ][ strategy ][ 'pairlist' ]) # Get market change (average change of all pairs from start to end of the backtest period) print ( stats [ 'strategy' ][ strategy ][ 'market_change' ]) # Maximum drawdown () print ( stats [ 'strategy' ][ strategy ][ 'max_drawdown' ]) # Maximum drawdown start and end print ( stats [ 'strategy' ][ strategy ][ 'drawdown_start' ]) print ( stats [ 'strategy' ][ strategy ][ 'drawdown_end' ]) # Get strategy comparison (only relevant if multiple strategies were compared) print ( stats [ 'strategy_comparison' ]) # Load backtested trades as dataframe trades = load_backtest_data ( backtest_dir ) # Show value-counts per pair trades . groupby ( \"pair\" )[ \"exit_reason\" ] . value_counts ()","title":"Load backtest results to pandas dataframe"},{"location":"strategy_analysis_example/#plotting-daily-profit-equity-line","text":"# Plotting equity line (starting with 0 on day 1 and adding daily profit for each backtested day) from freqtrade.configuration import Configuration from freqtrade.data.btanalysis import load_backtest_data , load_backtest_stats import plotly.express as px import pandas as pd # strategy = 'SampleStrategy' # config = Configuration.from_files([\"user_data/config.json\"]) # backtest_dir = config[\"user_data_dir\"] / \"backtest_results\" stats = load_backtest_stats ( backtest_dir ) strategy_stats = stats [ 'strategy' ][ strategy ] dates = [] profits = [] for date_profit in strategy_stats [ 'daily_profit' ]: dates . append ( date_profit [ 0 ]) profits . append ( date_profit [ 1 ]) equity = 0 equity_daily = [] for daily_profit in profits : equity_daily . append ( equity ) equity += float ( daily_profit ) df = pd . DataFrame ({ 'dates' : dates , 'equity_daily' : equity_daily }) fig = px . line ( df , x = \"dates\" , y = \"equity_daily\" ) fig . show ()","title":"Plotting daily profit / equity line"},{"location":"strategy_analysis_example/#load-live-trading-results-into-a-pandas-dataframe","text":"In case you did already some trading and want to analyze your performance from freqtrade.data.btanalysis import load_trades_from_db # Fetch trades from database trades = load_trades_from_db ( \"sqlite:///tradesv3.sqlite\" ) # Display results trades . groupby ( \"pair\" )[ \"exit_reason\" ] . value_counts ()","title":"Load live trading results into a pandas dataframe"},{"location":"strategy_analysis_example/#analyze-the-loaded-trades-for-trade-parallelism","text":"This can be useful to find the best max_open_trades parameter, when used with backtesting in conjunction with --disable-max-market-positions . analyze_trade_parallelism() returns a timeseries dataframe with an \"open_trades\" column, specifying the number of open trades for each candle. from freqtrade.data.btanalysis import analyze_trade_parallelism # Analyze the above parallel_trades = analyze_trade_parallelism ( trades , '5m' ) parallel_trades . plot ()","title":"Analyze the loaded trades for trade parallelism"},{"location":"strategy_analysis_example/#plot-results","text":"Freqtrade offers interactive plotting capabilities based on plotly. from freqtrade.plot.plotting import generate_candlestick_graph # Limit graph period to keep plotly quick and reactive # Filter trades to one pair trades_red = trades . loc [ trades [ 'pair' ] == pair ] data_red = data [ '2019-06-01' : '2019-06-10' ] # Generate candlestick graph graph = generate_candlestick_graph ( pair = pair , data = data_red , trades = trades_red , indicators1 = [ 'sma20' , 'ema50' , 'ema55' ], indicators2 = [ 'rsi' , 'macd' , 'macdsignal' , 'macdhist' ] ) # Show graph inline # graph.show() # Render graph in a seperate window graph . show ( renderer = \"browser\" )","title":"Plot results"},{"location":"strategy_analysis_example/#plot-average-profit-per-trade-as-distribution-graph","text":"import plotly.figure_factory as ff hist_data = [ trades . profit_ratio ] group_labels = [ 'profit_ratio' ] # name of the dataset fig = ff . create_distplot ( hist_data , group_labels , bin_size = 0.01 ) fig . show () Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.","title":"Plot average profit per trade as distribution graph"},{"location":"strategy_migration/","text":"Strategy Migration between V2 and V3 \u00b6 To support new markets and trade-types (namely short trades / trades with leverage), some things had to change in the interface. If you intend on using markets other than spot markets, please migrate your strategy to the new format. We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets , there should be no changes necessary for now. You can use the quick summary as checklist. Please refer to the detailed sections below for full migration details. Quick summary / migration checklist \u00b6 Note : forcesell , forcebuy , emergencysell are changed to force_exit , force_enter , emergency_exit respectively. Strategy methods: populate_buy_trend() -> populate_entry_trend() populate_sell_trend() -> populate_exit_trend() custom_sell() -> custom_exit() check_buy_timeout() -> check_entry_timeout() check_sell_timeout() -> check_exit_timeout() New side argument to callbacks without trade object custom_stake_amount confirm_trade_entry custom_entry_price Changed argument name in confirm_trade_exit Dataframe columns: buy -> enter_long sell -> exit_long buy_tag -> enter_tag (used for both long and short trades) New column enter_short and corresponding new column exit_short trade-object now has the following new properties: is_short entry_side exit_side trade_direction renamed: sell_reason -> exit_reason Renamed trade.nr_of_successful_buys to trade.nr_of_successful_entries (mostly relevant for adjust_trade_position() ) Introduced new leverage callback . Informative pairs can now pass a 3 rd element in the Tuple, defining the candle type. @informative decorator now takes an optional candle_type argument. helper methods stoploss_from_open and stoploss_from_absolute now take is_short as additional argument. INTERFACE_VERSION should be set to 3. Strategy/Configuration settings . order_time_in_force buy -> entry, sell -> exit. order_types buy -> entry, sell -> exit. unfilledtimeout buy -> entry, sell -> exit. Terminology changes Sell reasons changed to reflect the new naming of \"exit\" instead of sells. Be careful in your strategy if you're using exit_reason checks and eventually update your strategy. sell_signal -> exit_signal custom_sell -> custom_exit force_sell -> force_exit emergency_sell -> emergency_exit Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to entry webhookbuy -> webhookentry webhookbuyfill -> webhookentryfill webhookbuycancel -> webhookentrycancel webhooksell -> webhookexit webhooksellfill -> webhookexitfill webhooksellcancel -> webhookexitcancel Telegram notification settings buy -> entry buy_fill -> entry_fill buy_cancel -> entry_cancel sell -> exit sell_fill -> exit_fill sell_cancel -> exit_cancel Strategy/config settings: use_sell_signal -> use_exit_signal sell_profit_only -> exit_profit_only sell_profit_offset -> exit_profit_offset ignore_roi_if_buy_signal -> ignore_roi_if_entry_signal forcebuy_enable -> force_entry_enable Extensive explanation \u00b6 populate_buy_trend \u00b6 In populate_buy_trend() - you will want to change the columns you assign from 'buy ' to 'enter_long' , as well as the method name from populate_buy_trend to populate_entry_trend . def populate_buy_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'buy' , 'buy_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe After: def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Please refer to the Strategy documentation on how to enter and exit short trades. populate_sell_trend \u00b6 Similar to populate_buy_trend , populate_sell_trend() will be renamed to populate_exit_trend() . We'll also change the column from 'sell' to 'exit_long' . def populate_sell_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'sell' , 'exit_tag' ]] = ( 1 , 'some_exit_tag' ) return dataframe After def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'some_exit_tag' ) return dataframe Please refer to the Strategy documentation on how to enter and exit short trades. custom_sell \u00b6 custom_sell has been renamed to custom_exit . It's now also being called for every iteration, independent of current profit and exit_profit_only settings. class AwesomeStrategy ( IStrategy ): def custom_sell ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # ... class AwesomeStrategy ( IStrategy ): def custom_exit ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # ... custom_entry_timeout \u00b6 check_buy_timeout() has been renamed to check_entry_timeout() , and check_sell_timeout() has been renamed to check_exit_timeout() . class AwesomeStrategy ( IStrategy ): def check_buy_timeout ( self , pair : str , trade : 'Trade' , order : dict , current_time : datetime , ** kwargs ) -> bool : return False def check_sell_timeout ( self , pair : str , trade : 'Trade' , order : dict , current_time : datetime , ** kwargs ) -> bool : return False class AwesomeStrategy ( IStrategy ): def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : return False def check_exit_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : return False custom_stake_amount \u00b6 New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , entry_tag : Optional [ str ], ** kwargs ) -> float : # ... return proposed_stake class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : # ... return proposed_stake confirm_trade_entry \u00b6 New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], ** kwargs ) -> bool : return True After: class AwesomeStrategy ( IStrategy ): def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], side : str , ** kwargs ) -> bool : return True confirm_trade_exit \u00b6 Changed argument sell_reason to exit_reason . For compatibility, sell_reason will still be provided for a limited time. class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , sell_reason : str , current_time : datetime , ** kwargs ) -> bool : return True After: class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : datetime , ** kwargs ) -> bool : return True custom_entry_price \u00b6 New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], ** kwargs ) -> float : return proposed_rate After: class AwesomeStrategy ( IStrategy ): def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : return proposed_rate Adjust trade position changes \u00b6 While adjust-trade-position itself did not change, you should no longer use trade.nr_of_successful_buys - and instead use trade.nr_of_successful_entries , which will also include short entries. Helper methods \u00b6 Added argument \"is_short\" to stoploss_from_open and stoploss_from_absolute . This should be given the value of trade.is_short . def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit ) return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate ) return 1 After: def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate , is_short = trade . is_short ) Strategy/Configuration settings \u00b6 order_time_in_force \u00b6 order_time_in_force attributes changed from \"buy\" to \"entry\" and \"sell\" to \"exit\" . order_time_in_force : Dict = { \"buy\" : \"gtc\" , \"sell\" : \"gtc\" , } After: order_time_in_force : Dict = { \"entry\" : \"gtc\" , \"exit\" : \"gtc\" , } order_types \u00b6 order_types have changed all wordings from buy to entry - and sell to exit . And two words are joined with _ . order_types = { \"buy\" : \"limit\" , \"sell\" : \"limit\" , \"emergencysell\" : \"market\" , \"forcesell\" : \"market\" , \"forcebuy\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 } After: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_exit\" : \"market\" , \"force_entry\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 } Strategy level settings \u00b6 use_sell_signal -> use_exit_signal sell_profit_only -> exit_profit_only sell_profit_offset -> exit_profit_offset ignore_roi_if_buy_signal -> ignore_roi_if_entry_signal # These values can be overridden in the config. use_sell_signal = True sell_profit_only = True sell_profit_offset : 0.01 ignore_roi_if_buy_signal = False After: # These values can be overridden in the config. use_exit_signal = True exit_profit_only = True exit_profit_offset : 0.01 ignore_roi_if_entry_signal = False unfilledtimeout \u00b6 unfilledtimeout have changed all wordings from buy to entry - and sell to exit . unfilledtimeout = { \"buy\" : 10 , \"sell\" : 10 , \"exit_timeout_count\" : 0 , \"unit\" : \"minutes\" } After: unfilledtimeout = { \"entry\" : 10 , \"exit\" : 10 , \"exit_timeout_count\" : 0 , \"unit\" : \"minutes\" } order pricing \u00b6 Order pricing changed in 2 ways. bid_strategy was renamed to entry_pricing and ask_strategy was renamed to exit_pricing . The attributes ask_last_balance -> price_last_balance and bid_last_balance -> price_last_balance were renamed as well. Also, price-side can now be defined as ask , bid , same or other . Please refer to the pricing documentation for more information. { \"bid_strategy\" : { \"price_side\" : \"bid\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"ask_last_balance\" : 0.0 , \"check_depth_of_market\" : { \"enabled\" : false , \"bids_to_ask_delta\" : 1 } }, \"ask_strategy\" :{ \"price_side\" : \"ask\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"bid_last_balance\" : 0.0 } } after: { \"entry_pricing\" : { \"price_side\" : \"same\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"price_last_balance\" : 0.0 , \"check_depth_of_market\" : { \"enabled\" : false , \"bids_to_ask_delta\" : 1 } }, \"exit_pricing\" :{ \"price_side\" : \"same\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"price_last_balance\" : 0.0 } }","title":"Strategy migration"},{"location":"strategy_migration/#strategy-migration-between-v2-and-v3","text":"To support new markets and trade-types (namely short trades / trades with leverage), some things had to change in the interface. If you intend on using markets other than spot markets, please migrate your strategy to the new format. We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets , there should be no changes necessary for now. You can use the quick summary as checklist. Please refer to the detailed sections below for full migration details.","title":"Strategy Migration between V2 and V3"},{"location":"strategy_migration/#quick-summary-migration-checklist","text":"Note : forcesell , forcebuy , emergencysell are changed to force_exit , force_enter , emergency_exit respectively. Strategy methods: populate_buy_trend() -> populate_entry_trend() populate_sell_trend() -> populate_exit_trend() custom_sell() -> custom_exit() check_buy_timeout() -> check_entry_timeout() check_sell_timeout() -> check_exit_timeout() New side argument to callbacks without trade object custom_stake_amount confirm_trade_entry custom_entry_price Changed argument name in confirm_trade_exit Dataframe columns: buy -> enter_long sell -> exit_long buy_tag -> enter_tag (used for both long and short trades) New column enter_short and corresponding new column exit_short trade-object now has the following new properties: is_short entry_side exit_side trade_direction renamed: sell_reason -> exit_reason Renamed trade.nr_of_successful_buys to trade.nr_of_successful_entries (mostly relevant for adjust_trade_position() ) Introduced new leverage callback . Informative pairs can now pass a 3 rd element in the Tuple, defining the candle type. @informative decorator now takes an optional candle_type argument. helper methods stoploss_from_open and stoploss_from_absolute now take is_short as additional argument. INTERFACE_VERSION should be set to 3. Strategy/Configuration settings . order_time_in_force buy -> entry, sell -> exit. order_types buy -> entry, sell -> exit. unfilledtimeout buy -> entry, sell -> exit. Terminology changes Sell reasons changed to reflect the new naming of \"exit\" instead of sells. Be careful in your strategy if you're using exit_reason checks and eventually update your strategy. sell_signal -> exit_signal custom_sell -> custom_exit force_sell -> force_exit emergency_sell -> emergency_exit Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to entry webhookbuy -> webhookentry webhookbuyfill -> webhookentryfill webhookbuycancel -> webhookentrycancel webhooksell -> webhookexit webhooksellfill -> webhookexitfill webhooksellcancel -> webhookexitcancel Telegram notification settings buy -> entry buy_fill -> entry_fill buy_cancel -> entry_cancel sell -> exit sell_fill -> exit_fill sell_cancel -> exit_cancel Strategy/config settings: use_sell_signal -> use_exit_signal sell_profit_only -> exit_profit_only sell_profit_offset -> exit_profit_offset ignore_roi_if_buy_signal -> ignore_roi_if_entry_signal forcebuy_enable -> force_entry_enable","title":"Quick summary / migration checklist"},{"location":"strategy_migration/#extensive-explanation","text":"","title":"Extensive explanation"},{"location":"strategy_migration/#populate_buy_trend","text":"In populate_buy_trend() - you will want to change the columns you assign from 'buy ' to 'enter_long' , as well as the method name from populate_buy_trend to populate_entry_trend . def populate_buy_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'buy' , 'buy_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe After: def populate_entry_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 30 )) & # Signal: RSI crosses above 30 ( dataframe [ 'tema' ] <= dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] > dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'enter_long' , 'enter_tag' ]] = ( 1 , 'rsi_cross' ) return dataframe Please refer to the Strategy documentation on how to enter and exit short trades.","title":"populate_buy_trend"},{"location":"strategy_migration/#populate_sell_trend","text":"Similar to populate_buy_trend , populate_sell_trend() will be renamed to populate_exit_trend() . We'll also change the column from 'sell' to 'exit_long' . def populate_sell_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'sell' , 'exit_tag' ]] = ( 1 , 'some_exit_tag' ) return dataframe After def populate_exit_trend ( self , dataframe : DataFrame , metadata : dict ) -> DataFrame : dataframe . loc [ ( ( qtpylib . crossed_above ( dataframe [ 'rsi' ], 70 )) & # Signal: RSI crosses above 70 ( dataframe [ 'tema' ] > dataframe [ 'bb_middleband' ]) & # Guard ( dataframe [ 'tema' ] < dataframe [ 'tema' ] . shift ( 1 )) & # Guard ( dataframe [ 'volume' ] > 0 ) # Make sure Volume is not 0 ), [ 'exit_long' , 'exit_tag' ]] = ( 1 , 'some_exit_tag' ) return dataframe Please refer to the Strategy documentation on how to enter and exit short trades.","title":"populate_sell_trend"},{"location":"strategy_migration/#custom_sell","text":"custom_sell has been renamed to custom_exit . It's now also being called for every iteration, independent of current profit and exit_profit_only settings. class AwesomeStrategy ( IStrategy ): def custom_sell ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # ... class AwesomeStrategy ( IStrategy ): def custom_exit ( self , pair : str , trade : 'Trade' , current_time : 'datetime' , current_rate : float , current_profit : float , ** kwargs ): dataframe , _ = self . dp . get_analyzed_dataframe ( pair , self . timeframe ) last_candle = dataframe . iloc [ - 1 ] . squeeze () # ...","title":"custom_sell"},{"location":"strategy_migration/#custom_entry_timeout","text":"check_buy_timeout() has been renamed to check_entry_timeout() , and check_sell_timeout() has been renamed to check_exit_timeout() . class AwesomeStrategy ( IStrategy ): def check_buy_timeout ( self , pair : str , trade : 'Trade' , order : dict , current_time : datetime , ** kwargs ) -> bool : return False def check_sell_timeout ( self , pair : str , trade : 'Trade' , order : dict , current_time : datetime , ** kwargs ) -> bool : return False class AwesomeStrategy ( IStrategy ): def check_entry_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : return False def check_exit_timeout ( self , pair : str , trade : 'Trade' , order : 'Order' , current_time : datetime , ** kwargs ) -> bool : return False","title":"custom_entry_timeout"},{"location":"strategy_migration/#custom_stake_amount","text":"New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , entry_tag : Optional [ str ], ** kwargs ) -> float : # ... return proposed_stake class AwesomeStrategy ( IStrategy ): def custom_stake_amount ( self , pair : str , current_time : datetime , current_rate : float , proposed_stake : float , min_stake : Optional [ float ], max_stake : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : # ... return proposed_stake","title":"custom_stake_amount"},{"location":"strategy_migration/#confirm_trade_entry","text":"New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], ** kwargs ) -> bool : return True After: class AwesomeStrategy ( IStrategy ): def confirm_trade_entry ( self , pair : str , order_type : str , amount : float , rate : float , time_in_force : str , current_time : datetime , entry_tag : Optional [ str ], side : str , ** kwargs ) -> bool : return True","title":"confirm_trade_entry"},{"location":"strategy_migration/#confirm_trade_exit","text":"Changed argument sell_reason to exit_reason . For compatibility, sell_reason will still be provided for a limited time. class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , sell_reason : str , current_time : datetime , ** kwargs ) -> bool : return True After: class AwesomeStrategy ( IStrategy ): def confirm_trade_exit ( self , pair : str , trade : Trade , order_type : str , amount : float , rate : float , time_in_force : str , exit_reason : str , current_time : datetime , ** kwargs ) -> bool : return True","title":"confirm_trade_exit"},{"location":"strategy_migration/#custom_entry_price","text":"New string argument side - which can be either \"long\" or \"short\" . class AwesomeStrategy ( IStrategy ): def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], ** kwargs ) -> float : return proposed_rate After: class AwesomeStrategy ( IStrategy ): def custom_entry_price ( self , pair : str , current_time : datetime , proposed_rate : float , entry_tag : Optional [ str ], side : str , ** kwargs ) -> float : return proposed_rate","title":"custom_entry_price"},{"location":"strategy_migration/#adjust-trade-position-changes","text":"While adjust-trade-position itself did not change, you should no longer use trade.nr_of_successful_buys - and instead use trade.nr_of_successful_entries , which will also include short entries.","title":"Adjust trade position changes"},{"location":"strategy_migration/#helper-methods","text":"Added argument \"is_short\" to stoploss_from_open and stoploss_from_absolute . This should be given the value of trade.is_short . def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit ) return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate ) return 1 After: def custom_stoploss ( self , pair : str , trade : 'Trade' , current_time : datetime , current_rate : float , current_profit : float , ** kwargs ) -> float : # once the profit has risen above 10%, keep the stoploss at 7% above the open price if current_profit > 0.10 : return stoploss_from_open ( 0.07 , current_profit , is_short = trade . is_short ) return stoploss_from_absolute ( current_rate - ( candle [ 'atr' ] * 2 ), current_rate , is_short = trade . is_short )","title":"Helper methods"},{"location":"strategy_migration/#strategyconfiguration-settings","text":"","title":"Strategy/Configuration settings"},{"location":"strategy_migration/#order_time_in_force","text":"order_time_in_force attributes changed from \"buy\" to \"entry\" and \"sell\" to \"exit\" . order_time_in_force : Dict = { \"buy\" : \"gtc\" , \"sell\" : \"gtc\" , } After: order_time_in_force : Dict = { \"entry\" : \"gtc\" , \"exit\" : \"gtc\" , }","title":"order_time_in_force"},{"location":"strategy_migration/#order_types","text":"order_types have changed all wordings from buy to entry - and sell to exit . And two words are joined with _ . order_types = { \"buy\" : \"limit\" , \"sell\" : \"limit\" , \"emergencysell\" : \"market\" , \"forcesell\" : \"market\" , \"forcebuy\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 } After: order_types = { \"entry\" : \"limit\" , \"exit\" : \"limit\" , \"emergency_exit\" : \"market\" , \"force_exit\" : \"market\" , \"force_entry\" : \"market\" , \"stoploss\" : \"market\" , \"stoploss_on_exchange\" : false , \"stoploss_on_exchange_interval\" : 60 }","title":"order_types"},{"location":"strategy_migration/#strategy-level-settings","text":"use_sell_signal -> use_exit_signal sell_profit_only -> exit_profit_only sell_profit_offset -> exit_profit_offset ignore_roi_if_buy_signal -> ignore_roi_if_entry_signal # These values can be overridden in the config. use_sell_signal = True sell_profit_only = True sell_profit_offset : 0.01 ignore_roi_if_buy_signal = False After: # These values can be overridden in the config. use_exit_signal = True exit_profit_only = True exit_profit_offset : 0.01 ignore_roi_if_entry_signal = False","title":"Strategy level settings"},{"location":"strategy_migration/#unfilledtimeout","text":"unfilledtimeout have changed all wordings from buy to entry - and sell to exit . unfilledtimeout = { \"buy\" : 10 , \"sell\" : 10 , \"exit_timeout_count\" : 0 , \"unit\" : \"minutes\" } After: unfilledtimeout = { \"entry\" : 10 , \"exit\" : 10 , \"exit_timeout_count\" : 0 , \"unit\" : \"minutes\" }","title":"unfilledtimeout"},{"location":"strategy_migration/#order-pricing","text":"Order pricing changed in 2 ways. bid_strategy was renamed to entry_pricing and ask_strategy was renamed to exit_pricing . The attributes ask_last_balance -> price_last_balance and bid_last_balance -> price_last_balance were renamed as well. Also, price-side can now be defined as ask , bid , same or other . Please refer to the pricing documentation for more information. { \"bid_strategy\" : { \"price_side\" : \"bid\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"ask_last_balance\" : 0.0 , \"check_depth_of_market\" : { \"enabled\" : false , \"bids_to_ask_delta\" : 1 } }, \"ask_strategy\" :{ \"price_side\" : \"ask\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"bid_last_balance\" : 0.0 } } after: { \"entry_pricing\" : { \"price_side\" : \"same\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"price_last_balance\" : 0.0 , \"check_depth_of_market\" : { \"enabled\" : false , \"bids_to_ask_delta\" : 1 } }, \"exit_pricing\" :{ \"price_side\" : \"same\" , \"use_order_book\" : true , \"order_book_top\" : 1 , \"price_last_balance\" : 0.0 } }","title":"order pricing"},{"location":"telegram-usage/","text":"Telegram usage \u00b6 Setup your Telegram bot \u00b6 Below we explain how to create your Telegram Bot, and how to get your Telegram user id. 1. Create your Telegram bot \u00b6 Start a chat with the Telegram BotFather Send the message /newbot . BotFather response: Alright, a new bot. How are we going to call it? Please choose a name for your bot. Choose the public name of your bot (e.x. Freqtrade bot ) BotFather response: Good. Now let's choose a username for your bot. It must end in bot . Like this, for example: TetrisBot or tetris_bot. Choose the name id of your bot and send it to the BotFather (e.g. \" My_own_freqtrade_bot \") BotFather response: Done! Congratulations on your new bot. You will find it at t.me/yourbots_name_bot . You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this. Use this token to access the HTTP API: 22222222:APITOKEN For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key) Copy the API Token ( 22222222:APITOKEN in the above example) and keep use it for the config parameter token . Don't forget to start the conversation with your bot, by clicking /START button 2. Telegram user_id \u00b6 Get your user id \u00b6 Talk to the userinfobot Get your \"Id\", you will use it for the config parameter chat_id . Use Group id \u00b6 You can use bots in telegram groups by just adding them to the group. You can find the group id by first adding a RawDataBot to your group. The Group id is shown as id in the \"chat\" section, which the RawDataBot will send to you: \"chat\" :{ \"id\" : -1001332619709 } For the Freqtrade configuration, you can then use the the full value (including - if it's there) as string: \"chat_id\" : \"-1001332619709\" Using telegram groups When using telegram groups, you're giving every member of the telegram group access to your freqtrade bot and to all commands possible via telegram. Please make sure that you can trust everyone in the telegram group to avoid unpleasent surprises. Control telegram noise \u00b6 Freqtrade provides means to control the verbosity of your telegram bot. Each setting has the following possible values: on - Messages will be sent, and user will be notified. silent - Message will be sent, Notification will be without sound / vibration. off - Skip sending a message-type all together. Example configuration showing the different settings: \"telegram\" : { \"enabled\" : true , \"token\" : \"your_telegram_token\" , \"chat_id\" : \"your_telegram_chat_id\" , \"notification_settings\" : { \"status\" : \"silent\" , \"warning\" : \"on\" , \"startup\" : \"off\" , \"entry\" : \"silent\" , \"exit\" : { \"roi\" : \"silent\" , \"emergency_exit\" : \"on\" , \"force_exit\" : \"on\" , \"exit_signal\" : \"silent\" , \"trailing_stop_loss\" : \"on\" , \"stop_loss\" : \"on\" , \"stoploss_on_exchange\" : \"on\" , \"custom_exit\" : \"silent\" }, \"entry_cancel\" : \"silent\" , \"exit_cancel\" : \"on\" , \"entry_fill\" : \"off\" , \"exit_fill\" : \"off\" , \"protection_trigger\" : \"off\" , \"protection_trigger_global\" : \"on\" , \"strategy_msg\" : \"off\" , \"show_candle\" : \"off\" }, \"reload\" : true , \"balance_dust_level\" : 0.01 }, entry notifications are sent when the order is placed, while entry_fill notifications are sent when the order is filled on the exchange. exit notifications are sent when the order is placed, while exit_fill notifications are sent when the order is filled on the exchange. *_fill notifications are off by default and must be explicitly enabled. protection_trigger notifications are sent when a protection triggers and protection_trigger_global notifications trigger when global protections are triggered. strategy_msg - Receive notifications from the strategy, sent via self.dp.send_msg() from the strategy more details . show_candle - show candle values as part of entry/exit messages. Only possible values are \"ohlc\" or \"off\" . balance_dust_level will define what the /balance command takes as \"dust\" - Currencies with a balance below this will be shown. reload allows you to disable reload-buttons on selected messages. Create a custom keyboard (command shortcut buttons) \u00b6 Telegram allows us to create a custom keyboard with buttons for commands. The default custom keyboard looks like this. [ [ \"/daily\" , \"/profit\" , \"/balance\" ], # row 1, 3 commands [ \"/status\" , \"/status table\" , \"/performance\" ], # row 2, 3 commands [ \"/count\" , \"/start\" , \"/stop\" , \"/help\" ] # row 3, 4 commands ] Usage \u00b6 You can create your own keyboard in config.json : \"telegram\" : { \"enabled\" : true , \"token\" : \"your_telegram_token\" , \"chat_id\" : \"your_telegram_chat_id\" , \"keyboard\" : [ [ \"/daily\" , \"/stats\" , \"/balance\" , \"/profit\" ], [ \"/status table\" , \"/performance\" ], [ \"/reload_config\" , \"/count\" , \"/logs\" ] ] }, Supported Commands Only the following commands are allowed. Command arguments are not supported! /start , /stop , /status , /status table , /trades , /profit , /performance , /daily , /stats , /count , /locks , /balance , /stopentry , /reload_config , /show_config , /logs , /whitelist , /blacklist , /edge , /help , /version Telegram commands \u00b6 Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with /help . Command Description /start Starts the trader /stop Stops the trader /stopbuy | /stopentry Stops the trader from opening new trades. Gracefully closes open trades according to their rules. /reload_config Reloads the configuration file /show_config Shows part of the current configuration with relevant settings to operation /logs [limit] Show last log messages. /status Lists all open trades /status <trade_id> Lists one or more specific trade. Separate multiple with a blank space. /status table List all open trades in a table format. Pending buy orders are marked with an asterisk ( ) Pending sell orders are marked with a double asterisk ( *) /trades [limit] List all recently closed trades in a table format. /delete <trade_id> Delete a specific trade from the Database. Tries to close open orders. Requires manual handling of this trade on the exchange. /count Displays number of trades used and available /locks Show currently locked pairs. /unlock <pair or lock_id> Remove the lock for this pair (or for this lock id). /profit [<n>] Display a summary of your profit/loss from close trades and some stats about your performance, over the last n days (all trades by default) /forceexit <trade_id> | /fx <tradeid> Instantly exits the given trade (Ignoring minimum_roi ). /forceexit all | /fx all Instantly exits all open trades (Ignoring minimum_roi ). /fx alias for /forceexit /forcelong <pair> [rate] Instantly buys the given pair. Rate is optional and only applies to limit orders. ( force_entry_enable must be set to True) /forceshort <pair> [rate] Instantly shorts the given pair. Rate is optional and only applies to limit orders. This will only work on non-spot markets. ( force_entry_enable must be set to True) /performance Show performance of each finished trade grouped by pair /balance Show account balance per currency /daily <n> Shows profit or loss per day, over the last n days (n defaults to 7) /weekly <n> Shows profit or loss per week, over the last n weeks (n defaults to 8) /monthly <n> Shows profit or loss per month, over the last n months (n defaults to 6) /stats Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /exits Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /entries Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /whitelist [sorted] [baseonly] Show the current whitelist. Optionally display in alphabetical order and/or with just the base currency of each pairing. /blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. /edge Show validated pairs by Edge if it is enabled. /help Show help message /version Show version Telegram commands in action \u00b6 Below, example of Telegram message you will receive for each command. /start \u00b6 Status: running /stop \u00b6 Stopping trader ... Status: stopped /stopbuy \u00b6 status: Setting max_open_trades to 0. Run /reload_config to reset. Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...). After this, give the bot time to close off open trades (can be checked via /status table ). Once all positions are sold, run /stop to completely stop the bot. /reload_config resets \"max_open_trades\" to the value set in the configuration and resets this command. Warning The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset. /status \u00b6 For each open trade, the bot will send you the following message. Enter Tag is configurable via Strategy. Trade ID: 123 (since 1 days ago) Current Pair: CVC/BTC Direction: Long Leverage: 1.0 Amount: 26.64180098 Enter Tag: Awesome Long Signal Open Rate: 0.00007489 Current Rate: 0.00007489 Current Profit: 12.95% Stoploss: 0.00007389 (-0.02%) /status table \u00b6 Return the status of all open trades in a table format. ID L/S Pair Since Profit ---- -------- ------- -------- 67 L SC/BTC 1 d 13.33% 123 S CVC/BTC 1 h 12.95% /count \u00b6 Return the number of trades used and available. current max --------- ----- 2 10 /profit \u00b6 Return a summary of your profit/loss and performance. ROI: Close trades \u2219 0.00485701 BTC (2.2%) (15.2 \u03a3%) \u2219 62.968 USD ROI: All trades \u2219 0.00255280 BTC (1.5%) (6.43 \u03a3%) \u2219 33.095 EUR Total Trade Count: 138 First Trade opened: 3 days ago Latest Trade opened: 2 minutes ago Avg. Duration: 2:33:45 Best Performing: PAY/BTC: 50.23% Trading volume: 0.5 BTC Profit factor: 1.04 Max Drawdown: 9.23% (0.01255 BTC) The relative profit of 1.2% is the average profit per trade. The relative profit of 15.2 \u03a3% is be based on the starting capital - so in this case, the starting capital was 0.00485701 * 1.152 = 0.00738 BTC . Starting capital is either taken from the available_capital setting, or calculated by using current wallet size - profits. Profit Factor is calculated as gross profits / gross losses - and should serve as an overall metric for the strategy. Max drawdown corresponds to the backtesting metric Absolute Drawdown (Account) - calculated as (Absolute Drawdown) / (DrawdownHigh + startingBalance) . /forceexit \u00b6 BINANCE: Exiting BTC/LTC with limit 0.01650000 (profit: ~-4.07%, -0.00008168) Tip You can get a list of all open trades by calling /forceexit without parameter, which will show a list of buttons to simply exit a trade. This command has an alias in /fx - which has the same capabilities, but is faster to type in \"emergency\" situations. /forcelong [rate] | /forceshort [rate] \u00b6 /forcebuy <pair> [rate] is also supported for longs but should be considered deprecated. BINANCE: Long ETH/BTC with limit 0.03400000 ( 1.000000 ETH , 225.290 USD ) Omitting the pair will open a query asking for the pair to trade (based on the current whitelist). Trades created through /forcelong will have the buy-tag of force_entry . Note that for this to work, force_entry_enable needs to be set to true. More details /performance \u00b6 Return the performance of each crypto-currency the bot has sold. Performance: 1. RCN/BTC 0.003 BTC (57.77%) (1) 2. PAY/BTC 0.0012 BTC (56.91%) (1) 3. VIB/BTC 0.0011 BTC (47.07%) (1) 4. SALT/BTC 0.0010 BTC (30.24%) (1) 5. STORJ/BTC 0.0009 BTC (27.24%) (1) ... /balance \u00b6 Return the balance of all crypto-currency your have on the exchange. Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0 Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0 /daily \u00b6 Per default /daily will return the 7 last days. The example below if for /daily 3 : Daily Profit over the last 3 days: Day (count) USDT USD Profit % -------------- ------------ ---------- ---------- 2022-06-11 (1) -0.746 USDT -0.75 USD -0.08% 2022-06-10 (0) 0 USDT 0.00 USD 0.00% 2022-06-09 (5) 20 USDT 20.10 USD 5.00% /weekly \u00b6 Per default /weekly will return the 8 last weeks, including the current week. Each week starts from Monday. The example below if for /weekly 3 : Weekly Profit over the last 3 weeks (starting from Monday): Monday (count) Profit BTC Profit USD Profit % ------------- -------------- ------------ ---------- 2018-01-03 (5) 0.00224175 BTC 29,142 USD 4.98% 2017-12-27 (1) 0.00033131 BTC 4,307 USD 0.00% 2017-12-20 (4) 0.00269130 BTC 34.986 USD 5.12% /monthly \u00b6 Per default /monthly will return the 6 last months, including the current month. The example below if for /monthly 3 : Monthly Profit over the last 3 months: Month (count) Profit BTC Profit USD Profit % ------------- -------------- ------------ ---------- 2018-01 (20) 0.00224175 BTC 29,142 USD 4.98% 2017-12 (5) 0.00033131 BTC 4,307 USD 0.00% 2017-11 (10) 0.00269130 BTC 34.986 USD 5.10% /whitelist \u00b6 Shows the current whitelist Using whitelist StaticPairList with 22 pairs IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC /blacklist [pair] \u00b6 Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, separated by a space. Use /reload_config to reset the blacklist. Using blacklist StaticPairList with 2 pairs DODGE/BTC , HOT/BTC . /edge \u00b6 Shows pairs validated by Edge along with their corresponding win-rate, expectancy and stoploss values. Edge only validated following pairs: Pair Winrate Expectancy Stoploss -------- --------- ------------ ---------- DOCK/ETH 0.522727 0.881821 -0.03 PHX/ETH 0.677419 0.560488 -0.03 HOT/ETH 0.733333 0.490492 -0.03 HC/ETH 0.588235 0.280988 -0.02 ARDR/ETH 0.366667 0.143059 -0.01 /version \u00b6 Version: 0.14.3","title":"Telegram"},{"location":"telegram-usage/#telegram-usage","text":"","title":"Telegram usage"},{"location":"telegram-usage/#setup-your-telegram-bot","text":"Below we explain how to create your Telegram Bot, and how to get your Telegram user id.","title":"Setup your Telegram bot"},{"location":"telegram-usage/#1-create-your-telegram-bot","text":"Start a chat with the Telegram BotFather Send the message /newbot . BotFather response: Alright, a new bot. How are we going to call it? Please choose a name for your bot. Choose the public name of your bot (e.x. Freqtrade bot ) BotFather response: Good. Now let's choose a username for your bot. It must end in bot . Like this, for example: TetrisBot or tetris_bot. Choose the name id of your bot and send it to the BotFather (e.g. \" My_own_freqtrade_bot \") BotFather response: Done! Congratulations on your new bot. You will find it at t.me/yourbots_name_bot . You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this. Use this token to access the HTTP API: 22222222:APITOKEN For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key) Copy the API Token ( 22222222:APITOKEN in the above example) and keep use it for the config parameter token . Don't forget to start the conversation with your bot, by clicking /START button","title":"1. Create your Telegram bot"},{"location":"telegram-usage/#2-telegram-user_id","text":"","title":"2. Telegram user_id"},{"location":"telegram-usage/#get-your-user-id","text":"Talk to the userinfobot Get your \"Id\", you will use it for the config parameter chat_id .","title":"Get your user id"},{"location":"telegram-usage/#use-group-id","text":"You can use bots in telegram groups by just adding them to the group. You can find the group id by first adding a RawDataBot to your group. The Group id is shown as id in the \"chat\" section, which the RawDataBot will send to you: \"chat\" :{ \"id\" : -1001332619709 } For the Freqtrade configuration, you can then use the the full value (including - if it's there) as string: \"chat_id\" : \"-1001332619709\" Using telegram groups When using telegram groups, you're giving every member of the telegram group access to your freqtrade bot and to all commands possible via telegram. Please make sure that you can trust everyone in the telegram group to avoid unpleasent surprises.","title":"Use Group id"},{"location":"telegram-usage/#control-telegram-noise","text":"Freqtrade provides means to control the verbosity of your telegram bot. Each setting has the following possible values: on - Messages will be sent, and user will be notified. silent - Message will be sent, Notification will be without sound / vibration. off - Skip sending a message-type all together. Example configuration showing the different settings: \"telegram\" : { \"enabled\" : true , \"token\" : \"your_telegram_token\" , \"chat_id\" : \"your_telegram_chat_id\" , \"notification_settings\" : { \"status\" : \"silent\" , \"warning\" : \"on\" , \"startup\" : \"off\" , \"entry\" : \"silent\" , \"exit\" : { \"roi\" : \"silent\" , \"emergency_exit\" : \"on\" , \"force_exit\" : \"on\" , \"exit_signal\" : \"silent\" , \"trailing_stop_loss\" : \"on\" , \"stop_loss\" : \"on\" , \"stoploss_on_exchange\" : \"on\" , \"custom_exit\" : \"silent\" }, \"entry_cancel\" : \"silent\" , \"exit_cancel\" : \"on\" , \"entry_fill\" : \"off\" , \"exit_fill\" : \"off\" , \"protection_trigger\" : \"off\" , \"protection_trigger_global\" : \"on\" , \"strategy_msg\" : \"off\" , \"show_candle\" : \"off\" }, \"reload\" : true , \"balance_dust_level\" : 0.01 }, entry notifications are sent when the order is placed, while entry_fill notifications are sent when the order is filled on the exchange. exit notifications are sent when the order is placed, while exit_fill notifications are sent when the order is filled on the exchange. *_fill notifications are off by default and must be explicitly enabled. protection_trigger notifications are sent when a protection triggers and protection_trigger_global notifications trigger when global protections are triggered. strategy_msg - Receive notifications from the strategy, sent via self.dp.send_msg() from the strategy more details . show_candle - show candle values as part of entry/exit messages. Only possible values are \"ohlc\" or \"off\" . balance_dust_level will define what the /balance command takes as \"dust\" - Currencies with a balance below this will be shown. reload allows you to disable reload-buttons on selected messages.","title":"Control telegram noise"},{"location":"telegram-usage/#create-a-custom-keyboard-command-shortcut-buttons","text":"Telegram allows us to create a custom keyboard with buttons for commands. The default custom keyboard looks like this. [ [ \"/daily\" , \"/profit\" , \"/balance\" ], # row 1, 3 commands [ \"/status\" , \"/status table\" , \"/performance\" ], # row 2, 3 commands [ \"/count\" , \"/start\" , \"/stop\" , \"/help\" ] # row 3, 4 commands ]","title":"Create a custom keyboard (command shortcut buttons)"},{"location":"telegram-usage/#usage","text":"You can create your own keyboard in config.json : \"telegram\" : { \"enabled\" : true , \"token\" : \"your_telegram_token\" , \"chat_id\" : \"your_telegram_chat_id\" , \"keyboard\" : [ [ \"/daily\" , \"/stats\" , \"/balance\" , \"/profit\" ], [ \"/status table\" , \"/performance\" ], [ \"/reload_config\" , \"/count\" , \"/logs\" ] ] }, Supported Commands Only the following commands are allowed. Command arguments are not supported! /start , /stop , /status , /status table , /trades , /profit , /performance , /daily , /stats , /count , /locks , /balance , /stopentry , /reload_config , /show_config , /logs , /whitelist , /blacklist , /edge , /help , /version","title":"Usage"},{"location":"telegram-usage/#telegram-commands","text":"Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with /help . Command Description /start Starts the trader /stop Stops the trader /stopbuy | /stopentry Stops the trader from opening new trades. Gracefully closes open trades according to their rules. /reload_config Reloads the configuration file /show_config Shows part of the current configuration with relevant settings to operation /logs [limit] Show last log messages. /status Lists all open trades /status <trade_id> Lists one or more specific trade. Separate multiple with a blank space. /status table List all open trades in a table format. Pending buy orders are marked with an asterisk ( ) Pending sell orders are marked with a double asterisk ( *) /trades [limit] List all recently closed trades in a table format. /delete <trade_id> Delete a specific trade from the Database. Tries to close open orders. Requires manual handling of this trade on the exchange. /count Displays number of trades used and available /locks Show currently locked pairs. /unlock <pair or lock_id> Remove the lock for this pair (or for this lock id). /profit [<n>] Display a summary of your profit/loss from close trades and some stats about your performance, over the last n days (all trades by default) /forceexit <trade_id> | /fx <tradeid> Instantly exits the given trade (Ignoring minimum_roi ). /forceexit all | /fx all Instantly exits all open trades (Ignoring minimum_roi ). /fx alias for /forceexit /forcelong <pair> [rate] Instantly buys the given pair. Rate is optional and only applies to limit orders. ( force_entry_enable must be set to True) /forceshort <pair> [rate] Instantly shorts the given pair. Rate is optional and only applies to limit orders. This will only work on non-spot markets. ( force_entry_enable must be set to True) /performance Show performance of each finished trade grouped by pair /balance Show account balance per currency /daily <n> Shows profit or loss per day, over the last n days (n defaults to 7) /weekly <n> Shows profit or loss per week, over the last n weeks (n defaults to 8) /monthly <n> Shows profit or loss per month, over the last n months (n defaults to 6) /stats Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /exits Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /entries Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells /whitelist [sorted] [baseonly] Show the current whitelist. Optionally display in alphabetical order and/or with just the base currency of each pairing. /blacklist [pair] Show the current blacklist, or adds a pair to the blacklist. /edge Show validated pairs by Edge if it is enabled. /help Show help message /version Show version","title":"Telegram commands"},{"location":"telegram-usage/#telegram-commands-in-action","text":"Below, example of Telegram message you will receive for each command.","title":"Telegram commands in action"},{"location":"telegram-usage/#start","text":"Status: running","title":"/start"},{"location":"telegram-usage/#stop","text":"Stopping trader ... Status: stopped","title":"/stop"},{"location":"telegram-usage/#stopbuy","text":"status: Setting max_open_trades to 0. Run /reload_config to reset. Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...). After this, give the bot time to close off open trades (can be checked via /status table ). Once all positions are sold, run /stop to completely stop the bot. /reload_config resets \"max_open_trades\" to the value set in the configuration and resets this command. Warning The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset.","title":"/stopbuy"},{"location":"telegram-usage/#status","text":"For each open trade, the bot will send you the following message. Enter Tag is configurable via Strategy. Trade ID: 123 (since 1 days ago) Current Pair: CVC/BTC Direction: Long Leverage: 1.0 Amount: 26.64180098 Enter Tag: Awesome Long Signal Open Rate: 0.00007489 Current Rate: 0.00007489 Current Profit: 12.95% Stoploss: 0.00007389 (-0.02%)","title":"/status"},{"location":"telegram-usage/#status-table","text":"Return the status of all open trades in a table format. ID L/S Pair Since Profit ---- -------- ------- -------- 67 L SC/BTC 1 d 13.33% 123 S CVC/BTC 1 h 12.95%","title":"/status table"},{"location":"telegram-usage/#count","text":"Return the number of trades used and available. current max --------- ----- 2 10","title":"/count"},{"location":"telegram-usage/#profit","text":"Return a summary of your profit/loss and performance. ROI: Close trades \u2219 0.00485701 BTC (2.2%) (15.2 \u03a3%) \u2219 62.968 USD ROI: All trades \u2219 0.00255280 BTC (1.5%) (6.43 \u03a3%) \u2219 33.095 EUR Total Trade Count: 138 First Trade opened: 3 days ago Latest Trade opened: 2 minutes ago Avg. Duration: 2:33:45 Best Performing: PAY/BTC: 50.23% Trading volume: 0.5 BTC Profit factor: 1.04 Max Drawdown: 9.23% (0.01255 BTC) The relative profit of 1.2% is the average profit per trade. The relative profit of 15.2 \u03a3% is be based on the starting capital - so in this case, the starting capital was 0.00485701 * 1.152 = 0.00738 BTC . Starting capital is either taken from the available_capital setting, or calculated by using current wallet size - profits. Profit Factor is calculated as gross profits / gross losses - and should serve as an overall metric for the strategy. Max drawdown corresponds to the backtesting metric Absolute Drawdown (Account) - calculated as (Absolute Drawdown) / (DrawdownHigh + startingBalance) .","title":"/profit"},{"location":"telegram-usage/#forceexit","text":"BINANCE: Exiting BTC/LTC with limit 0.01650000 (profit: ~-4.07%, -0.00008168) Tip You can get a list of all open trades by calling /forceexit without parameter, which will show a list of buttons to simply exit a trade. This command has an alias in /fx - which has the same capabilities, but is faster to type in \"emergency\" situations.","title":"/forceexit "},{"location":"telegram-usage/#forcelong-rate-forceshort-rate","text":"/forcebuy <pair> [rate] is also supported for longs but should be considered deprecated. BINANCE: Long ETH/BTC with limit 0.03400000 ( 1.000000 ETH , 225.290 USD ) Omitting the pair will open a query asking for the pair to trade (based on the current whitelist). Trades created through /forcelong will have the buy-tag of force_entry . Note that for this to work, force_entry_enable needs to be set to true. More details","title":"/forcelong  [rate] | /forceshort  [rate]"},{"location":"telegram-usage/#performance","text":"Return the performance of each crypto-currency the bot has sold. Performance: 1. RCN/BTC 0.003 BTC (57.77%) (1) 2. PAY/BTC 0.0012 BTC (56.91%) (1) 3. VIB/BTC 0.0011 BTC (47.07%) (1) 4. SALT/BTC 0.0010 BTC (30.24%) (1) 5. STORJ/BTC 0.0009 BTC (27.24%) (1) ...","title":"/performance"},{"location":"telegram-usage/#balance","text":"Return the balance of all crypto-currency your have on the exchange. Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0 Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0","title":"/balance"},{"location":"telegram-usage/#daily","text":"Per default /daily will return the 7 last days. The example below if for /daily 3 : Daily Profit over the last 3 days: Day (count) USDT USD Profit % -------------- ------------ ---------- ---------- 2022-06-11 (1) -0.746 USDT -0.75 USD -0.08% 2022-06-10 (0) 0 USDT 0.00 USD 0.00% 2022-06-09 (5) 20 USDT 20.10 USD 5.00%","title":"/daily "},{"location":"telegram-usage/#weekly","text":"Per default /weekly will return the 8 last weeks, including the current week. Each week starts from Monday. The example below if for /weekly 3 : Weekly Profit over the last 3 weeks (starting from Monday): Monday (count) Profit BTC Profit USD Profit % ------------- -------------- ------------ ---------- 2018-01-03 (5) 0.00224175 BTC 29,142 USD 4.98% 2017-12-27 (1) 0.00033131 BTC 4,307 USD 0.00% 2017-12-20 (4) 0.00269130 BTC 34.986 USD 5.12%","title":"/weekly "},{"location":"telegram-usage/#monthly","text":"Per default /monthly will return the 6 last months, including the current month. The example below if for /monthly 3 : Monthly Profit over the last 3 months: Month (count) Profit BTC Profit USD Profit % ------------- -------------- ------------ ---------- 2018-01 (20) 0.00224175 BTC 29,142 USD 4.98% 2017-12 (5) 0.00033131 BTC 4,307 USD 0.00% 2017-11 (10) 0.00269130 BTC 34.986 USD 5.10%","title":"/monthly "},{"location":"telegram-usage/#whitelist","text":"Shows the current whitelist Using whitelist StaticPairList with 22 pairs IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC","title":"/whitelist"},{"location":"telegram-usage/#blacklist-pair","text":"Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, separated by a space. Use /reload_config to reset the blacklist. Using blacklist StaticPairList with 2 pairs DODGE/BTC , HOT/BTC .","title":"/blacklist [pair]"},{"location":"telegram-usage/#edge","text":"Shows pairs validated by Edge along with their corresponding win-rate, expectancy and stoploss values. Edge only validated following pairs: Pair Winrate Expectancy Stoploss -------- --------- ------------ ---------- DOCK/ETH 0.522727 0.881821 -0.03 PHX/ETH 0.677419 0.560488 -0.03 HOT/ETH 0.733333 0.490492 -0.03 HC/ETH 0.588235 0.280988 -0.02 ARDR/ETH 0.366667 0.143059 -0.01","title":"/edge"},{"location":"telegram-usage/#version","text":"Version: 0.14.3","title":"/version"},{"location":"updating/","text":"How to update \u00b6 To update your freqtrade installation, please use one of the below methods, corresponding to your installation method. Tracking changes Breaking changes / changed behavior will be documented in the changelog that is posted alongside every release. For the develop branch, please follow PR's to avoid being surprised by changes. docker-compose \u00b6 Legacy installations using the master image We're switching from master to stable for the release Images - please adjust your docker-file and replace freqtradeorg/freqtrade:master with freqtradeorg/freqtrade:stable docker-compose pull docker-compose up -d Installation via setup script \u00b6 ./setup.sh --update Note Make sure to run this command with your virtual environment disabled! Plain native installation \u00b6 Please ensure that you're also updating dependencies - otherwise things might break without you noticing. git pull pip install -U -r requirements.txt pip install -e . # Ensure freqUI is at the latest version freqtrade install-ui","title":"Updating Freqtrade"},{"location":"updating/#how-to-update","text":"To update your freqtrade installation, please use one of the below methods, corresponding to your installation method. Tracking changes Breaking changes / changed behavior will be documented in the changelog that is posted alongside every release. For the develop branch, please follow PR's to avoid being surprised by changes.","title":"How to update"},{"location":"updating/#docker-compose","text":"Legacy installations using the master image We're switching from master to stable for the release Images - please adjust your docker-file and replace freqtradeorg/freqtrade:master with freqtradeorg/freqtrade:stable docker-compose pull docker-compose up -d","title":"docker-compose"},{"location":"updating/#installation-via-setup-script","text":"./setup.sh --update Note Make sure to run this command with your virtual environment disabled!","title":"Installation via setup script"},{"location":"updating/#plain-native-installation","text":"Please ensure that you're also updating dependencies - otherwise things might break without you noticing. git pull pip install -U -r requirements.txt pip install -e . # Ensure freqUI is at the latest version freqtrade install-ui","title":"Plain native installation"},{"location":"utils/","text":"Utility Subcommands \u00b6 Besides the Live-Trade and Dry-Run run modes, the backtesting , edge and hyperopt optimization subcommands, and the download-data subcommand which prepares historical data, the bot contains a number of utility subcommands. They are described in this section. Create userdir \u00b6 Creates the directory structure to hold your files for freqtrade. Will also create strategy and hyperopt examples for you to get started. Can be used multiple times - using --reset will reset the sample strategy and hyperopt files to their default state. usage: freqtrade create-userdir [-h] [--userdir PATH] [--reset] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. --reset Reset sample files to their original state. Warning Using --reset may result in loss of data, since this will overwrite all sample files without asking again. \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 hyperopts \u2502 \u251c\u2500\u2500 sample_hyperopt_loss.py \u251c\u2500\u2500 notebooks \u2502 \u2514\u2500\u2500 strategy_analysis_example.ipynb \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies \u2514\u2500\u2500 sample_strategy.py Create new config \u00b6 Creates a new configuration file, asking some questions which are important selections for a configuration. usage: freqtrade new-config [-h] [-c PATH] optional arguments: -h, --help show this help message and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. Warning Only vital questions are asked. Freqtrade offers a lot more configuration possibilities, which are listed in the Configuration documentation Create config examples \u00b6 $ freqtrade new-config --config config_binance.json ? Do you want to enable Dry-run (simulated trades)? Yes ? Please insert your stake currency: BTC ? Please insert your stake amount: 0.05 ? Please insert max_open_trades (Integer or -1 for unlimited open trades): 3 ? Please insert your desired timeframe (e.g. 5m): 5m ? Please insert your display Currency (for reporting): USD ? Select exchange binance ? Do you want to enable Telegram? No Create new strategy \u00b6 Creates a new strategy from a template similar to SampleStrategy. The file will be named inline with your class name, and will not overwrite existing files. Results will be located in user_data/strategies/<strategyclassname>.py . usage: freqtrade new-strategy [-h] [--userdir PATH] [-s NAME] [--template {full,minimal,advanced}] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --template {full,minimal,advanced} Use a template which is either `minimal`, `full` (containing multiple sample indicators) or `advanced`. Default: `full`. Sample usage of new-strategy \u00b6 freqtrade new-strategy --strategy AwesomeStrategy With custom user directory freqtrade new-strategy --userdir ~/.freqtrade/ --strategy AwesomeStrategy Using the advanced template (populates all optional functions and methods) freqtrade new-strategy --strategy AwesomeStrategy --template advanced List Strategies \u00b6 Use the list-strategies subcommand to see all strategies in one particular directory. This subcommand is useful for finding problems in your environment with loading strategies: modules with strategies that contain errors and failed to load are printed in red (LOAD FAILED), while strategies with duplicate names are printed in yellow (DUPLICATE NAME). usage: freqtrade list-strategies [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--strategy-path PATH] [-1] [--no-color] [--recursive-strategy-search] optional arguments: -h, --help show this help message and exit --strategy-path PATH Specify additional strategy lookup path. -1, --one-column Print output in one column. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --recursive-strategy-search Recursively search for a strategy in the strategies folder. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Warning Using these commands will try to load all python files from a directory. This can be a security risk if untrusted files reside in this directory, since all module-level code is executed. Example: Search default strategies directories (within the default userdir). freqtrade list-strategies Example: Search strategies directory within the userdir. freqtrade list-strategies --userdir ~/.freqtrade/ Example: Search dedicated strategy path. freqtrade list-strategies --strategy-path ~/.freqtrade/strategies/ List Exchanges \u00b6 Use the list-exchanges subcommand to see the exchanges available for the bot. usage: freqtrade list-exchanges [-h] [-1] [-a] optional arguments: -h, --help show this help message and exit -1, --one-column Print output in one column. -a, --all Print all exchanges known to the ccxt library. Example: see exchanges available for the bot: $ freqtrade list-exchanges Exchanges available for Freqtrade: Exchange name Valid reason --------------- ------- -------------------------------------------- aax True ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bitbank True missing opt: fetchTickers bitcoincom True bitfinex True bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitpanda True bittrex True bitvavo True bitz True missing opt: fetchMyTrades btcalpha True missing opt: fetchTicker, fetchTickers btcmarkets True missing opt: fetchTickers buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coinex True crex24 True deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers ftx True gateio True gemini True gopax True hbtc True hitbtc True huobijp True huobipro True idex True kraken True kucoin True lbank True missing opt: fetchMyTrades mercado True missing opt: fetchTickers ndax True missing opt: fetchTickers novadax True okcoin True okex True probit True qtrade True stex True timex True upbit True missing opt: fetchMyTrades vcc True zb True missing opt: fetchMyTrades missing opt exchanges Values with \"missing opt:\" might need special configuration (e.g. using orderbook if fetchTickers is missing) - but should in theory work (although we cannot guarantee they will). Example: see all exchanges supported by the ccxt library (including 'bad' ones, i.e. those that are known to not work with Freqtrade): $ freqtrade list-exchanges -a All exchanges supported by the ccxt library: Exchange name Valid reason ------------------ ------- --------------------------------------------------------------------------------------- aax True aofex False missing: fetchOrder ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bit2c False missing: fetchOrder, fetchOHLCV bitbank True missing opt: fetchTickers bitbay False missing: fetchOrder bitcoincom True bitfinex True bitfinex2 False missing: fetchOrder bitflyer False missing: fetchOrder, fetchOHLCV bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitmex False Various reasons. bitpanda True bitso False missing: fetchOHLCV bitstamp True missing opt: fetchTickers bitstamp1 False missing: fetchOrder, fetchOHLCV bittrex True bitvavo True bitz True missing opt: fetchMyTrades bl3p False missing: fetchOrder, fetchOHLCV bleutrade False missing: fetchOrder braziliex False missing: fetchOHLCV btcalpha True missing opt: fetchTicker, fetchTickers btcbox False missing: fetchOHLCV btcmarkets True missing opt: fetchTickers btctradeua False missing: fetchOrder, fetchOHLCV btcturk False missing: fetchOrder buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades chilebit False missing: fetchOrder, fetchOHLCV coinbase False missing: fetchOrder, cancelOrder, createOrder, fetchOHLCV coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coincheck False missing: fetchOrder, fetchOHLCV coinegg False missing: fetchOHLCV coinex True coinfalcon False missing: fetchOHLCV coinfloor False missing: fetchOrder, fetchOHLCV coingi False missing: fetchOrder, fetchOHLCV coinmarketcap False missing: fetchOrder, cancelOrder, createOrder, fetchBalance, fetchOHLCV coinmate False missing: fetchOHLCV coinone False missing: fetchOHLCV coinspot False missing: fetchOrder, cancelOrder, fetchOHLCV crex24 True currencycom False missing: fetchOrder delta False missing: fetchOrder deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True exmo False missing: fetchOrder exx False missing: fetchOHLCV fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers flowbtc False missing: fetchOrder, fetchOHLCV foxbit False missing: fetchOrder, fetchOHLCV ftx True gateio True gemini True gopax True hbtc True hitbtc True hollaex False missing: fetchOrder huobijp True huobipro True idex True independentreserve False missing: fetchOHLCV indodax False missing: fetchOHLCV itbit False missing: fetchOHLCV kraken True kucoin True kuna False missing: fetchOHLCV lakebtc False missing: fetchOrder, fetchOHLCV latoken False missing: fetchOrder, fetchOHLCV lbank True missing opt: fetchMyTrades liquid False missing: fetchOHLCV luno False missing: fetchOHLCV lykke False missing: fetchOHLCV mercado True missing opt: fetchTickers mixcoins False missing: fetchOrder, fetchOHLCV ndax True missing opt: fetchTickers novadax True oceanex False missing: fetchOHLCV okcoin True okex True paymium False missing: fetchOrder, fetchOHLCV phemex False Does not provide history. poloniex False missing: fetchOrder probit True qtrade True rightbtc False missing: fetchOrder ripio False missing: fetchOHLCV southxchange False missing: fetchOrder, fetchOHLCV stex True surbitcoin False missing: fetchOrder, fetchOHLCV therock False missing: fetchOHLCV tidebit False missing: fetchOrder tidex False missing: fetchOHLCV timex True upbit True missing opt: fetchMyTrades vbtc False missing: fetchOrder, fetchOHLCV vcc True wavesexchange False missing: fetchOrder whitebit False missing: fetchOrder, cancelOrder, createOrder, fetchBalance xbtce False missing: fetchOrder, fetchOHLCV xena False missing: fetchOrder yobit False missing: fetchOHLCV zaif False missing: fetchOrder, fetchOHLCV zb True missing opt: fetchMyTrades List Timeframes \u00b6 Use the list-timeframes subcommand to see the list of timeframes available for the exchange. usage: freqtrade list-timeframes [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [-1] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. -1, --one-column Print output in one column. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example: see the timeframes for the 'binance' exchange, set in the configuration file: $ freqtrade list-timeframes -c config_binance.json ... Timeframes available for the exchange `binance`: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M Example: enumerate exchanges available for Freqtrade and print timeframes supported by each of them: $ for i in `freqtrade list-exchanges -1`; do freqtrade list-timeframes --exchange $i; done List pairs/list markets \u00b6 The list-pairs and list-markets subcommands allow to see the pairs/markets available on exchange. Pairs are markets with the '/' character between the base currency part and the quote currency part in the market symbol. For example, in the 'ETH/BTC' pair 'ETH' is the base currency, while 'BTC' is the quote currency. For pairs traded by Freqtrade the pair quote currency is defined by the value of the stake_currency configuration setting. You can print info about any pair/market with these subcommands - and you can filter output by quote-currency using --quote BTC , or by base-currency using --base ETH options correspondingly. These subcommands have same usage and same set of available options: usage: freqtrade list-markets [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] [--trading-mode {spot,margin,futures}] usage: freqtrade list-pairs [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] [--trading-mode {spot,margin,futures}] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --print-list Print list of pairs or market symbols. By default data is printed in the tabular format. --print-json Print list of pairs or market symbols in JSON format. -1, --one-column Print output in one column. --print-csv Print exchange pair or market data in the csv format. --base BASE_CURRENCY [BASE_CURRENCY ...] Specify base currency(-ies). Space-separated list. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -a, --all Print all pairs or market symbols. By default only active ones are shown. --trading-mode {spot,margin,futures} Select Trading mode Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. By default, only active pairs/markets are shown. Active pairs/markets are those that can currently be traded on the exchange. The see the list of all pairs/markets (not only the active ones), use the -a / -all option. Pairs/markets are sorted by its symbol string in the printed output. Examples \u00b6 Print the list of active pairs with quote currency USD on exchange, specified in the default configuration file (i.e. pairs on the \"Bittrex\" exchange) in JSON format: $ freqtrade list-pairs --quote USD --print-json Print the list of all pairs on the exchange, specified in the config_binance.json configuration file (i.e. on the \"Binance\" exchange) with base currencies BTC or ETH and quote currencies USDT or USD, as the human-readable list with summary: $ freqtrade list-pairs -c config_binance.json --all --base BTC ETH --quote USDT USD --print-list Print all markets on exchange \"Kraken\", in the tabular format: $ freqtrade list-markets --exchange kraken --all Test pairlist \u00b6 Use the test-pairlist subcommand to test the configuration of dynamic pairlists . Requires a configuration with specified pairlists attribute. Can be used to generate static pairlists to be used during backtesting / hyperopt. usage: freqtrade test-pairlist [-h] [-v] [-c PATH] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-1] [--print-json] [--exchange EXCHANGE] optional arguments: -h, --help show this help message and exit -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -1, --one-column Print output in one column. --print-json Print list of pairs or market symbols in JSON format. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. Examples \u00b6 Show whitelist when using a dynamic pairlist . freqtrade test-pairlist --config config.json --quote USDT BTC Convert database \u00b6 freqtrade convert-db can be used to convert your database from one system to another (sqlite -> postgres, postgres -> other postgres), migrating all trades, orders and Pairlocks. Please refer to the SQL cheatsheet to learn about requirements for different database systems. usage: freqtrade convert-db [-h] [--db-url PATH] [--db-url-from PATH] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --db-url-from PATH Source db url to use when migrating a database. Warning Please ensure to only use this on an empty target database. Freqtrade will perform a regular migration, but may fail if entries already existed. Webserver mode \u00b6 Experimental Webserver mode is an experimental mode to increase backesting and strategy development productivity. There may still be bugs - so if you happen to stumble across these, please report them as github issues, thanks. Run freqtrade in webserver mode. Freqtrade will start the webserver and allow FreqUI to start and control backtesting processes. This has the advantage that data will not be reloaded between backtesting runs (as long as timeframe and timerange remain identical). FreqUI will also show the backtesting results. usage: freqtrade webserver [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] optional arguments: -h, --help show this help message and exit Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Webserver mode - docker \u00b6 You can also use webserver mode via docker. Starting a one-off container requires the configuration of the port explicitly, as ports are not exposed by default. You can use docker-compose run --rm -p 127.0.0.1:8080:8080 freqtrade webserver to start a one-off container that'll be removed once you stop it. This assumes that port 8080 is still available and no other bot is running on that port. Alternatively, you can reconfigure the docker-compose file to have the command updated: command: > webserver --config /freqtrade/user_data/config.json You can now use docker-compose up to start the webserver. This assumes that the configuration has a webserver enabled and configured for docker (listening port = 0.0.0.0 ). Tip Don't forget to reset the command back to the trade command if you want to start a live or dry-run bot. Show previous Backtest results \u00b6 Allows you to show previous backtest results. Adding --show-pair-list outputs a sorted pair list you can easily copy/paste into your configuration (omitting bad pairs). Strategy overfitting Only using winning pairs can lead to an overfitted strategy, which will not work well on future data. Make sure to extensively test your strategy in dry-run before risking real money. usage: freqtrade backtesting-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--show-pair-list] optional arguments: -h, --help show this help message and exit --export-filename PATH Save backtest results to the file with this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --show-pair-list Show backtesting pairlist sorted by profit. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Detailed backtest analysis \u00b6 Advanced backtest result analysis. More details in the Backtesting analysis Section. usage: freqtrade backtesting-analysis [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...]] [--enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...]] [--exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...]] [--indicator-list INDICATOR_LIST [INDICATOR_LIST ...]] optional arguments: -h, --help show this help message and exit --export-filename PATH, --backtest-filename PATH Use this filename for backtest results.Requires `--export` to be set as well. Example: `--export-filen ame=user_data/backtest_results/backtest_today.json` --analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...] grouping output - 0: simple wins/losses by enter tag, 1: by enter_tag, 2: by enter_tag and exit_tag, 3: by pair and enter_tag, 4: by pair, enter_ and exit_tag (this can get quite large) --enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...] Comma separated list of entry signals to analyse. Default: all. e.g. 'entry_tag_a,entry_tag_b' --exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...] Comma separated list of exit signals to analyse. Default: all. e.g. 'exit_tag_a,roi,stop_loss,trailing_stop_loss' --indicator-list INDICATOR_LIST [INDICATOR_LIST ...] Comma separated list of indicators to analyse. e.g. 'close,rsi,bb_lowerband,profit_abs' Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. List Hyperopt results \u00b6 You can list the hyperoptimization epochs the Hyperopt module evaluated previously with the hyperopt-list sub-command. usage: freqtrade hyperopt-list [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [--min-trades INT] [--max-trades INT] [--min-avg-time FLOAT] [--max-avg-time FLOAT] [--min-avg-profit FLOAT] [--max-avg-profit FLOAT] [--min-total-profit FLOAT] [--max-total-profit FLOAT] [--min-objective FLOAT] [--max-objective FLOAT] [--no-color] [--print-json] [--no-details] [--hyperopt-filename PATH] [--export-csv FILE] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. --min-trades INT Select epochs with more than INT trades. --max-trades INT Select epochs with less than INT trades. --min-avg-time FLOAT Select epochs above average time. --max-avg-time FLOAT Select epochs below average time. --min-avg-profit FLOAT Select epochs above average profit. --max-avg-profit FLOAT Select epochs below average profit. --min-total-profit FLOAT Select epochs above total profit. --max-total-profit FLOAT Select epochs below total profit. --min-objective FLOAT Select epochs above objective. --max-objective FLOAT Select epochs below objective. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. --no-details Do not print best epoch details. --hyperopt-filename FILENAME Hyperopt result filename.Example: `--hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle` --export-csv FILE Export to CSV-File. This will disable table print. Example: --export-csv hyperopt.csv Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Note hyperopt-list will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!). Examples \u00b6 List all results, print details of the best result at the end: freqtrade hyperopt-list List only epochs with positive profit. Do not print the details of the best epoch, so that the list can be iterated in a script: freqtrade hyperopt-list --profitable --no-details Show details of Hyperopt results \u00b6 You can show the details of any hyperoptimization epoch previously evaluated by the Hyperopt module with the hyperopt-show subcommand. usage: freqtrade hyperopt-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [-n INT] [--print-json] [--hyperopt-filename FILENAME] [--no-header] [--disable-param-export] [--breakdown {day,week,month} [{day,week,month} ...]] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. -n INT, --index INT Specify the index of the epoch to print details for. --print-json Print output in JSON format. --hyperopt-filename FILENAME Hyperopt result filename.Example: `--hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle` --no-header Do not print epoch details header. --disable-param-export Disable automatic hyperopt parameter export. --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Note hyperopt-show will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!). Examples \u00b6 Print details for the epoch 168 (the number of the epoch is shown by the hyperopt-list subcommand or by Hyperopt itself during hyperoptimization run): freqtrade hyperopt-show -n 168 Prints JSON data with details for the last best epoch (i.e., the best of all epochs): freqtrade hyperopt-show --best -n -1 --print-json --no-header Show trades \u00b6 Print selected (or all) trades from database to screen. usage: freqtrade show-trades [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--db-url PATH] [--trade-ids TRADE_IDS [TRADE_IDS ...]] [--print-json] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-ids TRADE_IDS [TRADE_IDS ...] Specify the list of trade ids. --print-json Print output in JSON format. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Examples \u00b6 Print trades with id 2 and 3 as json freqtrade show-trades --db-url sqlite:///tradesv3.sqlite --trade-ids 2 3 --print-json","title":"Utility Sub-commands"},{"location":"utils/#utility-subcommands","text":"Besides the Live-Trade and Dry-Run run modes, the backtesting , edge and hyperopt optimization subcommands, and the download-data subcommand which prepares historical data, the bot contains a number of utility subcommands. They are described in this section.","title":"Utility Subcommands"},{"location":"utils/#create-userdir","text":"Creates the directory structure to hold your files for freqtrade. Will also create strategy and hyperopt examples for you to get started. Can be used multiple times - using --reset will reset the sample strategy and hyperopt files to their default state. usage: freqtrade create-userdir [-h] [--userdir PATH] [--reset] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. --reset Reset sample files to their original state. Warning Using --reset may result in loss of data, since this will overwrite all sample files without asking again. \u251c\u2500\u2500 backtest_results \u251c\u2500\u2500 data \u251c\u2500\u2500 hyperopt_results \u251c\u2500\u2500 hyperopts \u2502 \u251c\u2500\u2500 sample_hyperopt_loss.py \u251c\u2500\u2500 notebooks \u2502 \u2514\u2500\u2500 strategy_analysis_example.ipynb \u251c\u2500\u2500 plot \u2514\u2500\u2500 strategies \u2514\u2500\u2500 sample_strategy.py","title":"Create userdir"},{"location":"utils/#create-new-config","text":"Creates a new configuration file, asking some questions which are important selections for a configuration. usage: freqtrade new-config [-h] [-c PATH] optional arguments: -h, --help show this help message and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. Warning Only vital questions are asked. Freqtrade offers a lot more configuration possibilities, which are listed in the Configuration documentation","title":"Create new config"},{"location":"utils/#create-config-examples","text":"$ freqtrade new-config --config config_binance.json ? Do you want to enable Dry-run (simulated trades)? Yes ? Please insert your stake currency: BTC ? Please insert your stake amount: 0.05 ? Please insert max_open_trades (Integer or -1 for unlimited open trades): 3 ? Please insert your desired timeframe (e.g. 5m): 5m ? Please insert your display Currency (for reporting): USD ? Select exchange binance ? Do you want to enable Telegram? No","title":"Create config examples"},{"location":"utils/#create-new-strategy","text":"Creates a new strategy from a template similar to SampleStrategy. The file will be named inline with your class name, and will not overwrite existing files. Results will be located in user_data/strategies/<strategyclassname>.py . usage: freqtrade new-strategy [-h] [--userdir PATH] [-s NAME] [--template {full,minimal,advanced}] optional arguments: -h, --help show this help message and exit --userdir PATH, --user-data-dir PATH Path to userdata directory. -s NAME, --strategy NAME Specify strategy class name which will be used by the bot. --template {full,minimal,advanced} Use a template which is either `minimal`, `full` (containing multiple sample indicators) or `advanced`. Default: `full`.","title":"Create new strategy"},{"location":"utils/#sample-usage-of-new-strategy","text":"freqtrade new-strategy --strategy AwesomeStrategy With custom user directory freqtrade new-strategy --userdir ~/.freqtrade/ --strategy AwesomeStrategy Using the advanced template (populates all optional functions and methods) freqtrade new-strategy --strategy AwesomeStrategy --template advanced","title":"Sample usage of new-strategy"},{"location":"utils/#list-strategies","text":"Use the list-strategies subcommand to see all strategies in one particular directory. This subcommand is useful for finding problems in your environment with loading strategies: modules with strategies that contain errors and failed to load are printed in red (LOAD FAILED), while strategies with duplicate names are printed in yellow (DUPLICATE NAME). usage: freqtrade list-strategies [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--strategy-path PATH] [-1] [--no-color] [--recursive-strategy-search] optional arguments: -h, --help show this help message and exit --strategy-path PATH Specify additional strategy lookup path. -1, --one-column Print output in one column. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --recursive-strategy-search Recursively search for a strategy in the strategies folder. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Warning Using these commands will try to load all python files from a directory. This can be a security risk if untrusted files reside in this directory, since all module-level code is executed. Example: Search default strategies directories (within the default userdir). freqtrade list-strategies Example: Search strategies directory within the userdir. freqtrade list-strategies --userdir ~/.freqtrade/ Example: Search dedicated strategy path. freqtrade list-strategies --strategy-path ~/.freqtrade/strategies/","title":"List Strategies"},{"location":"utils/#list-exchanges","text":"Use the list-exchanges subcommand to see the exchanges available for the bot. usage: freqtrade list-exchanges [-h] [-1] [-a] optional arguments: -h, --help show this help message and exit -1, --one-column Print output in one column. -a, --all Print all exchanges known to the ccxt library. Example: see exchanges available for the bot: $ freqtrade list-exchanges Exchanges available for Freqtrade: Exchange name Valid reason --------------- ------- -------------------------------------------- aax True ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bitbank True missing opt: fetchTickers bitcoincom True bitfinex True bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitpanda True bittrex True bitvavo True bitz True missing opt: fetchMyTrades btcalpha True missing opt: fetchTicker, fetchTickers btcmarkets True missing opt: fetchTickers buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coinex True crex24 True deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers ftx True gateio True gemini True gopax True hbtc True hitbtc True huobijp True huobipro True idex True kraken True kucoin True lbank True missing opt: fetchMyTrades mercado True missing opt: fetchTickers ndax True missing opt: fetchTickers novadax True okcoin True okex True probit True qtrade True stex True timex True upbit True missing opt: fetchMyTrades vcc True zb True missing opt: fetchMyTrades missing opt exchanges Values with \"missing opt:\" might need special configuration (e.g. using orderbook if fetchTickers is missing) - but should in theory work (although we cannot guarantee they will). Example: see all exchanges supported by the ccxt library (including 'bad' ones, i.e. those that are known to not work with Freqtrade): $ freqtrade list-exchanges -a All exchanges supported by the ccxt library: Exchange name Valid reason ------------------ ------- --------------------------------------------------------------------------------------- aax True aofex False missing: fetchOrder ascendex True missing opt: fetchMyTrades bequant True bibox True bigone True binance True binanceus True bit2c False missing: fetchOrder, fetchOHLCV bitbank True missing opt: fetchTickers bitbay False missing: fetchOrder bitcoincom True bitfinex True bitfinex2 False missing: fetchOrder bitflyer False missing: fetchOrder, fetchOHLCV bitforex True missing opt: fetchMyTrades, fetchTickers bitget True bithumb True missing opt: fetchMyTrades bitkk True missing opt: fetchMyTrades bitmart True bitmax True missing opt: fetchMyTrades bitmex False Various reasons. bitpanda True bitso False missing: fetchOHLCV bitstamp True missing opt: fetchTickers bitstamp1 False missing: fetchOrder, fetchOHLCV bittrex True bitvavo True bitz True missing opt: fetchMyTrades bl3p False missing: fetchOrder, fetchOHLCV bleutrade False missing: fetchOrder braziliex False missing: fetchOHLCV btcalpha True missing opt: fetchTicker, fetchTickers btcbox False missing: fetchOHLCV btcmarkets True missing opt: fetchTickers btctradeua False missing: fetchOrder, fetchOHLCV btcturk False missing: fetchOrder buda True missing opt: fetchMyTrades, fetchTickers bw True missing opt: fetchMyTrades, fetchL2OrderBook bybit True bytetrade True cdax True cex True missing opt: fetchMyTrades chilebit False missing: fetchOrder, fetchOHLCV coinbase False missing: fetchOrder, cancelOrder, createOrder, fetchOHLCV coinbaseprime True missing opt: fetchTickers coinbasepro True missing opt: fetchTickers coincheck False missing: fetchOrder, fetchOHLCV coinegg False missing: fetchOHLCV coinex True coinfalcon False missing: fetchOHLCV coinfloor False missing: fetchOrder, fetchOHLCV coingi False missing: fetchOrder, fetchOHLCV coinmarketcap False missing: fetchOrder, cancelOrder, createOrder, fetchBalance, fetchOHLCV coinmate False missing: fetchOHLCV coinone False missing: fetchOHLCV coinspot False missing: fetchOrder, cancelOrder, fetchOHLCV crex24 True currencycom False missing: fetchOrder delta False missing: fetchOrder deribit True digifinex True equos True missing opt: fetchTicker, fetchTickers eterbase True exmo False missing: fetchOrder exx False missing: fetchOHLCV fcoin True missing opt: fetchMyTrades, fetchTickers fcoinjp True missing opt: fetchMyTrades, fetchTickers flowbtc False missing: fetchOrder, fetchOHLCV foxbit False missing: fetchOrder, fetchOHLCV ftx True gateio True gemini True gopax True hbtc True hitbtc True hollaex False missing: fetchOrder huobijp True huobipro True idex True independentreserve False missing: fetchOHLCV indodax False missing: fetchOHLCV itbit False missing: fetchOHLCV kraken True kucoin True kuna False missing: fetchOHLCV lakebtc False missing: fetchOrder, fetchOHLCV latoken False missing: fetchOrder, fetchOHLCV lbank True missing opt: fetchMyTrades liquid False missing: fetchOHLCV luno False missing: fetchOHLCV lykke False missing: fetchOHLCV mercado True missing opt: fetchTickers mixcoins False missing: fetchOrder, fetchOHLCV ndax True missing opt: fetchTickers novadax True oceanex False missing: fetchOHLCV okcoin True okex True paymium False missing: fetchOrder, fetchOHLCV phemex False Does not provide history. poloniex False missing: fetchOrder probit True qtrade True rightbtc False missing: fetchOrder ripio False missing: fetchOHLCV southxchange False missing: fetchOrder, fetchOHLCV stex True surbitcoin False missing: fetchOrder, fetchOHLCV therock False missing: fetchOHLCV tidebit False missing: fetchOrder tidex False missing: fetchOHLCV timex True upbit True missing opt: fetchMyTrades vbtc False missing: fetchOrder, fetchOHLCV vcc True wavesexchange False missing: fetchOrder whitebit False missing: fetchOrder, cancelOrder, createOrder, fetchBalance xbtce False missing: fetchOrder, fetchOHLCV xena False missing: fetchOrder yobit False missing: fetchOHLCV zaif False missing: fetchOrder, fetchOHLCV zb True missing opt: fetchMyTrades","title":"List Exchanges"},{"location":"utils/#list-timeframes","text":"Use the list-timeframes subcommand to see the list of timeframes available for the exchange. usage: freqtrade list-timeframes [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [-1] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. -1, --one-column Print output in one column. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Example: see the timeframes for the 'binance' exchange, set in the configuration file: $ freqtrade list-timeframes -c config_binance.json ... Timeframes available for the exchange `binance`: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M Example: enumerate exchanges available for Freqtrade and print timeframes supported by each of them: $ for i in `freqtrade list-exchanges -1`; do freqtrade list-timeframes --exchange $i; done","title":"List Timeframes"},{"location":"utils/#list-pairslist-markets","text":"The list-pairs and list-markets subcommands allow to see the pairs/markets available on exchange. Pairs are markets with the '/' character between the base currency part and the quote currency part in the market symbol. For example, in the 'ETH/BTC' pair 'ETH' is the base currency, while 'BTC' is the quote currency. For pairs traded by Freqtrade the pair quote currency is defined by the value of the stake_currency configuration setting. You can print info about any pair/market with these subcommands - and you can filter output by quote-currency using --quote BTC , or by base-currency using --base ETH options correspondingly. These subcommands have same usage and same set of available options: usage: freqtrade list-markets [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] [--trading-mode {spot,margin,futures}] usage: freqtrade list-pairs [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--exchange EXCHANGE] [--print-list] [--print-json] [-1] [--print-csv] [--base BASE_CURRENCY [BASE_CURRENCY ...]] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a] [--trading-mode {spot,margin,futures}] optional arguments: -h, --help show this help message and exit --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided. --print-list Print list of pairs or market symbols. By default data is printed in the tabular format. --print-json Print list of pairs or market symbols in JSON format. -1, --one-column Print output in one column. --print-csv Print exchange pair or market data in the csv format. --base BASE_CURRENCY [BASE_CURRENCY ...] Specify base currency(-ies). Space-separated list. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -a, --all Print all pairs or market symbols. By default only active ones are shown. --trading-mode {spot,margin,futures} Select Trading mode Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. By default, only active pairs/markets are shown. Active pairs/markets are those that can currently be traded on the exchange. The see the list of all pairs/markets (not only the active ones), use the -a / -all option. Pairs/markets are sorted by its symbol string in the printed output.","title":"List pairs/list markets"},{"location":"utils/#examples","text":"Print the list of active pairs with quote currency USD on exchange, specified in the default configuration file (i.e. pairs on the \"Bittrex\" exchange) in JSON format: $ freqtrade list-pairs --quote USD --print-json Print the list of all pairs on the exchange, specified in the config_binance.json configuration file (i.e. on the \"Binance\" exchange) with base currencies BTC or ETH and quote currencies USDT or USD, as the human-readable list with summary: $ freqtrade list-pairs -c config_binance.json --all --base BTC ETH --quote USDT USD --print-list Print all markets on exchange \"Kraken\", in the tabular format: $ freqtrade list-markets --exchange kraken --all","title":"Examples"},{"location":"utils/#test-pairlist","text":"Use the test-pairlist subcommand to test the configuration of dynamic pairlists . Requires a configuration with specified pairlists attribute. Can be used to generate static pairlists to be used during backtesting / hyperopt. usage: freqtrade test-pairlist [-h] [-v] [-c PATH] [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-1] [--print-json] [--exchange EXCHANGE] optional arguments: -h, --help show this help message and exit -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...] Specify quote currency(-ies). Space-separated list. -1, --one-column Print output in one column. --print-json Print list of pairs or market symbols in JSON format. --exchange EXCHANGE Exchange name (default: `bittrex`). Only valid if no config is provided.","title":"Test pairlist"},{"location":"utils/#examples_1","text":"Show whitelist when using a dynamic pairlist . freqtrade test-pairlist --config config.json --quote USDT BTC","title":"Examples"},{"location":"utils/#convert-database","text":"freqtrade convert-db can be used to convert your database from one system to another (sqlite -> postgres, postgres -> other postgres), migrating all trades, orders and Pairlocks. Please refer to the SQL cheatsheet to learn about requirements for different database systems. usage: freqtrade convert-db [-h] [--db-url PATH] [--db-url-from PATH] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --db-url-from PATH Source db url to use when migrating a database. Warning Please ensure to only use this on an empty target database. Freqtrade will perform a regular migration, but may fail if entries already existed.","title":"Convert database"},{"location":"utils/#webserver-mode","text":"Experimental Webserver mode is an experimental mode to increase backesting and strategy development productivity. There may still be bugs - so if you happen to stumble across these, please report them as github issues, thanks. Run freqtrade in webserver mode. Freqtrade will start the webserver and allow FreqUI to start and control backtesting processes. This has the advantage that data will not be reloaded between backtesting runs (as long as timeframe and timerange remain identical). FreqUI will also show the backtesting results. usage: freqtrade webserver [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] optional arguments: -h, --help show this help message and exit Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Webserver mode"},{"location":"utils/#webserver-mode-docker","text":"You can also use webserver mode via docker. Starting a one-off container requires the configuration of the port explicitly, as ports are not exposed by default. You can use docker-compose run --rm -p 127.0.0.1:8080:8080 freqtrade webserver to start a one-off container that'll be removed once you stop it. This assumes that port 8080 is still available and no other bot is running on that port. Alternatively, you can reconfigure the docker-compose file to have the command updated: command: > webserver --config /freqtrade/user_data/config.json You can now use docker-compose up to start the webserver. This assumes that the configuration has a webserver enabled and configured for docker (listening port = 0.0.0.0 ). Tip Don't forget to reset the command back to the trade command if you want to start a live or dry-run bot.","title":"Webserver mode - docker"},{"location":"utils/#show-previous-backtest-results","text":"Allows you to show previous backtest results. Adding --show-pair-list outputs a sorted pair list you can easily copy/paste into your configuration (omitting bad pairs). Strategy overfitting Only using winning pairs can lead to an overfitted strategy, which will not work well on future data. Make sure to extensively test your strategy in dry-run before risking real money. usage: freqtrade backtesting-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--show-pair-list] optional arguments: -h, --help show this help message and exit --export-filename PATH Save backtest results to the file with this filename. Requires `--export` to be set as well. Example: `--export-filename=user_data/backtest_results/backtest _today.json` --show-pair-list Show backtesting pairlist sorted by profit. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Show previous Backtest results"},{"location":"utils/#detailed-backtest-analysis","text":"Advanced backtest result analysis. More details in the Backtesting analysis Section. usage: freqtrade backtesting-analysis [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--export-filename PATH] [--analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...]] [--enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...]] [--exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...]] [--indicator-list INDICATOR_LIST [INDICATOR_LIST ...]] optional arguments: -h, --help show this help message and exit --export-filename PATH, --backtest-filename PATH Use this filename for backtest results.Requires `--export` to be set as well. Example: `--export-filen ame=user_data/backtest_results/backtest_today.json` --analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...] grouping output - 0: simple wins/losses by enter tag, 1: by enter_tag, 2: by enter_tag and exit_tag, 3: by pair and enter_tag, 4: by pair, enter_ and exit_tag (this can get quite large) --enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...] Comma separated list of entry signals to analyse. Default: all. e.g. 'entry_tag_a,entry_tag_b' --exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...] Comma separated list of exit signals to analyse. Default: all. e.g. 'exit_tag_a,roi,stop_loss,trailing_stop_loss' --indicator-list INDICATOR_LIST [INDICATOR_LIST ...] Comma separated list of indicators to analyse. e.g. 'close,rsi,bb_lowerband,profit_abs' Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Detailed backtest analysis"},{"location":"utils/#list-hyperopt-results","text":"You can list the hyperoptimization epochs the Hyperopt module evaluated previously with the hyperopt-list sub-command. usage: freqtrade hyperopt-list [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [--min-trades INT] [--max-trades INT] [--min-avg-time FLOAT] [--max-avg-time FLOAT] [--min-avg-profit FLOAT] [--max-avg-profit FLOAT] [--min-total-profit FLOAT] [--max-total-profit FLOAT] [--min-objective FLOAT] [--max-objective FLOAT] [--no-color] [--print-json] [--no-details] [--hyperopt-filename PATH] [--export-csv FILE] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. --min-trades INT Select epochs with more than INT trades. --max-trades INT Select epochs with less than INT trades. --min-avg-time FLOAT Select epochs above average time. --max-avg-time FLOAT Select epochs below average time. --min-avg-profit FLOAT Select epochs above average profit. --max-avg-profit FLOAT Select epochs below average profit. --min-total-profit FLOAT Select epochs above total profit. --max-total-profit FLOAT Select epochs below total profit. --min-objective FLOAT Select epochs above objective. --max-objective FLOAT Select epochs below objective. --no-color Disable colorization of hyperopt results. May be useful if you are redirecting output to a file. --print-json Print output in JSON format. --no-details Do not print best epoch details. --hyperopt-filename FILENAME Hyperopt result filename.Example: `--hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle` --export-csv FILE Export to CSV-File. This will disable table print. Example: --export-csv hyperopt.csv Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Note hyperopt-list will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!).","title":"List Hyperopt results"},{"location":"utils/#examples_2","text":"List all results, print details of the best result at the end: freqtrade hyperopt-list List only epochs with positive profit. Do not print the details of the best epoch, so that the list can be iterated in a script: freqtrade hyperopt-list --profitable --no-details","title":"Examples"},{"location":"utils/#show-details-of-hyperopt-results","text":"You can show the details of any hyperoptimization epoch previously evaluated by the Hyperopt module with the hyperopt-show subcommand. usage: freqtrade hyperopt-show [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--best] [--profitable] [-n INT] [--print-json] [--hyperopt-filename FILENAME] [--no-header] [--disable-param-export] [--breakdown {day,week,month} [{day,week,month} ...]] optional arguments: -h, --help show this help message and exit --best Select only best epochs. --profitable Select only profitable epochs. -n INT, --index INT Specify the index of the epoch to print details for. --print-json Print output in JSON format. --hyperopt-filename FILENAME Hyperopt result filename.Example: `--hyperopt- filename=hyperopt_results_2020-09-27_16-20-48.pickle` --no-header Do not print epoch details header. --disable-param-export Disable automatic hyperopt parameter export. --breakdown {day,week,month} [{day,week,month} ...] Show backtesting breakdown per [day, week, month]. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory. Note hyperopt-show will automatically use the latest available hyperopt results file. You can override this using the --hyperopt-filename argument, and specify another, available filename (without path!).","title":"Show details of Hyperopt results"},{"location":"utils/#examples_3","text":"Print details for the epoch 168 (the number of the epoch is shown by the hyperopt-list subcommand or by Hyperopt itself during hyperoptimization run): freqtrade hyperopt-show -n 168 Prints JSON data with details for the last best epoch (i.e., the best of all epochs): freqtrade hyperopt-show --best -n -1 --print-json --no-header","title":"Examples"},{"location":"utils/#show-trades","text":"Print selected (or all) trades from database to screen. usage: freqtrade show-trades [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH] [--userdir PATH] [--db-url PATH] [--trade-ids TRADE_IDS [TRADE_IDS ...]] [--print-json] optional arguments: -h, --help show this help message and exit --db-url PATH Override trades database URL, this is useful in custom deployments (default: `sqlite:///tradesv3.sqlite` for Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for Dry Run). --trade-ids TRADE_IDS [TRADE_IDS ...] Specify the list of trade ids. --print-json Print output in JSON format. Common arguments: -v, --verbose Verbose mode (-vv for more, -vvv to get all messages). --logfile FILE Log to the file specified. Special values are: 'syslog', 'journald'. See the documentation for more details. -V, --version show program's version number and exit -c PATH, --config PATH Specify configuration file (default: `userdir/config.json` or `config.json` whichever exists). Multiple --config options may be used. Can be set to `-` to read config from stdin. -d PATH, --datadir PATH Path to directory with historical backtesting data. --userdir PATH, --user-data-dir PATH Path to userdata directory.","title":"Show trades"},{"location":"utils/#examples_4","text":"Print trades with id 2 and 3 as json freqtrade show-trades --db-url sqlite:///tradesv3.sqlite --trade-ids 2 3 --print-json","title":"Examples"},{"location":"webhook-config/","text":"Webhook usage \u00b6 Configuration \u00b6 Enable webhooks by adding a webhook-section to your configuration file, and setting webhook.enabled to true . Sample configuration (tested using IFTTT). \"webhook\" : { \"enabled\" : true , \"url\" : \"https://maker.ifttt.com/trigger/<YOUREVENT>/with/key/<YOURKEY>/\" , \"webhookentry\" : { \"value1\" : \"Buying {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"{stake_amount:8f} {stake_currency}\" }, \"webhookentrycancel\" : { \"value1\" : \"Cancelling Open Buy Order for {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"{stake_amount:8f} {stake_currency}\" }, \"webhookentryfill\" : { \"value1\" : \"Buy Order for {pair} filled\" , \"value2\" : \"at {open_rate:8f}\" , \"value3\" : \"\" }, \"webhookexit\" : { \"value1\" : \"Exiting {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhookexitcancel\" : { \"value1\" : \"Cancelling Open Exit Order for {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhookexitfill\" : { \"value1\" : \"Exit Order for {pair} filled\" , \"value2\" : \"at {close_rate:8f}.\" , \"value3\" : \"\" }, \"webhookstatus\" : { \"value1\" : \"Status: {status}\" , \"value2\" : \"\" , \"value3\" : \"\" } }, The url in webhook.url should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert your event and key to the url. You can set the POST body format to Form-Encoded (default), JSON-Encoded, or raw data. Use \"format\": \"form\" , \"format\": \"json\" , or \"format\": \"raw\" respectively. Example configuration for Mattermost Cloud integration: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURSUBDOMAIN>.cloud.mattermost.com/hooks/<YOURHOOK>\" , \"format\" : \"json\" , \"webhookstatus\" : { \"text\" : \"Status: {status}\" } }, The result would be a POST request with e.g. {\"text\":\"Status: running\"} body and Content-Type: application/json header which results Status: running message in the Mattermost channel. When using the Form-Encoded or JSON-Encoded configuration you can configure any number of payload values, and both the key and value will be ouput in the POST request. However, when using the raw data format you can only configure one value and it must be named \"data\" . In this instance the data key will not be output in the POST request, only the value. For example: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURHOOKURL>\" , \"format\" : \"raw\" , \"webhookstatus\" : { \"data\" : \"Status: {status}\" } }, The result would be a POST request with e.g. Status: running body and Content-Type: text/plain header. Optional parameters are available to enable automatic retries for webhook messages. The webhook.retries parameter can be set for the maximum number of retries the webhook request should attempt if it is unsuccessful (i.e. HTTP response status is not 200). By default this is set to 0 which is disabled. An additional webhook.retry_delay parameter can be set to specify the time in seconds between retry attempts. By default this is set to 0.1 (i.e. 100ms). Note that increasing the number of retries or retry delay may slow down the trader if there are connectivity issues with the webhook. Example configuration for retries: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURHOOKURL>\" , \"retries\" : 3 , \"retry_delay\" : 0.2 , \"webhookstatus\" : { \"status\" : \"Status: {status}\" } }, Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called. Webhookentry \u00b6 The fields in webhook.webhookentry are filled when the bot executes a long/short. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage limit # Deprecated - should no longer be used. open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag Webhookentrycancel \u00b6 The fields in webhook.webhookentrycancel are filled when the bot cancels a long/short order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage limit amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag Webhookentryfill \u00b6 The fields in webhook.webhookentryfill are filled when the bot filled a long/short order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag Webhookexit \u00b6 The fields in webhook.webhookexit are filled when the bot exits a trade. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain limit amount open_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date Webhookexitfill \u00b6 The fields in webhook.webhookexitfill are filled when the bot fills a exit order (closes a Trade). Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain close_rate amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date Webhookexitcancel \u00b6 The fields in webhook.webhookexitcancel are filled when the bot cancels a exit order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain limit amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date Webhookstatus \u00b6 The fields in webhook.webhookstatus are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format. The only possible value here is {status} . Discord \u00b6 A special form of webhooks is available for discord. You can configure this as follows: \"discord\" : { \"enabled\" : true , \"webhook_url\" : \"https://discord.com/api/webhooks/<Your webhook URL ...>\" , \"exit_fill\" : [ { \"Trade ID\" : \"{trade_id}\" }, { \"Exchange\" : \"{exchange}\" }, { \"Pair\" : \"{pair}\" }, { \"Direction\" : \"{direction}\" }, { \"Open rate\" : \"{open_rate}\" }, { \"Close rate\" : \"{close_rate}\" }, { \"Amount\" : \"{amount}\" }, { \"Open date\" : \"{open_date:%Y-%m-%d %H:%M:%S}\" }, { \"Close date\" : \"{close_date:%Y-%m-%d %H:%M:%S}\" }, { \"Profit\" : \"{profit_amount} {stake_currency}\" }, { \"Profitability\" : \"{profit_ratio:.2%}\" }, { \"Enter tag\" : \"{enter_tag}\" }, { \"Exit Reason\" : \"{exit_reason}\" }, { \"Strategy\" : \"{strategy}\" }, { \"Timeframe\" : \"{timeframe}\" }, ], \"entry_fill\" : [ { \"Trade ID\" : \"{trade_id}\" }, { \"Exchange\" : \"{exchange}\" }, { \"Pair\" : \"{pair}\" }, { \"Direction\" : \"{direction}\" }, { \"Open rate\" : \"{open_rate}\" }, { \"Amount\" : \"{amount}\" }, { \"Open date\" : \"{open_date:%Y-%m-%d %H:%M:%S}\" }, { \"Enter tag\" : \"{enter_tag}\" }, { \"Strategy\" : \"{strategy} {timeframe}\" }, ] } The above represents the default ( exit_fill and entry_fill are optional and will default to the above configuration) - modifications are obviously possible. Available fields correspond to the fields for webhooks and are documented in the corresponding webhook sections. The notifications will look as follows by default.","title":"Web Hook"},{"location":"webhook-config/#webhook-usage","text":"","title":"Webhook usage"},{"location":"webhook-config/#configuration","text":"Enable webhooks by adding a webhook-section to your configuration file, and setting webhook.enabled to true . Sample configuration (tested using IFTTT). \"webhook\" : { \"enabled\" : true , \"url\" : \"https://maker.ifttt.com/trigger/<YOUREVENT>/with/key/<YOURKEY>/\" , \"webhookentry\" : { \"value1\" : \"Buying {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"{stake_amount:8f} {stake_currency}\" }, \"webhookentrycancel\" : { \"value1\" : \"Cancelling Open Buy Order for {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"{stake_amount:8f} {stake_currency}\" }, \"webhookentryfill\" : { \"value1\" : \"Buy Order for {pair} filled\" , \"value2\" : \"at {open_rate:8f}\" , \"value3\" : \"\" }, \"webhookexit\" : { \"value1\" : \"Exiting {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhookexitcancel\" : { \"value1\" : \"Cancelling Open Exit Order for {pair}\" , \"value2\" : \"limit {limit:8f}\" , \"value3\" : \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\" }, \"webhookexitfill\" : { \"value1\" : \"Exit Order for {pair} filled\" , \"value2\" : \"at {close_rate:8f}.\" , \"value3\" : \"\" }, \"webhookstatus\" : { \"value1\" : \"Status: {status}\" , \"value2\" : \"\" , \"value3\" : \"\" } }, The url in webhook.url should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert your event and key to the url. You can set the POST body format to Form-Encoded (default), JSON-Encoded, or raw data. Use \"format\": \"form\" , \"format\": \"json\" , or \"format\": \"raw\" respectively. Example configuration for Mattermost Cloud integration: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURSUBDOMAIN>.cloud.mattermost.com/hooks/<YOURHOOK>\" , \"format\" : \"json\" , \"webhookstatus\" : { \"text\" : \"Status: {status}\" } }, The result would be a POST request with e.g. {\"text\":\"Status: running\"} body and Content-Type: application/json header which results Status: running message in the Mattermost channel. When using the Form-Encoded or JSON-Encoded configuration you can configure any number of payload values, and both the key and value will be ouput in the POST request. However, when using the raw data format you can only configure one value and it must be named \"data\" . In this instance the data key will not be output in the POST request, only the value. For example: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURHOOKURL>\" , \"format\" : \"raw\" , \"webhookstatus\" : { \"data\" : \"Status: {status}\" } }, The result would be a POST request with e.g. Status: running body and Content-Type: text/plain header. Optional parameters are available to enable automatic retries for webhook messages. The webhook.retries parameter can be set for the maximum number of retries the webhook request should attempt if it is unsuccessful (i.e. HTTP response status is not 200). By default this is set to 0 which is disabled. An additional webhook.retry_delay parameter can be set to specify the time in seconds between retry attempts. By default this is set to 0.1 (i.e. 100ms). Note that increasing the number of retries or retry delay may slow down the trader if there are connectivity issues with the webhook. Example configuration for retries: \"webhook\" : { \"enabled\" : true , \"url\" : \"https://<YOURHOOKURL>\" , \"retries\" : 3 , \"retry_delay\" : 0.2 , \"webhookstatus\" : { \"status\" : \"Status: {status}\" } }, Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called.","title":"Configuration"},{"location":"webhook-config/#webhookentry","text":"The fields in webhook.webhookentry are filled when the bot executes a long/short. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage limit # Deprecated - should no longer be used. open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag","title":"Webhookentry"},{"location":"webhook-config/#webhookentrycancel","text":"The fields in webhook.webhookentrycancel are filled when the bot cancels a long/short order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage limit amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag","title":"Webhookentrycancel"},{"location":"webhook-config/#webhookentryfill","text":"The fields in webhook.webhookentryfill are filled when the bot filled a long/short order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage open_rate amount open_date stake_amount stake_currency base_currency fiat_currency order_type current_rate enter_tag","title":"Webhookentryfill"},{"location":"webhook-config/#webhookexit","text":"The fields in webhook.webhookexit are filled when the bot exits a trade. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain limit amount open_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date","title":"Webhookexit"},{"location":"webhook-config/#webhookexitfill","text":"The fields in webhook.webhookexitfill are filled when the bot fills a exit order (closes a Trade). Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain close_rate amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date","title":"Webhookexitfill"},{"location":"webhook-config/#webhookexitcancel","text":"The fields in webhook.webhookexitcancel are filled when the bot cancels a exit order. Parameters are filled using string.format. Possible parameters are: trade_id exchange pair direction leverage gain limit amount open_rate current_rate profit_amount profit_ratio stake_currency base_currency fiat_currency exit_reason order_type open_date close_date","title":"Webhookexitcancel"},{"location":"webhook-config/#webhookstatus","text":"The fields in webhook.webhookstatus are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format. The only possible value here is {status} .","title":"Webhookstatus"},{"location":"webhook-config/#discord","text":"A special form of webhooks is available for discord. You can configure this as follows: \"discord\" : { \"enabled\" : true , \"webhook_url\" : \"https://discord.com/api/webhooks/<Your webhook URL ...>\" , \"exit_fill\" : [ { \"Trade ID\" : \"{trade_id}\" }, { \"Exchange\" : \"{exchange}\" }, { \"Pair\" : \"{pair}\" }, { \"Direction\" : \"{direction}\" }, { \"Open rate\" : \"{open_rate}\" }, { \"Close rate\" : \"{close_rate}\" }, { \"Amount\" : \"{amount}\" }, { \"Open date\" : \"{open_date:%Y-%m-%d %H:%M:%S}\" }, { \"Close date\" : \"{close_date:%Y-%m-%d %H:%M:%S}\" }, { \"Profit\" : \"{profit_amount} {stake_currency}\" }, { \"Profitability\" : \"{profit_ratio:.2%}\" }, { \"Enter tag\" : \"{enter_tag}\" }, { \"Exit Reason\" : \"{exit_reason}\" }, { \"Strategy\" : \"{strategy}\" }, { \"Timeframe\" : \"{timeframe}\" }, ], \"entry_fill\" : [ { \"Trade ID\" : \"{trade_id}\" }, { \"Exchange\" : \"{exchange}\" }, { \"Pair\" : \"{pair}\" }, { \"Direction\" : \"{direction}\" }, { \"Open rate\" : \"{open_rate}\" }, { \"Amount\" : \"{amount}\" }, { \"Open date\" : \"{open_date:%Y-%m-%d %H:%M:%S}\" }, { \"Enter tag\" : \"{enter_tag}\" }, { \"Strategy\" : \"{strategy} {timeframe}\" }, ] } The above represents the default ( exit_fill and entry_fill are optional and will default to the above configuration) - modifications are obviously possible. Available fields correspond to the fields for webhooks and are documented in the corresponding webhook sections. The notifications will look as follows by default.","title":"Discord"},{"location":"windows_installation/","text":"Windows installation \u00b6 We strongly recommend that Windows users use Docker as this will work much easier and smoother (also more secure). If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. Otherwise, try the instructions below. Install freqtrade manually \u00b6 Note Make sure to use 64bit Windows and 64bit Python to avoid problems with backtesting or hyperopt due to the memory constraints 32bit applications have under Windows. Hint Using the Anaconda Distribution under Windows can greatly help with installation problems. Check out the Anaconda installation section in this document for more information. 1. Clone the git repository \u00b6 git clone https://github.com/freqtrade/freqtrade.git 2. Install ta-lib \u00b6 Install ta-lib according to the ta-lib documentation . As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), there is also a repository of unofficial pre-compiled windows Wheels here , which need to be downloaded and installed using pip install TA_Lib-0.4.24-cp38-cp38-win_amd64.whl (make sure to use the version matching your python version). Freqtrade provides these dependencies for the latest 3 Python versions (3.8, 3.9 and 3.10) and for 64bit Windows. Other versions must be downloaded from the above link. cd \\ path \\ freqtrade python -m venv . env . env \\ Scripts \\ activate . ps1 # optionally install ta-lib from wheel # Eventually adjust the below filename to match the downloaded wheel pip install build_helpers / TA_Lib - 0 . 4 . 19-cp38-cp38-win_amd64 . whl pip install -r requirements . txt pip install -e . freqtrade Use Powershell The above installation script assumes you're using powershell on a 64bit windows. Commands for the legacy CMD windows console may differ. Thanks Owdr for the commands. Source: Issue #222 Error during installation on Windows \u00b6 error: Microsoft Visual C++ 14 .0 is required. Get it with \"Microsoft Visual C++ Build Tools\" : http://landinghub.visualstudio.com/visual-cpp-build-tools Unfortunately, many packages requiring compilation don't provide a pre-built wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use. You can download the Visual C++ build tools from here and install \"Desktop development with C++\" in it's default configuration. Unfortunately, this is a heavy download / dependency so you might want to consider WSL2 or docker compose first.","title":"Windows"},{"location":"windows_installation/#windows-installation","text":"We strongly recommend that Windows users use Docker as this will work much easier and smoother (also more secure). If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. Otherwise, try the instructions below.","title":"Windows installation"},{"location":"windows_installation/#install-freqtrade-manually","text":"Note Make sure to use 64bit Windows and 64bit Python to avoid problems with backtesting or hyperopt due to the memory constraints 32bit applications have under Windows. Hint Using the Anaconda Distribution under Windows can greatly help with installation problems. Check out the Anaconda installation section in this document for more information.","title":"Install freqtrade manually"},{"location":"windows_installation/#1-clone-the-git-repository","text":"git clone https://github.com/freqtrade/freqtrade.git","title":"1. Clone the git repository"},{"location":"windows_installation/#2-install-ta-lib","text":"Install ta-lib according to the ta-lib documentation . As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), there is also a repository of unofficial pre-compiled windows Wheels here , which need to be downloaded and installed using pip install TA_Lib-0.4.24-cp38-cp38-win_amd64.whl (make sure to use the version matching your python version). Freqtrade provides these dependencies for the latest 3 Python versions (3.8, 3.9 and 3.10) and for 64bit Windows. Other versions must be downloaded from the above link. cd \\ path \\ freqtrade python -m venv . env . env \\ Scripts \\ activate . ps1 # optionally install ta-lib from wheel # Eventually adjust the below filename to match the downloaded wheel pip install build_helpers / TA_Lib - 0 . 4 . 19-cp38-cp38-win_amd64 . whl pip install -r requirements . txt pip install -e . freqtrade Use Powershell The above installation script assumes you're using powershell on a 64bit windows. Commands for the legacy CMD windows console may differ. Thanks Owdr for the commands. Source: Issue #222","title":"2. Install ta-lib"},{"location":"windows_installation/#error-during-installation-on-windows","text":"error: Microsoft Visual C++ 14 .0 is required. Get it with \"Microsoft Visual C++ Build Tools\" : http://landinghub.visualstudio.com/visual-cpp-build-tools Unfortunately, many packages requiring compilation don't provide a pre-built wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use. You can download the Visual C++ build tools from here and install \"Desktop development with C++\" in it's default configuration. Unfortunately, this is a heavy download / dependency so you might want to consider WSL2 or docker compose first.","title":"Error during installation on Windows"},{"location":"includes/pairlists/","text":"Pairlists and Pairlist Handlers \u00b6 Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist. Pair blacklist \u00b6 The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!) Available Pairlist Handlers \u00b6 StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly. Static Pair List \u00b6 By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . \"pairlists\" : [ { \"method\" : \"StaticPairList\" } ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist. Volume Pair List \u00b6 VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange. VolumePairList Advanced mode \u00b6 VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 3600 , \"lookback_timeframe\" : \"1h\" , \"lookback_period\" : 72 } ], Note VolumePairList does not support backtesting mode. AgeFilter \u00b6 Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed . OffsetFilter \u00b6 Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list): \"pairlists\" : [ // ... { \"method\" : \"OffsetFilter\" , \"offset\" : 10 , \"number_assets\" : 20 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger than the total length of the incoming pairlist will result in an empty pairlist. PerformanceFilter \u00b6 Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. \"pairlists\" : [ // ... { \"method\" : \"PerformanceFilter\" , \"minutes\" : 1440 , // rolling 24h \"min_profit\" : 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode. PrecisionFilter \u00b6 Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies. PriceFilter \u00b6 The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding. ShuffleFilter \u00b6 Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set. SpreadFilter \u00b6 Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out. RangeStabilityFilter \u00b6 Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. \"pairlists\" : [ { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"max_rate_of_change\" : 0.99 , \"refresh_period\" : 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time. VolatilityFilter \u00b6 Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. \"pairlists\" : [ { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 } ] Full example of Pairlist Handlers \u00b6 The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. \"exchange\" : { \"pair_whitelist\" : [], \"pair_blacklist\" : [ \"BNB/BTC\" ] }, \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" }, { \"method\" : \"AgeFilter\" , \"min_days_listed\" : 10 }, { \"method\" : \"PrecisionFilter\" }, { \"method\" : \"PriceFilter\" , \"low_price_ratio\" : 0.01 }, { \"method\" : \"SpreadFilter\" , \"max_spread_ratio\" : 0.005 }, { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"refresh_period\" : 1440 }, { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 }, { \"method\" : \"ShuffleFilter\" , \"seed\" : 42 } ],","title":"Pairlists"},{"location":"includes/pairlists/#pairlists-and-pairlist-handlers","text":"Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the pairlists section of the configuration settings. In your configuration, you can use Static Pairlist (defined by the StaticPairList Pairlist Handler) and Dynamic Pairlist (defined by the VolumePairList Pairlist Handler). Additionally, AgeFilter , PrecisionFilter , PriceFilter , ShuffleFilter , SpreadFilter and VolatilityFilter act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist. If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You should always configure either StaticPairList or VolumePairList as the starting Pairlist Handler. Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the pair_blacklist configuration setting) are also always removed from the resulting pairlist.","title":"Pairlists and Pairlist Handlers"},{"location":"includes/pairlists/#pair-blacklist","text":"The pair blacklist (configured via exchange.pair_blacklist in the configuration) disallows certain pairs from trading. This can be as simple as excluding DOGE/BTC - which will remove exactly this pair. The pair-blacklist does also support wildcards (in regex-style) - so BNB/.* will exclude ALL pairs that start with BNB. You may also use something like .*DOWN/BTC or .*UP/BTC to exclude leveraged tokens (check Pair naming conventions for your exchange!)","title":"Pair blacklist"},{"location":"includes/pairlists/#available-pairlist-handlers","text":"StaticPairList (default, if not configured differently) VolumePairList AgeFilter OffsetFilter PerformanceFilter PrecisionFilter PriceFilter ShuffleFilter SpreadFilter RangeStabilityFilter VolatilityFilter Testing pairlists Pairlist configurations can be quite tricky to get right. Best use the test-pairlist utility sub-command to test your configuration quickly.","title":"Available Pairlist Handlers"},{"location":"includes/pairlists/#static-pair-list","text":"By default, the StaticPairList method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so .*/BTC will include all pairs with BTC as a stake. It uses configuration from exchange.pair_whitelist and exchange.pair_blacklist . \"pairlists\" : [ { \"method\" : \"StaticPairList\" } ], By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set \"allow_inactive\": true within the StaticPairList configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with exchange.skip_pair_validation in the exchange configuration. When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in 'pair_whitelist' will be added to the end of the pairlist.","title":"Static Pair List"},{"location":"includes/pairlists/#volume-pair-list","text":"VolumePairList employs sorting/filtering of pairs by their trading volume. It selects number_assets top pairs with sorting based on the sort_key (which can only be quoteVolume ). When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), VolumePairList considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume. When used in the leading position of the chain of Pairlist Handlers, the pair_whitelist configuration setting is ignored. Instead, VolumePairList selects the top assets from all available markets with matching stake-currency on the exchange. The refresh_period setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache ( refresh_period ) on VolumePairList is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache and will always use up-to-date data. VolumePairList is per default based on the ticker data from exchange, as reported by the ccxt library: The quoteVolume is the amount of quote (stake) currency traded (bought or sold) in last 24 hours. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 1800 } ], You can define a minimum volume with min_value - which will filter out pairs with a volume lower than the specified value in the specified timerange.","title":"Volume Pair List"},{"location":"includes/pairlists/#volumepairlist-advanced-mode","text":"VolumePairList can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the quoteVolume over the given range. This allows different scenarios, for a more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles. For convenience lookback_days can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 7 } ], Range look back and refresh period When used in conjunction with lookback_days and lookback_timeframe the refresh_period can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API. Performance implications when using lookback range If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with VolumeFilter to narrow the pairlist down for further range volume calculation. Unsupported exchanges (Bittrex, Gemini) On some exchanges (like Bittrex and Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day. \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 86400 , \"lookback_days\" : 1 } ], More sophisticated approach can be used, by using lookback_timeframe for candle size and lookback_period which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles: \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" , \"min_value\" : 0 , \"refresh_period\" : 3600 , \"lookback_timeframe\" : \"1h\" , \"lookback_period\" : 72 } ], Note VolumePairList does not support backtesting mode.","title":"VolumePairList Advanced mode"},{"location":"includes/pairlists/#agefilter","text":"Removes pairs that have been listed on the exchange for less than min_days_listed days (defaults to 10 ) or more than max_days_listed days (defaults None mean infinity). When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price. This filter allows freqtrade to ignore pairs until they have been listed for at least min_days_listed days and listed before max_days_listed .","title":"AgeFilter"},{"location":"includes/pairlists/#offsetfilter","text":"Offsets an incoming pairlist by a given offset value. As an example it can be used in conjunction with VolumeFilter to remove the top X volume pairs. Or to split a larger pairlist on two bot instances. Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list): \"pairlists\" : [ // ... { \"method\" : \"OffsetFilter\" , \"offset\" : 10 , \"number_assets\" : 20 } ], Warning When OffsetFilter is used to split a larger pairlist among multiple bots in combination with VolumeFilter it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the VolumeFilter . Note An offset larger than the total length of the incoming pairlist will result in an empty pairlist.","title":"OffsetFilter"},{"location":"includes/pairlists/#performancefilter","text":"Sorts pairs by past trade performance, as follows: Positive performance. No closed trades yet. Negative performance. Trade count is used as a tie breaker. You can use the minutes parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance. The optional min_profit (as ratio -> a setting of 0.01 corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without minutes is highly discouraged, as it can lead to an empty pairlist without a way to recover. \"pairlists\" : [ // ... { \"method\" : \"PerformanceFilter\" , \"minutes\" : 1440 , // rolling 24h \"min_profit\" : 0.01 // minimal profit 1% } ], As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database. Backtesting PerformanceFilter does not support backtesting mode.","title":"PerformanceFilter"},{"location":"includes/pairlists/#precisionfilter","text":"Filters low-value coins which would not allow setting stoplosses. Backtesting PrecisionFilter does not support backtesting mode using multiple strategies.","title":"PrecisionFilter"},{"location":"includes/pairlists/#pricefilter","text":"The PriceFilter allows filtering of pairs by price. Currently the following price filters are supported: min_price max_price max_value low_price_ratio The min_price setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_price setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to > 0. The max_value setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. FTX) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit. The low_price_ratio setting removes pairs where a raise of 1 price unit (pip) is above the low_price_ratio ratio. This option is disabled by default, and will only apply if set to > 0. For PriceFilter at least one of its min_price , max_price or low_price_ratio settings must be applied. Calculation example: Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with low_price_ratio set to 0.09 (9%) or with min_price set to 0.00000011, correspondingly. Low priced pairs Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.","title":"PriceFilter"},{"location":"includes/pairlists/#shufflefilter","text":"Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority. Tip You may set the seed value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If seed is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the seed only for backtesting modes - if a seed value is set.","title":"ShuffleFilter"},{"location":"includes/pairlists/#spreadfilter","text":"Removes pairs that have a difference between asks and bids above the specified ratio, max_spread_ratio (defaults to 0.005 ). Example: If DOGE/BTC maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: 1 - bid/ask ~= 0.037 which is > 0.005 and this pair will be filtered out.","title":"SpreadFilter"},{"location":"includes/pairlists/#rangestabilityfilter","text":"Removes pairs where the difference between lowest low and highest high over lookback_days days is below min_rate_of_change or above max_rate_of_change . Since this is a filter that requires additional data, the results are cached for refresh_period . In the below example: If the trading range over the last 10 days is <1% or >99%, remove the pair from the whitelist. \"pairlists\" : [ { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"max_rate_of_change\" : 0.99 , \"refresh_period\" : 1440 } ] Tip This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.","title":"RangeStabilityFilter"},{"location":"includes/pairlists/#volatilityfilter","text":"Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of volatility . This filter removes pairs if the average volatility over a lookback_days days is below min_volatility or above max_volatility . Since this is a filter that requires additional data, the results are cached for refresh_period . This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs. In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h. \"pairlists\" : [ { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 } ]","title":"VolatilityFilter"},{"location":"includes/pairlists/#full-example-of-pairlist-handlers","text":"The below example blacklists BNB/BTC , uses VolumePairList with 20 assets, sorting pairs by quoteVolume and applies PrecisionFilter and PriceFilter , filtering all assets where 1 price unit is > 1%. Then the SpreadFilter and VolatilityFilter is applied and pairs are finally shuffled with the random seed set to some predefined value. \"exchange\" : { \"pair_whitelist\" : [], \"pair_blacklist\" : [ \"BNB/BTC\" ] }, \"pairlists\" : [ { \"method\" : \"VolumePairList\" , \"number_assets\" : 20 , \"sort_key\" : \"quoteVolume\" }, { \"method\" : \"AgeFilter\" , \"min_days_listed\" : 10 }, { \"method\" : \"PrecisionFilter\" }, { \"method\" : \"PriceFilter\" , \"low_price_ratio\" : 0.01 }, { \"method\" : \"SpreadFilter\" , \"max_spread_ratio\" : 0.005 }, { \"method\" : \"RangeStabilityFilter\" , \"lookback_days\" : 10 , \"min_rate_of_change\" : 0.01 , \"refresh_period\" : 1440 }, { \"method\" : \"VolatilityFilter\" , \"lookback_days\" : 10 , \"min_volatility\" : 0.05 , \"max_volatility\" : 0.50 , \"refresh_period\" : 86400 }, { \"method\" : \"ShuffleFilter\" , \"seed\" : 42 } ],","title":"Full example of Pairlist Handlers"},{"location":"includes/pricing/","text":"Prices used for orders \u00b6 Prices for regular orders can be controlled via the parameter structures entry_pricing for trade entries and exit_pricing for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders. Entry price \u00b6 Enter price side \u00b6 The configuration setting entry_pricing.price_side defines the side of the orderbook the bot looks for when buying. The following displays an orderbook. ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If entry_pricing.price_side is set to \"bid\" , then the bot will use 99 as entry price. In line with that, if entry_pricing.price_side is set to \"ask\" , then the bot will use 101 as entry price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price). Entry price with Orderbook enabled \u00b6 When entering a trade with the orderbook enabled ( entry_pricing.use_order_book=True ), Freqtrade fetches the entry_pricing.order_book_top entries from the orderbook and uses the entry specified as entry_pricing.order_book_top on the configured side ( entry_pricing.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Entry price without Orderbook enabled \u00b6 The following section uses side as the configured entry_pricing.price_side (defaults to \"same\" ). When not using orderbook ( entry_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on entry_pricing.price_last_balance . The entry_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price. Check depth of market \u00b6 When check depth of market is enabled ( entry_pricing.check_depth_of_market.enabled=True ), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the entry_pricing.check_depth_of_market.bids_to_ask_delta parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side). Exit price \u00b6 Exit price side \u00b6 The configuration setting exit_pricing.price_side defines the side of the spread the bot looks for when exiting a trade. The following displays an orderbook: ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If exit_pricing.price_side is set to \"ask\" , then the bot will use 101 as exiting price. In line with that, if exit_pricing.price_side is set to \"bid\" , then the bot will use 99 as exiting price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes Exit price with Orderbook enabled \u00b6 When exiting with the orderbook enabled ( exit_pricing.use_order_book=True ), Freqtrade fetches the exit_pricing.order_book_top entries in the orderbook and uses the entry specified as exit_pricing.order_book_top from the configured side ( exit_pricing.price_side ) as trade exit price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on. Exit price without Orderbook enabled \u00b6 The following section uses side as the configured exit_pricing.price_side (defaults to \"ask\" ). When not using orderbook ( exit_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on exit_pricing.price_last_balance . The exit_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price. Market order pricing \u00b6 When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used \"order_types\": { \"entry\": \"market\", \"exit\": \"market\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Pricing"},{"location":"includes/pricing/#prices-used-for-orders","text":"Prices for regular orders can be controlled via the parameter structures entry_pricing for trade entries and exit_pricing for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data. Note Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function fetch_order_book() , i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's fetch_ticker() / fetch_tickers() functions. Refer to the ccxt library documentation for more details. Using market orders Please read the section Market order pricing section when using market orders.","title":"Prices used for orders"},{"location":"includes/pricing/#entry-price","text":"","title":"Entry price"},{"location":"includes/pricing/#enter-price-side","text":"The configuration setting entry_pricing.price_side defines the side of the orderbook the bot looks for when buying. The following displays an orderbook. ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If entry_pricing.price_side is set to \"bid\" , then the bot will use 99 as entry price. In line with that, if entry_pricing.price_side is set to \"ask\" , then the bot will use 101 as entry price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).","title":"Enter price side"},{"location":"includes/pricing/#entry-price-with-orderbook-enabled","text":"When entering a trade with the orderbook enabled ( entry_pricing.use_order_book=True ), Freqtrade fetches the entry_pricing.order_book_top entries from the orderbook and uses the entry specified as entry_pricing.order_book_top on the configured side ( entry_pricing.price_side ) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Entry price with Orderbook enabled"},{"location":"includes/pricing/#entry-price-without-orderbook-enabled","text":"The following section uses side as the configured entry_pricing.price_side (defaults to \"same\" ). When not using orderbook ( entry_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's below the last traded price from the ticker. Otherwise (when the side price is above the last price), it calculates a rate between side and last price based on entry_pricing.price_last_balance . The entry_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between ask and last price.","title":"Entry price without Orderbook enabled"},{"location":"includes/pricing/#check-depth-of-market","text":"When check depth of market is enabled ( entry_pricing.check_depth_of_market.enabled=True ), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side. Orderbook bid (buy) side depth is then divided by the orderbook ask (sell) side depth and the resulting delta is compared to the value of the entry_pricing.check_depth_of_market.bids_to_ask_delta parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value. Note A delta value below 1 means that ask (sell) orderbook side depth is greater than the depth of the bid (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).","title":"Check depth of market"},{"location":"includes/pricing/#exit-price","text":"","title":"Exit price"},{"location":"includes/pricing/#exit-price-side","text":"The configuration setting exit_pricing.price_side defines the side of the spread the bot looks for when exiting a trade. The following displays an orderbook: ... 103 102 101 # ask -------------Current spread 99 # bid 98 97 ... If exit_pricing.price_side is set to \"ask\" , then the bot will use 101 as exiting price. In line with that, if exit_pricing.price_side is set to \"bid\" , then the bot will use 99 as exiting price. Depending on the order direction ( long / short ), this will lead to different results. Therefore we recommend to use \"same\" or \"other\" for this configuration instead. This would result in the following pricing matrix: Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes","title":"Exit price side"},{"location":"includes/pricing/#exit-price-with-orderbook-enabled","text":"When exiting with the orderbook enabled ( exit_pricing.use_order_book=True ), Freqtrade fetches the exit_pricing.order_book_top entries in the orderbook and uses the entry specified as exit_pricing.order_book_top from the configured side ( exit_pricing.price_side ) as trade exit price. 1 specifies the topmost entry in the orderbook, while 2 would use the 2 nd entry in the orderbook, and so on.","title":"Exit price with Orderbook enabled"},{"location":"includes/pricing/#exit-price-without-orderbook-enabled","text":"The following section uses side as the configured exit_pricing.price_side (defaults to \"ask\" ). When not using orderbook ( exit_pricing.use_order_book=False ), Freqtrade uses the best side price from the ticker if it's above the last traded price from the ticker. Otherwise (when the side price is below the last price), it calculates a rate between side and last price based on exit_pricing.price_last_balance . The exit_pricing.price_last_balance configuration parameter controls this. A value of 0.0 will use side price, while 1.0 will use the last price and values between those interpolate between side and last price.","title":"Exit price without Orderbook enabled"},{"location":"includes/pricing/#market-order-pricing","text":"When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used \"order_types\": { \"entry\": \"market\", \"exit\": \"market\" // ... }, \"entry_pricing\": { \"price_side\": \"other\", // ... }, \"exit_pricing\":{ \"price_side\": \"other\", // ... }, Obviously, if only one side is using limit orders, different pricing combinations can be used.","title":"Market order pricing"},{"location":"includes/protections/","text":"Protections \u00b6 Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property . Available Protections \u00b6 StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade. Common settings to all Protections \u00b6 Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition. Stoploss Guard \u00b6 StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. Similarly, this protection will by default look at all trades (long and short). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses. required_profit will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. @property def protections ( self ): return [ { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 4 , \"required_profit\" : 0.0 , \"only_per_pair\" : False , \"only_per_side\" : False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy. MaxDrawdown \u00b6 MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. @property def protections ( self ): return [ { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 12 , \"max_allowed_drawdown\" : 0.2 }, ] Low Profit Pairs \u00b6 LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses. The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. @property def protections ( self ): return [ { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration\" : 60 , \"required_profit\" : 0.02 , \"only_per_pair\" : False , } ] Cooldown Period \u00b6 CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade. Full example of Protections \u00b6 All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. from freqtrade.strategy import IStrategy class AwesomeStrategy ( IStrategy ) timeframe = '1h' @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 5 }, { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 4 , \"max_allowed_drawdown\" : 0.2 }, { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"only_per_pair\" : False }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration_candles\" : 60 , \"required_profit\" : 0.02 }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"required_profit\" : 0.01 } ] # ...","title":"Protections"},{"location":"includes/protections/#protections","text":"Beta feature This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue. Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys. Note Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance. Tip Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term). Backtesting Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the --enable-protections flag. Setting protections from the configuration Setting protections from the configuration via \"protections\": [], key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property .","title":"Protections"},{"location":"includes/protections/#available-protections","text":"StoplossGuard Stop trading if a certain amount of stoploss occurred within a certain time window. MaxDrawdown Stop trading if max-drawdown is reached. LowProfitPairs Lock pairs with low profits CooldownPeriod Don't enter a trade right after selling a trade.","title":"Available Protections"},{"location":"includes/protections/#common-settings-to-all-protections","text":"Parameter Description method Protection name to use. Datatype: String, selected from available Protections stop_duration_candles For how many candles should the lock be set? Datatype: Positive integer (in candles) stop_duration how many minutes should protections be locked. Cannot be used together with stop_duration_candles . Datatype: Float (in minutes) lookback_period_candles Only trades that completed within the last lookback_period_candles candles will be considered. This setting may be ignored by some Protections. Datatype: Positive integer (in candles). lookback_period Only trades that completed after current_time - lookback_period will be considered. Cannot be used together with lookback_period_candles . This setting may be ignored by some Protections. Datatype: Float (in minutes) trade_limit Number of trades required at minimum (not used by all Protections). Datatype: Positive integer Durations Durations ( stop_duration* and lookback_period* can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.","title":"Common settings to all Protections"},{"location":"includes/protections/#stoploss-guard","text":"StoplossGuard selects all trades within lookback_period in minutes (or in candles when using lookback_period_candles ). If trade_limit or more trades resulted in stoploss, trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ). This applies across all pairs, unless only_per_pair is set to true, which will then only look at one pair at a time. Similarly, this protection will by default look at all trades (long and short). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses. required_profit will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block. The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles. @property def protections ( self ): return [ { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 4 , \"required_profit\" : 0.0 , \"only_per_pair\" : False , \"only_per_side\" : False } ] Note StoplossGuard considers all trades with the results \"stop_loss\" , \"stoploss_on_exchange\" and \"trailing_stop_loss\" if the resulting profit was negative. trade_limit and lookback_period will need to be tuned for your strategy.","title":"Stoploss Guard"},{"location":"includes/protections/#maxdrawdown","text":"MaxDrawdown uses all trades within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the maximum drawdown. If the drawdown is below max_allowed_drawdown , trading will stop for stop_duration in minutes (or in candles when using stop_duration_candles ) after the last trade - assuming that the bot needs some time to let markets recover. The below sample stops trading for 12 candles if max-drawdown is > 20% considering all pairs - with a minimum of trade_limit trades - within the last 48 candles. If desired, lookback_period and/or stop_duration can be used. @property def protections ( self ): return [ { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 12 , \"max_allowed_drawdown\" : 0.2 }, ]","title":"MaxDrawdown"},{"location":"includes/protections/#low-profit-pairs","text":"LowProfitPairs uses all trades for a pair within lookback_period in minutes (or in candles when using lookback_period_candles ) to determine the overall profit ratio. If that ratio is below required_profit , that pair will be locked for stop_duration in minutes (or in candles when using stop_duration_candles ). For futures bots, setting only_per_side will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses. The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles. @property def protections ( self ): return [ { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration\" : 60 , \"required_profit\" : 0.02 , \"only_per_pair\" : False , } ]","title":"Low Profit Pairs"},{"location":"includes/protections/#cooldown-period","text":"CooldownPeriod locks a pair for stop_duration in minutes (or in candles when using stop_duration_candles ) after selling, avoiding a re-entry for this pair for stop_duration minutes. The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\". @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 2 } ] Note This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider lookback_period as it only looks at the latest trade.","title":"Cooldown Period"},{"location":"includes/protections/#full-example-of-protections","text":"All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined. The below example assumes a timeframe of 1 hour: Locks each pair after selling for an additional 5 candles ( CooldownPeriod ), giving other pairs a chance to get filled. Stops trading for 4 hours ( 4 * 1h candles ) if the last 2 days ( 48 * 1h candles ) had 20 trades, which caused a max-drawdown of more than 20%. ( MaxDrawdown ). Stops trading if more than 4 stoploss occur for all pairs within a 1 day ( 24 * 1h candles ) limit ( StoplossGuard ). Locks all pairs that had 4 Trades within the last 6 hours ( 6 * 1h candles ) with a combined profit ratio of below 0.02 (<2%) ( LowProfitPairs ). Locks all pairs for 2 candles that had a profit of below 0.01 (<1%) within the last 24h ( 24 * 1h candles ), a minimum of 4 trades. from freqtrade.strategy import IStrategy class AwesomeStrategy ( IStrategy ) timeframe = '1h' @property def protections ( self ): return [ { \"method\" : \"CooldownPeriod\" , \"stop_duration_candles\" : 5 }, { \"method\" : \"MaxDrawdown\" , \"lookback_period_candles\" : 48 , \"trade_limit\" : 20 , \"stop_duration_candles\" : 4 , \"max_allowed_drawdown\" : 0.2 }, { \"method\" : \"StoplossGuard\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"only_per_pair\" : False }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 6 , \"trade_limit\" : 2 , \"stop_duration_candles\" : 60 , \"required_profit\" : 0.02 }, { \"method\" : \"LowProfitPairs\" , \"lookback_period_candles\" : 24 , \"trade_limit\" : 4 , \"stop_duration_candles\" : 2 , \"required_profit\" : 0.01 } ] # ...","title":"Full example of Protections"}]}